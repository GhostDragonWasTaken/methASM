; Generated by MethASM
; x86-64 Assembly Output

section .text
; Code section

; First pass: processing 24 declarations
; Declaration 0 type: 4 (AST_INLINE_ASM = 18)
; Declaration 1 type: 4 (AST_INLINE_ASM = 18)
; Declaration 2 type: 4 (AST_INLINE_ASM = 18)
; Declaration 3 type: 4 (AST_INLINE_ASM = 18)
; Declaration 4 type: 4 (AST_INLINE_ASM = 18)
; Declaration 5 type: 4 (AST_INLINE_ASM = 18)
; Declaration 6 type: 4 (AST_INLINE_ASM = 18)
; Declaration 7 type: 4 (AST_INLINE_ASM = 18)
; Declaration 8 type: 4 (AST_INLINE_ASM = 18)
; Declaration 9 type: 4 (AST_INLINE_ASM = 18)
; Declaration 10 type: 4 (AST_INLINE_ASM = 18)
; Declaration 11 type: 4 (AST_INLINE_ASM = 18)
; Declaration 12 type: 4 (AST_INLINE_ASM = 18)
; Declaration 13 type: 4 (AST_INLINE_ASM = 18)
; Declaration 14 type: 4 (AST_INLINE_ASM = 18)
; Declaration 15 type: 4 (AST_INLINE_ASM = 18)
; Declaration 16 type: 4 (AST_INLINE_ASM = 18)
; Declaration 17 type: 4 (AST_INLINE_ASM = 18)
; Declaration 18 type: 4 (AST_INLINE_ASM = 18)
; Declaration 19 type: 4 (AST_INLINE_ASM = 18)
; Declaration 20 type: 3 (AST_INLINE_ASM = 18)
; Declaration 21 type: 3 (AST_INLINE_ASM = 18)
; Declaration 22 type: 4 (AST_INLINE_ASM = 18)
; Declaration 23 type: 4 (AST_INLINE_ASM = 18)

section .text
    extern puts
    extern putchar
    extern getchar

global cstr

cstr:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 80    ; Allocate 80 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 's'
    ; Parameter 's' arrived in register rcx
ir_entry_0:
    lea rax, [rbp - 8]
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    mov rax, qword [rax]
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    jmp Lcstr_exit
Lcstr_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global print

print:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 240    ; Allocate 240 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'msg'
    ; Parameter 'msg' arrived in register rcx
ir_entry_1:
    mov rax, 0
    ; Store to variable: i
    mov qword [rbp - 16], rax  ; To stack [rbp - 16]
ir_while_2:
    ; Load variable: i
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 24], rax
    ; Load variable: msg
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 24]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    movzx rax, byte [rax]
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_while_end_3
    ; Load variable: i
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 56], rax
    ; Load variable: msg
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 56]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    movzx rax, byte [rax]
    mov [rbp - 72], rax
    ; IR call: putchar (1 args)
    sub rsp, 32
    mov rax, [rbp - 72]
    mov rcx, rax
    call putchar
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 80], rax
    ; Load variable: i
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    ; Store to variable: i
    mov qword [rbp - 16], rax  ; To stack [rbp - 16]
    jmp ir_while_2
ir_while_end_3:
Lprint_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global println

println:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 32    ; Allocate 32 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'msg'
    ; Parameter 'msg' arrived in register rcx
ir_entry_4:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; Load variable: msg
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call puts
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 16], rax
Lprintln_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global newline

newline:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 32    ; Allocate 32 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_5:
    ; IR call: putchar (1 args)
    sub rsp, 32
    mov rax, 10
    mov rcx, rax
    call putchar
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 8], rax
Lnewline_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global print_int

print_int:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 656    ; Allocate 656 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'n'
    ; Parameter 'n' arrived in register rcx
ir_entry_6:
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 104], rax
    mov rax, [rbp - 104]
    test rax, rax
    jz ir_if_next_8
    ; IR call: putchar (1 args)
    sub rsp, 32
    mov rax, 45
    mov rcx, rax
    call putchar
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 112], rax
    mov rax, 0
    push rax
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 120], rax
    mov rax, [rbp - 120]
    ; Store to variable: n
    mov qword [rbp - 8], rax  ; To stack [rbp - 8]
    jmp ir_if_end_7
ir_if_next_8:
ir_if_end_7:
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 128], rax
    mov rax, [rbp - 128]
    test rax, rax
    jz ir_if_next_10
    ; IR call: putchar (1 args)
    sub rsp, 32
    mov rax, 48
    mov rcx, rax
    call putchar
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 136], rax
    jmp Lprint_int_exit
    jmp ir_if_end_9
ir_if_next_10:
ir_if_end_9:
    mov rax, 0
    ; Store to variable: len
    mov dword [rbp - 92], eax  ; To stack [rbp - 92]
ir_while_11:
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setg al
    movzx rax, al
    mov [rbp - 144], rax
    mov rax, [rbp - 144]
    test rax, rax
    jz ir_while_end_12
    mov rax, 48
    push rax
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 152], rax
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 10
    mov r10, rax
    pop rax
    cqo
    idiv r10
    mov [rbp - 160], rax
    mov rax, [rbp - 160]
    push rax
    mov rax, 10
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 168], rax
    mov rax, [rbp - 152]
    push rax
    mov rax, [rbp - 168]
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 176], rax
    ; Load variable: len
    movsxd rax, dword [rbp - 92]  ; From stack [rbp - 92]
    push rax
    mov rax, 4
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 184], rax
    ; Load variable: buf
    lea rax, [rbp - 88]  ; Local array base
    push rax
    mov rax, [rbp - 184]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 192], rax
    mov rax, [rbp - 192]
    push rax
    mov rax, [rbp - 176]
    mov rcx, rax
    pop rax
    mov dword [rax], ecx
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 10
    mov r10, rax
    pop rax
    cqo
    idiv r10
    mov [rbp - 208], rax
    mov rax, [rbp - 208]
    ; Store to variable: n
    mov qword [rbp - 8], rax  ; To stack [rbp - 8]
    ; Load variable: len
    movsxd rax, dword [rbp - 92]  ; From stack [rbp - 92]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 216], rax
    mov rax, [rbp - 216]
    ; Store to variable: len
    mov dword [rbp - 92], eax  ; To stack [rbp - 92]
    jmp ir_while_11
ir_while_end_12:
    ; Load variable: len
    movsxd rax, dword [rbp - 92]  ; From stack [rbp - 92]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 224], rax
    mov rax, [rbp - 224]
    ; Store to variable: i
    mov dword [rbp - 96], eax  ; To stack [rbp - 96]
ir_while_13:
    ; Load variable: i
    movsxd rax, dword [rbp - 96]  ; From stack [rbp - 96]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 232], rax
    mov rax, [rbp - 232]
    test rax, rax
    jz ir_while_end_14
    ; Load variable: i
    movsxd rax, dword [rbp - 96]  ; From stack [rbp - 96]
    push rax
    mov rax, 4
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 240], rax
    ; Load variable: buf
    lea rax, [rbp - 88]  ; Local array base
    push rax
    mov rax, [rbp - 240]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 248], rax
    mov rax, [rbp - 248]
    mov eax, dword [rax]
    mov [rbp - 256], rax
    ; IR call: putchar (1 args)
    sub rsp, 32
    mov rax, [rbp - 256]
    mov rcx, rax
    call putchar
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 264], rax
    ; Load variable: i
    movsxd rax, dword [rbp - 96]  ; From stack [rbp - 96]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 272], rax
    mov rax, [rbp - 272]
    ; Store to variable: i
    mov dword [rbp - 96], eax  ; To stack [rbp - 96]
    jmp ir_while_13
ir_while_end_14:
Lprint_int_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global println_int

println_int:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 64    ; Allocate 64 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'n'
    ; Parameter 'n' arrived in register rcx
ir_entry_15:
    ; IR call: print_int (1 args)
    sub rsp, 32
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call print_int
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Void return - no value to handle
    mov [rbp - 16], rax
    ; IR call: putchar (1 args)
    sub rsp, 32
    mov rax, 10
    mov rcx, rax
    call putchar
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 24], rax
Lprintln_int_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller
    extern fopen
    extern fclose
    extern fread
    extern fwrite
    extern fputs
    extern fgets
    extern fflush
    extern __acrt_iob_func

global get_stdin

get_stdin:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 32    ; Allocate 32 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_16:
    ; IR call: __acrt_iob_func (1 args)
    sub rsp, 32
    mov rax, 0
    mov rcx, rax
    call __acrt_iob_func
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    mov [rbp - 8], rax
    mov rax, [rbp - 8]
    jmp Lget_stdin_exit
Lget_stdin_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global get_stdout

get_stdout:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 32    ; Allocate 32 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_17:
    ; IR call: __acrt_iob_func (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call __acrt_iob_func
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    mov [rbp - 8], rax
    mov rax, [rbp - 8]
    jmp Lget_stdout_exit
Lget_stdout_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global get_stderr

get_stderr:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 32    ; Allocate 32 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_18:
    ; IR call: __acrt_iob_func (1 args)
    sub rsp, 32
    mov rax, 2
    mov rcx, rax
    call __acrt_iob_func
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    mov [rbp - 8], rax
    mov rax, [rbp - 8]
    jmp Lget_stderr_exit
Lget_stderr_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global extract_form_value

extract_form_value:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 1360    ; Allocate 1360 bytes on stack (aligned)
    ; Registering 7 function parameters
    mov [rbp - 8], rcx  ; Home param 'buf'
    ; Parameter 'buf' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'body_start'
    ; Parameter 'body_start' arrived in register rdx
    mov [rbp - 24], r8  ; Home param 'body_len'
    ; Parameter 'body_len' arrived in register r8
    mov [rbp - 32], r9  ; Home param 'key'
    ; Parameter 'key' arrived in register r9
    mov rax, [rbp + 16]  ; Load stack param 'key_len'
    mov [rbp - 40], rax  ; Home param 'key_len'
    ; Parameter 'key_len' arrived on stack [rbp + 16]
    mov rax, [rbp + 24]  ; Load stack param 'out'
    mov [rbp - 48], rax  ; Home param 'out'
    ; Parameter 'out' arrived on stack [rbp + 24]
    mov rax, [rbp + 32]  ; Load stack param 'out_max'
    mov [rbp - 56], rax  ; Home param 'out_max'
    ; Parameter 'out_max' arrived on stack [rbp + 32]
ir_entry_19:
    ; Load variable: body_start
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    ; Store to variable: i
    mov dword [rbp - 60], eax  ; To stack [rbp - 60]
    ; Load variable: body_start
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    ; Load variable: body_len
    movsxd rax, dword [rbp - 24]  ; From stack [rbp - 24]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    ; Store to variable: end
    mov dword [rbp - 64], eax  ; To stack [rbp - 64]
ir_while_20:
    ; Load variable: i
    movsxd rax, dword [rbp - 60]  ; From stack [rbp - 60]
    push rax
    ; Load variable: key_len
    movsxd rax, dword [rbp - 40]  ; From stack [rbp - 40]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 104], rax
    mov rax, [rbp - 104]
    push rax
    ; Load variable: end
    movsxd rax, dword [rbp - 64]  ; From stack [rbp - 64]
    mov r10, rax
    pop rax
    cmp rax, r10
    setle al
    movzx rax, al
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    test rax, rax
    jz ir_while_end_21
    mov rax, 1
    ; Store to variable: match
    mov dword [rbp - 68], eax  ; To stack [rbp - 68]
    mov rax, 0
    ; Store to variable: k
    mov dword [rbp - 72], eax  ; To stack [rbp - 72]
ir_while_22:
    ; Load variable: k
    movsxd rax, dword [rbp - 72]  ; From stack [rbp - 72]
    push rax
    ; Load variable: key_len
    movsxd rax, dword [rbp - 40]  ; From stack [rbp - 40]
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 120], rax
    mov rax, [rbp - 120]
    test rax, rax
    jz ir_while_end_23
    ; Load variable: i
    movsxd rax, dword [rbp - 60]  ; From stack [rbp - 60]
    push rax
    ; Load variable: k
    movsxd rax, dword [rbp - 72]  ; From stack [rbp - 72]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 128], rax
    mov rax, [rbp - 128]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 136], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 136]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 144], rax
    mov rax, [rbp - 144]
    movzx rax, byte [rax]
    mov [rbp - 152], rax
    ; Load variable: k
    movsxd rax, dword [rbp - 72]  ; From stack [rbp - 72]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 160], rax
    ; Load variable: key
    mov rax, qword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, [rbp - 160]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    movzx rax, byte [rax]
    mov [rbp - 176], rax
    mov rax, [rbp - 152]
    push rax
    mov rax, [rbp - 176]
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 184], rax
    mov rax, [rbp - 184]
    test rax, rax
    jz ir_if_next_25
    mov rax, 0
    ; Store to variable: match
    mov dword [rbp - 68], eax  ; To stack [rbp - 68]
    jmp ir_while_end_23
    jmp ir_if_end_24
ir_if_next_25:
ir_if_end_24:
    ; Load variable: k
    movsxd rax, dword [rbp - 72]  ; From stack [rbp - 72]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 192], rax
    mov rax, [rbp - 192]
    ; Store to variable: k
    mov dword [rbp - 72], eax  ; To stack [rbp - 72]
    jmp ir_while_22
ir_while_end_23:
    ; Load variable: match
    movsxd rax, dword [rbp - 68]  ; From stack [rbp - 68]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 200], rax
    mov rax, [rbp - 200]
    test rax, rax
    jz ir_sc_false_30
ir_sc_rhs_28:
    ; Load variable: i
    movsxd rax, dword [rbp - 60]  ; From stack [rbp - 60]
    push rax
    ; Load variable: key_len
    movsxd rax, dword [rbp - 40]  ; From stack [rbp - 40]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 208], rax
    mov rax, [rbp - 208]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 216], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 216]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 224], rax
    mov rax, [rbp - 224]
    movzx rax, byte [rax]
    mov [rbp - 232], rax
    mov rax, [rbp - 232]
    push rax
    mov rax, 61
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 240], rax
    mov rax, [rbp - 240]
    test rax, rax
    jz ir_sc_false_30
ir_sc_true_29:
    mov rax, 1
    mov [rbp - 248], rax
    jmp ir_sc_end_31
ir_sc_false_30:
    mov rax, 0
    mov [rbp - 248], rax
ir_sc_end_31:
    mov rax, [rbp - 248]
    test rax, rax
    jz ir_if_next_27
    ; Load variable: i
    movsxd rax, dword [rbp - 60]  ; From stack [rbp - 60]
    push rax
    ; Load variable: key_len
    movsxd rax, dword [rbp - 40]  ; From stack [rbp - 40]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 264], rax
    mov rax, [rbp - 264]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 272], rax
    mov rax, [rbp - 272]
    ; Store to variable: i
    mov dword [rbp - 60], eax  ; To stack [rbp - 60]
    mov rax, 0
    ; Store to variable: out_len
    mov dword [rbp - 76], eax  ; To stack [rbp - 76]
ir_while_32:
    ; Load variable: i
    movsxd rax, dword [rbp - 60]  ; From stack [rbp - 60]
    push rax
    ; Load variable: end
    movsxd rax, dword [rbp - 64]  ; From stack [rbp - 64]
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 280], rax
    mov rax, [rbp - 280]
    test rax, rax
    jz ir_sc_false_36
ir_sc_rhs_34:
    ; Load variable: out_max
    movsxd rax, dword [rbp - 56]  ; From stack [rbp - 56]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 288], rax
    ; Load variable: out_len
    movsxd rax, dword [rbp - 76]  ; From stack [rbp - 76]
    push rax
    mov rax, [rbp - 288]
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 296], rax
    mov rax, [rbp - 296]
    test rax, rax
    jz ir_sc_false_36
ir_sc_true_35:
    mov rax, 1
    mov [rbp - 304], rax
    jmp ir_sc_end_37
ir_sc_false_36:
    mov rax, 0
    mov [rbp - 304], rax
ir_sc_end_37:
    mov rax, [rbp - 304]
    test rax, rax
    jz ir_while_end_33
    ; Load variable: i
    movsxd rax, dword [rbp - 60]  ; From stack [rbp - 60]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 320], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 320]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 328], rax
    mov rax, [rbp - 328]
    movzx rax, byte [rax]
    mov [rbp - 336], rax
    mov rax, [rbp - 336]
    push rax
    mov rax, 38
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 344], rax
    mov rax, [rbp - 344]
    test rax, rax
    jz ir_if_next_39
    jmp ir_while_end_33
    jmp ir_if_end_38
ir_if_next_39:
ir_if_end_38:
    ; Load variable: i
    movsxd rax, dword [rbp - 60]  ; From stack [rbp - 60]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 352], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 352]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 360], rax
    mov rax, [rbp - 360]
    movzx rax, byte [rax]
    mov [rbp - 368], rax
    mov rax, [rbp - 368]
    push rax
    mov rax, 43
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 376], rax
    mov rax, [rbp - 376]
    test rax, rax
    jz ir_if_next_41
    ; Load variable: out_len
    movsxd rax, dword [rbp - 76]  ; From stack [rbp - 76]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 384], rax
    ; Load variable: out
    mov rax, qword [rbp - 48]  ; From stack [rbp - 48]
    push rax
    mov rax, [rbp - 384]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 392], rax
    mov rax, [rbp - 392]
    push rax
    mov rax, 32
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    jmp ir_if_end_40
ir_if_next_41:
    ; Load variable: i
    movsxd rax, dword [rbp - 60]  ; From stack [rbp - 60]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 408], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 408]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 416], rax
    mov rax, [rbp - 416]
    movzx rax, byte [rax]
    mov [rbp - 424], rax
    ; Load variable: out_len
    movsxd rax, dword [rbp - 76]  ; From stack [rbp - 76]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 432], rax
    ; Load variable: out
    mov rax, qword [rbp - 48]  ; From stack [rbp - 48]
    push rax
    mov rax, [rbp - 432]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 440], rax
    mov rax, [rbp - 440]
    push rax
    mov rax, [rbp - 424]
    mov rcx, rax
    pop rax
    mov byte [rax], cl
ir_if_end_40:
    ; Load variable: out_len
    movsxd rax, dword [rbp - 76]  ; From stack [rbp - 76]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 456], rax
    mov rax, [rbp - 456]
    ; Store to variable: out_len
    mov dword [rbp - 76], eax  ; To stack [rbp - 76]
    ; Load variable: i
    movsxd rax, dword [rbp - 60]  ; From stack [rbp - 60]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 464], rax
    mov rax, [rbp - 464]
    ; Store to variable: i
    mov dword [rbp - 60], eax  ; To stack [rbp - 60]
    jmp ir_while_32
ir_while_end_33:
    ; Load variable: out_len
    movsxd rax, dword [rbp - 76]  ; From stack [rbp - 76]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 472], rax
    ; Load variable: out
    mov rax, qword [rbp - 48]  ; From stack [rbp - 48]
    push rax
    mov rax, [rbp - 472]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 480], rax
    mov rax, [rbp - 480]
    push rax
    mov rax, 0
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: out_len
    movsxd rax, dword [rbp - 76]  ; From stack [rbp - 76]
    jmp Lextract_form_value_exit
    jmp ir_if_end_26
ir_if_next_27:
ir_if_end_26:
    ; Load variable: i
    movsxd rax, dword [rbp - 60]  ; From stack [rbp - 60]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 496], rax
    mov rax, [rbp - 496]
    ; Store to variable: i
    mov dword [rbp - 60], eax  ; To stack [rbp - 60]
    jmp ir_while_20
ir_while_end_21:
    mov rax, 0
    jmp Lextract_form_value_exit
Lextract_form_value_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global main

main:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 496    ; Allocate 496 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_42:
    lea rax, [rel REQ]
    mov [rbp - 80], rax
    mov rax, [rbp - 80]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    mov rax, qword [rax]
    mov [rbp - 96], rax
    lea rax, [rel REQ]
    mov [rbp - 104], rax
    mov rax, [rbp - 104]
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    mov rax, qword [rax]
    mov [rbp - 120], rax
    mov rax, [rbp - 120]
    push rax
    mov rax, 33
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 128], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: key_title
    mov rax, qword [rel key_title]  ; From global memory
    mov rcx, rax
    call cstr
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    mov [rbp - 136], rax
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 144], rax
    ; Load variable: out
    lea rax, [rbp - 64]  ; Local array base
    push rax
    mov rax, [rbp - 144]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 152], rax
    ; IR call: extract_form_value (7 args)
    sub rsp, 64
    mov rax, 5
    mov [rsp + 32], rax
    mov rax, [rbp - 152]
    mov [rsp + 40], rax
    mov rax, 64
    mov [rsp + 48], rax
    mov rax, [rbp - 96]
    mov rcx, rax
    mov rax, 33
    mov rdx, rax
    mov rax, [rbp - 128]
    mov r8, rax
    mov rax, [rbp - 136]
    mov r9, rax
    call extract_form_value
    mov rcx, rax
    add rsp, 64
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 160], rax
    mov rax, [rbp - 160]
    ; Store to variable: got
    mov dword [rbp - 68], eax  ; To stack [rbp - 68]
    ; IR call: print_int (1 args)
    sub rsp, 32
    ; Load variable: got
    movsxd rax, dword [rbp - 68]  ; From stack [rbp - 68]
    mov rcx, rax
    call print_int
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Void return - no value to handle
    mov [rbp - 168], rax
    ; IR call: putchar (1 args)
    sub rsp, 32
    mov rax, 10
    mov rcx, rax
    call putchar
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 176], rax
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 184], rax
    ; Load variable: out
    lea rax, [rbp - 64]  ; Local array base
    push rax
    mov rax, [rbp - 184]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 192], rax
    ; IR call: print (1 args)
    sub rsp, 32
    mov rax, [rbp - 192]
    mov rcx, rax
    call print
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Void return - no value to handle
    mov [rbp - 200], rax
    ; IR call: putchar (1 args)
    sub rsp, 32
    mov rax, 10
    mov rcx, rax
    call putchar
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 208], rax
    mov rax, 0
    jmp Lmain_exit
Lmain_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

; Default program entry point
global mainCRTStartup
mainCRTStartup:
    sub rsp, 40      ; Shadow space + alignment
    ; Initialize garbage collector runtime
    lea rcx, [rsp + 40]
    extern gc_init
    call gc_init
    extern gc_register_root
    lea rcx, [rel REQ]
    call gc_register_root
    lea rcx, [rel key_title]
    call gc_register_root
    ; Call user main function
    call main
    mov [rsp + 32], rax ; Preserve main return code
    extern gc_shutdown
    call gc_shutdown
    mov rcx, [rsp + 32] ; Use main return as exit code
    extern ExitProcess
    call ExitProcess

; Data section for global variables
section .data
; Global variable: REQ (string, 16 bytes)
REQ:
    dq Lstr0  ; Pointer to string data
    dq 44  ; String length
Lstr0:
    db "POST /forum HTTP/1.1", 13, 10, "Host: x", 13, 10, 13, 10, "title=hello", 0

; Global variable: key_title (string, 16 bytes)
key_title:
    dq Lstr1  ; Pointer to string data
    dq 5  ; String length
Lstr1:
    db "title", 0

