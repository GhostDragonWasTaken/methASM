; Generated by MethASM
; x86-64 Assembly Output

section .text
; Code section

; First pass: processing 23 declarations
; Declaration 0 type: 3 (AST_INLINE_ASM = 16)
; Declaration 1 type: 3 (AST_INLINE_ASM = 16)
; Declaration 2 type: 3 (AST_INLINE_ASM = 16)
; Declaration 3 type: 3 (AST_INLINE_ASM = 16)
; Declaration 4 type: 3 (AST_INLINE_ASM = 16)
; Declaration 5 type: 3 (AST_INLINE_ASM = 16)
; Declaration 6 type: 3 (AST_INLINE_ASM = 16)
; Declaration 7 type: 3 (AST_INLINE_ASM = 16)
; Declaration 8 type: 3 (AST_INLINE_ASM = 16)
; Declaration 9 type: 3 (AST_INLINE_ASM = 16)
; Declaration 10 type: 3 (AST_INLINE_ASM = 16)
; Declaration 11 type: 3 (AST_INLINE_ASM = 16)
; Declaration 12 type: 4 (AST_INLINE_ASM = 16)
; Declaration 13 type: 2 (AST_INLINE_ASM = 16)
; Declaration 14 type: 2 (AST_INLINE_ASM = 16)
; Declaration 15 type: 2 (AST_INLINE_ASM = 16)
; Declaration 16 type: 2 (AST_INLINE_ASM = 16)
; Declaration 17 type: 2 (AST_INLINE_ASM = 16)
; Declaration 18 type: 2 (AST_INLINE_ASM = 16)
; Declaration 19 type: 2 (AST_INLINE_ASM = 16)
; Declaration 20 type: 2 (AST_INLINE_ASM = 16)
; Declaration 21 type: 3 (AST_INLINE_ASM = 16)
; Declaration 22 type: 3 (AST_INLINE_ASM = 16)

; Data section for global variables
section .data
; Global variable: http_header (string, 16 bytes)
http_header:
    dq Lstr0  ; Pointer to string data
    dq 78  ; String length
Lstr0:
    db "HTTP/1.1 200 OK", 13, 10, "Content-Type: text/html; charset=utf-8", 13, 10, "Connection: close", 13, 10, 13, 10, 0

; Global variable: html_body (string, 16 bytes)
html_body:
    dq Lstr1  ; Pointer to string data
    dq 130  ; String length
Lstr1:
    db "<!DOCTYPE html><html><head><title>MethASM</title></head><body><h1>MethASM Web Server</h1><p>Running on port 5000</p></body></html>", 0

; Global variable: nl (string, 16 bytes)
nl:
    dq Lstr2  ; Pointer to string data
    dq 2  ; String length
Lstr2:
    db 13, 10, 0

; Global variable: msg_wsa_fail (string, 16 bytes)
msg_wsa_fail:
    dq Lstr3  ; Pointer to string data
    dq 32  ; String length
Lstr3:
    db "Startup error: WSAStartup failed", 0

; Global variable: msg_socket_fail (string, 16 bytes)
msg_socket_fail:
    dq Lstr4  ; Pointer to string data
    dq 30  ; String length
Lstr4:
    db "Startup error: socket() failed", 0

; Global variable: msg_bind_fail (string, 16 bytes)
msg_bind_fail:
    dq Lstr5  ; Pointer to string data
    dq 43  ; String length
Lstr5:
    db "Startup error: bind() failed (port in use?)", 0

; Global variable: msg_listen_fail (string, 16 bytes)
msg_listen_fail:
    dq Lstr6  ; Pointer to string data
    dq 30  ; String length
Lstr6:
    db "Startup error: listen() failed", 0

; Global variable: msg_started (string, 16 bytes)
msg_started:
    dq Lstr7  ; Pointer to string data
    dq 41  ; String length
Lstr7:
    db "Server listening on http://localhost:5000", 0


section .text
    extern WSAStartup
    extern WSACleanup
    extern socket
    extern bind
    extern listen
    extern accept
    extern recv
    extern send
    extern closesocket
    extern htons
    extern GetStdHandle
    extern WriteFile
    ; Struct declaration: SockAddrIn
    ; Struct SockAddrIn: size=16, alignment=4

global log_line_parts

log_line_parts:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 304    ; Allocate 304 bytes on stack (aligned)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 'chars'
    ; Parameter 'chars' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'len'
    ; Parameter 'len' arrived in register rdx
ir_entry_0:
    mov rax, 11
    neg rax
    mov [rbp - 32], rax
    ; IR call: GetStdHandle (1 args)
    sub rsp, 32
    mov rax, [rbp - 32]
    mov rcx, rax
    call GetStdHandle
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    ; Store to variable: out
    mov qword [rbp - 24], rax  ; To stack [rbp - 24]
    ; Load variable: out
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_if_else_1
    jmp Llog_line_parts_exit
    jmp ir_if_end_2
ir_if_else_1:
ir_if_end_2:
    ; IR call: WriteFile (5 args)
    sub rsp, 48
    mov rax, 0
    mov [rsp + 32], rax
    ; Load variable: out
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov rcx, rax
    ; Load variable: chars
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rdx, rax
    ; Load variable: len
    mov eax, dword [rbp - 16]  ; From stack [rbp - 16]
    mov r8, rax
    mov rax, 0
    mov r9, rax
    call WriteFile
    mov rcx, rax
    add rsp, 48
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 56], rax
    lea rax, [rel nl]
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    mov rax, qword [rax]
    mov [rbp - 80], rax
    lea rax, [rel nl]
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    mov rax, qword [rax]
    mov [rbp - 104], rax
    ; IR call: WriteFile (5 args)
    sub rsp, 48
    mov rax, 0
    mov [rsp + 32], rax
    ; Load variable: out
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov rcx, rax
    mov rax, [rbp - 80]
    mov rdx, rax
    mov rax, [rbp - 104]
    mov r8, rax
    mov rax, 0
    mov r9, rax
    call WriteFile
    mov rcx, rax
    add rsp, 48
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 112], rax
Llog_line_parts_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global main

main:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 3552    ; Allocate 3552 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_3:
    mov rax, 0
    ; Store to variable: listen_sock
    mov qword [rbp - 440], rax  ; To stack [rbp - 440]
    mov rax, 0
    ; Store to variable: client
    mov qword [rbp - 448], rax  ; To stack [rbp - 448]
    mov rax, 0
    ; Store to variable: result
    mov dword [rbp - 452], eax  ; To stack [rbp - 452]
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1496], rax
    ; Load variable: wsa
    lea rax, [rbp - 416]  ; Local array base
    push rax
    mov rax, [rbp - 1496]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1504], rax
    ; IR call: WSAStartup (2 args)
    sub rsp, 32
    mov rax, 514
    mov rcx, rax
    mov rax, [rbp - 1504]
    mov rdx, rax
    call WSAStartup
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1512], rax
    mov rax, [rbp - 1512]
    ; Store to variable: result
    mov dword [rbp - 452], eax  ; To stack [rbp - 452]
    ; Load variable: result
    mov eax, dword [rbp - 452]  ; From stack [rbp - 452]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 1520], rax
    mov rax, [rbp - 1520]
    test rax, rax
    jz ir_if_else_4
    lea rax, [rel msg_wsa_fail]
    mov [rbp - 1528], rax
    mov rax, [rbp - 1528]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1536], rax
    mov rax, [rbp - 1536]
    mov rax, qword [rax]
    mov [rbp - 1544], rax
    lea rax, [rel msg_wsa_fail]
    mov [rbp - 1552], rax
    mov rax, [rbp - 1552]
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1560], rax
    mov rax, [rbp - 1560]
    mov rax, qword [rax]
    mov [rbp - 1568], rax
    ; IR call: log_line_parts (2 args)
    sub rsp, 32
    mov rax, [rbp - 1544]
    mov rcx, rax
    mov rax, [rbp - 1568]
    mov rdx, rax
    call log_line_parts
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Void return - no value to handle
    mov [rbp - 1576], rax
    mov rax, 1
    jmp Lmain_exit
    jmp ir_if_end_5
ir_if_else_4:
ir_if_end_5:
    ; IR call: socket (3 args)
    sub rsp, 32
    mov rax, 2
    mov rcx, rax
    mov rax, 1
    mov rdx, rax
    mov rax, 0
    mov r8, rax
    call socket
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    mov [rbp - 1584], rax
    mov rax, [rbp - 1584]
    ; Store to variable: listen_sock
    mov qword [rbp - 440], rax  ; To stack [rbp - 440]
    ; Load variable: listen_sock
    mov rax, qword [rbp - 440]  ; From stack [rbp - 440]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1592], rax
    mov rax, [rbp - 1592]
    test rax, rax
    jz ir_if_else_6
    lea rax, [rel msg_socket_fail]
    mov [rbp - 1600], rax
    mov rax, [rbp - 1600]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1608], rax
    mov rax, [rbp - 1608]
    mov rax, qword [rax]
    mov [rbp - 1616], rax
    lea rax, [rel msg_socket_fail]
    mov [rbp - 1624], rax
    mov rax, [rbp - 1624]
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1632], rax
    mov rax, [rbp - 1632]
    mov rax, qword [rax]
    mov [rbp - 1640], rax
    ; IR call: log_line_parts (2 args)
    sub rsp, 32
    mov rax, [rbp - 1616]
    mov rcx, rax
    mov rax, [rbp - 1640]
    mov rdx, rax
    call log_line_parts
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Void return - no value to handle
    mov [rbp - 1648], rax
    ; IR call: WSACleanup (0 args)
    sub rsp, 32
    call WSACleanup
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1656], rax
    mov rax, 1
    jmp Lmain_exit
    jmp ir_if_end_7
ir_if_else_6:
ir_if_end_7:
    lea rax, [rbp - 432]
    mov [rbp - 1664], rax
    mov rax, [rbp - 1664]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1672], rax
    mov rax, [rbp - 1672]
    push rax
    mov rax, 2
    mov rcx, rax
    pop rax
    mov word [rax], cx
    ; IR call: htons (1 args)
    sub rsp, 32
    mov rax, 5000
    mov rcx, rax
    call htons
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    movzx eax, ax    ; Zero-extend 16-bit return value
    mov [rbp - 1688], rax
    lea rax, [rbp - 432]
    mov [rbp - 1696], rax
    mov rax, [rbp - 1696]
    push rax
    mov rax, 2
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1704], rax
    mov rax, [rbp - 1704]
    push rax
    mov rax, [rbp - 1688]
    mov rcx, rax
    pop rax
    mov word [rax], cx
    lea rax, [rbp - 432]
    mov [rbp - 1720], rax
    mov rax, [rbp - 1720]
    push rax
    mov rax, 4
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1728], rax
    mov rax, [rbp - 1728]
    push rax
    mov rax, 0
    mov rcx, rax
    pop rax
    mov dword [rax], ecx
    lea rax, [rbp - 432]
    mov [rbp - 1744], rax
    ; IR call: bind (3 args)
    sub rsp, 32
    ; Load variable: listen_sock
    mov rax, qword [rbp - 440]  ; From stack [rbp - 440]
    mov rcx, rax
    mov rax, [rbp - 1744]
    mov rdx, rax
    mov rax, 16
    mov r8, rax
    call bind
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1752], rax
    mov rax, [rbp - 1752]
    ; Store to variable: result
    mov dword [rbp - 452], eax  ; To stack [rbp - 452]
    ; Load variable: result
    mov eax, dword [rbp - 452]  ; From stack [rbp - 452]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 1760], rax
    mov rax, [rbp - 1760]
    test rax, rax
    jz ir_if_else_8
    lea rax, [rel msg_bind_fail]
    mov [rbp - 1768], rax
    mov rax, [rbp - 1768]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1776], rax
    mov rax, [rbp - 1776]
    mov rax, qword [rax]
    mov [rbp - 1784], rax
    lea rax, [rel msg_bind_fail]
    mov [rbp - 1792], rax
    mov rax, [rbp - 1792]
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1800], rax
    mov rax, [rbp - 1800]
    mov rax, qword [rax]
    mov [rbp - 1808], rax
    ; IR call: log_line_parts (2 args)
    sub rsp, 32
    mov rax, [rbp - 1784]
    mov rcx, rax
    mov rax, [rbp - 1808]
    mov rdx, rax
    call log_line_parts
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Void return - no value to handle
    mov [rbp - 1816], rax
    ; IR call: closesocket (1 args)
    sub rsp, 32
    ; Load variable: listen_sock
    mov rax, qword [rbp - 440]  ; From stack [rbp - 440]
    mov rcx, rax
    call closesocket
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1824], rax
    ; IR call: WSACleanup (0 args)
    sub rsp, 32
    call WSACleanup
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1832], rax
    mov rax, 1
    jmp Lmain_exit
    jmp ir_if_end_9
ir_if_else_8:
ir_if_end_9:
    ; IR call: listen (2 args)
    sub rsp, 32
    ; Load variable: listen_sock
    mov rax, qword [rbp - 440]  ; From stack [rbp - 440]
    mov rcx, rax
    mov rax, 5
    mov rdx, rax
    call listen
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1840], rax
    mov rax, [rbp - 1840]
    ; Store to variable: result
    mov dword [rbp - 452], eax  ; To stack [rbp - 452]
    ; Load variable: result
    mov eax, dword [rbp - 452]  ; From stack [rbp - 452]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 1848], rax
    mov rax, [rbp - 1848]
    test rax, rax
    jz ir_if_else_10
    lea rax, [rel msg_listen_fail]
    mov [rbp - 1856], rax
    mov rax, [rbp - 1856]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1864], rax
    mov rax, [rbp - 1864]
    mov rax, qword [rax]
    mov [rbp - 1872], rax
    lea rax, [rel msg_listen_fail]
    mov [rbp - 1880], rax
    mov rax, [rbp - 1880]
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1888], rax
    mov rax, [rbp - 1888]
    mov rax, qword [rax]
    mov [rbp - 1896], rax
    ; IR call: log_line_parts (2 args)
    sub rsp, 32
    mov rax, [rbp - 1872]
    mov rcx, rax
    mov rax, [rbp - 1896]
    mov rdx, rax
    call log_line_parts
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Void return - no value to handle
    mov [rbp - 1904], rax
    ; IR call: closesocket (1 args)
    sub rsp, 32
    ; Load variable: listen_sock
    mov rax, qword [rbp - 440]  ; From stack [rbp - 440]
    mov rcx, rax
    call closesocket
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1912], rax
    ; IR call: WSACleanup (0 args)
    sub rsp, 32
    call WSACleanup
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1920], rax
    mov rax, 1
    jmp Lmain_exit
    jmp ir_if_end_11
ir_if_else_10:
ir_if_end_11:
    lea rax, [rel msg_started]
    mov [rbp - 1928], rax
    mov rax, [rbp - 1928]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1936], rax
    mov rax, [rbp - 1936]
    mov rax, qword [rax]
    mov [rbp - 1944], rax
    lea rax, [rel msg_started]
    mov [rbp - 1952], rax
    mov rax, [rbp - 1952]
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1960], rax
    mov rax, [rbp - 1960]
    mov rax, qword [rax]
    mov [rbp - 1968], rax
    ; IR call: log_line_parts (2 args)
    sub rsp, 32
    mov rax, [rbp - 1944]
    mov rcx, rax
    mov rax, [rbp - 1968]
    mov rdx, rax
    call log_line_parts
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Void return - no value to handle
    mov [rbp - 1976], rax
ir_while_12:
    mov rax, 1
    test rax, rax
    jz ir_while_end_13
    ; IR call: accept (3 args)
    sub rsp, 32
    ; Load variable: listen_sock
    mov rax, qword [rbp - 440]  ; From stack [rbp - 440]
    mov rcx, rax
    mov rax, 0
    mov rdx, rax
    mov rax, 0
    mov r8, rax
    call accept
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    mov [rbp - 1984], rax
    mov rax, [rbp - 1984]
    ; Store to variable: client
    mov qword [rbp - 448], rax  ; To stack [rbp - 448]
    ; Load variable: client
    mov rax, qword [rbp - 448]  ; From stack [rbp - 448]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1992], rax
    mov rax, [rbp - 1992]
    test rax, rax
    jz ir_if_else_14
    jmp ir_while_12
    jmp ir_if_end_15
ir_if_else_14:
ir_if_end_15:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 2000], rax
    ; Load variable: discard
    lea rax, [rbp - 1480]  ; Local array base
    push rax
    mov rax, [rbp - 2000]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2008], rax
    ; IR call: recv (4 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 448]  ; From stack [rbp - 448]
    mov rcx, rax
    mov rax, [rbp - 2008]
    mov rdx, rax
    mov rax, 1024
    mov r8, rax
    mov rax, 0
    mov r9, rax
    call recv
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 2016], rax
    mov rax, [rbp - 2016]
    ; Store to variable: bytes_read
    mov dword [rbp - 1484], eax  ; To stack [rbp - 1484]
    ; Load variable: bytes_read
    mov eax, dword [rbp - 1484]  ; From stack [rbp - 1484]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setle al
    movzx rax, al
    mov [rbp - 2024], rax
    mov rax, [rbp - 2024]
    test rax, rax
    jz ir_if_else_16
    ; IR call: closesocket (1 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 448]  ; From stack [rbp - 448]
    mov rcx, rax
    call closesocket
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 2032], rax
    jmp ir_while_12
    jmp ir_if_end_17
ir_if_else_16:
ir_if_end_17:
    lea rax, [rel http_header]
    mov [rbp - 2040], rax
    mov rax, [rbp - 2040]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2048], rax
    mov rax, [rbp - 2048]
    mov rax, qword [rax]
    mov [rbp - 2056], rax
    lea rax, [rel http_header]
    mov [rbp - 2064], rax
    mov rax, [rbp - 2064]
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2072], rax
    mov rax, [rbp - 2072]
    mov rax, qword [rax]
    mov [rbp - 2080], rax
    ; IR call: send (4 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 448]  ; From stack [rbp - 448]
    mov rcx, rax
    mov rax, [rbp - 2056]
    mov rdx, rax
    mov rax, [rbp - 2080]
    mov r8, rax
    mov rax, 0
    mov r9, rax
    call send
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 2088], rax
    lea rax, [rel html_body]
    mov [rbp - 2096], rax
    mov rax, [rbp - 2096]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2104], rax
    mov rax, [rbp - 2104]
    mov rax, qword [rax]
    mov [rbp - 2112], rax
    lea rax, [rel html_body]
    mov [rbp - 2120], rax
    mov rax, [rbp - 2120]
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2128], rax
    mov rax, [rbp - 2128]
    mov rax, qword [rax]
    mov [rbp - 2136], rax
    ; IR call: send (4 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 448]  ; From stack [rbp - 448]
    mov rcx, rax
    mov rax, [rbp - 2112]
    mov rdx, rax
    mov rax, [rbp - 2136]
    mov r8, rax
    mov rax, 0
    mov r9, rax
    call send
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 2144], rax
    ; IR call: closesocket (1 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 448]  ; From stack [rbp - 448]
    mov rcx, rax
    call closesocket
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 2152], rax
    jmp ir_while_12
ir_while_end_13:
    ; IR call: closesocket (1 args)
    sub rsp, 32
    ; Load variable: listen_sock
    mov rax, qword [rbp - 440]  ; From stack [rbp - 440]
    mov rcx, rax
    call closesocket
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 2160], rax
    ; IR call: WSACleanup (0 args)
    sub rsp, 32
    call WSACleanup
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 2168], rax
    mov rax, 0
    jmp Lmain_exit
Lmain_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

; Default program entry point
global mainCRTStartup
mainCRTStartup:
    sub rsp, 40      ; Shadow space + alignment
    ; Initialize garbage collector runtime
    lea rcx, [rsp + 40]
    extern gc_init
    call gc_init
    extern gc_register_root
    lea rcx, [rel http_header]
    call gc_register_root
    lea rcx, [rel html_body]
    call gc_register_root
    lea rcx, [rel nl]
    call gc_register_root
    lea rcx, [rel msg_wsa_fail]
    call gc_register_root
    lea rcx, [rel msg_socket_fail]
    call gc_register_root
    lea rcx, [rel msg_bind_fail]
    call gc_register_root
    lea rcx, [rel msg_listen_fail]
    call gc_register_root
    lea rcx, [rel msg_started]
    call gc_register_root
    ; Call user main function
    call main
    mov [rsp + 32], rax ; Preserve main return code
    extern gc_shutdown
    call gc_shutdown
    mov rcx, [rsp + 32] ; Use main return as exit code
    extern ExitProcess
    call ExitProcess
