; Generated by MethASM
; x86-64 Assembly Output

section .text
; Code section

; First pass: processing 229 declarations
; Declaration 0 type: 4 (AST_INLINE_ASM = 20)
; Declaration 1 type: 4 (AST_INLINE_ASM = 20)
; Declaration 2 type: 4 (AST_INLINE_ASM = 20)
; Declaration 3 type: 4 (AST_INLINE_ASM = 20)
; Declaration 4 type: 4 (AST_INLINE_ASM = 20)
; Declaration 5 type: 4 (AST_INLINE_ASM = 20)
; Declaration 6 type: 4 (AST_INLINE_ASM = 20)
; Declaration 7 type: 4 (AST_INLINE_ASM = 20)
; Declaration 8 type: 4 (AST_INLINE_ASM = 20)
; Declaration 9 type: 4 (AST_INLINE_ASM = 20)
; Declaration 10 type: 4 (AST_INLINE_ASM = 20)
; Declaration 11 type: 4 (AST_INLINE_ASM = 20)
; Declaration 12 type: 4 (AST_INLINE_ASM = 20)
; Declaration 13 type: 4 (AST_INLINE_ASM = 20)
; Declaration 14 type: 4 (AST_INLINE_ASM = 20)
; Declaration 15 type: 4 (AST_INLINE_ASM = 20)
; Declaration 16 type: 4 (AST_INLINE_ASM = 20)
; Declaration 17 type: 4 (AST_INLINE_ASM = 20)
; Declaration 18 type: 4 (AST_INLINE_ASM = 20)
; Declaration 19 type: 4 (AST_INLINE_ASM = 20)
; Declaration 20 type: 4 (AST_INLINE_ASM = 20)
; Declaration 21 type: 4 (AST_INLINE_ASM = 20)
; Declaration 22 type: 4 (AST_INLINE_ASM = 20)
; Declaration 23 type: 4 (AST_INLINE_ASM = 20)
; Declaration 24 type: 4 (AST_INLINE_ASM = 20)
; Declaration 25 type: 4 (AST_INLINE_ASM = 20)
; Declaration 26 type: 4 (AST_INLINE_ASM = 20)
; Declaration 27 type: 4 (AST_INLINE_ASM = 20)
; Declaration 28 type: 4 (AST_INLINE_ASM = 20)
; Declaration 29 type: 4 (AST_INLINE_ASM = 20)
; Declaration 30 type: 4 (AST_INLINE_ASM = 20)
; Declaration 31 type: 4 (AST_INLINE_ASM = 20)
; Declaration 32 type: 4 (AST_INLINE_ASM = 20)
; Declaration 33 type: 4 (AST_INLINE_ASM = 20)
; Declaration 34 type: 4 (AST_INLINE_ASM = 20)
; Declaration 35 type: 4 (AST_INLINE_ASM = 20)
; Declaration 36 type: 4 (AST_INLINE_ASM = 20)
; Declaration 37 type: 4 (AST_INLINE_ASM = 20)
; Declaration 38 type: 4 (AST_INLINE_ASM = 20)
; Declaration 39 type: 4 (AST_INLINE_ASM = 20)
; Declaration 40 type: 4 (AST_INLINE_ASM = 20)
; Declaration 41 type: 4 (AST_INLINE_ASM = 20)
; Declaration 42 type: 4 (AST_INLINE_ASM = 20)
; Declaration 43 type: 4 (AST_INLINE_ASM = 20)
; Declaration 44 type: 4 (AST_INLINE_ASM = 20)
; Declaration 45 type: 4 (AST_INLINE_ASM = 20)
; Declaration 46 type: 4 (AST_INLINE_ASM = 20)
; Declaration 47 type: 4 (AST_INLINE_ASM = 20)
; Declaration 48 type: 4 (AST_INLINE_ASM = 20)
; Declaration 49 type: 4 (AST_INLINE_ASM = 20)
; Declaration 50 type: 4 (AST_INLINE_ASM = 20)
; Declaration 51 type: 4 (AST_INLINE_ASM = 20)
; Declaration 52 type: 4 (AST_INLINE_ASM = 20)
; Declaration 53 type: 4 (AST_INLINE_ASM = 20)
; Declaration 54 type: 4 (AST_INLINE_ASM = 20)
; Declaration 55 type: 4 (AST_INLINE_ASM = 20)
; Declaration 56 type: 4 (AST_INLINE_ASM = 20)
; Declaration 57 type: 4 (AST_INLINE_ASM = 20)
; Declaration 58 type: 4 (AST_INLINE_ASM = 20)
; Declaration 59 type: 4 (AST_INLINE_ASM = 20)
; Declaration 60 type: 4 (AST_INLINE_ASM = 20)
; Declaration 61 type: 4 (AST_INLINE_ASM = 20)
; Declaration 62 type: 4 (AST_INLINE_ASM = 20)
; Declaration 63 type: 4 (AST_INLINE_ASM = 20)
; Declaration 64 type: 4 (AST_INLINE_ASM = 20)
; Declaration 65 type: 4 (AST_INLINE_ASM = 20)
; Declaration 66 type: 4 (AST_INLINE_ASM = 20)
; Declaration 67 type: 3 (AST_INLINE_ASM = 20)
; Declaration 68 type: 3 (AST_INLINE_ASM = 20)
; Declaration 69 type: 4 (AST_INLINE_ASM = 20)
; Declaration 70 type: 4 (AST_INLINE_ASM = 20)
; Declaration 71 type: 4 (AST_INLINE_ASM = 20)
; Declaration 72 type: 4 (AST_INLINE_ASM = 20)
; Declaration 73 type: 4 (AST_INLINE_ASM = 20)
; Declaration 74 type: 4 (AST_INLINE_ASM = 20)
; Declaration 75 type: 4 (AST_INLINE_ASM = 20)
; Declaration 76 type: 4 (AST_INLINE_ASM = 20)
; Declaration 77 type: 4 (AST_INLINE_ASM = 20)
; Declaration 78 type: 4 (AST_INLINE_ASM = 20)
; Declaration 79 type: 4 (AST_INLINE_ASM = 20)
; Declaration 80 type: 4 (AST_INLINE_ASM = 20)
; Declaration 81 type: 4 (AST_INLINE_ASM = 20)
; Declaration 82 type: 4 (AST_INLINE_ASM = 20)
; Declaration 83 type: 4 (AST_INLINE_ASM = 20)
; Declaration 84 type: 4 (AST_INLINE_ASM = 20)
; Declaration 85 type: 4 (AST_INLINE_ASM = 20)
; Declaration 86 type: 4 (AST_INLINE_ASM = 20)
; Declaration 87 type: 4 (AST_INLINE_ASM = 20)
; Declaration 88 type: 4 (AST_INLINE_ASM = 20)
; Declaration 89 type: 4 (AST_INLINE_ASM = 20)
; Declaration 90 type: 4 (AST_INLINE_ASM = 20)
; Declaration 91 type: 4 (AST_INLINE_ASM = 20)
; Declaration 92 type: 4 (AST_INLINE_ASM = 20)
; Declaration 93 type: 4 (AST_INLINE_ASM = 20)
; Declaration 94 type: 4 (AST_INLINE_ASM = 20)
; Declaration 95 type: 4 (AST_INLINE_ASM = 20)
; Declaration 96 type: 4 (AST_INLINE_ASM = 20)
; Declaration 97 type: 4 (AST_INLINE_ASM = 20)
; Declaration 98 type: 4 (AST_INLINE_ASM = 20)
; Declaration 99 type: 4 (AST_INLINE_ASM = 20)
; Declaration 100 type: 4 (AST_INLINE_ASM = 20)
; Declaration 101 type: 4 (AST_INLINE_ASM = 20)
; Declaration 102 type: 4 (AST_INLINE_ASM = 20)
; Declaration 103 type: 4 (AST_INLINE_ASM = 20)
; Declaration 104 type: 4 (AST_INLINE_ASM = 20)
; Declaration 105 type: 4 (AST_INLINE_ASM = 20)
; Declaration 106 type: 4 (AST_INLINE_ASM = 20)
; Declaration 107 type: 4 (AST_INLINE_ASM = 20)
; Declaration 108 type: 4 (AST_INLINE_ASM = 20)
; Declaration 109 type: 4 (AST_INLINE_ASM = 20)
; Declaration 110 type: 4 (AST_INLINE_ASM = 20)
; Declaration 111 type: 4 (AST_INLINE_ASM = 20)
; Declaration 112 type: 4 (AST_INLINE_ASM = 20)
; Declaration 113 type: 4 (AST_INLINE_ASM = 20)
; Declaration 114 type: 4 (AST_INLINE_ASM = 20)
; Declaration 115 type: 4 (AST_INLINE_ASM = 20)
; Declaration 116 type: 4 (AST_INLINE_ASM = 20)
; Declaration 117 type: 4 (AST_INLINE_ASM = 20)
; Declaration 118 type: 4 (AST_INLINE_ASM = 20)
; Declaration 119 type: 4 (AST_INLINE_ASM = 20)
; Declaration 120 type: 4 (AST_INLINE_ASM = 20)
; Declaration 121 type: 4 (AST_INLINE_ASM = 20)
; Declaration 122 type: 4 (AST_INLINE_ASM = 20)
; Declaration 123 type: 4 (AST_INLINE_ASM = 20)
; Declaration 124 type: 4 (AST_INLINE_ASM = 20)
; Declaration 125 type: 4 (AST_INLINE_ASM = 20)
; Declaration 126 type: 4 (AST_INLINE_ASM = 20)
; Declaration 127 type: 4 (AST_INLINE_ASM = 20)
; Declaration 128 type: 4 (AST_INLINE_ASM = 20)
; Declaration 129 type: 4 (AST_INLINE_ASM = 20)
; Declaration 130 type: 4 (AST_INLINE_ASM = 20)
; Declaration 131 type: 4 (AST_INLINE_ASM = 20)
; Declaration 132 type: 4 (AST_INLINE_ASM = 20)
; Declaration 133 type: 4 (AST_INLINE_ASM = 20)
; Declaration 134 type: 4 (AST_INLINE_ASM = 20)
; Declaration 135 type: 4 (AST_INLINE_ASM = 20)
; Declaration 136 type: 4 (AST_INLINE_ASM = 20)
; Declaration 137 type: 4 (AST_INLINE_ASM = 20)
; Declaration 138 type: 4 (AST_INLINE_ASM = 20)
; Declaration 139 type: 4 (AST_INLINE_ASM = 20)
; Declaration 140 type: 3 (AST_INLINE_ASM = 20)
; Declaration 141 type: 3 (AST_INLINE_ASM = 20)
; Declaration 142 type: 3 (AST_INLINE_ASM = 20)
; Declaration 143 type: 3 (AST_INLINE_ASM = 20)
; Declaration 144 type: 3 (AST_INLINE_ASM = 20)
; Declaration 145 type: 3 (AST_INLINE_ASM = 20)
; Declaration 146 type: 3 (AST_INLINE_ASM = 20)
; Declaration 147 type: 3 (AST_INLINE_ASM = 20)
; Declaration 148 type: 3 (AST_INLINE_ASM = 20)
; Declaration 149 type: 3 (AST_INLINE_ASM = 20)
; Declaration 150 type: 3 (AST_INLINE_ASM = 20)
; Declaration 151 type: 3 (AST_INLINE_ASM = 20)
; Declaration 152 type: 3 (AST_INLINE_ASM = 20)
; Declaration 153 type: 3 (AST_INLINE_ASM = 20)
; Declaration 154 type: 3 (AST_INLINE_ASM = 20)
; Declaration 155 type: 3 (AST_INLINE_ASM = 20)
; Declaration 156 type: 3 (AST_INLINE_ASM = 20)
; Declaration 157 type: 3 (AST_INLINE_ASM = 20)
; Declaration 158 type: 3 (AST_INLINE_ASM = 20)
; Declaration 159 type: 3 (AST_INLINE_ASM = 20)
; Declaration 160 type: 3 (AST_INLINE_ASM = 20)
; Declaration 161 type: 3 (AST_INLINE_ASM = 20)
; Declaration 162 type: 3 (AST_INLINE_ASM = 20)
; Declaration 163 type: 3 (AST_INLINE_ASM = 20)
; Declaration 164 type: 3 (AST_INLINE_ASM = 20)
; Declaration 165 type: 3 (AST_INLINE_ASM = 20)
; Declaration 166 type: 3 (AST_INLINE_ASM = 20)
; Declaration 167 type: 3 (AST_INLINE_ASM = 20)
; Declaration 168 type: 3 (AST_INLINE_ASM = 20)
; Declaration 169 type: 3 (AST_INLINE_ASM = 20)
; Declaration 170 type: 3 (AST_INLINE_ASM = 20)
; Declaration 171 type: 3 (AST_INLINE_ASM = 20)
; Declaration 172 type: 3 (AST_INLINE_ASM = 20)
; Declaration 173 type: 3 (AST_INLINE_ASM = 20)
; Declaration 174 type: 3 (AST_INLINE_ASM = 20)
; Declaration 175 type: 3 (AST_INLINE_ASM = 20)
; Declaration 176 type: 3 (AST_INLINE_ASM = 20)
; Declaration 177 type: 3 (AST_INLINE_ASM = 20)
; Declaration 178 type: 3 (AST_INLINE_ASM = 20)
; Declaration 179 type: 3 (AST_INLINE_ASM = 20)
; Declaration 180 type: 3 (AST_INLINE_ASM = 20)
; Declaration 181 type: 3 (AST_INLINE_ASM = 20)
; Declaration 182 type: 3 (AST_INLINE_ASM = 20)
; Declaration 183 type: 3 (AST_INLINE_ASM = 20)
; Declaration 184 type: 3 (AST_INLINE_ASM = 20)
; Declaration 185 type: 3 (AST_INLINE_ASM = 20)
; Declaration 186 type: 3 (AST_INLINE_ASM = 20)
; Declaration 187 type: 3 (AST_INLINE_ASM = 20)
; Declaration 188 type: 3 (AST_INLINE_ASM = 20)
; Declaration 189 type: 3 (AST_INLINE_ASM = 20)
; Declaration 190 type: 3 (AST_INLINE_ASM = 20)
; Declaration 191 type: 3 (AST_INLINE_ASM = 20)
; Declaration 192 type: 3 (AST_INLINE_ASM = 20)
; Declaration 193 type: 3 (AST_INLINE_ASM = 20)
; Declaration 194 type: 3 (AST_INLINE_ASM = 20)
; Declaration 195 type: 3 (AST_INLINE_ASM = 20)
; Declaration 196 type: 3 (AST_INLINE_ASM = 20)
; Declaration 197 type: 3 (AST_INLINE_ASM = 20)
; Declaration 198 type: 3 (AST_INLINE_ASM = 20)
; Declaration 199 type: 3 (AST_INLINE_ASM = 20)
; Declaration 200 type: 3 (AST_INLINE_ASM = 20)
; Declaration 201 type: 3 (AST_INLINE_ASM = 20)
; Declaration 202 type: 3 (AST_INLINE_ASM = 20)
; Declaration 203 type: 3 (AST_INLINE_ASM = 20)
; Declaration 204 type: 3 (AST_INLINE_ASM = 20)
; Declaration 205 type: 4 (AST_INLINE_ASM = 20)
; Declaration 206 type: 4 (AST_INLINE_ASM = 20)
; Declaration 207 type: 4 (AST_INLINE_ASM = 20)
; Declaration 208 type: 3 (AST_INLINE_ASM = 20)
; Declaration 209 type: 3 (AST_INLINE_ASM = 20)
; Declaration 210 type: 3 (AST_INLINE_ASM = 20)
; Declaration 211 type: 3 (AST_INLINE_ASM = 20)
; Declaration 212 type: 3 (AST_INLINE_ASM = 20)
; Declaration 213 type: 3 (AST_INLINE_ASM = 20)
; Declaration 214 type: 3 (AST_INLINE_ASM = 20)
; Declaration 215 type: 3 (AST_INLINE_ASM = 20)
; Declaration 216 type: 4 (AST_INLINE_ASM = 20)
; Declaration 217 type: 4 (AST_INLINE_ASM = 20)
; Declaration 218 type: 4 (AST_INLINE_ASM = 20)
; Declaration 219 type: 4 (AST_INLINE_ASM = 20)
; Declaration 220 type: 4 (AST_INLINE_ASM = 20)
; Declaration 221 type: 4 (AST_INLINE_ASM = 20)
; Declaration 222 type: 4 (AST_INLINE_ASM = 20)
; Declaration 223 type: 4 (AST_INLINE_ASM = 20)
; Declaration 224 type: 4 (AST_INLINE_ASM = 20)
; Declaration 225 type: 4 (AST_INLINE_ASM = 20)
; Declaration 226 type: 4 (AST_INLINE_ASM = 20)
; Declaration 227 type: 4 (AST_INLINE_ASM = 20)
; Declaration 228 type: 4 (AST_INLINE_ASM = 20)

section .text
    extern puts
    extern putchar
    extern getchar

global cstr

cstr:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 80    ; Allocate 80 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 's'
    ; Parameter 's' arrived in register rcx
ir_entry_0:
    ; Load variable: s
    mov rax, qword [rbp - 8]  ; String param ptr
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    mov rax, qword [rax]
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_1
    jmp ir_errdefer_end_2
ir_errdefer_ok_1:
ir_errdefer_end_2:
    mov rax, [rbp - 24]
    jmp Lcstr_exit
Lcstr_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global print

print:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 272    ; Allocate 272 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'msg'
    ; Parameter 'msg' arrived in register rcx
ir_entry_3:
    mov rax, 0
    ; Store to variable: i
    mov qword [rbp - 16], rax  ; To stack [rbp - 16]
ir_while_4:
    ; Load variable: msg
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_6
    jmp ir_nonnull_7
ir_trap_null_6:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct73]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    extern exit
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_7:
    ; Load variable: i
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 24], rax
    ; Load variable: msg
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 24]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    movzx rax, byte [rax]
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_while_end_5
    ; Load variable: msg
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_8
    jmp ir_nonnull_9
ir_trap_null_8:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct75]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_9:
    ; Load variable: i
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 56], rax
    ; Load variable: msg
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 56]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    movzx rax, byte [rax]
    mov [rbp - 72], rax
    ; IR call: putchar (1 args)
    sub rsp, 32
    mov rax, [rbp - 72]
    mov rcx, rax
    call putchar
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 80], rax
    ; Load variable: i
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    ; Store to variable: i
    mov qword [rbp - 16], rax  ; To stack [rbp - 16]
    jmp ir_while_4
ir_while_end_5:
    mov rax, 0
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    test rax, rax
    jz ir_errdefer_ok_10
    jmp ir_errdefer_end_11
ir_errdefer_ok_10:
ir_errdefer_end_11:
    jmp Lprint_exit
Lprint_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global println

println:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 64    ; Allocate 64 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'msg'
    ; Parameter 'msg' arrived in register rcx
ir_entry_12:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; Load variable: msg
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 16], rax
    mov rax, 0
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_errdefer_ok_13
    jmp ir_errdefer_end_14
ir_errdefer_ok_13:
ir_errdefer_end_14:
    jmp Lprintln_exit
Lprintln_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global newline

newline:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 48    ; Allocate 48 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_15:
    ; IR call: putchar (1 args)
    sub rsp, 32
    mov rax, 10
    mov rcx, rax
    call putchar
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 8], rax
    mov rax, 0
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_errdefer_ok_16
    jmp ir_errdefer_end_17
ir_errdefer_ok_16:
ir_errdefer_end_17:
    jmp Lnewline_exit
Lnewline_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global print_int

print_int:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 752    ; Allocate 752 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'n'
    ; Parameter 'n' arrived in register rcx
ir_entry_18:
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 104], rax
    mov rax, [rbp - 104]
    test rax, rax
    jz ir_if_next_20
    ; IR call: putchar (1 args)
    sub rsp, 32
    mov rax, 45
    mov rcx, rax
    call putchar
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 112], rax
    mov rax, 0
    push rax
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 120], rax
    mov rax, [rbp - 120]
    ; Store to variable: n
    mov qword [rbp - 8], rax  ; To stack [rbp - 8]
    jmp ir_if_end_19
ir_if_next_20:
ir_if_end_19:
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 128], rax
    mov rax, [rbp - 128]
    test rax, rax
    jz ir_if_next_22
    ; IR call: putchar (1 args)
    sub rsp, 32
    mov rax, 48
    mov rcx, rax
    call putchar
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 136], rax
    mov rax, 0
    mov [rbp - 144], rax
    mov rax, [rbp - 144]
    test rax, rax
    jz ir_errdefer_ok_23
    jmp ir_errdefer_end_24
ir_errdefer_ok_23:
ir_errdefer_end_24:
    jmp Lprint_int_exit
    jmp ir_if_end_21
ir_if_next_22:
ir_if_end_21:
    mov rax, 0
    ; Store to variable: len
    mov dword [rbp - 92], eax  ; To stack [rbp - 92]
ir_while_25:
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setg al
    movzx rax, al
    mov [rbp - 152], rax
    mov rax, [rbp - 152]
    test rax, rax
    jz ir_while_end_26
    mov rax, 48
    push rax
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 160], rax
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 10
    mov r10, rax
    pop rax
    cqo
    idiv r10
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    push rax
    mov rax, 10
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 176], rax
    mov rax, [rbp - 160]
    push rax
    mov rax, [rbp - 176]
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 184], rax
    ; Load variable: len
    movsxd rax, dword [rbp - 92]  ; From stack [rbp - 92]
    push rax
    mov rax, 20
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 192], rax
    mov rax, [rbp - 192]
    test rax, rax
    jz ir_trap_bounds_27
    jmp ir_in_bounds_28
ir_trap_bounds_27:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct77]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_28:
    ; Load variable: len
    movsxd rax, dword [rbp - 92]  ; From stack [rbp - 92]
    push rax
    mov rax, 4
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 200], rax
    ; Load variable: buf
    lea rax, [rbp - 88]  ; Local array base
    push rax
    mov rax, [rbp - 200]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 208], rax
    mov rax, [rbp - 208]
    push rax
    mov rax, [rbp - 184]
    mov rcx, rax
    pop rax
    mov dword [rax], ecx
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 10
    mov r10, rax
    pop rax
    cqo
    idiv r10
    mov [rbp - 224], rax
    mov rax, [rbp - 224]
    ; Store to variable: n
    mov qword [rbp - 8], rax  ; To stack [rbp - 8]
    ; Load variable: len
    movsxd rax, dword [rbp - 92]  ; From stack [rbp - 92]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 232], rax
    mov rax, [rbp - 232]
    ; Store to variable: len
    mov dword [rbp - 92], eax  ; To stack [rbp - 92]
    jmp ir_while_25
ir_while_end_26:
    ; Load variable: len
    movsxd rax, dword [rbp - 92]  ; From stack [rbp - 92]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 240], rax
    mov rax, [rbp - 240]
    ; Store to variable: i
    mov dword [rbp - 96], eax  ; To stack [rbp - 96]
ir_while_29:
    ; Load variable: i
    movsxd rax, dword [rbp - 96]  ; From stack [rbp - 96]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 248], rax
    mov rax, [rbp - 248]
    test rax, rax
    jz ir_while_end_30
    ; Load variable: i
    movsxd rax, dword [rbp - 96]  ; From stack [rbp - 96]
    push rax
    mov rax, 20
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 256], rax
    mov rax, [rbp - 256]
    test rax, rax
    jz ir_trap_bounds_31
    jmp ir_in_bounds_32
ir_trap_bounds_31:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct79]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_32:
    ; Load variable: i
    movsxd rax, dword [rbp - 96]  ; From stack [rbp - 96]
    push rax
    mov rax, 4
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 264], rax
    ; Load variable: buf
    lea rax, [rbp - 88]  ; Local array base
    push rax
    mov rax, [rbp - 264]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 272], rax
    mov rax, [rbp - 272]
    mov eax, dword [rax]
    mov [rbp - 280], rax
    ; IR call: putchar (1 args)
    sub rsp, 32
    mov rax, [rbp - 280]
    mov rcx, rax
    call putchar
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 288], rax
    ; Load variable: i
    movsxd rax, dword [rbp - 96]  ; From stack [rbp - 96]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 296], rax
    mov rax, [rbp - 296]
    ; Store to variable: i
    mov dword [rbp - 96], eax  ; To stack [rbp - 96]
    jmp ir_while_29
ir_while_end_30:
    mov rax, 0
    mov [rbp - 304], rax
    mov rax, [rbp - 304]
    test rax, rax
    jz ir_errdefer_ok_33
    jmp ir_errdefer_end_34
ir_errdefer_ok_33:
ir_errdefer_end_34:
    jmp Lprint_int_exit
Lprint_int_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global println_int

println_int:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 80    ; Allocate 80 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'n'
    ; Parameter 'n' arrived in register rcx
ir_entry_35:
    ; IR call: print_int (1 args)
    sub rsp, 32
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call print_int
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 16], rax
    ; IR call: putchar (1 args)
    sub rsp, 32
    mov rax, 10
    mov rcx, rax
    call putchar
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 24], rax
    mov rax, 0
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_36
    jmp ir_errdefer_end_37
ir_errdefer_ok_36:
ir_errdefer_end_37:
    jmp Lprintln_int_exit
Lprintln_int_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller
    extern fopen
    extern fclose
    extern fread
    extern fwrite
    extern fputs
    extern fgets
    extern fflush
    extern __acrt_iob_func

global get_stdin

get_stdin:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 48    ; Allocate 48 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_38:
    ; IR call: __acrt_iob_func (1 args)
    sub rsp, 32
    mov rax, 0
    mov rcx, rax
    call __acrt_iob_func
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 8], rax
    mov rax, [rbp - 8]
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_errdefer_ok_39
    jmp ir_errdefer_end_40
ir_errdefer_ok_39:
ir_errdefer_end_40:
    mov rax, [rbp - 8]
    jmp Lget_stdin_exit
Lget_stdin_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global get_stdout

get_stdout:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 48    ; Allocate 48 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_41:
    ; IR call: __acrt_iob_func (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call __acrt_iob_func
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 8], rax
    mov rax, [rbp - 8]
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_errdefer_ok_42
    jmp ir_errdefer_end_43
ir_errdefer_ok_42:
ir_errdefer_end_43:
    mov rax, [rbp - 8]
    jmp Lget_stdout_exit
Lget_stdout_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global get_stderr

get_stderr:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 48    ; Allocate 48 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_44:
    ; IR call: __acrt_iob_func (1 args)
    sub rsp, 32
    mov rax, 2
    mov rcx, rax
    call __acrt_iob_func
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 8], rax
    mov rax, [rbp - 8]
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_errdefer_ok_45
    jmp ir_errdefer_end_46
ir_errdefer_ok_45:
ir_errdefer_end_46:
    mov rax, [rbp - 8]
    jmp Lget_stderr_exit
Lget_stderr_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller
    extern malloc
    extern calloc
    extern realloc
    extern free
    extern memset
    extern memcpy
    extern memmove
    extern memcmp

global alloc_zeroed

alloc_zeroed:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 64    ; Allocate 64 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'n'
    ; Parameter 'n' arrived in register rcx
ir_entry_47:
    ; IR call: calloc (2 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rdx, rax
    call calloc
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_errdefer_ok_48
    jmp ir_errdefer_end_49
ir_errdefer_ok_48:
ir_errdefer_end_49:
    mov rax, [rbp - 16]
    jmp Lalloc_zeroed_exit
Lalloc_zeroed_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global buf_dup

buf_dup:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 160    ; Allocate 160 bytes on stack (aligned)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 'src'
    ; Parameter 'src' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'len'
    ; Parameter 'len' arrived in register rdx
ir_entry_50:
    ; IR call: malloc (1 args)
    sub rsp, 32
    ; Load variable: len
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov rcx, rax
    call malloc
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    ; Store to variable: dst
    mov qword [rbp - 24], rax  ; To stack [rbp - 24]
    ; Load variable: dst
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_if_next_52
    mov rax, 0
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_errdefer_ok_53
    jmp ir_errdefer_end_54
ir_errdefer_ok_53:
ir_errdefer_end_54:
    mov rax, 0
    jmp Lbuf_dup_exit
    jmp ir_if_end_51
ir_if_next_52:
ir_if_end_51:
    ; IR call: memcpy (3 args)
    sub rsp, 32
    ; Load variable: dst
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov rcx, rax
    ; Load variable: src
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rdx, rax
    ; Load variable: len
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov r8, rax
    call memcpy
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 56], rax
    ; Load variable: dst
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    test rax, rax
    jz ir_errdefer_ok_55
    jmp ir_errdefer_end_56
ir_errdefer_ok_55:
ir_errdefer_end_56:
    ; Load variable: dst
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    jmp Lbuf_dup_exit
Lbuf_dup_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global INFINITE

INFINITE:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 32    ; Allocate 32 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_57:
    mov rax, 0
    mov [rbp - 8], rax
    mov rax, [rbp - 8]
    test rax, rax
    jz ir_errdefer_ok_58
    jmp ir_errdefer_end_59
ir_errdefer_ok_58:
ir_errdefer_end_59:
    mov rax, 0
    jmp LINFINITE_exit
LINFINITE_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global WAIT_OBJECT_0

WAIT_OBJECT_0:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 32    ; Allocate 32 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_60:
    mov rax, 0
    mov [rbp - 8], rax
    mov rax, [rbp - 8]
    test rax, rax
    jz ir_errdefer_ok_61
    jmp ir_errdefer_end_62
ir_errdefer_ok_61:
ir_errdefer_end_62:
    mov rax, 0
    jmp LWAIT_OBJECT_0_exit
LWAIT_OBJECT_0_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global WAIT_TIMEOUT

WAIT_TIMEOUT:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 32    ; Allocate 32 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_63:
    mov rax, 258
    mov [rbp - 8], rax
    mov rax, [rbp - 8]
    test rax, rax
    jz ir_errdefer_ok_64
    jmp ir_errdefer_end_65
ir_errdefer_ok_64:
ir_errdefer_end_65:
    mov rax, 258
    jmp LWAIT_TIMEOUT_exit
LWAIT_TIMEOUT_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global WAIT_FAILED

WAIT_FAILED:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 32    ; Allocate 32 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_66:
    mov rax, 0
    mov [rbp - 8], rax
    mov rax, [rbp - 8]
    test rax, rax
    jz ir_errdefer_ok_67
    jmp ir_errdefer_end_68
ir_errdefer_ok_67:
ir_errdefer_end_68:
    mov rax, 0
    jmp LWAIT_FAILED_exit
LWAIT_FAILED_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller
    extern CreateThread
    extern CloseHandle
    extern WaitForSingleObject
    extern GetCurrentThreadId
    extern Sleep
    extern CreateMutexA
    extern ReleaseMutex
    extern gc_thread_attach
    extern gc_thread_detach
    extern _InterlockedCompareExchange
    extern _InterlockedExchange
    extern _InterlockedIncrement
    extern _InterlockedDecrement

global thread_close

thread_close:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 64    ; Allocate 64 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'handle'
    ; Parameter 'handle' arrived in register rcx
ir_entry_69:
    ; IR call: CloseHandle (1 args)
    sub rsp, 32
    ; Load variable: handle
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call CloseHandle
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_errdefer_ok_70
    jmp ir_errdefer_end_71
ir_errdefer_ok_70:
ir_errdefer_end_71:
    mov rax, [rbp - 16]
    jmp Lthread_close_exit
Lthread_close_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global thread_join

thread_join:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 64    ; Allocate 64 bytes on stack (aligned)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 'handle'
    ; Parameter 'handle' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'timeout_ms'
    ; Parameter 'timeout_ms' arrived in register rdx
ir_entry_72:
    ; IR call: WaitForSingleObject (2 args)
    sub rsp, 32
    ; Load variable: handle
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    ; Load variable: timeout_ms
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    mov rdx, rax
    call WaitForSingleObject
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_73
    jmp ir_errdefer_end_74
ir_errdefer_ok_73:
ir_errdefer_end_74:
    mov rax, [rbp - 24]
    jmp Lthread_join_exit
Lthread_join_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global thread_join_infinite

thread_join_infinite:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 80    ; Allocate 80 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'handle'
    ; Parameter 'handle' arrived in register rcx
ir_entry_75:
    ; IR call: INFINITE (0 args)
    sub rsp, 32
    call INFINITE
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 16], rax
    ; IR call: WaitForSingleObject (2 args)
    sub rsp, 32
    ; Load variable: handle
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    mov rax, [rbp - 16]
    mov rdx, rax
    call WaitForSingleObject
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_76
    jmp ir_errdefer_end_77
ir_errdefer_ok_76:
ir_errdefer_end_77:
    mov rax, [rbp - 24]
    jmp Lthread_join_infinite_exit
Lthread_join_infinite_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global thread_detach

thread_detach:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 64    ; Allocate 64 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'handle'
    ; Parameter 'handle' arrived in register rcx
ir_entry_78:
    ; IR call: CloseHandle (1 args)
    sub rsp, 32
    ; Load variable: handle
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call CloseHandle
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_errdefer_ok_79
    jmp ir_errdefer_end_80
ir_errdefer_ok_79:
ir_errdefer_end_80:
    mov rax, [rbp - 16]
    jmp Lthread_detach_exit
Lthread_detach_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global thread_sleep_ms

thread_sleep_ms:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 64    ; Allocate 64 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'milliseconds'
    ; Parameter 'milliseconds' arrived in register rcx
ir_entry_81:
    ; IR call: Sleep (1 args)
    sub rsp, 32
    ; Load variable: milliseconds
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call Sleep
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 16], rax
    mov rax, 0
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_errdefer_ok_82
    jmp ir_errdefer_end_83
ir_errdefer_ok_82:
ir_errdefer_end_83:
    jmp Lthread_sleep_ms_exit
Lthread_sleep_ms_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global thread_gc_attach

thread_gc_attach:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 48    ; Allocate 48 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_84:
    ; IR call: gc_thread_attach (0 args)
    sub rsp, 32
    call gc_thread_attach
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 8], rax
    mov rax, 0
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_errdefer_ok_85
    jmp ir_errdefer_end_86
ir_errdefer_ok_85:
ir_errdefer_end_86:
    jmp Lthread_gc_attach_exit
Lthread_gc_attach_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global thread_gc_detach

thread_gc_detach:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 48    ; Allocate 48 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_87:
    ; IR call: gc_thread_detach (0 args)
    sub rsp, 32
    call gc_thread_detach
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 8], rax
    mov rax, 0
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_errdefer_ok_88
    jmp ir_errdefer_end_89
ir_errdefer_ok_88:
ir_errdefer_end_89:
    jmp Lthread_gc_detach_exit
Lthread_gc_detach_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global mutex_create

mutex_create:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 48    ; Allocate 48 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_90:
    ; IR call: CreateMutexA (3 args)
    sub rsp, 32
    mov rax, 0
    mov rcx, rax
    mov rax, 0
    mov rdx, rax
    mov rax, 0
    mov r8, rax
    call CreateMutexA
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 8], rax
    mov rax, [rbp - 8]
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_errdefer_ok_91
    jmp ir_errdefer_end_92
ir_errdefer_ok_91:
ir_errdefer_end_92:
    mov rax, [rbp - 8]
    jmp Lmutex_create_exit
Lmutex_create_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global mutex_create_owned

mutex_create_owned:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 48    ; Allocate 48 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_93:
    ; IR call: CreateMutexA (3 args)
    sub rsp, 32
    mov rax, 0
    mov rcx, rax
    mov rax, 1
    mov rdx, rax
    mov rax, 0
    mov r8, rax
    call CreateMutexA
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 8], rax
    mov rax, [rbp - 8]
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_errdefer_ok_94
    jmp ir_errdefer_end_95
ir_errdefer_ok_94:
ir_errdefer_end_95:
    mov rax, [rbp - 8]
    jmp Lmutex_create_owned_exit
Lmutex_create_owned_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global mutex_lock

mutex_lock:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 160    ; Allocate 160 bytes on stack (aligned)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 'mutex'
    ; Parameter 'mutex' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'timeout_ms'
    ; Parameter 'timeout_ms' arrived in register rdx
ir_entry_96:
    ; IR call: WaitForSingleObject (2 args)
    sub rsp, 32
    ; Load variable: mutex
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    ; Load variable: timeout_ms
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    mov rdx, rax
    call WaitForSingleObject
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    ; Store to variable: result
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
    ; IR call: WAIT_OBJECT_0 (0 args)
    sub rsp, 32
    call WAIT_OBJECT_0
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 40], rax
    ; Load variable: result
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, [rbp - 40]
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_if_next_98
    mov rax, 1
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    test rax, rax
    jz ir_errdefer_ok_99
    jmp ir_errdefer_end_100
ir_errdefer_ok_99:
ir_errdefer_end_100:
    mov rax, 1
    jmp Lmutex_lock_exit
    jmp ir_if_end_97
ir_if_next_98:
ir_if_end_97:
    mov rax, 0
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    test rax, rax
    jz ir_errdefer_ok_101
    jmp ir_errdefer_end_102
ir_errdefer_ok_101:
ir_errdefer_end_102:
    mov rax, 0
    jmp Lmutex_lock_exit
Lmutex_lock_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global mutex_lock_infinite

mutex_lock_infinite:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 80    ; Allocate 80 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'mutex'
    ; Parameter 'mutex' arrived in register rcx
ir_entry_103:
    ; IR call: INFINITE (0 args)
    sub rsp, 32
    call INFINITE
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 16], rax
    ; IR call: mutex_lock (2 args)
    sub rsp, 32
    ; Load variable: mutex
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    mov rax, [rbp - 16]
    mov rdx, rax
    call mutex_lock
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_104
    jmp ir_errdefer_end_105
ir_errdefer_ok_104:
ir_errdefer_end_105:
    mov rax, [rbp - 24]
    jmp Lmutex_lock_infinite_exit
Lmutex_lock_infinite_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global mutex_unlock

mutex_unlock:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 64    ; Allocate 64 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'mutex'
    ; Parameter 'mutex' arrived in register rcx
ir_entry_106:
    ; IR call: ReleaseMutex (1 args)
    sub rsp, 32
    ; Load variable: mutex
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call ReleaseMutex
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_errdefer_ok_107
    jmp ir_errdefer_end_108
ir_errdefer_ok_107:
ir_errdefer_end_108:
    mov rax, [rbp - 16]
    jmp Lmutex_unlock_exit
Lmutex_unlock_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global mutex_close

mutex_close:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 64    ; Allocate 64 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'mutex'
    ; Parameter 'mutex' arrived in register rcx
ir_entry_109:
    ; IR call: CloseHandle (1 args)
    sub rsp, 32
    ; Load variable: mutex
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call CloseHandle
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_errdefer_ok_110
    jmp ir_errdefer_end_111
ir_errdefer_ok_110:
ir_errdefer_end_111:
    mov rax, [rbp - 16]
    jmp Lmutex_close_exit
Lmutex_close_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global atomic_compare_exchange_i32

atomic_compare_exchange_i32:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 80    ; Allocate 80 bytes on stack (aligned)
    ; Registering 3 function parameters
    mov [rbp - 8], rcx  ; Home param 'target'
    ; Parameter 'target' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'exchange'
    ; Parameter 'exchange' arrived in register rdx
    mov [rbp - 24], r8  ; Home param 'comparand'
    ; Parameter 'comparand' arrived in register r8
ir_entry_112:
    ; IR call: InterlockedCompareExchange (3 args)
    sub rsp, 32
    ; Load variable: target
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    ; Load variable: exchange
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    mov rdx, rax
    ; Load variable: comparand
    movsxd rax, dword [rbp - 24]  ; From stack [rbp - 24]
    mov r8, rax
    call _InterlockedCompareExchange
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_errdefer_ok_113
    jmp ir_errdefer_end_114
ir_errdefer_ok_113:
ir_errdefer_end_114:
    mov rax, [rbp - 32]
    jmp Latomic_compare_exchange_i32_exit
Latomic_compare_exchange_i32_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global atomic_exchange_i32

atomic_exchange_i32:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 64    ; Allocate 64 bytes on stack (aligned)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 'target'
    ; Parameter 'target' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'value'
    ; Parameter 'value' arrived in register rdx
ir_entry_115:
    ; IR call: InterlockedExchange (2 args)
    sub rsp, 32
    ; Load variable: target
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    ; Load variable: value
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    mov rdx, rax
    call _InterlockedExchange
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_116
    jmp ir_errdefer_end_117
ir_errdefer_ok_116:
ir_errdefer_end_117:
    mov rax, [rbp - 24]
    jmp Latomic_exchange_i32_exit
Latomic_exchange_i32_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global atomic_inc_i32

atomic_inc_i32:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 64    ; Allocate 64 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'target'
    ; Parameter 'target' arrived in register rcx
ir_entry_118:
    ; IR call: InterlockedIncrement (1 args)
    sub rsp, 32
    ; Load variable: target
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call _InterlockedIncrement
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_errdefer_ok_119
    jmp ir_errdefer_end_120
ir_errdefer_ok_119:
ir_errdefer_end_120:
    mov rax, [rbp - 16]
    jmp Latomic_inc_i32_exit
Latomic_inc_i32_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global atomic_dec_i32

atomic_dec_i32:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 64    ; Allocate 64 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'target'
    ; Parameter 'target' arrived in register rcx
ir_entry_121:
    ; IR call: InterlockedDecrement (1 args)
    sub rsp, 32
    ; Load variable: target
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call _InterlockedDecrement
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_errdefer_ok_122
    jmp ir_errdefer_end_123
ir_errdefer_ok_122:
ir_errdefer_end_123:
    mov rax, [rbp - 16]
    jmp Latomic_dec_i32_exit
Latomic_dec_i32_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global spin_try_lock

spin_try_lock:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 112    ; Allocate 112 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'lock_var'
    ; Parameter 'lock_var' arrived in register rcx
ir_entry_124:
    ; IR call: InterlockedCompareExchange (3 args)
    sub rsp, 32
    ; Load variable: lock_var
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    mov rax, 1
    mov rdx, rax
    mov rax, 0
    mov r8, rax
    call _InterlockedCompareExchange
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_next_126
    mov rax, 1
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_127
    jmp ir_errdefer_end_128
ir_errdefer_ok_127:
ir_errdefer_end_128:
    mov rax, 1
    jmp Lspin_try_lock_exit
    jmp ir_if_end_125
ir_if_next_126:
ir_if_end_125:
    mov rax, 0
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_errdefer_ok_129
    jmp ir_errdefer_end_130
ir_errdefer_ok_129:
ir_errdefer_end_130:
    mov rax, 0
    jmp Lspin_try_lock_exit
Lspin_try_lock_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global spin_lock

spin_lock:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 112    ; Allocate 112 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'lock_var'
    ; Parameter 'lock_var' arrived in register rcx
ir_entry_131:
ir_while_132:
    ; IR call: spin_try_lock (1 args)
    sub rsp, 32
    ; Load variable: lock_var
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call spin_try_lock
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_while_end_133
    ; IR call: Sleep (1 args)
    sub rsp, 32
    mov rax, 0
    mov rcx, rax
    call Sleep
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 32], rax
    jmp ir_while_132
ir_while_end_133:
    mov rax, 0
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_errdefer_ok_134
    jmp ir_errdefer_end_135
ir_errdefer_ok_134:
ir_errdefer_end_135:
    jmp Lspin_lock_exit
Lspin_lock_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global spin_unlock

spin_unlock:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 64    ; Allocate 64 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'lock_var'
    ; Parameter 'lock_var' arrived in register rcx
ir_entry_136:
    ; IR call: InterlockedExchange (2 args)
    sub rsp, 32
    ; Load variable: lock_var
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    mov rax, 0
    mov rdx, rax
    call _InterlockedExchange
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 16], rax
    mov rax, 0
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_errdefer_ok_137
    jmp ir_errdefer_end_138
ir_errdefer_ok_137:
ir_errdefer_end_138:
    jmp Lspin_unlock_exit
Lspin_unlock_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global AF_INET

AF_INET:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 32    ; Allocate 32 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_139:
    mov rax, 2
    mov [rbp - 8], rax
    mov rax, [rbp - 8]
    test rax, rax
    jz ir_errdefer_ok_140
    jmp ir_errdefer_end_141
ir_errdefer_ok_140:
ir_errdefer_end_141:
    mov rax, 2
    jmp LAF_INET_exit
LAF_INET_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global SOCK_STREAM

SOCK_STREAM:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 32    ; Allocate 32 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_142:
    mov rax, 1
    mov [rbp - 8], rax
    mov rax, [rbp - 8]
    test rax, rax
    jz ir_errdefer_ok_143
    jmp ir_errdefer_end_144
ir_errdefer_ok_143:
ir_errdefer_end_144:
    mov rax, 1
    jmp LSOCK_STREAM_exit
LSOCK_STREAM_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global SOCK_DGRAM

SOCK_DGRAM:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 32    ; Allocate 32 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_145:
    mov rax, 2
    mov [rbp - 8], rax
    mov rax, [rbp - 8]
    test rax, rax
    jz ir_errdefer_ok_146
    jmp ir_errdefer_end_147
ir_errdefer_ok_146:
ir_errdefer_end_147:
    mov rax, 2
    jmp LSOCK_DGRAM_exit
LSOCK_DGRAM_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global IPPROTO_TCP

IPPROTO_TCP:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 32    ; Allocate 32 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_148:
    mov rax, 6
    mov [rbp - 8], rax
    mov rax, [rbp - 8]
    test rax, rax
    jz ir_errdefer_ok_149
    jmp ir_errdefer_end_150
ir_errdefer_ok_149:
ir_errdefer_end_150:
    mov rax, 6
    jmp LIPPROTO_TCP_exit
LIPPROTO_TCP_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global IPPROTO_UDP

IPPROTO_UDP:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 32    ; Allocate 32 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_151:
    mov rax, 17
    mov [rbp - 8], rax
    mov rax, [rbp - 8]
    test rax, rax
    jz ir_errdefer_ok_152
    jmp ir_errdefer_end_153
ir_errdefer_ok_152:
ir_errdefer_end_153:
    mov rax, 17
    jmp LIPPROTO_UDP_exit
LIPPROTO_UDP_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global SOL_SOCKET

SOL_SOCKET:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 32    ; Allocate 32 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_154:
    mov rax, 0
    mov [rbp - 8], rax
    mov rax, [rbp - 8]
    test rax, rax
    jz ir_errdefer_ok_155
    jmp ir_errdefer_end_156
ir_errdefer_ok_155:
ir_errdefer_end_156:
    mov rax, 0
    jmp LSOL_SOCKET_exit
LSOL_SOCKET_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global SO_REUSEADDR

SO_REUSEADDR:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 32    ; Allocate 32 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_157:
    mov rax, 4
    mov [rbp - 8], rax
    mov rax, [rbp - 8]
    test rax, rax
    jz ir_errdefer_ok_158
    jmp ir_errdefer_end_159
ir_errdefer_ok_158:
ir_errdefer_end_159:
    mov rax, 4
    jmp LSO_REUSEADDR_exit
LSO_REUSEADDR_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global SD_RECEIVE

SD_RECEIVE:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 32    ; Allocate 32 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_160:
    mov rax, 0
    mov [rbp - 8], rax
    mov rax, [rbp - 8]
    test rax, rax
    jz ir_errdefer_ok_161
    jmp ir_errdefer_end_162
ir_errdefer_ok_161:
ir_errdefer_end_162:
    mov rax, 0
    jmp LSD_RECEIVE_exit
LSD_RECEIVE_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global SD_SEND

SD_SEND:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 32    ; Allocate 32 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_163:
    mov rax, 1
    mov [rbp - 8], rax
    mov rax, [rbp - 8]
    test rax, rax
    jz ir_errdefer_ok_164
    jmp ir_errdefer_end_165
ir_errdefer_ok_164:
ir_errdefer_end_165:
    mov rax, 1
    jmp LSD_SEND_exit
LSD_SEND_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global SD_BOTH

SD_BOTH:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 32    ; Allocate 32 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_166:
    mov rax, 2
    mov [rbp - 8], rax
    mov rax, [rbp - 8]
    test rax, rax
    jz ir_errdefer_ok_167
    jmp ir_errdefer_end_168
ir_errdefer_ok_167:
ir_errdefer_end_168:
    mov rax, 2
    jmp LSD_BOTH_exit
LSD_BOTH_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global INADDR_ANY

INADDR_ANY:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 32    ; Allocate 32 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_169:
    mov rax, 0
    mov [rbp - 8], rax
    mov rax, [rbp - 8]
    test rax, rax
    jz ir_errdefer_ok_170
    jmp ir_errdefer_end_171
ir_errdefer_ok_170:
ir_errdefer_end_171:
    mov rax, 0
    jmp LINADDR_ANY_exit
LINADDR_ANY_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global INVALID_SOCKET

INVALID_SOCKET:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 48    ; Allocate 48 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_172:
    mov rax, 1
    neg rax
    mov [rbp - 8], rax
    mov rax, [rbp - 8]
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_errdefer_ok_173
    jmp ir_errdefer_end_174
ir_errdefer_ok_173:
ir_errdefer_end_174:
    mov rax, [rbp - 8]
    jmp LINVALID_SOCKET_exit
LINVALID_SOCKET_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global SOCKET_ERROR

SOCKET_ERROR:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 48    ; Allocate 48 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_175:
    mov rax, 1
    neg rax
    mov [rbp - 8], rax
    mov rax, [rbp - 8]
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_errdefer_ok_176
    jmp ir_errdefer_end_177
ir_errdefer_ok_176:
ir_errdefer_end_177:
    mov rax, [rbp - 8]
    jmp LSOCKET_ERROR_exit
LSOCKET_ERROR_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller
    extern WSAStartup
    extern WSACleanup
    extern WSAGetLastError
    extern socket
    extern closesocket
    extern shutdown
    extern connect
    extern bind
    extern listen
    extern accept
    extern setsockopt
    extern send
    extern recv
    extern htons
    extern htonl
    extern ntohs
    extern ntohl
    extern inet_addr

global net_init

net_init:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 480    ; Allocate 480 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_178:
    lea rax, [rel net_ref_lock]
    mov [rbp - 24], rax
    ; IR call: spin_lock (1 args)
    sub rsp, 32
    mov rax, [rbp - 24]
    mov rcx, rax
    call spin_lock
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 32], rax
    ; Load variable: net_ref_count
    movsxd rax, dword [rel net_ref_count]  ; From global memory
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setg al
    movzx rax, al
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_if_next_180
    ; Load variable: net_ref_count
    movsxd rax, dword [rel net_ref_count]  ; From global memory
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    ; Store to variable: net_ref_count
    mov dword [rel net_ref_count], eax  ; To global memory
    lea rax, [rel net_ref_lock]
    mov [rbp - 56], rax
    ; IR call: spin_unlock (1 args)
    sub rsp, 32
    mov rax, [rbp - 56]
    mov rcx, rax
    call spin_unlock
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 64], rax
    mov rax, 0
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    test rax, rax
    jz ir_errdefer_ok_181
    jmp ir_errdefer_end_182
ir_errdefer_ok_181:
ir_errdefer_end_182:
    mov rax, 0
    jmp Lnet_init_exit
    jmp ir_if_end_179
ir_if_next_180:
ir_if_end_179:
    ; IR call: malloc (1 args)
    sub rsp, 32
    mov rax, 408
    mov rcx, rax
    call malloc
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 80], rax
    mov rax, [rbp - 80]
    ; Store to variable: wsa_buf
    mov qword [rbp - 8], rax  ; To stack [rbp - 8]
    ; Load variable: wsa_buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    test rax, rax
    jz ir_if_next_184
    lea rax, [rel net_ref_lock]
    mov [rbp - 96], rax
    ; IR call: spin_unlock (1 args)
    sub rsp, 32
    mov rax, [rbp - 96]
    mov rcx, rax
    call spin_unlock
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 104], rax
    mov rax, 1
    neg rax
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    mov [rbp - 120], rax
    mov rax, [rbp - 120]
    test rax, rax
    jz ir_errdefer_ok_185
    jmp ir_errdefer_end_186
ir_errdefer_ok_185:
ir_errdefer_end_186:
    mov rax, [rbp - 112]
    jmp Lnet_init_exit
    jmp ir_if_end_183
ir_if_next_184:
ir_if_end_183:
    ; IR call: WSAStartup (2 args)
    sub rsp, 32
    mov rax, 514
    mov rcx, rax
    ; Load variable: wsa_buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rdx, rax
    call WSAStartup
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 128], rax
    mov rax, [rbp - 128]
    ; Store to variable: result
    mov dword [rbp - 12], eax  ; To stack [rbp - 12]
    ; IR call: free (1 args)
    sub rsp, 32
    ; Load variable: wsa_buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call free
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 136], rax
    ; Load variable: result
    movsxd rax, dword [rbp - 12]  ; From stack [rbp - 12]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 144], rax
    mov rax, [rbp - 144]
    test rax, rax
    jz ir_if_next_188
    mov rax, 1
    ; Store to variable: net_ref_count
    mov dword [rel net_ref_count], eax  ; To global memory
    jmp ir_if_end_187
ir_if_next_188:
ir_if_end_187:
    lea rax, [rel net_ref_lock]
    mov [rbp - 152], rax
    ; IR call: spin_unlock (1 args)
    sub rsp, 32
    mov rax, [rbp - 152]
    mov rcx, rax
    call spin_unlock
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 160], rax
    ; Load variable: result
    movsxd rax, dword [rbp - 12]  ; From stack [rbp - 12]
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    test rax, rax
    jz ir_errdefer_ok_189
    jmp ir_errdefer_end_190
ir_errdefer_ok_189:
ir_errdefer_end_190:
    ; Load variable: result
    movsxd rax, dword [rbp - 12]  ; From stack [rbp - 12]
    jmp Lnet_init_exit
Lnet_init_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global net_cleanup

net_cleanup:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 368    ; Allocate 368 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_191:
    lea rax, [rel net_ref_lock]
    mov [rbp - 16], rax
    ; IR call: spin_lock (1 args)
    sub rsp, 32
    mov rax, [rbp - 16]
    mov rcx, rax
    call spin_lock
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 24], rax
    ; Load variable: net_ref_count
    movsxd rax, dword [rel net_ref_count]  ; From global memory
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setle al
    movzx rax, al
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_if_next_193
    lea rax, [rel net_ref_lock]
    mov [rbp - 40], rax
    ; IR call: spin_unlock (1 args)
    sub rsp, 32
    mov rax, [rbp - 40]
    mov rcx, rax
    call spin_unlock
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 48], rax
    mov rax, 0
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    test rax, rax
    jz ir_errdefer_ok_194
    jmp ir_errdefer_end_195
ir_errdefer_ok_194:
ir_errdefer_end_195:
    mov rax, 0
    jmp Lnet_cleanup_exit
    jmp ir_if_end_192
ir_if_next_193:
ir_if_end_192:
    ; Load variable: net_ref_count
    movsxd rax, dword [rel net_ref_count]  ; From global memory
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    ; Store to variable: net_ref_count
    mov dword [rel net_ref_count], eax  ; To global memory
    ; Load variable: net_ref_count
    movsxd rax, dword [rel net_ref_count]  ; From global memory
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setg al
    movzx rax, al
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    test rax, rax
    jz ir_if_next_197
    lea rax, [rel net_ref_lock]
    mov [rbp - 80], rax
    ; IR call: spin_unlock (1 args)
    sub rsp, 32
    mov rax, [rbp - 80]
    mov rcx, rax
    call spin_unlock
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 88], rax
    mov rax, 0
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    test rax, rax
    jz ir_errdefer_ok_198
    jmp ir_errdefer_end_199
ir_errdefer_ok_198:
ir_errdefer_end_199:
    mov rax, 0
    jmp Lnet_cleanup_exit
    jmp ir_if_end_196
ir_if_next_197:
ir_if_end_196:
    ; IR call: WSACleanup (0 args)
    sub rsp, 32
    call WSACleanup
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 104], rax
    mov rax, [rbp - 104]
    ; Store to variable: result
    mov dword [rbp - 4], eax  ; To stack [rbp - 4]
    lea rax, [rel net_ref_lock]
    mov [rbp - 112], rax
    ; IR call: spin_unlock (1 args)
    sub rsp, 32
    mov rax, [rbp - 112]
    mov rcx, rax
    call spin_unlock
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 120], rax
    ; Load variable: result
    movsxd rax, dword [rbp - 4]  ; From stack [rbp - 4]
    mov [rbp - 128], rax
    mov rax, [rbp - 128]
    test rax, rax
    jz ir_errdefer_ok_200
    jmp ir_errdefer_end_201
ir_errdefer_ok_200:
ir_errdefer_end_201:
    ; Load variable: result
    movsxd rax, dword [rbp - 4]  ; From stack [rbp - 4]
    jmp Lnet_cleanup_exit
Lnet_cleanup_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global net_last_error

net_last_error:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 48    ; Allocate 48 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_202:
    ; IR call: WSAGetLastError (0 args)
    sub rsp, 32
    call WSAGetLastError
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 8], rax
    mov rax, [rbp - 8]
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_errdefer_ok_203
    jmp ir_errdefer_end_204
ir_errdefer_ok_203:
ir_errdefer_end_204:
    mov rax, [rbp - 8]
    jmp Lnet_last_error_exit
Lnet_last_error_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global socket_tcp

socket_tcp:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 128    ; Allocate 128 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_205:
    ; IR call: AF_INET (0 args)
    sub rsp, 32
    call AF_INET
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 8], rax
    ; IR call: SOCK_STREAM (0 args)
    sub rsp, 32
    call SOCK_STREAM
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 16], rax
    ; IR call: IPPROTO_TCP (0 args)
    sub rsp, 32
    call IPPROTO_TCP
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 24], rax
    ; IR call: socket (3 args)
    sub rsp, 32
    mov rax, [rbp - 8]
    mov rcx, rax
    mov rax, [rbp - 16]
    mov rdx, rax
    mov rax, [rbp - 24]
    mov r8, rax
    call socket
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_errdefer_ok_206
    jmp ir_errdefer_end_207
ir_errdefer_ok_206:
ir_errdefer_end_207:
    mov rax, [rbp - 32]
    jmp Lsocket_tcp_exit
Lsocket_tcp_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global socket_udp

socket_udp:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 128    ; Allocate 128 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_208:
    ; IR call: AF_INET (0 args)
    sub rsp, 32
    call AF_INET
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 8], rax
    ; IR call: SOCK_DGRAM (0 args)
    sub rsp, 32
    call SOCK_DGRAM
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 16], rax
    ; IR call: IPPROTO_UDP (0 args)
    sub rsp, 32
    call IPPROTO_UDP
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 24], rax
    ; IR call: socket (3 args)
    sub rsp, 32
    mov rax, [rbp - 8]
    mov rcx, rax
    mov rax, [rbp - 16]
    mov rdx, rax
    mov rax, [rbp - 24]
    mov r8, rax
    call socket
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_errdefer_ok_209
    jmp ir_errdefer_end_210
ir_errdefer_ok_209:
ir_errdefer_end_210:
    mov rax, [rbp - 32]
    jmp Lsocket_udp_exit
Lsocket_udp_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global net_is_initialized

net_is_initialized:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 160    ; Allocate 160 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_211:
    mov rax, 0
    ; Store to variable: ready
    mov dword [rbp - 4], eax  ; To stack [rbp - 4]
    lea rax, [rel net_ref_lock]
    mov [rbp - 16], rax
    ; IR call: spin_lock (1 args)
    sub rsp, 32
    mov rax, [rbp - 16]
    mov rcx, rax
    call spin_lock
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 24], rax
    ; Load variable: net_ref_count
    movsxd rax, dword [rel net_ref_count]  ; From global memory
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setg al
    movzx rax, al
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_if_next_213
    mov rax, 1
    ; Store to variable: ready
    mov dword [rbp - 4], eax  ; To stack [rbp - 4]
    jmp ir_if_end_212
ir_if_next_213:
ir_if_end_212:
    lea rax, [rel net_ref_lock]
    mov [rbp - 40], rax
    ; IR call: spin_unlock (1 args)
    sub rsp, 32
    mov rax, [rbp - 40]
    mov rcx, rax
    call spin_unlock
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 48], rax
    ; Load variable: ready
    movsxd rax, dword [rbp - 4]  ; From stack [rbp - 4]
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    test rax, rax
    jz ir_errdefer_ok_214
    jmp ir_errdefer_end_215
ir_errdefer_ok_214:
ir_errdefer_end_215:
    ; Load variable: ready
    movsxd rax, dword [rbp - 4]  ; From stack [rbp - 4]
    jmp Lnet_is_initialized_exit
Lnet_is_initialized_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global sockaddr_in

sockaddr_in:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 896    ; Allocate 896 bytes on stack (aligned)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 'ip'
    ; Parameter 'ip' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'port'
    ; Parameter 'port' arrived in register rdx
ir_entry_216:
    ; IR call: malloc (1 args)
    sub rsp, 32
    mov rax, 16
    mov rcx, rax
    call malloc
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    ; Store to variable: buf
    mov qword [rbp - 24], rax  ; To stack [rbp - 24]
    ; Load variable: buf
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_if_next_218
    mov rax, 0
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    test rax, rax
    jz ir_errdefer_ok_219
    jmp ir_errdefer_end_220
ir_errdefer_ok_219:
ir_errdefer_end_220:
    mov rax, 0
    jmp Lsockaddr_in_exit
    jmp ir_if_end_217
ir_if_next_218:
ir_if_end_217:
    ; IR call: memset (3 args)
    sub rsp, 32
    ; Load variable: buf
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov rcx, rax
    mov rax, 0
    mov rdx, rax
    mov rax, 16
    mov r8, rax
    call memset
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 64], rax
    ; Load variable: buf
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    test rax, rax
    jz ir_trap_null_221
    jmp ir_nonnull_222
ir_trap_null_221:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct81]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_222:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 72], rax
    ; Load variable: buf
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, [rbp - 72]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 80], rax
    mov rax, [rbp - 80]
    push rax
    mov rax, 2
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: buf
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    test rax, rax
    jz ir_trap_null_223
    jmp ir_nonnull_224
ir_trap_null_223:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct83]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_224:
    mov rax, 1
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 96], rax
    ; Load variable: buf
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, [rbp - 96]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 104], rax
    mov rax, [rbp - 104]
    push rax
    mov rax, 0
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; IR call: htons (1 args)
    sub rsp, 32
    ; Load variable: port
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    mov rcx, rax
    call htons
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 120], rax
    mov rax, [rbp - 120]
    ; Store to variable: net_port
    mov dword [rbp - 28], eax  ; To stack [rbp - 28]
    ; Load variable: buf
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    test rax, rax
    jz ir_trap_null_225
    jmp ir_nonnull_226
ir_trap_null_225:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct85]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_226:
    mov rax, 2
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 128], rax
    ; Load variable: buf
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, [rbp - 128]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 136], rax
    mov rax, [rbp - 136]
    push rax
    ; Load variable: net_port
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: net_port
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 256
    mov r10, rax
    pop rax
    cqo
    idiv r10
    mov [rbp - 152], rax
    ; Load variable: buf
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    test rax, rax
    jz ir_trap_null_227
    jmp ir_nonnull_228
ir_trap_null_227:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct87]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_228:
    mov rax, 3
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 160], rax
    ; Load variable: buf
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, [rbp - 160]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    push rax
    mov rax, [rbp - 152]
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; IR call: inet_addr (1 args)
    sub rsp, 32
    ; Load variable: ip
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call inet_addr
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 184], rax
    mov rax, [rbp - 184]
    ; Store to variable: addr
    mov dword [rbp - 32], eax  ; To stack [rbp - 32]
    ; Load variable: buf
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    test rax, rax
    jz ir_trap_null_229
    jmp ir_nonnull_230
ir_trap_null_229:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct89]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_230:
    mov rax, 4
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 192], rax
    ; Load variable: buf
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, [rbp - 192]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 200], rax
    mov rax, [rbp - 200]
    push rax
    ; Load variable: addr
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: addr
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, 256
    mov r10, rax
    pop rax
    cqo
    idiv r10
    mov [rbp - 216], rax
    ; Load variable: buf
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    test rax, rax
    jz ir_trap_null_231
    jmp ir_nonnull_232
ir_trap_null_231:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct91]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_232:
    mov rax, 5
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 224], rax
    ; Load variable: buf
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, [rbp - 224]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 232], rax
    mov rax, [rbp - 232]
    push rax
    mov rax, [rbp - 216]
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: addr
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, 65536
    mov r10, rax
    pop rax
    cqo
    idiv r10
    mov [rbp - 248], rax
    ; Load variable: buf
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    test rax, rax
    jz ir_trap_null_233
    jmp ir_nonnull_234
ir_trap_null_233:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct93]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_234:
    mov rax, 6
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 256], rax
    ; Load variable: buf
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, [rbp - 256]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 264], rax
    mov rax, [rbp - 264]
    push rax
    mov rax, [rbp - 248]
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: addr
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, 16777216
    mov r10, rax
    pop rax
    cqo
    idiv r10
    mov [rbp - 280], rax
    ; Load variable: buf
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    test rax, rax
    jz ir_trap_null_235
    jmp ir_nonnull_236
ir_trap_null_235:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct95]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_236:
    mov rax, 7
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 288], rax
    ; Load variable: buf
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, [rbp - 288]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 296], rax
    mov rax, [rbp - 296]
    push rax
    mov rax, [rbp - 280]
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: buf
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov [rbp - 312], rax
    mov rax, [rbp - 312]
    test rax, rax
    jz ir_errdefer_ok_237
    jmp ir_errdefer_end_238
ir_errdefer_ok_237:
ir_errdefer_end_238:
    ; Load variable: buf
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    jmp Lsockaddr_in_exit
Lsockaddr_in_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global sockaddr_in_any

sockaddr_in_any:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 496    ; Allocate 496 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'port'
    ; Parameter 'port' arrived in register rcx
ir_entry_239:
    ; IR call: malloc (1 args)
    sub rsp, 32
    mov rax, 16
    mov rcx, rax
    call malloc
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    ; Store to variable: buf
    mov qword [rbp - 16], rax  ; To stack [rbp - 16]
    ; Load variable: buf
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_if_next_241
    mov rax, 0
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_errdefer_ok_242
    jmp ir_errdefer_end_243
ir_errdefer_ok_242:
ir_errdefer_end_243:
    mov rax, 0
    jmp Lsockaddr_in_any_exit
    jmp ir_if_end_240
ir_if_next_241:
ir_if_end_240:
    ; IR call: memset (3 args)
    sub rsp, 32
    ; Load variable: buf
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov rcx, rax
    mov rax, 0
    mov rdx, rax
    mov rax, 16
    mov r8, rax
    call memset
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 56], rax
    ; Load variable: buf
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    test rax, rax
    jz ir_trap_null_244
    jmp ir_nonnull_245
ir_trap_null_244:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct97]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_245:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 64], rax
    ; Load variable: buf
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, [rbp - 64]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    push rax
    mov rax, 2
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: buf
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    test rax, rax
    jz ir_trap_null_246
    jmp ir_nonnull_247
ir_trap_null_246:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct99]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_247:
    mov rax, 1
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 88], rax
    ; Load variable: buf
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, [rbp - 88]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    push rax
    mov rax, 0
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; IR call: htons (1 args)
    sub rsp, 32
    ; Load variable: port
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call htons
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    ; Store to variable: net_port
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
    ; Load variable: buf
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    test rax, rax
    jz ir_trap_null_248
    jmp ir_nonnull_249
ir_trap_null_248:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct101]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_249:
    mov rax, 2
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 120], rax
    ; Load variable: buf
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, [rbp - 120]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 128], rax
    mov rax, [rbp - 128]
    push rax
    ; Load variable: net_port
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: net_port
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 256
    mov r10, rax
    pop rax
    cqo
    idiv r10
    mov [rbp - 144], rax
    ; Load variable: buf
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    test rax, rax
    jz ir_trap_null_250
    jmp ir_nonnull_251
ir_trap_null_250:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct103]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_251:
    mov rax, 3
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 152], rax
    ; Load variable: buf
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, [rbp - 152]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 160], rax
    mov rax, [rbp - 160]
    push rax
    mov rax, [rbp - 144]
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: buf
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov [rbp - 176], rax
    mov rax, [rbp - 176]
    test rax, rax
    jz ir_errdefer_ok_252
    jmp ir_errdefer_end_253
ir_errdefer_ok_252:
ir_errdefer_end_253:
    ; Load variable: buf
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    jmp Lsockaddr_in_any_exit
Lsockaddr_in_any_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global set_reuseaddr

set_reuseaddr:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 688    ; Allocate 688 bytes on stack (aligned)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 'sock'
    ; Parameter 'sock' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'enabled'
    ; Parameter 'enabled' arrived in register rdx
ir_entry_254:
    ; Load variable: enabled
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_if_next_256
    mov rax, 0
    push rax
    mov rax, 4
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_trap_bounds_257
    jmp ir_in_bounds_258
ir_trap_bounds_257:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct105]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_258:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 48], rax
    ; Load variable: opt
    lea rax, [rbp - 20]  ; Local array base
    push rax
    mov rax, [rbp - 48]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    push rax
    mov rax, 1
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    jmp ir_if_end_255
ir_if_next_256:
    mov rax, 0
    push rax
    mov rax, 4
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    test rax, rax
    jz ir_trap_bounds_259
    jmp ir_in_bounds_260
ir_trap_bounds_259:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct107]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_260:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 80], rax
    ; Load variable: opt
    lea rax, [rbp - 20]  ; Local array base
    push rax
    mov rax, [rbp - 80]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    push rax
    mov rax, 0
    mov rcx, rax
    pop rax
    mov byte [rax], cl
ir_if_end_255:
    mov rax, 1
    push rax
    mov rax, 4
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 104], rax
    mov rax, [rbp - 104]
    test rax, rax
    jz ir_trap_bounds_261
    jmp ir_in_bounds_262
ir_trap_bounds_261:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct109]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_262:
    mov rax, 1
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 112], rax
    ; Load variable: opt
    lea rax, [rbp - 20]  ; Local array base
    push rax
    mov rax, [rbp - 112]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 120], rax
    mov rax, [rbp - 120]
    push rax
    mov rax, 0
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    mov rax, 2
    push rax
    mov rax, 4
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 136], rax
    mov rax, [rbp - 136]
    test rax, rax
    jz ir_trap_bounds_263
    jmp ir_in_bounds_264
ir_trap_bounds_263:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct111]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_264:
    mov rax, 2
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 144], rax
    ; Load variable: opt
    lea rax, [rbp - 20]  ; Local array base
    push rax
    mov rax, [rbp - 144]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 152], rax
    mov rax, [rbp - 152]
    push rax
    mov rax, 0
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    mov rax, 3
    push rax
    mov rax, 4
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    test rax, rax
    jz ir_trap_bounds_265
    jmp ir_in_bounds_266
ir_trap_bounds_265:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct113]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_266:
    mov rax, 3
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 176], rax
    ; Load variable: opt
    lea rax, [rbp - 20]  ; Local array base
    push rax
    mov rax, [rbp - 176]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 184], rax
    mov rax, [rbp - 184]
    push rax
    mov rax, 0
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; IR call: SOL_SOCKET (0 args)
    sub rsp, 32
    call SOL_SOCKET
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 200], rax
    ; IR call: SO_REUSEADDR (0 args)
    sub rsp, 32
    call SO_REUSEADDR
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 208], rax
    mov rax, 0
    push rax
    mov rax, 4
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 216], rax
    mov rax, [rbp - 216]
    test rax, rax
    jz ir_trap_bounds_267
    jmp ir_in_bounds_268
ir_trap_bounds_267:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct115]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_268:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 224], rax
    ; Load variable: opt
    lea rax, [rbp - 20]  ; Local array base
    push rax
    mov rax, [rbp - 224]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 232], rax
    ; IR call: setsockopt (5 args)
    sub rsp, 48
    mov rax, 4
    mov [rsp + 32], rax
    ; Load variable: sock
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    mov rax, [rbp - 200]
    mov rdx, rax
    mov rax, [rbp - 208]
    mov r8, rax
    mov rax, [rbp - 232]
    mov r9, rax
    call setsockopt
    add rsp, 48
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 240], rax
    mov rax, [rbp - 240]
    mov [rbp - 248], rax
    mov rax, [rbp - 248]
    test rax, rax
    jz ir_errdefer_ok_269
    jmp ir_errdefer_end_270
ir_errdefer_ok_269:
ir_errdefer_end_270:
    mov rax, [rbp - 240]
    jmp Lset_reuseaddr_exit
Lset_reuseaddr_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global send_all

send_all:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 304    ; Allocate 304 bytes on stack (aligned)
    ; Registering 3 function parameters
    mov [rbp - 8], rcx  ; Home param 'sock'
    ; Parameter 'sock' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'buf'
    ; Parameter 'buf' arrived in register rdx
    mov [rbp - 24], r8  ; Home param 'len'
    ; Parameter 'len' arrived in register r8
ir_entry_271:
    mov rax, 0
    ; Store to variable: total
    mov dword [rbp - 28], eax  ; To stack [rbp - 28]
ir_while_272:
    ; Load variable: total
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    ; Load variable: len
    movsxd rax, dword [rbp - 24]  ; From stack [rbp - 24]
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_while_end_273
    ; Load variable: buf
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    test rax, rax
    jz ir_trap_null_274
    jmp ir_nonnull_275
ir_trap_null_274:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct117]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_275:
    ; Load variable: total
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 48], rax
    ; Load variable: buf
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, [rbp - 48]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 56], rax
    ; Load variable: len
    movsxd rax, dword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    ; Load variable: total
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 64], rax
    ; IR call: send (4 args)
    sub rsp, 32
    ; Load variable: sock
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    mov rax, [rbp - 56]
    mov rdx, rax
    mov rax, [rbp - 64]
    mov r8, rax
    mov rax, 0
    mov r9, rax
    call send
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    ; Store to variable: sent
    mov dword [rbp - 32], eax  ; To stack [rbp - 32]
    ; Load variable: sent
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setle al
    movzx rax, al
    mov [rbp - 80], rax
    mov rax, [rbp - 80]
    test rax, rax
    jz ir_if_next_277
    mov rax, 1
    neg rax
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    test rax, rax
    jz ir_errdefer_ok_278
    jmp ir_errdefer_end_279
ir_errdefer_ok_278:
ir_errdefer_end_279:
    mov rax, [rbp - 88]
    jmp Lsend_all_exit
    jmp ir_if_end_276
ir_if_next_277:
ir_if_end_276:
    ; Load variable: total
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    ; Load variable: sent
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 104], rax
    mov rax, [rbp - 104]
    ; Store to variable: total
    mov dword [rbp - 28], eax  ; To stack [rbp - 28]
    jmp ir_while_272
ir_while_end_273:
    ; Load variable: total
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    test rax, rax
    jz ir_errdefer_ok_280
    jmp ir_errdefer_end_281
ir_errdefer_ok_280:
ir_errdefer_end_281:
    ; Load variable: total
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    jmp Lsend_all_exit
Lsend_all_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller
    extern atoi
    extern atol

global digit_to_char

digit_to_char:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 64    ; Allocate 64 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'd'
    ; Parameter 'd' arrived in register rcx
ir_entry_282:
    ; Load variable: d
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 48
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_errdefer_ok_283
    jmp ir_errdefer_end_284
ir_errdefer_ok_283:
ir_errdefer_end_284:
    mov rax, [rbp - 16]
    jmp Ldigit_to_char_exit
Ldigit_to_char_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global char_to_digit

char_to_digit:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 64    ; Allocate 64 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_285:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 48
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_errdefer_ok_286
    jmp ir_errdefer_end_287
ir_errdefer_ok_286:
ir_errdefer_end_287:
    mov rax, [rbp - 16]
    jmp Lchar_to_digit_exit
Lchar_to_digit_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global is_digit

is_digit:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 112    ; Allocate 112 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_288:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 48
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_if_next_290
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 57
    mov r10, rax
    pop rax
    cmp rax, r10
    setle al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_next_292
    mov rax, 1
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_293
    jmp ir_errdefer_end_294
ir_errdefer_ok_293:
ir_errdefer_end_294:
    mov rax, 1
    jmp Lis_digit_exit
    jmp ir_if_end_291
ir_if_next_292:
ir_if_end_291:
    jmp ir_if_end_289
ir_if_next_290:
ir_if_end_289:
    mov rax, 0
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_errdefer_ok_295
    jmp ir_errdefer_end_296
ir_errdefer_ok_295:
ir_errdefer_end_296:
    mov rax, 0
    jmp Lis_digit_exit
Lis_digit_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global is_upper

is_upper:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 112    ; Allocate 112 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_297:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 65
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_if_next_299
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 90
    mov r10, rax
    pop rax
    cmp rax, r10
    setle al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_next_301
    mov rax, 1
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_302
    jmp ir_errdefer_end_303
ir_errdefer_ok_302:
ir_errdefer_end_303:
    mov rax, 1
    jmp Lis_upper_exit
    jmp ir_if_end_300
ir_if_next_301:
ir_if_end_300:
    jmp ir_if_end_298
ir_if_next_299:
ir_if_end_298:
    mov rax, 0
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_errdefer_ok_304
    jmp ir_errdefer_end_305
ir_errdefer_ok_304:
ir_errdefer_end_305:
    mov rax, 0
    jmp Lis_upper_exit
Lis_upper_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global is_lower

is_lower:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 112    ; Allocate 112 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_306:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 97
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_if_next_308
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 122
    mov r10, rax
    pop rax
    cmp rax, r10
    setle al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_next_310
    mov rax, 1
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_311
    jmp ir_errdefer_end_312
ir_errdefer_ok_311:
ir_errdefer_end_312:
    mov rax, 1
    jmp Lis_lower_exit
    jmp ir_if_end_309
ir_if_next_310:
ir_if_end_309:
    jmp ir_if_end_307
ir_if_next_308:
ir_if_end_307:
    mov rax, 0
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_errdefer_ok_313
    jmp ir_errdefer_end_314
ir_errdefer_ok_313:
ir_errdefer_end_314:
    mov rax, 0
    jmp Lis_lower_exit
Lis_lower_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global is_alpha

is_alpha:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 176    ; Allocate 176 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_315:
    ; IR call: is_upper (1 args)
    sub rsp, 32
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call is_upper
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_next_317
    mov rax, 1
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_318
    jmp ir_errdefer_end_319
ir_errdefer_ok_318:
ir_errdefer_end_319:
    mov rax, 1
    jmp Lis_alpha_exit
    jmp ir_if_end_316
ir_if_next_317:
ir_if_end_316:
    ; IR call: is_lower (1 args)
    sub rsp, 32
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call is_lower
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_if_next_321
    mov rax, 1
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    test rax, rax
    jz ir_errdefer_ok_322
    jmp ir_errdefer_end_323
ir_errdefer_ok_322:
ir_errdefer_end_323:
    mov rax, 1
    jmp Lis_alpha_exit
    jmp ir_if_end_320
ir_if_next_321:
ir_if_end_320:
    mov rax, 0
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    test rax, rax
    jz ir_errdefer_ok_324
    jmp ir_errdefer_end_325
ir_errdefer_ok_324:
ir_errdefer_end_325:
    mov rax, 0
    jmp Lis_alpha_exit
Lis_alpha_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global is_alnum

is_alnum:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 176    ; Allocate 176 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_326:
    ; IR call: is_alpha (1 args)
    sub rsp, 32
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call is_alpha
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_next_328
    mov rax, 1
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_329
    jmp ir_errdefer_end_330
ir_errdefer_ok_329:
ir_errdefer_end_330:
    mov rax, 1
    jmp Lis_alnum_exit
    jmp ir_if_end_327
ir_if_next_328:
ir_if_end_327:
    ; IR call: is_digit (1 args)
    sub rsp, 32
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call is_digit
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_if_next_332
    mov rax, 1
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    test rax, rax
    jz ir_errdefer_ok_333
    jmp ir_errdefer_end_334
ir_errdefer_ok_333:
ir_errdefer_end_334:
    mov rax, 1
    jmp Lis_alnum_exit
    jmp ir_if_end_331
ir_if_next_332:
ir_if_end_331:
    mov rax, 0
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    test rax, rax
    jz ir_errdefer_ok_335
    jmp ir_errdefer_end_336
ir_errdefer_ok_335:
ir_errdefer_end_336:
    mov rax, 0
    jmp Lis_alnum_exit
Lis_alnum_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global is_space

is_space:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 320    ; Allocate 320 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_337:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 32
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_if_next_339
    mov rax, 1
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_errdefer_ok_340
    jmp ir_errdefer_end_341
ir_errdefer_ok_340:
ir_errdefer_end_341:
    mov rax, 1
    jmp Lis_space_exit
    jmp ir_if_end_338
ir_if_next_339:
ir_if_end_338:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 9
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_if_next_343
    mov rax, 1
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_errdefer_ok_344
    jmp ir_errdefer_end_345
ir_errdefer_ok_344:
ir_errdefer_end_345:
    mov rax, 1
    jmp Lis_space_exit
    jmp ir_if_end_342
ir_if_next_343:
ir_if_end_342:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 10
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_if_next_347
    mov rax, 1
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    test rax, rax
    jz ir_errdefer_ok_348
    jmp ir_errdefer_end_349
ir_errdefer_ok_348:
ir_errdefer_end_349:
    mov rax, 1
    jmp Lis_space_exit
    jmp ir_if_end_346
ir_if_next_347:
ir_if_end_346:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 13
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    test rax, rax
    jz ir_if_next_351
    mov rax, 1
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    test rax, rax
    jz ir_errdefer_ok_352
    jmp ir_errdefer_end_353
ir_errdefer_ok_352:
ir_errdefer_end_353:
    mov rax, 1
    jmp Lis_space_exit
    jmp ir_if_end_350
ir_if_next_351:
ir_if_end_350:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 12
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 80], rax
    mov rax, [rbp - 80]
    test rax, rax
    jz ir_if_next_355
    mov rax, 1
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    test rax, rax
    jz ir_errdefer_ok_356
    jmp ir_errdefer_end_357
ir_errdefer_ok_356:
ir_errdefer_end_357:
    mov rax, 1
    jmp Lis_space_exit
    jmp ir_if_end_354
ir_if_next_355:
ir_if_end_354:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 11
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    test rax, rax
    jz ir_if_next_359
    mov rax, 1
    mov [rbp - 104], rax
    mov rax, [rbp - 104]
    test rax, rax
    jz ir_errdefer_ok_360
    jmp ir_errdefer_end_361
ir_errdefer_ok_360:
ir_errdefer_end_361:
    mov rax, 1
    jmp Lis_space_exit
    jmp ir_if_end_358
ir_if_next_359:
ir_if_end_358:
    mov rax, 0
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    test rax, rax
    jz ir_errdefer_ok_362
    jmp ir_errdefer_end_363
ir_errdefer_ok_362:
ir_errdefer_end_363:
    mov rax, 0
    jmp Lis_space_exit
Lis_space_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global to_lower

to_lower:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 128    ; Allocate 128 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_364:
    ; IR call: is_upper (1 args)
    sub rsp, 32
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call is_upper
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_next_366
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 32
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_errdefer_ok_367
    jmp ir_errdefer_end_368
ir_errdefer_ok_367:
ir_errdefer_end_368:
    mov rax, [rbp - 32]
    jmp Lto_lower_exit
    jmp ir_if_end_365
ir_if_next_366:
ir_if_end_365:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_errdefer_ok_369
    jmp ir_errdefer_end_370
ir_errdefer_ok_369:
ir_errdefer_end_370:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    jmp Lto_lower_exit
Lto_lower_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global to_upper

to_upper:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 128    ; Allocate 128 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_371:
    ; IR call: is_lower (1 args)
    sub rsp, 32
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call is_lower
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_next_373
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 32
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_errdefer_ok_374
    jmp ir_errdefer_end_375
ir_errdefer_ok_374:
ir_errdefer_end_375:
    mov rax, [rbp - 32]
    jmp Lto_upper_exit
    jmp ir_if_end_372
ir_if_next_373:
ir_if_end_372:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_errdefer_ok_376
    jmp ir_errdefer_end_377
ir_errdefer_ok_376:
ir_errdefer_end_377:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    jmp Lto_upper_exit
Lto_upper_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global strlen

strlen:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 176    ; Allocate 176 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 's'
    ; Parameter 's' arrived in register rcx
ir_entry_378:
    mov rax, 0
    ; Store to variable: i
    mov qword [rbp - 16], rax  ; To stack [rbp - 16]
ir_while_379:
    ; Load variable: s
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_381
    jmp ir_nonnull_382
ir_trap_null_381:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct119]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_382:
    ; Load variable: i
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 24], rax
    ; Load variable: s
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 24]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    movzx rax, byte [rax]
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_while_end_380
    ; Load variable: i
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    ; Store to variable: i
    mov qword [rbp - 16], rax  ; To stack [rbp - 16]
    jmp ir_while_379
ir_while_end_380:
    ; Load variable: i
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    test rax, rax
    jz ir_errdefer_ok_383
    jmp ir_errdefer_end_384
ir_errdefer_ok_383:
ir_errdefer_end_384:
    ; Load variable: i
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    jmp Lstrlen_exit
Lstrlen_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global streq

streq:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 480    ; Allocate 480 bytes on stack (aligned)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 'a'
    ; Parameter 'a' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'b'
    ; Parameter 'b' arrived in register rdx
ir_entry_385:
    mov rax, 0
    ; Store to variable: i
    mov qword [rbp - 24], rax  ; To stack [rbp - 24]
ir_while_386:
    ; Load variable: a
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_388
    jmp ir_nonnull_389
ir_trap_null_388:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct121]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_389:
    ; Load variable: i
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 32], rax
    ; Load variable: a
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 32]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    movzx rax, byte [rax]
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    test rax, rax
    jz ir_while_end_387
    ; Load variable: a
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_392
    jmp ir_nonnull_393
ir_trap_null_392:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct123]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_393:
    ; Load variable: i
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 64], rax
    ; Load variable: a
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 64]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    movzx rax, byte [rax]
    mov [rbp - 80], rax
    ; Load variable: b
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    test rax, rax
    jz ir_trap_null_394
    jmp ir_nonnull_395
ir_trap_null_394:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct125]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_395:
    ; Load variable: i
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 88], rax
    ; Load variable: b
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, [rbp - 88]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    movzx rax, byte [rax]
    mov [rbp - 104], rax
    mov rax, [rbp - 80]
    push rax
    mov rax, [rbp - 104]
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    test rax, rax
    jz ir_if_next_391
    mov rax, 0
    mov [rbp - 120], rax
    mov rax, [rbp - 120]
    test rax, rax
    jz ir_errdefer_ok_396
    jmp ir_errdefer_end_397
ir_errdefer_ok_396:
ir_errdefer_end_397:
    mov rax, 0
    jmp Lstreq_exit
    jmp ir_if_end_390
ir_if_next_391:
ir_if_end_390:
    ; Load variable: i
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 128], rax
    mov rax, [rbp - 128]
    ; Store to variable: i
    mov qword [rbp - 24], rax  ; To stack [rbp - 24]
    jmp ir_while_386
ir_while_end_387:
    ; Load variable: b
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    test rax, rax
    jz ir_trap_null_400
    jmp ir_nonnull_401
ir_trap_null_400:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct127]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_401:
    ; Load variable: i
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 136], rax
    ; Load variable: b
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, [rbp - 136]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 144], rax
    mov rax, [rbp - 144]
    movzx rax, byte [rax]
    mov [rbp - 152], rax
    mov rax, [rbp - 152]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 160], rax
    mov rax, [rbp - 160]
    test rax, rax
    jz ir_if_next_399
    mov rax, 0
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    test rax, rax
    jz ir_errdefer_ok_402
    jmp ir_errdefer_end_403
ir_errdefer_ok_402:
ir_errdefer_end_403:
    mov rax, 0
    jmp Lstreq_exit
    jmp ir_if_end_398
ir_if_next_399:
ir_if_end_398:
    mov rax, 1
    mov [rbp - 176], rax
    mov rax, [rbp - 176]
    test rax, rax
    jz ir_errdefer_ok_404
    jmp ir_errdefer_end_405
ir_errdefer_ok_404:
ir_errdefer_end_405:
    mov rax, 1
    jmp Lstreq_exit
Lstreq_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global strncmp

strncmp:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 960    ; Allocate 960 bytes on stack (aligned)
    ; Registering 4 function parameters
    mov [rbp - 8], rcx  ; Home param 'buf'
    ; Parameter 'buf' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'offset'
    ; Parameter 'offset' arrived in register rdx
    mov [rbp - 24], r8  ; Home param 'needle'
    ; Parameter 'needle' arrived in register r8
    mov [rbp - 32], r9  ; Home param 'buf_len'
    ; Parameter 'buf_len' arrived in register r9
ir_entry_406:
    ; Load variable: offset
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_if_next_408
    mov rax, 1
    neg rax
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    test rax, rax
    jz ir_errdefer_ok_409
    jmp ir_errdefer_end_410
ir_errdefer_ok_409:
ir_errdefer_end_410:
    mov rax, [rbp - 56]
    jmp Lstrncmp_exit
    jmp ir_if_end_407
ir_if_next_408:
ir_if_end_407:
    ; Load variable: buf_len
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    test rax, rax
    jz ir_if_next_412
    mov rax, 1
    neg rax
    mov [rbp - 80], rax
    mov rax, [rbp - 80]
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    test rax, rax
    jz ir_errdefer_ok_413
    jmp ir_errdefer_end_414
ir_errdefer_ok_413:
ir_errdefer_end_414:
    mov rax, [rbp - 80]
    jmp Lstrncmp_exit
    jmp ir_if_end_411
ir_if_next_412:
ir_if_end_411:
    ; Load variable: offset
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    ; Load variable: buf_len
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    mov r10, rax
    pop rax
    cmp rax, r10
    setg al
    movzx rax, al
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    test rax, rax
    jz ir_if_next_416
    mov rax, 1
    neg rax
    mov [rbp - 104], rax
    mov rax, [rbp - 104]
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    test rax, rax
    jz ir_errdefer_ok_417
    jmp ir_errdefer_end_418
ir_errdefer_ok_417:
ir_errdefer_end_418:
    mov rax, [rbp - 104]
    jmp Lstrncmp_exit
    jmp ir_if_end_415
ir_if_next_416:
ir_if_end_415:
    mov rax, 0
    ; Store to variable: i
    mov dword [rbp - 36], eax  ; To stack [rbp - 36]
ir_while_419:
    ; Load variable: needle
    mov rax, qword [rbp - 24]  ; String param ptr
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 120], rax
    mov rax, [rbp - 120]
    mov rax, qword [rax]
    mov [rbp - 128], rax
    ; Load variable: i
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    push rax
    mov rax, [rbp - 128]
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 136], rax
    mov rax, [rbp - 136]
    test rax, rax
    jz ir_while_end_420
    ; Load variable: offset
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    ; Load variable: i
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 144], rax
    mov rax, [rbp - 144]
    push rax
    ; Load variable: buf_len
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 152], rax
    mov rax, [rbp - 152]
    test rax, rax
    jz ir_if_next_422
    mov rax, 1
    neg rax
    mov [rbp - 160], rax
    mov rax, [rbp - 160]
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    test rax, rax
    jz ir_errdefer_ok_423
    jmp ir_errdefer_end_424
ir_errdefer_ok_423:
ir_errdefer_end_424:
    mov rax, [rbp - 160]
    jmp Lstrncmp_exit
    jmp ir_if_end_421
ir_if_next_422:
ir_if_end_421:
    ; Load variable: offset
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    ; Load variable: i
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 176], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_427
    jmp ir_nonnull_428
ir_trap_null_427:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct129]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_428:
    mov rax, [rbp - 176]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 184], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 184]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 192], rax
    mov rax, [rbp - 192]
    movzx rax, byte [rax]
    mov [rbp - 200], rax
    ; Load variable: needle
    mov rax, qword [rbp - 24]  ; String param ptr
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 208], rax
    mov rax, [rbp - 208]
    mov rax, qword [rax]
    mov [rbp - 216], rax
    mov rax, [rbp - 216]
    test rax, rax
    jz ir_trap_null_429
    jmp ir_nonnull_430
ir_trap_null_429:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct131]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_430:
    ; Load variable: i
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 224], rax
    mov rax, [rbp - 216]
    push rax
    mov rax, [rbp - 224]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 232], rax
    mov rax, [rbp - 232]
    movzx rax, byte [rax]
    mov [rbp - 240], rax
    mov rax, [rbp - 200]
    push rax
    mov rax, [rbp - 240]
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 248], rax
    mov rax, [rbp - 248]
    test rax, rax
    jz ir_if_next_426
    ; Load variable: offset
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    ; Load variable: i
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 256], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_431
    jmp ir_nonnull_432
ir_trap_null_431:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct133]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_432:
    mov rax, [rbp - 256]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 264], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 264]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 272], rax
    mov rax, [rbp - 272]
    movzx rax, byte [rax]
    mov [rbp - 280], rax
    ; Load variable: needle
    mov rax, qword [rbp - 24]  ; String param ptr
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 288], rax
    mov rax, [rbp - 288]
    mov rax, qword [rax]
    mov [rbp - 296], rax
    mov rax, [rbp - 296]
    test rax, rax
    jz ir_trap_null_433
    jmp ir_nonnull_434
ir_trap_null_433:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct135]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_434:
    ; Load variable: i
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 304], rax
    mov rax, [rbp - 296]
    push rax
    mov rax, [rbp - 304]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 312], rax
    mov rax, [rbp - 312]
    movzx rax, byte [rax]
    mov [rbp - 320], rax
    mov rax, [rbp - 280]
    push rax
    mov rax, [rbp - 320]
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 328], rax
    mov rax, [rbp - 328]
    mov [rbp - 336], rax
    mov rax, [rbp - 336]
    test rax, rax
    jz ir_errdefer_ok_435
    jmp ir_errdefer_end_436
ir_errdefer_ok_435:
ir_errdefer_end_436:
    mov rax, [rbp - 328]
    jmp Lstrncmp_exit
    jmp ir_if_end_425
ir_if_next_426:
ir_if_end_425:
    ; Load variable: i
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 344], rax
    mov rax, [rbp - 344]
    ; Store to variable: i
    mov dword [rbp - 36], eax  ; To stack [rbp - 36]
    jmp ir_while_419
ir_while_end_420:
    mov rax, 0
    mov [rbp - 352], rax
    mov rax, [rbp - 352]
    test rax, rax
    jz ir_errdefer_ok_437
    jmp ir_errdefer_end_438
ir_errdefer_ok_437:
ir_errdefer_end_438:
    mov rax, 0
    jmp Lstrncmp_exit
Lstrncmp_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller
    extern gc_init
    extern AllocConsole
    extern GetStdHandle
    extern WriteFile

global is_get

is_get:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 560    ; Allocate 560 bytes on stack (aligned)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 'buf'
    ; Parameter 'buf' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'n'
    ; Parameter 'n' arrived in register rdx
ir_entry_439:
    ; Load variable: n
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 4
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_next_441
    mov rax, 0
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_442
    jmp ir_errdefer_end_443
ir_errdefer_ok_442:
ir_errdefer_end_443:
    mov rax, 0
    jmp Lis_get_exit
    jmp ir_if_end_440
ir_if_next_441:
ir_if_end_440:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_446
    jmp ir_nonnull_447
ir_trap_null_446:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct137]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_447:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 40], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 40]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    movzx rax, byte [rax]
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    push rax
    mov rax, 71
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    test rax, rax
    jz ir_if_next_445
    mov rax, 0
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    test rax, rax
    jz ir_errdefer_ok_448
    jmp ir_errdefer_end_449
ir_errdefer_ok_448:
ir_errdefer_end_449:
    mov rax, 0
    jmp Lis_get_exit
    jmp ir_if_end_444
ir_if_next_445:
ir_if_end_444:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_452
    jmp ir_nonnull_453
ir_trap_null_452:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct139]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_453:
    mov rax, 1
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 80], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 80]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    movzx rax, byte [rax]
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    push rax
    mov rax, 69
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 104], rax
    mov rax, [rbp - 104]
    test rax, rax
    jz ir_if_next_451
    mov rax, 0
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    test rax, rax
    jz ir_errdefer_ok_454
    jmp ir_errdefer_end_455
ir_errdefer_ok_454:
ir_errdefer_end_455:
    mov rax, 0
    jmp Lis_get_exit
    jmp ir_if_end_450
ir_if_next_451:
ir_if_end_450:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_458
    jmp ir_nonnull_459
ir_trap_null_458:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct141]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_459:
    mov rax, 2
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 120], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 120]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 128], rax
    mov rax, [rbp - 128]
    movzx rax, byte [rax]
    mov [rbp - 136], rax
    mov rax, [rbp - 136]
    push rax
    mov rax, 84
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 144], rax
    mov rax, [rbp - 144]
    test rax, rax
    jz ir_if_next_457
    mov rax, 0
    mov [rbp - 152], rax
    mov rax, [rbp - 152]
    test rax, rax
    jz ir_errdefer_ok_460
    jmp ir_errdefer_end_461
ir_errdefer_ok_460:
ir_errdefer_end_461:
    mov rax, 0
    jmp Lis_get_exit
    jmp ir_if_end_456
ir_if_next_457:
ir_if_end_456:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_464
    jmp ir_nonnull_465
ir_trap_null_464:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct143]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_465:
    mov rax, 3
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 160], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 160]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    movzx rax, byte [rax]
    mov [rbp - 176], rax
    mov rax, [rbp - 176]
    push rax
    mov rax, 32
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 184], rax
    mov rax, [rbp - 184]
    test rax, rax
    jz ir_if_next_463
    mov rax, 0
    mov [rbp - 192], rax
    mov rax, [rbp - 192]
    test rax, rax
    jz ir_errdefer_ok_466
    jmp ir_errdefer_end_467
ir_errdefer_ok_466:
ir_errdefer_end_467:
    mov rax, 0
    jmp Lis_get_exit
    jmp ir_if_end_462
ir_if_next_463:
ir_if_end_462:
    mov rax, 1
    mov [rbp - 200], rax
    mov rax, [rbp - 200]
    test rax, rax
    jz ir_errdefer_ok_468
    jmp ir_errdefer_end_469
ir_errdefer_ok_468:
ir_errdefer_end_469:
    mov rax, 1
    jmp Lis_get_exit
Lis_get_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global is_root

is_root:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 320    ; Allocate 320 bytes on stack (aligned)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 'buf'
    ; Parameter 'buf' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'n'
    ; Parameter 'n' arrived in register rdx
ir_entry_470:
    ; Load variable: n
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 6
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_next_472
    mov rax, 0
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_473
    jmp ir_errdefer_end_474
ir_errdefer_ok_473:
ir_errdefer_end_474:
    mov rax, 0
    jmp Lis_root_exit
    jmp ir_if_end_471
ir_if_next_472:
ir_if_end_471:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_477
    jmp ir_nonnull_478
ir_trap_null_477:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct145]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_478:
    mov rax, 4
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 40], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 40]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    movzx rax, byte [rax]
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    push rax
    mov rax, 47
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    test rax, rax
    jz ir_if_next_476
    mov rax, 0
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    test rax, rax
    jz ir_errdefer_ok_479
    jmp ir_errdefer_end_480
ir_errdefer_ok_479:
ir_errdefer_end_480:
    mov rax, 0
    jmp Lis_root_exit
    jmp ir_if_end_475
ir_if_next_476:
ir_if_end_475:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_483
    jmp ir_nonnull_484
ir_trap_null_483:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct147]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_484:
    mov rax, 5
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 80], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 80]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    movzx rax, byte [rax]
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    push rax
    mov rax, 32
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 104], rax
    mov rax, [rbp - 104]
    test rax, rax
    jz ir_if_next_482
    mov rax, 0
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    test rax, rax
    jz ir_errdefer_ok_485
    jmp ir_errdefer_end_486
ir_errdefer_ok_485:
ir_errdefer_end_486:
    mov rax, 0
    jmp Lis_root_exit
    jmp ir_if_end_481
ir_if_next_482:
ir_if_end_481:
    mov rax, 1
    mov [rbp - 120], rax
    mov rax, [rbp - 120]
    test rax, rax
    jz ir_errdefer_ok_487
    jmp ir_errdefer_end_488
ir_errdefer_ok_487:
ir_errdefer_end_488:
    mov rax, 1
    jmp Lis_root_exit
Lis_root_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global is_health

is_health:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 1152    ; Allocate 1152 bytes on stack (aligned)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 'buf'
    ; Parameter 'buf' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'n'
    ; Parameter 'n' arrived in register rdx
ir_entry_489:
    ; Load variable: n
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 12
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_next_491
    mov rax, 0
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_492
    jmp ir_errdefer_end_493
ir_errdefer_ok_492:
ir_errdefer_end_493:
    mov rax, 0
    jmp Lis_health_exit
    jmp ir_if_end_490
ir_if_next_491:
ir_if_end_490:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_496
    jmp ir_nonnull_497
ir_trap_null_496:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct149]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_497:
    mov rax, 4
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 40], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 40]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    movzx rax, byte [rax]
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    push rax
    mov rax, 47
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    test rax, rax
    jz ir_if_next_495
    mov rax, 0
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    test rax, rax
    jz ir_errdefer_ok_498
    jmp ir_errdefer_end_499
ir_errdefer_ok_498:
ir_errdefer_end_499:
    mov rax, 0
    jmp Lis_health_exit
    jmp ir_if_end_494
ir_if_next_495:
ir_if_end_494:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_502
    jmp ir_nonnull_503
ir_trap_null_502:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct151]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_503:
    mov rax, 5
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 80], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 80]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    movzx rax, byte [rax]
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    push rax
    mov rax, 104
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 104], rax
    mov rax, [rbp - 104]
    test rax, rax
    jz ir_if_next_501
    mov rax, 0
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    test rax, rax
    jz ir_errdefer_ok_504
    jmp ir_errdefer_end_505
ir_errdefer_ok_504:
ir_errdefer_end_505:
    mov rax, 0
    jmp Lis_health_exit
    jmp ir_if_end_500
ir_if_next_501:
ir_if_end_500:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_508
    jmp ir_nonnull_509
ir_trap_null_508:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct153]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_509:
    mov rax, 6
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 120], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 120]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 128], rax
    mov rax, [rbp - 128]
    movzx rax, byte [rax]
    mov [rbp - 136], rax
    mov rax, [rbp - 136]
    push rax
    mov rax, 101
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 144], rax
    mov rax, [rbp - 144]
    test rax, rax
    jz ir_if_next_507
    mov rax, 0
    mov [rbp - 152], rax
    mov rax, [rbp - 152]
    test rax, rax
    jz ir_errdefer_ok_510
    jmp ir_errdefer_end_511
ir_errdefer_ok_510:
ir_errdefer_end_511:
    mov rax, 0
    jmp Lis_health_exit
    jmp ir_if_end_506
ir_if_next_507:
ir_if_end_506:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_514
    jmp ir_nonnull_515
ir_trap_null_514:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct155]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_515:
    mov rax, 7
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 160], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 160]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    movzx rax, byte [rax]
    mov [rbp - 176], rax
    mov rax, [rbp - 176]
    push rax
    mov rax, 97
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 184], rax
    mov rax, [rbp - 184]
    test rax, rax
    jz ir_if_next_513
    mov rax, 0
    mov [rbp - 192], rax
    mov rax, [rbp - 192]
    test rax, rax
    jz ir_errdefer_ok_516
    jmp ir_errdefer_end_517
ir_errdefer_ok_516:
ir_errdefer_end_517:
    mov rax, 0
    jmp Lis_health_exit
    jmp ir_if_end_512
ir_if_next_513:
ir_if_end_512:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_520
    jmp ir_nonnull_521
ir_trap_null_520:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct157]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_521:
    mov rax, 8
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 200], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 200]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 208], rax
    mov rax, [rbp - 208]
    movzx rax, byte [rax]
    mov [rbp - 216], rax
    mov rax, [rbp - 216]
    push rax
    mov rax, 108
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 224], rax
    mov rax, [rbp - 224]
    test rax, rax
    jz ir_if_next_519
    mov rax, 0
    mov [rbp - 232], rax
    mov rax, [rbp - 232]
    test rax, rax
    jz ir_errdefer_ok_522
    jmp ir_errdefer_end_523
ir_errdefer_ok_522:
ir_errdefer_end_523:
    mov rax, 0
    jmp Lis_health_exit
    jmp ir_if_end_518
ir_if_next_519:
ir_if_end_518:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_526
    jmp ir_nonnull_527
ir_trap_null_526:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct159]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_527:
    mov rax, 9
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 240], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 240]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 248], rax
    mov rax, [rbp - 248]
    movzx rax, byte [rax]
    mov [rbp - 256], rax
    mov rax, [rbp - 256]
    push rax
    mov rax, 116
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 264], rax
    mov rax, [rbp - 264]
    test rax, rax
    jz ir_if_next_525
    mov rax, 0
    mov [rbp - 272], rax
    mov rax, [rbp - 272]
    test rax, rax
    jz ir_errdefer_ok_528
    jmp ir_errdefer_end_529
ir_errdefer_ok_528:
ir_errdefer_end_529:
    mov rax, 0
    jmp Lis_health_exit
    jmp ir_if_end_524
ir_if_next_525:
ir_if_end_524:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_532
    jmp ir_nonnull_533
ir_trap_null_532:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct161]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_533:
    mov rax, 10
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 280], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 280]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 288], rax
    mov rax, [rbp - 288]
    movzx rax, byte [rax]
    mov [rbp - 296], rax
    mov rax, [rbp - 296]
    push rax
    mov rax, 104
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 304], rax
    mov rax, [rbp - 304]
    test rax, rax
    jz ir_if_next_531
    mov rax, 0
    mov [rbp - 312], rax
    mov rax, [rbp - 312]
    test rax, rax
    jz ir_errdefer_ok_534
    jmp ir_errdefer_end_535
ir_errdefer_ok_534:
ir_errdefer_end_535:
    mov rax, 0
    jmp Lis_health_exit
    jmp ir_if_end_530
ir_if_next_531:
ir_if_end_530:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_538
    jmp ir_nonnull_539
ir_trap_null_538:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct163]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_539:
    mov rax, 11
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 320], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 320]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 328], rax
    mov rax, [rbp - 328]
    movzx rax, byte [rax]
    mov [rbp - 336], rax
    mov rax, [rbp - 336]
    push rax
    mov rax, 32
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 344], rax
    mov rax, [rbp - 344]
    test rax, rax
    jz ir_sc_false_542
ir_sc_rhs_540:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_544
    jmp ir_nonnull_545
ir_trap_null_544:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct165]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_545:
    mov rax, 11
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 352], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 352]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 360], rax
    mov rax, [rbp - 360]
    movzx rax, byte [rax]
    mov [rbp - 368], rax
    mov rax, [rbp - 368]
    push rax
    mov rax, 63
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 376], rax
    mov rax, [rbp - 376]
    test rax, rax
    jz ir_sc_false_542
ir_sc_true_541:
    mov rax, 1
    mov [rbp - 384], rax
    jmp ir_sc_end_543
ir_sc_false_542:
    mov rax, 0
    mov [rbp - 384], rax
ir_sc_end_543:
    mov rax, [rbp - 384]
    test rax, rax
    jz ir_if_next_537
    mov rax, 0
    mov [rbp - 400], rax
    mov rax, [rbp - 400]
    test rax, rax
    jz ir_errdefer_ok_546
    jmp ir_errdefer_end_547
ir_errdefer_ok_546:
ir_errdefer_end_547:
    mov rax, 0
    jmp Lis_health_exit
    jmp ir_if_end_536
ir_if_next_537:
ir_if_end_536:
    mov rax, 1
    mov [rbp - 408], rax
    mov rax, [rbp - 408]
    test rax, rax
    jz ir_errdefer_ok_548
    jmp ir_errdefer_end_549
ir_errdefer_ok_548:
ir_errdefer_end_549:
    mov rax, 1
    jmp Lis_health_exit
Lis_health_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global is_post

is_post:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 672    ; Allocate 672 bytes on stack (aligned)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 'buf'
    ; Parameter 'buf' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'n'
    ; Parameter 'n' arrived in register rdx
ir_entry_550:
    ; Load variable: n
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 5
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_next_552
    mov rax, 0
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_553
    jmp ir_errdefer_end_554
ir_errdefer_ok_553:
ir_errdefer_end_554:
    mov rax, 0
    jmp Lis_post_exit
    jmp ir_if_end_551
ir_if_next_552:
ir_if_end_551:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_557
    jmp ir_nonnull_558
ir_trap_null_557:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct167]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_558:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 40], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 40]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    movzx rax, byte [rax]
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    push rax
    mov rax, 80
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    test rax, rax
    jz ir_if_next_556
    mov rax, 0
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    test rax, rax
    jz ir_errdefer_ok_559
    jmp ir_errdefer_end_560
ir_errdefer_ok_559:
ir_errdefer_end_560:
    mov rax, 0
    jmp Lis_post_exit
    jmp ir_if_end_555
ir_if_next_556:
ir_if_end_555:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_563
    jmp ir_nonnull_564
ir_trap_null_563:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct169]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_564:
    mov rax, 1
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 80], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 80]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    movzx rax, byte [rax]
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    push rax
    mov rax, 79
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 104], rax
    mov rax, [rbp - 104]
    test rax, rax
    jz ir_if_next_562
    mov rax, 0
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    test rax, rax
    jz ir_errdefer_ok_565
    jmp ir_errdefer_end_566
ir_errdefer_ok_565:
ir_errdefer_end_566:
    mov rax, 0
    jmp Lis_post_exit
    jmp ir_if_end_561
ir_if_next_562:
ir_if_end_561:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_569
    jmp ir_nonnull_570
ir_trap_null_569:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct171]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_570:
    mov rax, 2
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 120], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 120]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 128], rax
    mov rax, [rbp - 128]
    movzx rax, byte [rax]
    mov [rbp - 136], rax
    mov rax, [rbp - 136]
    push rax
    mov rax, 83
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 144], rax
    mov rax, [rbp - 144]
    test rax, rax
    jz ir_if_next_568
    mov rax, 0
    mov [rbp - 152], rax
    mov rax, [rbp - 152]
    test rax, rax
    jz ir_errdefer_ok_571
    jmp ir_errdefer_end_572
ir_errdefer_ok_571:
ir_errdefer_end_572:
    mov rax, 0
    jmp Lis_post_exit
    jmp ir_if_end_567
ir_if_next_568:
ir_if_end_567:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_575
    jmp ir_nonnull_576
ir_trap_null_575:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct173]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_576:
    mov rax, 3
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 160], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 160]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    movzx rax, byte [rax]
    mov [rbp - 176], rax
    mov rax, [rbp - 176]
    push rax
    mov rax, 84
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 184], rax
    mov rax, [rbp - 184]
    test rax, rax
    jz ir_if_next_574
    mov rax, 0
    mov [rbp - 192], rax
    mov rax, [rbp - 192]
    test rax, rax
    jz ir_errdefer_ok_577
    jmp ir_errdefer_end_578
ir_errdefer_ok_577:
ir_errdefer_end_578:
    mov rax, 0
    jmp Lis_post_exit
    jmp ir_if_end_573
ir_if_next_574:
ir_if_end_573:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_581
    jmp ir_nonnull_582
ir_trap_null_581:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct175]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_582:
    mov rax, 4
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 200], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 200]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 208], rax
    mov rax, [rbp - 208]
    movzx rax, byte [rax]
    mov [rbp - 216], rax
    mov rax, [rbp - 216]
    push rax
    mov rax, 32
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 224], rax
    mov rax, [rbp - 224]
    test rax, rax
    jz ir_if_next_580
    mov rax, 0
    mov [rbp - 232], rax
    mov rax, [rbp - 232]
    test rax, rax
    jz ir_errdefer_ok_583
    jmp ir_errdefer_end_584
ir_errdefer_ok_583:
ir_errdefer_end_584:
    mov rax, 0
    jmp Lis_post_exit
    jmp ir_if_end_579
ir_if_next_580:
ir_if_end_579:
    mov rax, 1
    mov [rbp - 240], rax
    mov rax, [rbp - 240]
    test rax, rax
    jz ir_errdefer_ok_585
    jmp ir_errdefer_end_586
ir_errdefer_ok_585:
ir_errdefer_end_586:
    mov rax, 1
    jmp Lis_post_exit
Lis_post_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global is_forum

is_forum:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 928    ; Allocate 928 bytes on stack (aligned)
    ; Registering 3 function parameters
    mov [rbp - 8], rcx  ; Home param 'buf'
    ; Parameter 'buf' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'n'
    ; Parameter 'n' arrived in register rdx
    mov [rbp - 24], r8  ; Home param 'path_start'
    ; Parameter 'path_start' arrived in register r8
ir_entry_587:
    ; Load variable: path_start
    movsxd rax, dword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 6
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    push rax
    ; Load variable: n
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    mov r10, rax
    pop rax
    cmp rax, r10
    setg al
    movzx rax, al
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_if_next_589
    mov rax, 0
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_errdefer_ok_590
    jmp ir_errdefer_end_591
ir_errdefer_ok_590:
ir_errdefer_end_591:
    mov rax, 0
    jmp Lis_forum_exit
    jmp ir_if_end_588
ir_if_next_589:
ir_if_end_588:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_594
    jmp ir_nonnull_595
ir_trap_null_594:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct177]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_595:
    ; Load variable: path_start
    movsxd rax, dword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 56], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 56]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    movzx rax, byte [rax]
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    push rax
    mov rax, 47
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 80], rax
    mov rax, [rbp - 80]
    test rax, rax
    jz ir_if_next_593
    mov rax, 0
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    test rax, rax
    jz ir_errdefer_ok_596
    jmp ir_errdefer_end_597
ir_errdefer_ok_596:
ir_errdefer_end_597:
    mov rax, 0
    jmp Lis_forum_exit
    jmp ir_if_end_592
ir_if_next_593:
ir_if_end_592:
    ; Load variable: path_start
    movsxd rax, dword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 96], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_600
    jmp ir_nonnull_601
ir_trap_null_600:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct179]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_601:
    mov rax, [rbp - 96]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 104], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 104]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    movzx rax, byte [rax]
    mov [rbp - 120], rax
    mov rax, [rbp - 120]
    push rax
    mov rax, 102
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 128], rax
    mov rax, [rbp - 128]
    test rax, rax
    jz ir_if_next_599
    mov rax, 0
    mov [rbp - 136], rax
    mov rax, [rbp - 136]
    test rax, rax
    jz ir_errdefer_ok_602
    jmp ir_errdefer_end_603
ir_errdefer_ok_602:
ir_errdefer_end_603:
    mov rax, 0
    jmp Lis_forum_exit
    jmp ir_if_end_598
ir_if_next_599:
ir_if_end_598:
    ; Load variable: path_start
    movsxd rax, dword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 2
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 144], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_606
    jmp ir_nonnull_607
ir_trap_null_606:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct181]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_607:
    mov rax, [rbp - 144]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 152], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 152]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 160], rax
    mov rax, [rbp - 160]
    movzx rax, byte [rax]
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    push rax
    mov rax, 111
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 176], rax
    mov rax, [rbp - 176]
    test rax, rax
    jz ir_if_next_605
    mov rax, 0
    mov [rbp - 184], rax
    mov rax, [rbp - 184]
    test rax, rax
    jz ir_errdefer_ok_608
    jmp ir_errdefer_end_609
ir_errdefer_ok_608:
ir_errdefer_end_609:
    mov rax, 0
    jmp Lis_forum_exit
    jmp ir_if_end_604
ir_if_next_605:
ir_if_end_604:
    ; Load variable: path_start
    movsxd rax, dword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 3
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 192], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_612
    jmp ir_nonnull_613
ir_trap_null_612:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct183]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_613:
    mov rax, [rbp - 192]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 200], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 200]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 208], rax
    mov rax, [rbp - 208]
    movzx rax, byte [rax]
    mov [rbp - 216], rax
    mov rax, [rbp - 216]
    push rax
    mov rax, 114
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 224], rax
    mov rax, [rbp - 224]
    test rax, rax
    jz ir_if_next_611
    mov rax, 0
    mov [rbp - 232], rax
    mov rax, [rbp - 232]
    test rax, rax
    jz ir_errdefer_ok_614
    jmp ir_errdefer_end_615
ir_errdefer_ok_614:
ir_errdefer_end_615:
    mov rax, 0
    jmp Lis_forum_exit
    jmp ir_if_end_610
ir_if_next_611:
ir_if_end_610:
    ; Load variable: path_start
    movsxd rax, dword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 4
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 240], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_618
    jmp ir_nonnull_619
ir_trap_null_618:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct185]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_619:
    mov rax, [rbp - 240]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 248], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 248]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 256], rax
    mov rax, [rbp - 256]
    movzx rax, byte [rax]
    mov [rbp - 264], rax
    mov rax, [rbp - 264]
    push rax
    mov rax, 117
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 272], rax
    mov rax, [rbp - 272]
    test rax, rax
    jz ir_if_next_617
    mov rax, 0
    mov [rbp - 280], rax
    mov rax, [rbp - 280]
    test rax, rax
    jz ir_errdefer_ok_620
    jmp ir_errdefer_end_621
ir_errdefer_ok_620:
ir_errdefer_end_621:
    mov rax, 0
    jmp Lis_forum_exit
    jmp ir_if_end_616
ir_if_next_617:
ir_if_end_616:
    ; Load variable: path_start
    movsxd rax, dword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 5
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 288], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_624
    jmp ir_nonnull_625
ir_trap_null_624:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct187]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_625:
    mov rax, [rbp - 288]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 296], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 296]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 304], rax
    mov rax, [rbp - 304]
    movzx rax, byte [rax]
    mov [rbp - 312], rax
    mov rax, [rbp - 312]
    push rax
    mov rax, 109
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 320], rax
    mov rax, [rbp - 320]
    test rax, rax
    jz ir_if_next_623
    mov rax, 0
    mov [rbp - 328], rax
    mov rax, [rbp - 328]
    test rax, rax
    jz ir_errdefer_ok_626
    jmp ir_errdefer_end_627
ir_errdefer_ok_626:
ir_errdefer_end_627:
    mov rax, 0
    jmp Lis_forum_exit
    jmp ir_if_end_622
ir_if_next_623:
ir_if_end_622:
    mov rax, 1
    mov [rbp - 336], rax
    mov rax, [rbp - 336]
    test rax, rax
    jz ir_errdefer_ok_628
    jmp ir_errdefer_end_629
ir_errdefer_ok_628:
ir_errdefer_end_629:
    mov rax, 1
    jmp Lis_forum_exit
Lis_forum_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global get_thread_id

get_thread_id:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 1936    ; Allocate 1936 bytes on stack (aligned)
    ; Registering 3 function parameters
    mov [rbp - 8], rcx  ; Home param 'buf'
    ; Parameter 'buf' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'n'
    ; Parameter 'n' arrived in register rdx
    mov [rbp - 24], r8  ; Home param 'path_start'
    ; Parameter 'path_start' arrived in register r8
ir_entry_630:
    ; Load variable: path_start
    movsxd rax, dword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 6
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    ; Store to variable: i
    mov dword [rbp - 28], eax  ; To stack [rbp - 28]
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    ; Load variable: n
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_if_next_632
    mov rax, 0
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    test rax, rax
    jz ir_errdefer_ok_633
    jmp ir_errdefer_end_634
ir_errdefer_ok_633:
ir_errdefer_end_634:
    mov rax, 0
    jmp Lget_thread_id_exit
    jmp ir_if_end_631
ir_if_next_632:
ir_if_end_631:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_637
    jmp ir_nonnull_638
ir_trap_null_637:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct189]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_638:
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 64], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 64]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    movzx rax, byte [rax]
    mov [rbp - 80], rax
    mov rax, [rbp - 80]
    push rax
    mov rax, 63
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    test rax, rax
    jz ir_if_next_636
    mov rax, 0
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    test rax, rax
    jz ir_errdefer_ok_639
    jmp ir_errdefer_end_640
ir_errdefer_ok_639:
ir_errdefer_end_640:
    mov rax, 0
    jmp Lget_thread_id_exit
    jmp ir_if_end_635
ir_if_next_636:
ir_if_end_635:
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 104], rax
    mov rax, [rbp - 104]
    ; Store to variable: i
    mov dword [rbp - 28], eax  ; To stack [rbp - 28]
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 7
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    push rax
    ; Load variable: n
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    mov r10, rax
    pop rax
    cmp rax, r10
    setg al
    movzx rax, al
    mov [rbp - 120], rax
    mov rax, [rbp - 120]
    test rax, rax
    jz ir_if_next_642
    mov rax, 0
    mov [rbp - 128], rax
    mov rax, [rbp - 128]
    test rax, rax
    jz ir_errdefer_ok_643
    jmp ir_errdefer_end_644
ir_errdefer_ok_643:
ir_errdefer_end_644:
    mov rax, 0
    jmp Lget_thread_id_exit
    jmp ir_if_end_641
ir_if_next_642:
ir_if_end_641:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_647
    jmp ir_nonnull_648
ir_trap_null_647:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct191]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_648:
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 136], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 136]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 144], rax
    mov rax, [rbp - 144]
    movzx rax, byte [rax]
    mov [rbp - 152], rax
    mov rax, [rbp - 152]
    push rax
    mov rax, 116
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 160], rax
    mov rax, [rbp - 160]
    test rax, rax
    jz ir_sc_rhs_649
    jmp ir_sc_true_650
ir_sc_rhs_649:
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 168], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_653
    jmp ir_nonnull_654
ir_trap_null_653:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct193]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_654:
    mov rax, [rbp - 168]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 176], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 176]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 184], rax
    mov rax, [rbp - 184]
    movzx rax, byte [rax]
    mov [rbp - 192], rax
    mov rax, [rbp - 192]
    push rax
    mov rax, 104
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 200], rax
    mov rax, [rbp - 200]
    test rax, rax
    jz ir_sc_false_651
ir_sc_true_650:
    mov rax, 1
    mov [rbp - 208], rax
    jmp ir_sc_end_652
ir_sc_false_651:
    mov rax, 0
    mov [rbp - 208], rax
ir_sc_end_652:
    mov rax, [rbp - 208]
    test rax, rax
    jz ir_sc_rhs_655
    jmp ir_sc_true_656
ir_sc_rhs_655:
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 2
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 224], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_659
    jmp ir_nonnull_660
ir_trap_null_659:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct195]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_660:
    mov rax, [rbp - 224]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 232], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 232]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 240], rax
    mov rax, [rbp - 240]
    movzx rax, byte [rax]
    mov [rbp - 248], rax
    mov rax, [rbp - 248]
    push rax
    mov rax, 114
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 256], rax
    mov rax, [rbp - 256]
    test rax, rax
    jz ir_sc_false_657
ir_sc_true_656:
    mov rax, 1
    mov [rbp - 264], rax
    jmp ir_sc_end_658
ir_sc_false_657:
    mov rax, 0
    mov [rbp - 264], rax
ir_sc_end_658:
    mov rax, [rbp - 264]
    test rax, rax
    jz ir_sc_rhs_661
    jmp ir_sc_true_662
ir_sc_rhs_661:
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 3
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 280], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_665
    jmp ir_nonnull_666
ir_trap_null_665:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct197]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_666:
    mov rax, [rbp - 280]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 288], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 288]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 296], rax
    mov rax, [rbp - 296]
    movzx rax, byte [rax]
    mov [rbp - 304], rax
    mov rax, [rbp - 304]
    push rax
    mov rax, 101
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 312], rax
    mov rax, [rbp - 312]
    test rax, rax
    jz ir_sc_false_663
ir_sc_true_662:
    mov rax, 1
    mov [rbp - 320], rax
    jmp ir_sc_end_664
ir_sc_false_663:
    mov rax, 0
    mov [rbp - 320], rax
ir_sc_end_664:
    mov rax, [rbp - 320]
    test rax, rax
    jz ir_sc_rhs_667
    jmp ir_sc_true_668
ir_sc_rhs_667:
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 4
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 336], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_671
    jmp ir_nonnull_672
ir_trap_null_671:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct199]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_672:
    mov rax, [rbp - 336]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 344], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 344]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 352], rax
    mov rax, [rbp - 352]
    movzx rax, byte [rax]
    mov [rbp - 360], rax
    mov rax, [rbp - 360]
    push rax
    mov rax, 97
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 368], rax
    mov rax, [rbp - 368]
    test rax, rax
    jz ir_sc_false_669
ir_sc_true_668:
    mov rax, 1
    mov [rbp - 376], rax
    jmp ir_sc_end_670
ir_sc_false_669:
    mov rax, 0
    mov [rbp - 376], rax
ir_sc_end_670:
    mov rax, [rbp - 376]
    test rax, rax
    jz ir_sc_rhs_673
    jmp ir_sc_true_674
ir_sc_rhs_673:
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 5
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 392], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_677
    jmp ir_nonnull_678
ir_trap_null_677:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct201]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_678:
    mov rax, [rbp - 392]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 400], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 400]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 408], rax
    mov rax, [rbp - 408]
    movzx rax, byte [rax]
    mov [rbp - 416], rax
    mov rax, [rbp - 416]
    push rax
    mov rax, 100
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 424], rax
    mov rax, [rbp - 424]
    test rax, rax
    jz ir_sc_false_675
ir_sc_true_674:
    mov rax, 1
    mov [rbp - 432], rax
    jmp ir_sc_end_676
ir_sc_false_675:
    mov rax, 0
    mov [rbp - 432], rax
ir_sc_end_676:
    mov rax, [rbp - 432]
    test rax, rax
    jz ir_sc_rhs_679
    jmp ir_sc_true_680
ir_sc_rhs_679:
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 6
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 448], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_683
    jmp ir_nonnull_684
ir_trap_null_683:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct203]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_684:
    mov rax, [rbp - 448]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 456], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 456]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 464], rax
    mov rax, [rbp - 464]
    movzx rax, byte [rax]
    mov [rbp - 472], rax
    mov rax, [rbp - 472]
    push rax
    mov rax, 61
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 480], rax
    mov rax, [rbp - 480]
    test rax, rax
    jz ir_sc_false_681
ir_sc_true_680:
    mov rax, 1
    mov [rbp - 488], rax
    jmp ir_sc_end_682
ir_sc_false_681:
    mov rax, 0
    mov [rbp - 488], rax
ir_sc_end_682:
    mov rax, [rbp - 488]
    test rax, rax
    jz ir_if_next_646
    mov rax, 0
    mov [rbp - 504], rax
    mov rax, [rbp - 504]
    test rax, rax
    jz ir_errdefer_ok_685
    jmp ir_errdefer_end_686
ir_errdefer_ok_685:
ir_errdefer_end_686:
    mov rax, 0
    jmp Lget_thread_id_exit
    jmp ir_if_end_645
ir_if_next_646:
ir_if_end_645:
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 7
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 512], rax
    mov rax, [rbp - 512]
    ; Store to variable: i
    mov dword [rbp - 28], eax  ; To stack [rbp - 28]
    mov rax, 0
    ; Store to variable: id
    mov dword [rbp - 32], eax  ; To stack [rbp - 32]
ir_while_687:
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    ; Load variable: n
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 520], rax
    mov rax, [rbp - 520]
    test rax, rax
    jz ir_sc_false_691
ir_sc_rhs_689:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_693
    jmp ir_nonnull_694
ir_trap_null_693:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct205]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_694:
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 528], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 528]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 536], rax
    mov rax, [rbp - 536]
    movzx rax, byte [rax]
    mov [rbp - 544], rax
    mov rax, [rbp - 544]
    push rax
    mov rax, 48
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 552], rax
    mov rax, [rbp - 552]
    test rax, rax
    jz ir_sc_false_691
ir_sc_true_690:
    mov rax, 1
    mov [rbp - 560], rax
    jmp ir_sc_end_692
ir_sc_false_691:
    mov rax, 0
    mov [rbp - 560], rax
ir_sc_end_692:
    mov rax, [rbp - 560]
    test rax, rax
    jz ir_sc_false_697
ir_sc_rhs_695:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_699
    jmp ir_nonnull_700
ir_trap_null_699:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct207]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_700:
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 576], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 576]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 584], rax
    mov rax, [rbp - 584]
    movzx rax, byte [rax]
    mov [rbp - 592], rax
    mov rax, [rbp - 592]
    push rax
    mov rax, 57
    mov r10, rax
    pop rax
    cmp rax, r10
    setle al
    movzx rax, al
    mov [rbp - 600], rax
    mov rax, [rbp - 600]
    test rax, rax
    jz ir_sc_false_697
ir_sc_true_696:
    mov rax, 1
    mov [rbp - 608], rax
    jmp ir_sc_end_698
ir_sc_false_697:
    mov rax, 0
    mov [rbp - 608], rax
ir_sc_end_698:
    mov rax, [rbp - 608]
    test rax, rax
    jz ir_while_end_688
    ; Load variable: id
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, 10
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 624], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_701
    jmp ir_nonnull_702
ir_trap_null_701:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct209]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_702:
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 632], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 632]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 640], rax
    mov rax, [rbp - 640]
    movzx rax, byte [rax]
    mov [rbp - 648], rax
    mov rax, [rbp - 648]
    push rax
    mov rax, 48
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 656], rax
    mov rax, [rbp - 624]
    push rax
    mov rax, [rbp - 656]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 664], rax
    mov rax, [rbp - 664]
    ; Store to variable: id
    mov dword [rbp - 32], eax  ; To stack [rbp - 32]
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 672], rax
    mov rax, [rbp - 672]
    ; Store to variable: i
    mov dword [rbp - 28], eax  ; To stack [rbp - 28]
    jmp ir_while_687
ir_while_end_688:
    ; Load variable: id
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    mov [rbp - 680], rax
    mov rax, [rbp - 680]
    test rax, rax
    jz ir_errdefer_ok_703
    jmp ir_errdefer_end_704
ir_errdefer_ok_703:
ir_errdefer_end_704:
    ; Load variable: id
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    jmp Lget_thread_id_exit
Lget_thread_id_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global is_demo

is_demo:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 928    ; Allocate 928 bytes on stack (aligned)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 'buf'
    ; Parameter 'buf' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'n'
    ; Parameter 'n' arrived in register rdx
ir_entry_705:
    ; Load variable: n
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 9
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_next_707
    mov rax, 0
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_708
    jmp ir_errdefer_end_709
ir_errdefer_ok_708:
ir_errdefer_end_709:
    mov rax, 0
    jmp Lis_demo_exit
    jmp ir_if_end_706
ir_if_next_707:
ir_if_end_706:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_712
    jmp ir_nonnull_713
ir_trap_null_712:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct211]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_713:
    mov rax, 4
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 40], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 40]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    movzx rax, byte [rax]
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    push rax
    mov rax, 47
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    test rax, rax
    jz ir_if_next_711
    mov rax, 0
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    test rax, rax
    jz ir_errdefer_ok_714
    jmp ir_errdefer_end_715
ir_errdefer_ok_714:
ir_errdefer_end_715:
    mov rax, 0
    jmp Lis_demo_exit
    jmp ir_if_end_710
ir_if_next_711:
ir_if_end_710:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_718
    jmp ir_nonnull_719
ir_trap_null_718:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct213]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_719:
    mov rax, 5
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 80], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 80]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    movzx rax, byte [rax]
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    push rax
    mov rax, 100
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 104], rax
    mov rax, [rbp - 104]
    test rax, rax
    jz ir_if_next_717
    mov rax, 0
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    test rax, rax
    jz ir_errdefer_ok_720
    jmp ir_errdefer_end_721
ir_errdefer_ok_720:
ir_errdefer_end_721:
    mov rax, 0
    jmp Lis_demo_exit
    jmp ir_if_end_716
ir_if_next_717:
ir_if_end_716:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_724
    jmp ir_nonnull_725
ir_trap_null_724:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct215]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_725:
    mov rax, 6
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 120], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 120]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 128], rax
    mov rax, [rbp - 128]
    movzx rax, byte [rax]
    mov [rbp - 136], rax
    mov rax, [rbp - 136]
    push rax
    mov rax, 101
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 144], rax
    mov rax, [rbp - 144]
    test rax, rax
    jz ir_if_next_723
    mov rax, 0
    mov [rbp - 152], rax
    mov rax, [rbp - 152]
    test rax, rax
    jz ir_errdefer_ok_726
    jmp ir_errdefer_end_727
ir_errdefer_ok_726:
ir_errdefer_end_727:
    mov rax, 0
    jmp Lis_demo_exit
    jmp ir_if_end_722
ir_if_next_723:
ir_if_end_722:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_730
    jmp ir_nonnull_731
ir_trap_null_730:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct217]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_731:
    mov rax, 7
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 160], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 160]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    movzx rax, byte [rax]
    mov [rbp - 176], rax
    mov rax, [rbp - 176]
    push rax
    mov rax, 109
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 184], rax
    mov rax, [rbp - 184]
    test rax, rax
    jz ir_if_next_729
    mov rax, 0
    mov [rbp - 192], rax
    mov rax, [rbp - 192]
    test rax, rax
    jz ir_errdefer_ok_732
    jmp ir_errdefer_end_733
ir_errdefer_ok_732:
ir_errdefer_end_733:
    mov rax, 0
    jmp Lis_demo_exit
    jmp ir_if_end_728
ir_if_next_729:
ir_if_end_728:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_736
    jmp ir_nonnull_737
ir_trap_null_736:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct219]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_737:
    mov rax, 8
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 200], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 200]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 208], rax
    mov rax, [rbp - 208]
    movzx rax, byte [rax]
    mov [rbp - 216], rax
    mov rax, [rbp - 216]
    push rax
    mov rax, 111
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 224], rax
    mov rax, [rbp - 224]
    test rax, rax
    jz ir_if_next_735
    mov rax, 0
    mov [rbp - 232], rax
    mov rax, [rbp - 232]
    test rax, rax
    jz ir_errdefer_ok_738
    jmp ir_errdefer_end_739
ir_errdefer_ok_738:
ir_errdefer_end_739:
    mov rax, 0
    jmp Lis_demo_exit
    jmp ir_if_end_734
ir_if_next_735:
ir_if_end_734:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_742
    jmp ir_nonnull_743
ir_trap_null_742:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct221]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_743:
    mov rax, 9
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 240], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 240]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 248], rax
    mov rax, [rbp - 248]
    movzx rax, byte [rax]
    mov [rbp - 256], rax
    mov rax, [rbp - 256]
    push rax
    mov rax, 32
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 264], rax
    mov rax, [rbp - 264]
    test rax, rax
    jz ir_sc_false_746
ir_sc_rhs_744:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_748
    jmp ir_nonnull_749
ir_trap_null_748:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct223]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_749:
    mov rax, 9
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 272], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 272]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 280], rax
    mov rax, [rbp - 280]
    movzx rax, byte [rax]
    mov [rbp - 288], rax
    mov rax, [rbp - 288]
    push rax
    mov rax, 63
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 296], rax
    mov rax, [rbp - 296]
    test rax, rax
    jz ir_sc_false_746
ir_sc_true_745:
    mov rax, 1
    mov [rbp - 304], rax
    jmp ir_sc_end_747
ir_sc_false_746:
    mov rax, 0
    mov [rbp - 304], rax
ir_sc_end_747:
    mov rax, [rbp - 304]
    test rax, rax
    jz ir_if_next_741
    mov rax, 0
    mov [rbp - 320], rax
    mov rax, [rbp - 320]
    test rax, rax
    jz ir_errdefer_ok_750
    jmp ir_errdefer_end_751
ir_errdefer_ok_750:
ir_errdefer_end_751:
    mov rax, 0
    jmp Lis_demo_exit
    jmp ir_if_end_740
ir_if_next_741:
ir_if_end_740:
    mov rax, 1
    mov [rbp - 328], rax
    mov rax, [rbp - 328]
    test rax, rax
    jz ir_errdefer_ok_752
    jmp ir_errdefer_end_753
ir_errdefer_ok_752:
ir_errdefer_end_753:
    mov rax, 1
    jmp Lis_demo_exit
Lis_demo_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global is_benchmarks

is_benchmarks:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 1616    ; Allocate 1616 bytes on stack (aligned)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 'buf'
    ; Parameter 'buf' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'n'
    ; Parameter 'n' arrived in register rdx
ir_entry_754:
    ; Load variable: n
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 16
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_next_756
    mov rax, 0
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_757
    jmp ir_errdefer_end_758
ir_errdefer_ok_757:
ir_errdefer_end_758:
    mov rax, 0
    jmp Lis_benchmarks_exit
    jmp ir_if_end_755
ir_if_next_756:
ir_if_end_755:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_761
    jmp ir_nonnull_762
ir_trap_null_761:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct225]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_762:
    mov rax, 4
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 40], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 40]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    movzx rax, byte [rax]
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    push rax
    mov rax, 47
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    test rax, rax
    jz ir_if_next_760
    mov rax, 0
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    test rax, rax
    jz ir_errdefer_ok_763
    jmp ir_errdefer_end_764
ir_errdefer_ok_763:
ir_errdefer_end_764:
    mov rax, 0
    jmp Lis_benchmarks_exit
    jmp ir_if_end_759
ir_if_next_760:
ir_if_end_759:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_767
    jmp ir_nonnull_768
ir_trap_null_767:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct227]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_768:
    mov rax, 5
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 80], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 80]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    movzx rax, byte [rax]
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    push rax
    mov rax, 98
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 104], rax
    mov rax, [rbp - 104]
    test rax, rax
    jz ir_if_next_766
    mov rax, 0
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    test rax, rax
    jz ir_errdefer_ok_769
    jmp ir_errdefer_end_770
ir_errdefer_ok_769:
ir_errdefer_end_770:
    mov rax, 0
    jmp Lis_benchmarks_exit
    jmp ir_if_end_765
ir_if_next_766:
ir_if_end_765:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_773
    jmp ir_nonnull_774
ir_trap_null_773:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct229]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_774:
    mov rax, 6
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 120], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 120]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 128], rax
    mov rax, [rbp - 128]
    movzx rax, byte [rax]
    mov [rbp - 136], rax
    mov rax, [rbp - 136]
    push rax
    mov rax, 101
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 144], rax
    mov rax, [rbp - 144]
    test rax, rax
    jz ir_if_next_772
    mov rax, 0
    mov [rbp - 152], rax
    mov rax, [rbp - 152]
    test rax, rax
    jz ir_errdefer_ok_775
    jmp ir_errdefer_end_776
ir_errdefer_ok_775:
ir_errdefer_end_776:
    mov rax, 0
    jmp Lis_benchmarks_exit
    jmp ir_if_end_771
ir_if_next_772:
ir_if_end_771:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_779
    jmp ir_nonnull_780
ir_trap_null_779:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct231]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_780:
    mov rax, 7
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 160], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 160]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    movzx rax, byte [rax]
    mov [rbp - 176], rax
    mov rax, [rbp - 176]
    push rax
    mov rax, 110
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 184], rax
    mov rax, [rbp - 184]
    test rax, rax
    jz ir_if_next_778
    mov rax, 0
    mov [rbp - 192], rax
    mov rax, [rbp - 192]
    test rax, rax
    jz ir_errdefer_ok_781
    jmp ir_errdefer_end_782
ir_errdefer_ok_781:
ir_errdefer_end_782:
    mov rax, 0
    jmp Lis_benchmarks_exit
    jmp ir_if_end_777
ir_if_next_778:
ir_if_end_777:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_785
    jmp ir_nonnull_786
ir_trap_null_785:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct233]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_786:
    mov rax, 8
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 200], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 200]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 208], rax
    mov rax, [rbp - 208]
    movzx rax, byte [rax]
    mov [rbp - 216], rax
    mov rax, [rbp - 216]
    push rax
    mov rax, 99
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 224], rax
    mov rax, [rbp - 224]
    test rax, rax
    jz ir_if_next_784
    mov rax, 0
    mov [rbp - 232], rax
    mov rax, [rbp - 232]
    test rax, rax
    jz ir_errdefer_ok_787
    jmp ir_errdefer_end_788
ir_errdefer_ok_787:
ir_errdefer_end_788:
    mov rax, 0
    jmp Lis_benchmarks_exit
    jmp ir_if_end_783
ir_if_next_784:
ir_if_end_783:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_791
    jmp ir_nonnull_792
ir_trap_null_791:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct235]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_792:
    mov rax, 9
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 240], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 240]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 248], rax
    mov rax, [rbp - 248]
    movzx rax, byte [rax]
    mov [rbp - 256], rax
    mov rax, [rbp - 256]
    push rax
    mov rax, 104
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 264], rax
    mov rax, [rbp - 264]
    test rax, rax
    jz ir_if_next_790
    mov rax, 0
    mov [rbp - 272], rax
    mov rax, [rbp - 272]
    test rax, rax
    jz ir_errdefer_ok_793
    jmp ir_errdefer_end_794
ir_errdefer_ok_793:
ir_errdefer_end_794:
    mov rax, 0
    jmp Lis_benchmarks_exit
    jmp ir_if_end_789
ir_if_next_790:
ir_if_end_789:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_797
    jmp ir_nonnull_798
ir_trap_null_797:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct237]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_798:
    mov rax, 10
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 280], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 280]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 288], rax
    mov rax, [rbp - 288]
    movzx rax, byte [rax]
    mov [rbp - 296], rax
    mov rax, [rbp - 296]
    push rax
    mov rax, 109
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 304], rax
    mov rax, [rbp - 304]
    test rax, rax
    jz ir_if_next_796
    mov rax, 0
    mov [rbp - 312], rax
    mov rax, [rbp - 312]
    test rax, rax
    jz ir_errdefer_ok_799
    jmp ir_errdefer_end_800
ir_errdefer_ok_799:
ir_errdefer_end_800:
    mov rax, 0
    jmp Lis_benchmarks_exit
    jmp ir_if_end_795
ir_if_next_796:
ir_if_end_795:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_803
    jmp ir_nonnull_804
ir_trap_null_803:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct239]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_804:
    mov rax, 11
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 320], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 320]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 328], rax
    mov rax, [rbp - 328]
    movzx rax, byte [rax]
    mov [rbp - 336], rax
    mov rax, [rbp - 336]
    push rax
    mov rax, 97
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 344], rax
    mov rax, [rbp - 344]
    test rax, rax
    jz ir_if_next_802
    mov rax, 0
    mov [rbp - 352], rax
    mov rax, [rbp - 352]
    test rax, rax
    jz ir_errdefer_ok_805
    jmp ir_errdefer_end_806
ir_errdefer_ok_805:
ir_errdefer_end_806:
    mov rax, 0
    jmp Lis_benchmarks_exit
    jmp ir_if_end_801
ir_if_next_802:
ir_if_end_801:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_809
    jmp ir_nonnull_810
ir_trap_null_809:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct241]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_810:
    mov rax, 12
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 360], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 360]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 368], rax
    mov rax, [rbp - 368]
    movzx rax, byte [rax]
    mov [rbp - 376], rax
    mov rax, [rbp - 376]
    push rax
    mov rax, 114
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 384], rax
    mov rax, [rbp - 384]
    test rax, rax
    jz ir_if_next_808
    mov rax, 0
    mov [rbp - 392], rax
    mov rax, [rbp - 392]
    test rax, rax
    jz ir_errdefer_ok_811
    jmp ir_errdefer_end_812
ir_errdefer_ok_811:
ir_errdefer_end_812:
    mov rax, 0
    jmp Lis_benchmarks_exit
    jmp ir_if_end_807
ir_if_next_808:
ir_if_end_807:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_815
    jmp ir_nonnull_816
ir_trap_null_815:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct243]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_816:
    mov rax, 13
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 400], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 400]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 408], rax
    mov rax, [rbp - 408]
    movzx rax, byte [rax]
    mov [rbp - 416], rax
    mov rax, [rbp - 416]
    push rax
    mov rax, 107
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 424], rax
    mov rax, [rbp - 424]
    test rax, rax
    jz ir_if_next_814
    mov rax, 0
    mov [rbp - 432], rax
    mov rax, [rbp - 432]
    test rax, rax
    jz ir_errdefer_ok_817
    jmp ir_errdefer_end_818
ir_errdefer_ok_817:
ir_errdefer_end_818:
    mov rax, 0
    jmp Lis_benchmarks_exit
    jmp ir_if_end_813
ir_if_next_814:
ir_if_end_813:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_821
    jmp ir_nonnull_822
ir_trap_null_821:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct245]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_822:
    mov rax, 14
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 440], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 440]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 448], rax
    mov rax, [rbp - 448]
    movzx rax, byte [rax]
    mov [rbp - 456], rax
    mov rax, [rbp - 456]
    push rax
    mov rax, 115
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 464], rax
    mov rax, [rbp - 464]
    test rax, rax
    jz ir_if_next_820
    mov rax, 0
    mov [rbp - 472], rax
    mov rax, [rbp - 472]
    test rax, rax
    jz ir_errdefer_ok_823
    jmp ir_errdefer_end_824
ir_errdefer_ok_823:
ir_errdefer_end_824:
    mov rax, 0
    jmp Lis_benchmarks_exit
    jmp ir_if_end_819
ir_if_next_820:
ir_if_end_819:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_827
    jmp ir_nonnull_828
ir_trap_null_827:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct247]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_828:
    mov rax, 15
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 480], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 480]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 488], rax
    mov rax, [rbp - 488]
    movzx rax, byte [rax]
    mov [rbp - 496], rax
    mov rax, [rbp - 496]
    push rax
    mov rax, 32
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 504], rax
    mov rax, [rbp - 504]
    test rax, rax
    jz ir_sc_false_831
ir_sc_rhs_829:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_833
    jmp ir_nonnull_834
ir_trap_null_833:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct249]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_834:
    mov rax, 15
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 512], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 512]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 520], rax
    mov rax, [rbp - 520]
    movzx rax, byte [rax]
    mov [rbp - 528], rax
    mov rax, [rbp - 528]
    push rax
    mov rax, 63
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 536], rax
    mov rax, [rbp - 536]
    test rax, rax
    jz ir_sc_false_831
ir_sc_true_830:
    mov rax, 1
    mov [rbp - 544], rax
    jmp ir_sc_end_832
ir_sc_false_831:
    mov rax, 0
    mov [rbp - 544], rax
ir_sc_end_832:
    mov rax, [rbp - 544]
    test rax, rax
    jz ir_if_next_826
    mov rax, 0
    mov [rbp - 560], rax
    mov rax, [rbp - 560]
    test rax, rax
    jz ir_errdefer_ok_835
    jmp ir_errdefer_end_836
ir_errdefer_ok_835:
ir_errdefer_end_836:
    mov rax, 0
    jmp Lis_benchmarks_exit
    jmp ir_if_end_825
ir_if_next_826:
ir_if_end_825:
    mov rax, 1
    mov [rbp - 568], rax
    mov rax, [rbp - 568]
    test rax, rax
    jz ir_errdefer_ok_837
    jmp ir_errdefer_end_838
ir_errdefer_ok_837:
ir_errdefer_end_838:
    mov rax, 1
    jmp Lis_benchmarks_exit
Lis_benchmarks_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global is_docs

is_docs:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 928    ; Allocate 928 bytes on stack (aligned)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 'buf'
    ; Parameter 'buf' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'n'
    ; Parameter 'n' arrived in register rdx
ir_entry_839:
    ; Load variable: n
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 9
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_next_841
    mov rax, 0
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_842
    jmp ir_errdefer_end_843
ir_errdefer_ok_842:
ir_errdefer_end_843:
    mov rax, 0
    jmp Lis_docs_exit
    jmp ir_if_end_840
ir_if_next_841:
ir_if_end_840:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_846
    jmp ir_nonnull_847
ir_trap_null_846:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct251]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_847:
    mov rax, 4
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 40], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 40]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    movzx rax, byte [rax]
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    push rax
    mov rax, 47
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    test rax, rax
    jz ir_if_next_845
    mov rax, 0
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    test rax, rax
    jz ir_errdefer_ok_848
    jmp ir_errdefer_end_849
ir_errdefer_ok_848:
ir_errdefer_end_849:
    mov rax, 0
    jmp Lis_docs_exit
    jmp ir_if_end_844
ir_if_next_845:
ir_if_end_844:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_852
    jmp ir_nonnull_853
ir_trap_null_852:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct253]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_853:
    mov rax, 5
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 80], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 80]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    movzx rax, byte [rax]
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    push rax
    mov rax, 100
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 104], rax
    mov rax, [rbp - 104]
    test rax, rax
    jz ir_if_next_851
    mov rax, 0
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    test rax, rax
    jz ir_errdefer_ok_854
    jmp ir_errdefer_end_855
ir_errdefer_ok_854:
ir_errdefer_end_855:
    mov rax, 0
    jmp Lis_docs_exit
    jmp ir_if_end_850
ir_if_next_851:
ir_if_end_850:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_858
    jmp ir_nonnull_859
ir_trap_null_858:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct255]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_859:
    mov rax, 6
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 120], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 120]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 128], rax
    mov rax, [rbp - 128]
    movzx rax, byte [rax]
    mov [rbp - 136], rax
    mov rax, [rbp - 136]
    push rax
    mov rax, 111
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 144], rax
    mov rax, [rbp - 144]
    test rax, rax
    jz ir_if_next_857
    mov rax, 0
    mov [rbp - 152], rax
    mov rax, [rbp - 152]
    test rax, rax
    jz ir_errdefer_ok_860
    jmp ir_errdefer_end_861
ir_errdefer_ok_860:
ir_errdefer_end_861:
    mov rax, 0
    jmp Lis_docs_exit
    jmp ir_if_end_856
ir_if_next_857:
ir_if_end_856:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_864
    jmp ir_nonnull_865
ir_trap_null_864:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct257]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_865:
    mov rax, 7
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 160], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 160]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    movzx rax, byte [rax]
    mov [rbp - 176], rax
    mov rax, [rbp - 176]
    push rax
    mov rax, 99
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 184], rax
    mov rax, [rbp - 184]
    test rax, rax
    jz ir_if_next_863
    mov rax, 0
    mov [rbp - 192], rax
    mov rax, [rbp - 192]
    test rax, rax
    jz ir_errdefer_ok_866
    jmp ir_errdefer_end_867
ir_errdefer_ok_866:
ir_errdefer_end_867:
    mov rax, 0
    jmp Lis_docs_exit
    jmp ir_if_end_862
ir_if_next_863:
ir_if_end_862:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_870
    jmp ir_nonnull_871
ir_trap_null_870:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct259]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_871:
    mov rax, 8
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 200], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 200]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 208], rax
    mov rax, [rbp - 208]
    movzx rax, byte [rax]
    mov [rbp - 216], rax
    mov rax, [rbp - 216]
    push rax
    mov rax, 115
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 224], rax
    mov rax, [rbp - 224]
    test rax, rax
    jz ir_if_next_869
    mov rax, 0
    mov [rbp - 232], rax
    mov rax, [rbp - 232]
    test rax, rax
    jz ir_errdefer_ok_872
    jmp ir_errdefer_end_873
ir_errdefer_ok_872:
ir_errdefer_end_873:
    mov rax, 0
    jmp Lis_docs_exit
    jmp ir_if_end_868
ir_if_next_869:
ir_if_end_868:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_876
    jmp ir_nonnull_877
ir_trap_null_876:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct261]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_877:
    mov rax, 9
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 240], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 240]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 248], rax
    mov rax, [rbp - 248]
    movzx rax, byte [rax]
    mov [rbp - 256], rax
    mov rax, [rbp - 256]
    push rax
    mov rax, 32
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 264], rax
    mov rax, [rbp - 264]
    test rax, rax
    jz ir_sc_false_880
ir_sc_rhs_878:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_882
    jmp ir_nonnull_883
ir_trap_null_882:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct263]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_883:
    mov rax, 9
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 272], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 272]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 280], rax
    mov rax, [rbp - 280]
    movzx rax, byte [rax]
    mov [rbp - 288], rax
    mov rax, [rbp - 288]
    push rax
    mov rax, 63
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 296], rax
    mov rax, [rbp - 296]
    test rax, rax
    jz ir_sc_false_880
ir_sc_true_879:
    mov rax, 1
    mov [rbp - 304], rax
    jmp ir_sc_end_881
ir_sc_false_880:
    mov rax, 0
    mov [rbp - 304], rax
ir_sc_end_881:
    mov rax, [rbp - 304]
    test rax, rax
    jz ir_if_next_875
    mov rax, 0
    mov [rbp - 320], rax
    mov rax, [rbp - 320]
    test rax, rax
    jz ir_errdefer_ok_884
    jmp ir_errdefer_end_885
ir_errdefer_ok_884:
ir_errdefer_end_885:
    mov rax, 0
    jmp Lis_docs_exit
    jmp ir_if_end_874
ir_if_next_875:
ir_if_end_874:
    mov rax, 1
    mov [rbp - 328], rax
    mov rax, [rbp - 328]
    test rax, rax
    jz ir_errdefer_ok_886
    jmp ir_errdefer_end_887
ir_errdefer_ok_886:
ir_errdefer_end_887:
    mov rax, 1
    jmp Lis_docs_exit
Lis_docs_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global hex_char_val

hex_char_val:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 528    ; Allocate 528 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_888:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 48
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_sc_false_893
ir_sc_rhs_891:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 57
    mov r10, rax
    pop rax
    cmp rax, r10
    setle al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_sc_false_893
ir_sc_true_892:
    mov rax, 1
    mov [rbp - 32], rax
    jmp ir_sc_end_894
ir_sc_false_893:
    mov rax, 0
    mov [rbp - 32], rax
ir_sc_end_894:
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_if_next_890
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 48
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    test rax, rax
    jz ir_errdefer_ok_895
    jmp ir_errdefer_end_896
ir_errdefer_ok_895:
ir_errdefer_end_896:
    mov rax, [rbp - 48]
    jmp Lhex_char_val_exit
    jmp ir_if_end_889
ir_if_next_890:
ir_if_end_889:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 97
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    test rax, rax
    jz ir_sc_false_901
ir_sc_rhs_899:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 102
    mov r10, rax
    pop rax
    cmp rax, r10
    setle al
    movzx rax, al
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    test rax, rax
    jz ir_sc_false_901
ir_sc_true_900:
    mov rax, 1
    mov [rbp - 80], rax
    jmp ir_sc_end_902
ir_sc_false_901:
    mov rax, 0
    mov [rbp - 80], rax
ir_sc_end_902:
    mov rax, [rbp - 80]
    test rax, rax
    jz ir_if_next_898
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 97
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    push rax
    mov rax, 10
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 104], rax
    mov rax, [rbp - 104]
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    test rax, rax
    jz ir_errdefer_ok_903
    jmp ir_errdefer_end_904
ir_errdefer_ok_903:
ir_errdefer_end_904:
    mov rax, [rbp - 104]
    jmp Lhex_char_val_exit
    jmp ir_if_end_897
ir_if_next_898:
ir_if_end_897:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 65
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 120], rax
    mov rax, [rbp - 120]
    test rax, rax
    jz ir_sc_false_909
ir_sc_rhs_907:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 70
    mov r10, rax
    pop rax
    cmp rax, r10
    setle al
    movzx rax, al
    mov [rbp - 128], rax
    mov rax, [rbp - 128]
    test rax, rax
    jz ir_sc_false_909
ir_sc_true_908:
    mov rax, 1
    mov [rbp - 136], rax
    jmp ir_sc_end_910
ir_sc_false_909:
    mov rax, 0
    mov [rbp - 136], rax
ir_sc_end_910:
    mov rax, [rbp - 136]
    test rax, rax
    jz ir_if_next_906
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 65
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 152], rax
    mov rax, [rbp - 152]
    push rax
    mov rax, 10
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 160], rax
    mov rax, [rbp - 160]
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    test rax, rax
    jz ir_errdefer_ok_911
    jmp ir_errdefer_end_912
ir_errdefer_ok_911:
ir_errdefer_end_912:
    mov rax, [rbp - 160]
    jmp Lhex_char_val_exit
    jmp ir_if_end_905
ir_if_next_906:
ir_if_end_905:
    mov rax, 1
    neg rax
    mov [rbp - 176], rax
    mov rax, [rbp - 176]
    mov [rbp - 184], rax
    mov rax, [rbp - 184]
    test rax, rax
    jz ir_errdefer_ok_913
    jmp ir_errdefer_end_914
ir_errdefer_ok_913:
ir_errdefer_end_914:
    mov rax, [rbp - 176]
    jmp Lhex_char_val_exit
Lhex_char_val_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global extract_form_value

extract_form_value:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 2336    ; Allocate 2336 bytes on stack (aligned)
    ; Registering 7 function parameters
    mov [rbp - 8], rcx  ; Home param 'buf'
    ; Parameter 'buf' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'body_start'
    ; Parameter 'body_start' arrived in register rdx
    mov [rbp - 24], r8  ; Home param 'body_len'
    ; Parameter 'body_len' arrived in register r8
    mov [rbp - 32], r9  ; Home param 'key'
    ; Parameter 'key' arrived in register r9
    mov rax, [rbp + 48]  ; Load stack param 'key_len'
    mov [rbp - 40], rax  ; Home param 'key_len'
    ; Parameter 'key_len' arrived on stack [rbp + 48]
    mov rax, [rbp + 56]  ; Load stack param 'out'
    mov [rbp - 48], rax  ; Home param 'out'
    ; Parameter 'out' arrived on stack [rbp + 56]
    mov rax, [rbp + 64]  ; Load stack param 'out_max'
    mov [rbp - 56], rax  ; Home param 'out_max'
    ; Parameter 'out_max' arrived on stack [rbp + 64]
ir_entry_915:
    ; Load variable: body_start
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    ; Store to variable: i
    mov dword [rbp - 60], eax  ; To stack [rbp - 60]
    ; Load variable: body_start
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    ; Load variable: body_len
    movsxd rax, dword [rbp - 24]  ; From stack [rbp - 24]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    ; Store to variable: end
    mov dword [rbp - 64], eax  ; To stack [rbp - 64]
ir_while_916:
    ; Load variable: i
    movsxd rax, dword [rbp - 60]  ; From stack [rbp - 60]
    push rax
    ; Load variable: key_len
    movsxd rax, dword [rbp - 40]  ; From stack [rbp - 40]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 104], rax
    mov rax, [rbp - 104]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    push rax
    ; Load variable: end
    movsxd rax, dword [rbp - 64]  ; From stack [rbp - 64]
    mov r10, rax
    pop rax
    cmp rax, r10
    setle al
    movzx rax, al
    mov [rbp - 120], rax
    mov rax, [rbp - 120]
    test rax, rax
    jz ir_while_end_917
    mov rax, 1
    ; Store to variable: match
    mov dword [rbp - 68], eax  ; To stack [rbp - 68]
    mov rax, 0
    ; Store to variable: k
    mov dword [rbp - 72], eax  ; To stack [rbp - 72]
ir_while_918:
    ; Load variable: k
    movsxd rax, dword [rbp - 72]  ; From stack [rbp - 72]
    push rax
    ; Load variable: key_len
    movsxd rax, dword [rbp - 40]  ; From stack [rbp - 40]
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 128], rax
    mov rax, [rbp - 128]
    test rax, rax
    jz ir_while_end_919
    ; Load variable: i
    movsxd rax, dword [rbp - 60]  ; From stack [rbp - 60]
    push rax
    ; Load variable: k
    movsxd rax, dword [rbp - 72]  ; From stack [rbp - 72]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 136], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_922
    jmp ir_nonnull_923
ir_trap_null_922:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct265]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_923:
    mov rax, [rbp - 136]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 144], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 144]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 152], rax
    mov rax, [rbp - 152]
    movzx rax, byte [rax]
    mov [rbp - 160], rax
    ; Load variable: key
    mov rax, qword [rbp - 32]  ; From stack [rbp - 32]
    test rax, rax
    jz ir_trap_null_924
    jmp ir_nonnull_925
ir_trap_null_924:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct267]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_925:
    ; Load variable: k
    movsxd rax, dword [rbp - 72]  ; From stack [rbp - 72]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 168], rax
    ; Load variable: key
    mov rax, qword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, [rbp - 168]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 176], rax
    mov rax, [rbp - 176]
    movzx rax, byte [rax]
    mov [rbp - 184], rax
    mov rax, [rbp - 160]
    push rax
    mov rax, [rbp - 184]
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 192], rax
    mov rax, [rbp - 192]
    test rax, rax
    jz ir_if_next_921
    mov rax, 0
    ; Store to variable: match
    mov dword [rbp - 68], eax  ; To stack [rbp - 68]
    jmp ir_while_end_919
    jmp ir_if_end_920
ir_if_next_921:
ir_if_end_920:
    ; Load variable: k
    movsxd rax, dword [rbp - 72]  ; From stack [rbp - 72]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 200], rax
    mov rax, [rbp - 200]
    ; Store to variable: k
    mov dword [rbp - 72], eax  ; To stack [rbp - 72]
    jmp ir_while_918
ir_while_end_919:
    ; Load variable: match
    movsxd rax, dword [rbp - 68]  ; From stack [rbp - 68]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 208], rax
    mov rax, [rbp - 208]
    test rax, rax
    jz ir_sc_false_930
ir_sc_rhs_928:
    ; Load variable: i
    movsxd rax, dword [rbp - 60]  ; From stack [rbp - 60]
    push rax
    ; Load variable: key_len
    movsxd rax, dword [rbp - 40]  ; From stack [rbp - 40]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 216], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_932
    jmp ir_nonnull_933
ir_trap_null_932:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct269]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_933:
    mov rax, [rbp - 216]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 224], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 224]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 232], rax
    mov rax, [rbp - 232]
    movzx rax, byte [rax]
    mov [rbp - 240], rax
    mov rax, [rbp - 240]
    push rax
    mov rax, 61
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 248], rax
    mov rax, [rbp - 248]
    test rax, rax
    jz ir_sc_false_930
ir_sc_true_929:
    mov rax, 1
    mov [rbp - 256], rax
    jmp ir_sc_end_931
ir_sc_false_930:
    mov rax, 0
    mov [rbp - 256], rax
ir_sc_end_931:
    mov rax, [rbp - 256]
    test rax, rax
    jz ir_if_next_927
    ; Load variable: i
    movsxd rax, dword [rbp - 60]  ; From stack [rbp - 60]
    push rax
    ; Load variable: key_len
    movsxd rax, dword [rbp - 40]  ; From stack [rbp - 40]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 272], rax
    mov rax, [rbp - 272]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 280], rax
    mov rax, [rbp - 280]
    ; Store to variable: i
    mov dword [rbp - 60], eax  ; To stack [rbp - 60]
    mov rax, 0
    ; Store to variable: out_len
    mov dword [rbp - 76], eax  ; To stack [rbp - 76]
ir_while_934:
    ; Load variable: i
    movsxd rax, dword [rbp - 60]  ; From stack [rbp - 60]
    push rax
    ; Load variable: end
    movsxd rax, dword [rbp - 64]  ; From stack [rbp - 64]
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 288], rax
    mov rax, [rbp - 288]
    test rax, rax
    jz ir_sc_false_938
ir_sc_rhs_936:
    ; Load variable: out_max
    movsxd rax, dword [rbp - 56]  ; From stack [rbp - 56]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 296], rax
    ; Load variable: out_len
    movsxd rax, dword [rbp - 76]  ; From stack [rbp - 76]
    push rax
    mov rax, [rbp - 296]
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 304], rax
    mov rax, [rbp - 304]
    test rax, rax
    jz ir_sc_false_938
ir_sc_true_937:
    mov rax, 1
    mov [rbp - 312], rax
    jmp ir_sc_end_939
ir_sc_false_938:
    mov rax, 0
    mov [rbp - 312], rax
ir_sc_end_939:
    mov rax, [rbp - 312]
    test rax, rax
    jz ir_while_end_935
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_942
    jmp ir_nonnull_943
ir_trap_null_942:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct271]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_943:
    ; Load variable: i
    movsxd rax, dword [rbp - 60]  ; From stack [rbp - 60]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 328], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 328]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 336], rax
    mov rax, [rbp - 336]
    movzx rax, byte [rax]
    mov [rbp - 344], rax
    mov rax, [rbp - 344]
    push rax
    mov rax, 38
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 352], rax
    mov rax, [rbp - 352]
    test rax, rax
    jz ir_if_next_941
    jmp ir_while_end_935
    jmp ir_if_end_940
ir_if_next_941:
ir_if_end_940:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_946
    jmp ir_nonnull_947
ir_trap_null_946:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct273]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_947:
    ; Load variable: i
    movsxd rax, dword [rbp - 60]  ; From stack [rbp - 60]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 360], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 360]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 368], rax
    mov rax, [rbp - 368]
    movzx rax, byte [rax]
    mov [rbp - 376], rax
    mov rax, [rbp - 376]
    push rax
    mov rax, 43
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 384], rax
    mov rax, [rbp - 384]
    test rax, rax
    jz ir_if_next_945
    ; Load variable: out
    mov rax, qword [rbp - 48]  ; From stack [rbp - 48]
    test rax, rax
    jz ir_trap_null_948
    jmp ir_nonnull_949
ir_trap_null_948:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct275]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_949:
    ; Load variable: out_len
    movsxd rax, dword [rbp - 76]  ; From stack [rbp - 76]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 392], rax
    ; Load variable: out
    mov rax, qword [rbp - 48]  ; From stack [rbp - 48]
    push rax
    mov rax, [rbp - 392]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 400], rax
    mov rax, [rbp - 400]
    push rax
    mov rax, 32
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: out_len
    movsxd rax, dword [rbp - 76]  ; From stack [rbp - 76]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 416], rax
    mov rax, [rbp - 416]
    ; Store to variable: out_len
    mov dword [rbp - 76], eax  ; To stack [rbp - 76]
    ; Load variable: i
    movsxd rax, dword [rbp - 60]  ; From stack [rbp - 60]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 424], rax
    mov rax, [rbp - 424]
    ; Store to variable: i
    mov dword [rbp - 60], eax  ; To stack [rbp - 60]
    jmp ir_if_end_944
ir_if_next_945:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_951
    jmp ir_nonnull_952
ir_trap_null_951:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct277]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_952:
    ; Load variable: i
    movsxd rax, dword [rbp - 60]  ; From stack [rbp - 60]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 432], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 432]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 440], rax
    mov rax, [rbp - 440]
    movzx rax, byte [rax]
    mov [rbp - 448], rax
    mov rax, [rbp - 448]
    push rax
    mov rax, 37
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 456], rax
    mov rax, [rbp - 456]
    test rax, rax
    jz ir_sc_false_955
ir_sc_rhs_953:
    ; Load variable: i
    movsxd rax, dword [rbp - 60]  ; From stack [rbp - 60]
    push rax
    mov rax, 2
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 464], rax
    mov rax, [rbp - 464]
    push rax
    ; Load variable: end
    movsxd rax, dword [rbp - 64]  ; From stack [rbp - 64]
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 472], rax
    mov rax, [rbp - 472]
    test rax, rax
    jz ir_sc_false_955
ir_sc_true_954:
    mov rax, 1
    mov [rbp - 480], rax
    jmp ir_sc_end_956
ir_sc_false_955:
    mov rax, 0
    mov [rbp - 480], rax
ir_sc_end_956:
    mov rax, [rbp - 480]
    test rax, rax
    jz ir_if_next_950
    ; Load variable: i
    movsxd rax, dword [rbp - 60]  ; From stack [rbp - 60]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 496], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_957
    jmp ir_nonnull_958
ir_trap_null_957:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct279]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_958:
    mov rax, [rbp - 496]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 504], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 504]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 512], rax
    mov rax, [rbp - 512]
    movzx rax, byte [rax]
    mov [rbp - 520], rax
    ; IR call: hex_char_val (1 args)
    sub rsp, 32
    mov rax, [rbp - 520]
    mov rcx, rax
    call hex_char_val
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 528], rax
    mov rax, [rbp - 528]
    ; Store to variable: hi
    mov dword [rbp - 80], eax  ; To stack [rbp - 80]
    ; Load variable: i
    movsxd rax, dword [rbp - 60]  ; From stack [rbp - 60]
    push rax
    mov rax, 2
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 536], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_959
    jmp ir_nonnull_960
ir_trap_null_959:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct281]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_960:
    mov rax, [rbp - 536]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 544], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 544]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 552], rax
    mov rax, [rbp - 552]
    movzx rax, byte [rax]
    mov [rbp - 560], rax
    ; IR call: hex_char_val (1 args)
    sub rsp, 32
    mov rax, [rbp - 560]
    mov rcx, rax
    call hex_char_val
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 568], rax
    mov rax, [rbp - 568]
    ; Store to variable: lo
    mov dword [rbp - 84], eax  ; To stack [rbp - 84]
    ; Load variable: hi
    movsxd rax, dword [rbp - 80]  ; From stack [rbp - 80]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 576], rax
    mov rax, [rbp - 576]
    test rax, rax
    jz ir_sc_false_965
ir_sc_rhs_963:
    ; Load variable: lo
    movsxd rax, dword [rbp - 84]  ; From stack [rbp - 84]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 584], rax
    mov rax, [rbp - 584]
    test rax, rax
    jz ir_sc_false_965
ir_sc_true_964:
    mov rax, 1
    mov [rbp - 592], rax
    jmp ir_sc_end_966
ir_sc_false_965:
    mov rax, 0
    mov [rbp - 592], rax
ir_sc_end_966:
    mov rax, [rbp - 592]
    test rax, rax
    jz ir_if_next_962
    ; Load variable: hi
    movsxd rax, dword [rbp - 80]  ; From stack [rbp - 80]
    push rax
    mov rax, 4
    mov r10, rax
    pop rax
    mov rcx, r10
    shl rax, cl
    mov [rbp - 608], rax
    mov rax, [rbp - 608]
    push rax
    ; Load variable: lo
    movsxd rax, dword [rbp - 84]  ; From stack [rbp - 84]
    mov r10, rax
    pop rax
    or rax, r10
    mov [rbp - 616], rax
    ; Load variable: out
    mov rax, qword [rbp - 48]  ; From stack [rbp - 48]
    test rax, rax
    jz ir_trap_null_967
    jmp ir_nonnull_968
ir_trap_null_967:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct283]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_968:
    ; Load variable: out_len
    movsxd rax, dword [rbp - 76]  ; From stack [rbp - 76]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 624], rax
    ; Load variable: out
    mov rax, qword [rbp - 48]  ; From stack [rbp - 48]
    push rax
    mov rax, [rbp - 624]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 632], rax
    mov rax, [rbp - 632]
    push rax
    mov rax, [rbp - 616]
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: out_len
    movsxd rax, dword [rbp - 76]  ; From stack [rbp - 76]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 648], rax
    mov rax, [rbp - 648]
    ; Store to variable: out_len
    mov dword [rbp - 76], eax  ; To stack [rbp - 76]
    ; Load variable: i
    movsxd rax, dword [rbp - 60]  ; From stack [rbp - 60]
    push rax
    mov rax, 3
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 656], rax
    mov rax, [rbp - 656]
    ; Store to variable: i
    mov dword [rbp - 60], eax  ; To stack [rbp - 60]
    jmp ir_if_end_961
ir_if_next_962:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_969
    jmp ir_nonnull_970
ir_trap_null_969:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct285]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_970:
    ; Load variable: i
    movsxd rax, dword [rbp - 60]  ; From stack [rbp - 60]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 664], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 664]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 672], rax
    mov rax, [rbp - 672]
    movzx rax, byte [rax]
    mov [rbp - 680], rax
    ; Load variable: out
    mov rax, qword [rbp - 48]  ; From stack [rbp - 48]
    test rax, rax
    jz ir_trap_null_971
    jmp ir_nonnull_972
ir_trap_null_971:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct287]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_972:
    ; Load variable: out_len
    movsxd rax, dword [rbp - 76]  ; From stack [rbp - 76]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 688], rax
    ; Load variable: out
    mov rax, qword [rbp - 48]  ; From stack [rbp - 48]
    push rax
    mov rax, [rbp - 688]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 696], rax
    mov rax, [rbp - 696]
    push rax
    mov rax, [rbp - 680]
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: out_len
    movsxd rax, dword [rbp - 76]  ; From stack [rbp - 76]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 712], rax
    mov rax, [rbp - 712]
    ; Store to variable: out_len
    mov dword [rbp - 76], eax  ; To stack [rbp - 76]
    ; Load variable: i
    movsxd rax, dword [rbp - 60]  ; From stack [rbp - 60]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 720], rax
    mov rax, [rbp - 720]
    ; Store to variable: i
    mov dword [rbp - 60], eax  ; To stack [rbp - 60]
ir_if_end_961:
    jmp ir_if_end_944
ir_if_next_950:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_973
    jmp ir_nonnull_974
ir_trap_null_973:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct289]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_974:
    ; Load variable: i
    movsxd rax, dword [rbp - 60]  ; From stack [rbp - 60]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 728], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 728]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 736], rax
    mov rax, [rbp - 736]
    movzx rax, byte [rax]
    mov [rbp - 744], rax
    ; Load variable: out
    mov rax, qword [rbp - 48]  ; From stack [rbp - 48]
    test rax, rax
    jz ir_trap_null_975
    jmp ir_nonnull_976
ir_trap_null_975:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct291]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_976:
    ; Load variable: out_len
    movsxd rax, dword [rbp - 76]  ; From stack [rbp - 76]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 752], rax
    ; Load variable: out
    mov rax, qword [rbp - 48]  ; From stack [rbp - 48]
    push rax
    mov rax, [rbp - 752]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 760], rax
    mov rax, [rbp - 760]
    push rax
    mov rax, [rbp - 744]
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: out_len
    movsxd rax, dword [rbp - 76]  ; From stack [rbp - 76]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 776], rax
    mov rax, [rbp - 776]
    ; Store to variable: out_len
    mov dword [rbp - 76], eax  ; To stack [rbp - 76]
    ; Load variable: i
    movsxd rax, dword [rbp - 60]  ; From stack [rbp - 60]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 784], rax
    mov rax, [rbp - 784]
    ; Store to variable: i
    mov dword [rbp - 60], eax  ; To stack [rbp - 60]
ir_if_end_944:
    jmp ir_while_934
ir_while_end_935:
    ; Load variable: out
    mov rax, qword [rbp - 48]  ; From stack [rbp - 48]
    test rax, rax
    jz ir_trap_null_977
    jmp ir_nonnull_978
ir_trap_null_977:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct293]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_978:
    ; Load variable: out_len
    movsxd rax, dword [rbp - 76]  ; From stack [rbp - 76]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 792], rax
    ; Load variable: out
    mov rax, qword [rbp - 48]  ; From stack [rbp - 48]
    push rax
    mov rax, [rbp - 792]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 800], rax
    mov rax, [rbp - 800]
    push rax
    mov rax, 0
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: out_len
    movsxd rax, dword [rbp - 76]  ; From stack [rbp - 76]
    mov [rbp - 816], rax
    mov rax, [rbp - 816]
    test rax, rax
    jz ir_errdefer_ok_979
    jmp ir_errdefer_end_980
ir_errdefer_ok_979:
ir_errdefer_end_980:
    ; Load variable: out_len
    movsxd rax, dword [rbp - 76]  ; From stack [rbp - 76]
    jmp Lextract_form_value_exit
    jmp ir_if_end_926
ir_if_next_927:
ir_if_end_926:
    ; Load variable: i
    movsxd rax, dword [rbp - 60]  ; From stack [rbp - 60]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 824], rax
    mov rax, [rbp - 824]
    ; Store to variable: i
    mov dword [rbp - 60], eax  ; To stack [rbp - 60]
    jmp ir_while_916
ir_while_end_917:
    mov rax, 0
    mov [rbp - 832], rax
    mov rax, [rbp - 832]
    test rax, rax
    jz ir_errdefer_ok_981
    jmp ir_errdefer_end_982
ir_errdefer_ok_981:
ir_errdefer_end_982:
    mov rax, 0
    jmp Lextract_form_value_exit
Lextract_form_value_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global dbg

dbg:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 208    ; Allocate 208 bytes on stack (aligned)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 'label'
    ; Parameter 'label' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'val'
    ; Parameter 'val' arrived in register rdx
ir_entry_983:
    ; Load variable: dbg_on
    movsxd rax, dword [rel dbg_on]  ; From global memory
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_next_985
    mov rax, 0
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_986
    jmp ir_errdefer_end_987
ir_errdefer_ok_986:
ir_errdefer_end_987:
    jmp Ldbg_exit
    jmp ir_if_end_984
ir_if_next_985:
ir_if_end_984:
    ; IR call: print (1 args)
    sub rsp, 32
    ; Load variable: label
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call print
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 40], rax
    ; IR call: print_int (1 args)
    sub rsp, 32
    ; Load variable: val
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov rcx, rax
    call print_int
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 48], rax
    ; IR call: putchar (1 args)
    sub rsp, 32
    mov rax, 10
    mov rcx, rax
    call putchar
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 56], rax
    ; IR call: get_stdout (0 args)
    sub rsp, 32
    call get_stdout
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 64], rax
    ; IR call: fflush (1 args)
    sub rsp, 32
    mov rax, [rbp - 64]
    mov rcx, rax
    call fflush
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 72], rax
    mov rax, 0
    mov [rbp - 80], rax
    mov rax, [rbp - 80]
    test rax, rax
    jz ir_errdefer_ok_988
    jmp ir_errdefer_end_989
ir_errdefer_ok_988:
ir_errdefer_end_989:
    jmp Ldbg_exit
Ldbg_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global dbg_msg

dbg_msg:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 160    ; Allocate 160 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'msg'
    ; Parameter 'msg' arrived in register rcx
ir_entry_990:
    ; Load variable: dbg_on
    movsxd rax, dword [rel dbg_on]  ; From global memory
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_if_next_992
    mov rax, 0
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_errdefer_ok_993
    jmp ir_errdefer_end_994
ir_errdefer_ok_993:
ir_errdefer_end_994:
    jmp Ldbg_msg_exit
    jmp ir_if_end_991
ir_if_next_992:
ir_if_end_991:
    ; IR call: println (1 args)
    sub rsp, 32
    ; Load variable: msg
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call println
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 32], rax
    ; IR call: get_stdout (0 args)
    sub rsp, 32
    call get_stdout
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 40], rax
    ; IR call: fflush (1 args)
    sub rsp, 32
    mov rax, [rbp - 40]
    mov rcx, rax
    call fflush
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 48], rax
    mov rax, 0
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    test rax, rax
    jz ir_errdefer_ok_995
    jmp ir_errdefer_end_996
ir_errdefer_ok_995:
ir_errdefer_end_996:
    jmp Ldbg_msg_exit
Ldbg_msg_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global int_to_dec

int_to_dec:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 848    ; Allocate 848 bytes on stack (aligned)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 'buf'
    ; Parameter 'buf' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'n'
    ; Parameter 'n' arrived in register rdx
ir_entry_997:
    mov rax, 0
    ; Store to variable: count
    mov dword [rbp - 100], eax  ; To stack [rbp - 100]
    ; Load variable: n
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 128], rax
    mov rax, [rbp - 128]
    test rax, rax
    jz ir_if_next_999
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_1000
    jmp ir_nonnull_1001
ir_trap_null_1000:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct295]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1001:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 136], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 136]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 144], rax
    mov rax, [rbp - 144]
    push rax
    mov rax, 48
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    mov rax, 1
    mov [rbp - 160], rax
    mov rax, [rbp - 160]
    test rax, rax
    jz ir_errdefer_ok_1002
    jmp ir_errdefer_end_1003
ir_errdefer_ok_1002:
ir_errdefer_end_1003:
    mov rax, 1
    jmp Lint_to_dec_exit
    jmp ir_if_end_998
ir_if_next_999:
ir_if_end_998:
ir_while_1004:
    ; Load variable: n
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setg al
    movzx rax, al
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    test rax, rax
    jz ir_while_end_1005
    ; Load variable: n
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 10
    mov r10, rax
    pop rax
    cqo
    idiv r10
    mov [rbp - 176], rax
    mov rax, [rbp - 176]
    push rax
    mov rax, 10
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 184], rax
    ; Load variable: n
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, [rbp - 184]
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 192], rax
    mov rax, [rbp - 192]
    ; Store to variable: d
    mov qword [rbp - 112], rax  ; To stack [rbp - 112]
    ; Load variable: count
    movsxd rax, dword [rbp - 100]  ; From stack [rbp - 100]
    push rax
    mov rax, 20
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 200], rax
    mov rax, [rbp - 200]
    test rax, rax
    jz ir_trap_bounds_1006
    jmp ir_in_bounds_1007
ir_trap_bounds_1006:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct297]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1007:
    ; Load variable: count
    movsxd rax, dword [rbp - 100]  ; From stack [rbp - 100]
    push rax
    mov rax, 4
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 208], rax
    ; Load variable: digits
    lea rax, [rbp - 96]  ; Local array base
    push rax
    mov rax, [rbp - 208]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 216], rax
    mov rax, [rbp - 216]
    push rax
    ; Load variable: d
    mov rax, qword [rbp - 112]  ; From stack [rbp - 112]
    mov rcx, rax
    pop rax
    mov dword [rax], ecx
    ; Load variable: count
    movsxd rax, dword [rbp - 100]  ; From stack [rbp - 100]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 232], rax
    mov rax, [rbp - 232]
    ; Store to variable: count
    mov dword [rbp - 100], eax  ; To stack [rbp - 100]
    ; Load variable: n
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 10
    mov r10, rax
    pop rax
    cqo
    idiv r10
    mov [rbp - 240], rax
    mov rax, [rbp - 240]
    ; Store to variable: n
    mov qword [rbp - 16], rax  ; To stack [rbp - 16]
    jmp ir_while_1004
ir_while_end_1005:
    ; Load variable: count
    movsxd rax, dword [rbp - 100]  ; From stack [rbp - 100]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 248], rax
    mov rax, [rbp - 248]
    ; Store to variable: i
    mov dword [rbp - 116], eax  ; To stack [rbp - 116]
ir_while_1008:
    ; Load variable: i
    movsxd rax, dword [rbp - 116]  ; From stack [rbp - 116]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 256], rax
    mov rax, [rbp - 256]
    test rax, rax
    jz ir_while_end_1009
    ; Load variable: i
    movsxd rax, dword [rbp - 116]  ; From stack [rbp - 116]
    push rax
    mov rax, 20
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 264], rax
    mov rax, [rbp - 264]
    test rax, rax
    jz ir_trap_bounds_1010
    jmp ir_in_bounds_1011
ir_trap_bounds_1010:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct299]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1011:
    ; Load variable: i
    movsxd rax, dword [rbp - 116]  ; From stack [rbp - 116]
    push rax
    mov rax, 4
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 272], rax
    ; Load variable: digits
    lea rax, [rbp - 96]  ; Local array base
    push rax
    mov rax, [rbp - 272]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 280], rax
    mov rax, [rbp - 280]
    mov eax, dword [rax]
    mov [rbp - 288], rax
    ; IR call: digit_to_char (1 args)
    sub rsp, 32
    mov rax, [rbp - 288]
    mov rcx, rax
    call digit_to_char
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 296], rax
    ; Load variable: count
    movsxd rax, dword [rbp - 100]  ; From stack [rbp - 100]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 304], rax
    mov rax, [rbp - 304]
    push rax
    ; Load variable: i
    movsxd rax, dword [rbp - 116]  ; From stack [rbp - 116]
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 312], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_1012
    jmp ir_nonnull_1013
ir_trap_null_1012:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct301]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1013:
    mov rax, [rbp - 312]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 320], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 320]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 328], rax
    mov rax, [rbp - 328]
    push rax
    mov rax, [rbp - 296]
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: i
    movsxd rax, dword [rbp - 116]  ; From stack [rbp - 116]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 344], rax
    mov rax, [rbp - 344]
    ; Store to variable: i
    mov dword [rbp - 116], eax  ; To stack [rbp - 116]
    jmp ir_while_1008
ir_while_end_1009:
    ; Load variable: count
    movsxd rax, dword [rbp - 100]  ; From stack [rbp - 100]
    mov [rbp - 352], rax
    mov rax, [rbp - 352]
    test rax, rax
    jz ir_errdefer_ok_1014
    jmp ir_errdefer_end_1015
ir_errdefer_ok_1014:
ir_errdefer_end_1015:
    ; Load variable: count
    movsxd rax, dword [rbp - 100]  ; From stack [rbp - 100]
    jmp Lint_to_dec_exit
Lint_to_dec_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global con_writeln

con_writeln:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 560    ; Allocate 560 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 's'
    ; Parameter 's' arrived in register rcx
ir_entry_1016:
    mov rax, 11
    neg rax
    mov [rbp - 32], rax
    ; IR call: GetStdHandle (1 args)
    sub rsp, 32
    mov rax, [rbp - 32]
    mov rcx, rax
    call GetStdHandle
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    ; Store to variable: h
    mov qword [rbp - 16], rax  ; To stack [rbp - 16]
    mov rax, 1
    neg rax
    mov [rbp - 48], rax
    ; Load variable: h
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, [rbp - 48]
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    test rax, rax
    jz ir_sc_false_1021
ir_sc_rhs_1019:
    ; Load variable: h
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    test rax, rax
    jz ir_sc_false_1021
ir_sc_true_1020:
    mov rax, 1
    mov [rbp - 72], rax
    jmp ir_sc_end_1022
ir_sc_false_1021:
    mov rax, 0
    mov [rbp - 72], rax
ir_sc_end_1022:
    mov rax, [rbp - 72]
    test rax, rax
    jz ir_if_next_1018
    ; Load variable: s
    mov rax, qword [rbp - 8]  ; String param ptr
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    mov rax, qword [rax]
    mov [rbp - 96], rax
    ; Load variable: s
    mov rax, qword [rbp - 8]  ; String param ptr
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 104], rax
    mov rax, [rbp - 104]
    mov rax, qword [rax]
    mov [rbp - 112], rax
    mov rax, 0
    push rax
    mov rax, 4
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 120], rax
    mov rax, [rbp - 120]
    test rax, rax
    jz ir_trap_bounds_1023
    jmp ir_in_bounds_1024
ir_trap_bounds_1023:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct303]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1024:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 128], rax
    ; Load variable: written
    lea rax, [rbp - 20]  ; Local array base
    push rax
    mov rax, [rbp - 128]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 136], rax
    ; IR call: WriteFile (5 args)
    sub rsp, 48
    mov rax, 0
    mov [rsp + 32], rax
    ; Load variable: h
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov rcx, rax
    mov rax, [rbp - 96]
    mov rdx, rax
    mov rax, [rbp - 112]
    mov r8, rax
    mov rax, [rbp - 136]
    mov r9, rax
    call WriteFile
    add rsp, 48
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 144], rax
    ; Load variable: crlf
    lea rax, [rel crlf]  ; Address of global string
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 152], rax
    mov rax, [rbp - 152]
    mov rax, qword [rax]
    mov [rbp - 160], rax
    mov rax, 0
    push rax
    mov rax, 4
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    test rax, rax
    jz ir_trap_bounds_1025
    jmp ir_in_bounds_1026
ir_trap_bounds_1025:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct305]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1026:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 176], rax
    ; Load variable: written
    lea rax, [rbp - 20]  ; Local array base
    push rax
    mov rax, [rbp - 176]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 184], rax
    ; IR call: WriteFile (5 args)
    sub rsp, 48
    mov rax, 0
    mov [rsp + 32], rax
    ; Load variable: h
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov rcx, rax
    mov rax, [rbp - 160]
    mov rdx, rax
    mov rax, 2
    mov r8, rax
    mov rax, [rbp - 184]
    mov r9, rax
    call WriteFile
    add rsp, 48
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 192], rax
    jmp ir_if_end_1017
ir_if_next_1018:
ir_if_end_1017:
    mov rax, 0
    mov [rbp - 200], rax
    mov rax, [rbp - 200]
    test rax, rax
    jz ir_errdefer_ok_1027
    jmp ir_errdefer_end_1028
ir_errdefer_ok_1027:
ir_errdefer_end_1028:
    jmp Lcon_writeln_exit
Lcon_writeln_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global parse_content_length

parse_content_length:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 1552    ; Allocate 1552 bytes on stack (aligned)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 'buf'
    ; Parameter 'buf' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'n'
    ; Parameter 'n' arrived in register rdx
ir_entry_1029:
    mov rax, 0
    ; Store to variable: i
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
ir_while_1030:
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 15
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    push rax
    ; Load variable: n
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    mov r10, rax
    pop rax
    cmp rax, r10
    setle al
    movzx rax, al
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    test rax, rax
    jz ir_while_end_1031
    mov rax, 1
    ; Store to variable: match
    mov dword [rbp - 24], eax  ; To stack [rbp - 24]
    mov rax, 0
    ; Store to variable: k
    mov dword [rbp - 28], eax  ; To stack [rbp - 28]
ir_while_1032:
    ; Load variable: k
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 15
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    test rax, rax
    jz ir_while_end_1033
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    ; Load variable: k
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 80], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_1034
    jmp ir_nonnull_1035
ir_trap_null_1034:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct307]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1035:
    mov rax, [rbp - 80]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 88], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 88]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    movzx rax, byte [rax]
    mov [rbp - 104], rax
    mov rax, [rbp - 104]
    ; Store to variable: b
    mov dword [rbp - 32], eax  ; To stack [rbp - 32]
    ; Load variable: hdr_content_length
    lea rax, [rel hdr_content_length]  ; Address of global string
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    mov rax, qword [rax]
    mov [rbp - 120], rax
    mov rax, [rbp - 120]
    test rax, rax
    jz ir_trap_null_1036
    jmp ir_nonnull_1037
ir_trap_null_1036:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct309]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1037:
    ; Load variable: k
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 128], rax
    mov rax, [rbp - 120]
    push rax
    mov rax, [rbp - 128]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 136], rax
    mov rax, [rbp - 136]
    movzx rax, byte [rax]
    mov [rbp - 144], rax
    mov rax, [rbp - 144]
    ; Store to variable: h
    mov dword [rbp - 36], eax  ; To stack [rbp - 36]
    ; Load variable: hdr_content_length_lo
    lea rax, [rel hdr_content_length_lo]  ; Address of global string
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 152], rax
    mov rax, [rbp - 152]
    mov rax, qword [rax]
    mov [rbp - 160], rax
    mov rax, [rbp - 160]
    test rax, rax
    jz ir_trap_null_1038
    jmp ir_nonnull_1039
ir_trap_null_1038:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct311]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1039:
    ; Load variable: k
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 168], rax
    mov rax, [rbp - 160]
    push rax
    mov rax, [rbp - 168]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 176], rax
    mov rax, [rbp - 176]
    movzx rax, byte [rax]
    mov [rbp - 184], rax
    mov rax, [rbp - 184]
    ; Store to variable: lo
    mov dword [rbp - 40], eax  ; To stack [rbp - 40]
    ; Load variable: b
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    ; Load variable: h
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 192], rax
    mov rax, [rbp - 192]
    test rax, rax
    jz ir_sc_false_1044
ir_sc_rhs_1042:
    ; Load variable: b
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    ; Load variable: lo
    movsxd rax, dword [rbp - 40]  ; From stack [rbp - 40]
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 200], rax
    mov rax, [rbp - 200]
    test rax, rax
    jz ir_sc_false_1044
ir_sc_true_1043:
    mov rax, 1
    mov [rbp - 208], rax
    jmp ir_sc_end_1045
ir_sc_false_1044:
    mov rax, 0
    mov [rbp - 208], rax
ir_sc_end_1045:
    mov rax, [rbp - 208]
    test rax, rax
    jz ir_if_next_1041
    mov rax, 0
    ; Store to variable: match
    mov dword [rbp - 24], eax  ; To stack [rbp - 24]
    jmp ir_while_end_1033
    jmp ir_if_end_1040
ir_if_next_1041:
ir_if_end_1040:
    ; Load variable: k
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 224], rax
    mov rax, [rbp - 224]
    ; Store to variable: k
    mov dword [rbp - 28], eax  ; To stack [rbp - 28]
    jmp ir_while_1032
ir_while_end_1033:
    ; Load variable: match
    movsxd rax, dword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 232], rax
    mov rax, [rbp - 232]
    test rax, rax
    jz ir_if_next_1047
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 15
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 240], rax
    mov rax, [rbp - 240]
    ; Store to variable: i
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
ir_while_1048:
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    ; Load variable: n
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 248], rax
    mov rax, [rbp - 248]
    test rax, rax
    jz ir_sc_false_1052
ir_sc_rhs_1050:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_1054
    jmp ir_nonnull_1055
ir_trap_null_1054:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct313]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1055:
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 256], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 256]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 264], rax
    mov rax, [rbp - 264]
    movzx rax, byte [rax]
    mov [rbp - 272], rax
    mov rax, [rbp - 272]
    push rax
    mov rax, 32
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 280], rax
    mov rax, [rbp - 280]
    test rax, rax
    jz ir_sc_rhs_1056
    jmp ir_sc_true_1057
ir_sc_rhs_1056:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_1060
    jmp ir_nonnull_1061
ir_trap_null_1060:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct315]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1061:
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 288], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 288]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 296], rax
    mov rax, [rbp - 296]
    movzx rax, byte [rax]
    mov [rbp - 304], rax
    mov rax, [rbp - 304]
    push rax
    mov rax, 9
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 312], rax
    mov rax, [rbp - 312]
    test rax, rax
    jz ir_sc_false_1058
ir_sc_true_1057:
    mov rax, 1
    mov [rbp - 320], rax
    jmp ir_sc_end_1059
ir_sc_false_1058:
    mov rax, 0
    mov [rbp - 320], rax
ir_sc_end_1059:
    mov rax, [rbp - 320]
    test rax, rax
    jz ir_sc_false_1052
ir_sc_true_1051:
    mov rax, 1
    mov [rbp - 336], rax
    jmp ir_sc_end_1053
ir_sc_false_1052:
    mov rax, 0
    mov [rbp - 336], rax
ir_sc_end_1053:
    mov rax, [rbp - 336]
    test rax, rax
    jz ir_while_end_1049
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 352], rax
    mov rax, [rbp - 352]
    ; Store to variable: i
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
    jmp ir_while_1048
ir_while_end_1049:
    mov rax, 0
    ; Store to variable: val
    mov dword [rbp - 44], eax  ; To stack [rbp - 44]
ir_while_1062:
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    ; Load variable: n
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 360], rax
    mov rax, [rbp - 360]
    test rax, rax
    jz ir_sc_false_1066
ir_sc_rhs_1064:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_1068
    jmp ir_nonnull_1069
ir_trap_null_1068:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct317]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1069:
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 368], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 368]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 376], rax
    mov rax, [rbp - 376]
    movzx rax, byte [rax]
    mov [rbp - 384], rax
    mov rax, [rbp - 384]
    push rax
    mov rax, 48
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 392], rax
    mov rax, [rbp - 392]
    test rax, rax
    jz ir_sc_false_1066
ir_sc_true_1065:
    mov rax, 1
    mov [rbp - 400], rax
    jmp ir_sc_end_1067
ir_sc_false_1066:
    mov rax, 0
    mov [rbp - 400], rax
ir_sc_end_1067:
    mov rax, [rbp - 400]
    test rax, rax
    jz ir_sc_false_1072
ir_sc_rhs_1070:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_1074
    jmp ir_nonnull_1075
ir_trap_null_1074:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct319]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1075:
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 416], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 416]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 424], rax
    mov rax, [rbp - 424]
    movzx rax, byte [rax]
    mov [rbp - 432], rax
    mov rax, [rbp - 432]
    push rax
    mov rax, 57
    mov r10, rax
    pop rax
    cmp rax, r10
    setle al
    movzx rax, al
    mov [rbp - 440], rax
    mov rax, [rbp - 440]
    test rax, rax
    jz ir_sc_false_1072
ir_sc_true_1071:
    mov rax, 1
    mov [rbp - 448], rax
    jmp ir_sc_end_1073
ir_sc_false_1072:
    mov rax, 0
    mov [rbp - 448], rax
ir_sc_end_1073:
    mov rax, [rbp - 448]
    test rax, rax
    jz ir_while_end_1063
    ; Load variable: val
    movsxd rax, dword [rbp - 44]  ; From stack [rbp - 44]
    push rax
    mov rax, 10
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 464], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_1076
    jmp ir_nonnull_1077
ir_trap_null_1076:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct321]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1077:
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 472], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 472]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 480], rax
    mov rax, [rbp - 480]
    movzx rax, byte [rax]
    mov [rbp - 488], rax
    mov rax, [rbp - 488]
    push rax
    mov rax, 48
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 496], rax
    mov rax, [rbp - 464]
    push rax
    mov rax, [rbp - 496]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 504], rax
    mov rax, [rbp - 504]
    ; Store to variable: val
    mov dword [rbp - 44], eax  ; To stack [rbp - 44]
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 512], rax
    mov rax, [rbp - 512]
    ; Store to variable: i
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
    jmp ir_while_1062
ir_while_end_1063:
    ; Load variable: val
    movsxd rax, dword [rbp - 44]  ; From stack [rbp - 44]
    mov [rbp - 520], rax
    mov rax, [rbp - 520]
    test rax, rax
    jz ir_errdefer_ok_1078
    jmp ir_errdefer_end_1079
ir_errdefer_ok_1078:
ir_errdefer_end_1079:
    ; Load variable: val
    movsxd rax, dword [rbp - 44]  ; From stack [rbp - 44]
    jmp Lparse_content_length_exit
    jmp ir_if_end_1046
ir_if_next_1047:
ir_if_end_1046:
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 528], rax
    mov rax, [rbp - 528]
    ; Store to variable: i
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
    jmp ir_while_1030
ir_while_end_1031:
    mov rax, 0
    mov [rbp - 536], rax
    mov rax, [rbp - 536]
    test rax, rax
    jz ir_errdefer_ok_1080
    jmp ir_errdefer_end_1081
ir_errdefer_ok_1080:
ir_errdefer_end_1081:
    mov rax, 0
    jmp Lparse_content_length_exit
Lparse_content_length_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global find_body_start

find_body_start:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 912    ; Allocate 912 bytes on stack (aligned)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 'buf'
    ; Parameter 'buf' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'n'
    ; Parameter 'n' arrived in register rdx
ir_entry_1082:
    ; Load variable: dbg_on
    movsxd rax, dword [rel dbg_on]  ; From global memory
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_if_next_1084
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: dbg_fbs_ok
    lea rax, [rel dbg_fbs_ok]  ; Address of global string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 40], rax
    ; IR call: dbg_msg (1 args)
    sub rsp, 32
    mov rax, [rbp - 40]
    mov rcx, rax
    call dbg_msg
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 48], rax
    jmp ir_if_end_1083
ir_if_next_1084:
ir_if_end_1083:
    ; Load variable: dbg_on
    movsxd rax, dword [rel dbg_on]  ; From global memory
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    test rax, rax
    jz ir_if_next_1086
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: dbg_fbs_enter
    lea rax, [rel dbg_fbs_enter]  ; Address of global string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 64], rax
    ; IR call: dbg (2 args)
    sub rsp, 32
    mov rax, [rbp - 64]
    mov rcx, rax
    ; Load variable: n
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    mov rdx, rax
    call dbg
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 72], rax
    jmp ir_if_end_1085
ir_if_next_1086:
ir_if_end_1085:
    mov rax, 0
    ; Store to variable: i
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
ir_while_1087:
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 4
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 80], rax
    mov rax, [rbp - 80]
    push rax
    ; Load variable: n
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    mov r10, rax
    pop rax
    cmp rax, r10
    setle al
    movzx rax, al
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    test rax, rax
    jz ir_while_end_1088
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_1091
    jmp ir_nonnull_1092
ir_trap_null_1091:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct323]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1092:
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 96], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 96]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 104], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: pat_crlf2
    lea rax, [rel pat_crlf2]  ; Address of global string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 112], rax
    ; IR call: memcmp (3 args)
    sub rsp, 32
    mov rax, [rbp - 104]
    mov rcx, rax
    mov rax, [rbp - 112]
    mov rdx, rax
    mov rax, 4
    mov r8, rax
    call memcmp
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 120], rax
    mov rax, [rbp - 120]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 128], rax
    mov rax, [rbp - 128]
    test rax, rax
    jz ir_if_next_1090
    ; Load variable: dbg_on
    movsxd rax, dword [rel dbg_on]  ; From global memory
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 136], rax
    mov rax, [rbp - 136]
    test rax, rax
    jz ir_if_next_1094
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: dbg_fbs_exit
    lea rax, [rel dbg_fbs_exit]  ; Address of global string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 144], rax
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 4
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 152], rax
    ; IR call: dbg (2 args)
    sub rsp, 32
    mov rax, [rbp - 144]
    mov rcx, rax
    mov rax, [rbp - 152]
    mov rdx, rax
    call dbg
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 160], rax
    jmp ir_if_end_1093
ir_if_next_1094:
ir_if_end_1093:
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 4
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    mov [rbp - 176], rax
    mov rax, [rbp - 176]
    test rax, rax
    jz ir_errdefer_ok_1095
    jmp ir_errdefer_end_1096
ir_errdefer_ok_1095:
ir_errdefer_end_1096:
    mov rax, [rbp - 168]
    jmp Lfind_body_start_exit
    jmp ir_if_end_1089
ir_if_next_1090:
ir_if_end_1089:
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 184], rax
    mov rax, [rbp - 184]
    ; Store to variable: i
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
    jmp ir_while_1087
ir_while_end_1088:
    mov rax, 0
    ; Store to variable: i
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
ir_while_1097:
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 2
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 192], rax
    mov rax, [rbp - 192]
    push rax
    ; Load variable: n
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    mov r10, rax
    pop rax
    cmp rax, r10
    setle al
    movzx rax, al
    mov [rbp - 200], rax
    mov rax, [rbp - 200]
    test rax, rax
    jz ir_while_end_1098
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_1101
    jmp ir_nonnull_1102
ir_trap_null_1101:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct325]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1102:
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 208], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 208]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 216], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: pat_lf2
    lea rax, [rel pat_lf2]  ; Address of global string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 224], rax
    ; IR call: memcmp (3 args)
    sub rsp, 32
    mov rax, [rbp - 216]
    mov rcx, rax
    mov rax, [rbp - 224]
    mov rdx, rax
    mov rax, 2
    mov r8, rax
    call memcmp
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 232], rax
    mov rax, [rbp - 232]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 240], rax
    mov rax, [rbp - 240]
    test rax, rax
    jz ir_if_next_1100
    ; Load variable: dbg_on
    movsxd rax, dword [rel dbg_on]  ; From global memory
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 248], rax
    mov rax, [rbp - 248]
    test rax, rax
    jz ir_if_next_1104
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: dbg_fbs_exit
    lea rax, [rel dbg_fbs_exit]  ; Address of global string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 256], rax
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 2
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 264], rax
    ; IR call: dbg (2 args)
    sub rsp, 32
    mov rax, [rbp - 256]
    mov rcx, rax
    mov rax, [rbp - 264]
    mov rdx, rax
    call dbg
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 272], rax
    jmp ir_if_end_1103
ir_if_next_1104:
ir_if_end_1103:
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 2
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 280], rax
    mov rax, [rbp - 280]
    mov [rbp - 288], rax
    mov rax, [rbp - 288]
    test rax, rax
    jz ir_errdefer_ok_1105
    jmp ir_errdefer_end_1106
ir_errdefer_ok_1105:
ir_errdefer_end_1106:
    mov rax, [rbp - 280]
    jmp Lfind_body_start_exit
    jmp ir_if_end_1099
ir_if_next_1100:
ir_if_end_1099:
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 296], rax
    mov rax, [rbp - 296]
    ; Store to variable: i
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
    jmp ir_while_1097
ir_while_end_1098:
    ; Load variable: dbg_on
    movsxd rax, dword [rel dbg_on]  ; From global memory
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 304], rax
    mov rax, [rbp - 304]
    test rax, rax
    jz ir_if_next_1108
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: dbg_fbs_exit
    lea rax, [rel dbg_fbs_exit]  ; Address of global string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 312], rax
    ; IR call: dbg (2 args)
    sub rsp, 32
    mov rax, [rbp - 312]
    mov rcx, rax
    ; Load variable: n
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    mov rdx, rax
    call dbg
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 320], rax
    jmp ir_if_end_1107
ir_if_next_1108:
ir_if_end_1107:
    ; Load variable: n
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    mov [rbp - 328], rax
    mov rax, [rbp - 328]
    test rax, rax
    jz ir_errdefer_ok_1109
    jmp ir_errdefer_end_1110
ir_errdefer_ok_1109:
ir_errdefer_end_1110:
    ; Load variable: n
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    jmp Lfind_body_start_exit
Lfind_body_start_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global send_html_escaped

send_html_escaped:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 960    ; Allocate 960 bytes on stack (aligned)
    ; Registering 3 function parameters
    mov [rbp - 8], rcx  ; Home param 'client'
    ; Parameter 'client' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'src'
    ; Parameter 'src' arrived in register rdx
    mov [rbp - 24], r8  ; Home param 'len'
    ; Parameter 'len' arrived in register r8
ir_entry_1111:
    mov rax, 0
    ; Store to variable: i
    mov dword [rbp - 28], eax  ; To stack [rbp - 28]
ir_while_1112:
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    ; Load variable: len
    movsxd rax, dword [rbp - 24]  ; From stack [rbp - 24]
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_while_end_1113
    ; Load variable: src
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    test rax, rax
    jz ir_trap_null_1114
    jmp ir_nonnull_1115
ir_trap_null_1114:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct327]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1115:
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 48], rax
    ; Load variable: src
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, [rbp - 48]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    movzx rax, byte [rax]
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    ; Store to variable: ch
    mov dword [rbp - 32], eax  ; To stack [rbp - 32]
    ; Load variable: ch
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, 38
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    test rax, rax
    jz ir_if_next_1117
    ; Load variable: html_amp
    lea rax, [rel html_amp]  ; Address of global string
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 80], rax
    mov rax, [rbp - 80]
    mov rax, qword [rax]
    mov [rbp - 88], rax
    ; Load variable: html_amp
    lea rax, [rel html_amp]  ; Address of global string
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    mov rax, qword [rax]
    mov [rbp - 104], rax
    ; IR call: send_all (3 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    mov rax, [rbp - 88]
    mov rdx, rax
    mov rax, [rbp - 104]
    mov r8, rax
    call send_all
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 112], rax
    jmp ir_if_end_1116
ir_if_next_1117:
    ; Load variable: ch
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, 60
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 120], rax
    mov rax, [rbp - 120]
    test rax, rax
    jz ir_if_next_1118
    ; Load variable: html_lt
    lea rax, [rel html_lt]  ; Address of global string
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 128], rax
    mov rax, [rbp - 128]
    mov rax, qword [rax]
    mov [rbp - 136], rax
    ; Load variable: html_lt
    lea rax, [rel html_lt]  ; Address of global string
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 144], rax
    mov rax, [rbp - 144]
    mov rax, qword [rax]
    mov [rbp - 152], rax
    ; IR call: send_all (3 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    mov rax, [rbp - 136]
    mov rdx, rax
    mov rax, [rbp - 152]
    mov r8, rax
    call send_all
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 160], rax
    jmp ir_if_end_1116
ir_if_next_1118:
    ; Load variable: ch
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, 62
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    test rax, rax
    jz ir_if_next_1119
    ; Load variable: html_gt
    lea rax, [rel html_gt]  ; Address of global string
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 176], rax
    mov rax, [rbp - 176]
    mov rax, qword [rax]
    mov [rbp - 184], rax
    ; Load variable: html_gt
    lea rax, [rel html_gt]  ; Address of global string
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 192], rax
    mov rax, [rbp - 192]
    mov rax, qword [rax]
    mov [rbp - 200], rax
    ; IR call: send_all (3 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    mov rax, [rbp - 184]
    mov rdx, rax
    mov rax, [rbp - 200]
    mov r8, rax
    call send_all
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 208], rax
    jmp ir_if_end_1116
ir_if_next_1119:
    ; Load variable: ch
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, 34
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 216], rax
    mov rax, [rbp - 216]
    test rax, rax
    jz ir_if_next_1120
    ; Load variable: html_quot
    lea rax, [rel html_quot]  ; Address of global string
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 224], rax
    mov rax, [rbp - 224]
    mov rax, qword [rax]
    mov [rbp - 232], rax
    ; Load variable: html_quot
    lea rax, [rel html_quot]  ; Address of global string
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 240], rax
    mov rax, [rbp - 240]
    mov rax, qword [rax]
    mov [rbp - 248], rax
    ; IR call: send_all (3 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    mov rax, [rbp - 232]
    mov rdx, rax
    mov rax, [rbp - 248]
    mov r8, rax
    call send_all
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 256], rax
    jmp ir_if_end_1116
ir_if_next_1120:
    ; Load variable: ch
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, 39
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 264], rax
    mov rax, [rbp - 264]
    test rax, rax
    jz ir_if_next_1121
    ; Load variable: html_apos
    lea rax, [rel html_apos]  ; Address of global string
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 272], rax
    mov rax, [rbp - 272]
    mov rax, qword [rax]
    mov [rbp - 280], rax
    ; Load variable: html_apos
    lea rax, [rel html_apos]  ; Address of global string
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 288], rax
    mov rax, [rbp - 288]
    mov rax, qword [rax]
    mov [rbp - 296], rax
    ; IR call: send_all (3 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    mov rax, [rbp - 280]
    mov rdx, rax
    mov rax, [rbp - 296]
    mov r8, rax
    call send_all
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 304], rax
    jmp ir_if_end_1116
ir_if_next_1121:
    ; Load variable: src
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    test rax, rax
    jz ir_trap_null_1122
    jmp ir_nonnull_1123
ir_trap_null_1122:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct329]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1123:
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 312], rax
    ; Load variable: src
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, [rbp - 312]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 320], rax
    ; IR call: send_all (3 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    mov rax, [rbp - 320]
    mov rdx, rax
    mov rax, 1
    mov r8, rax
    call send_all
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 328], rax
ir_if_end_1116:
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 336], rax
    mov rax, [rbp - 336]
    ; Store to variable: i
    mov dword [rbp - 28], eax  ; To stack [rbp - 28]
    jmp ir_while_1112
ir_while_end_1113:
    mov rax, 0
    mov [rbp - 344], rax
    mov rax, [rbp - 344]
    test rax, rax
    jz ir_errdefer_ok_1124
    jmp ir_errdefer_end_1125
ir_errdefer_ok_1124:
ir_errdefer_end_1125:
    jmp Lsend_html_escaped_exit
Lsend_html_escaped_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global build_posts_filename

build_posts_filename:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 736    ; Allocate 736 bytes on stack (aligned)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 'buf'
    ; Parameter 'buf' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'id'
    ; Parameter 'id' arrived in register rdx
ir_entry_1126:
    ; Load variable: fn_posts_prefix
    lea rax, [rel fn_posts_prefix]  ; Address of global string
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    mov rax, qword [rax]
    mov [rbp - 40], rax
    ; Load variable: fn_posts_prefix
    lea rax, [rel fn_posts_prefix]  ; Address of global string
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    mov rax, qword [rax]
    mov [rbp - 56], rax
    ; IR call: memcpy (3 args)
    sub rsp, 32
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    mov rax, [rbp - 40]
    mov rdx, rax
    mov rax, [rbp - 56]
    mov r8, rax
    call memcpy
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 64], rax
    ; Load variable: fn_posts_prefix
    lea rax, [rel fn_posts_prefix]  ; Address of global string
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    mov rax, qword [rax]
    mov [rbp - 80], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_1127
    jmp ir_nonnull_1128
ir_trap_null_1127:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct331]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1128:
    mov rax, [rbp - 80]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 88], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 88]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 96], rax
    ; IR call: int_to_dec (2 args)
    sub rsp, 32
    mov rax, [rbp - 96]
    mov rcx, rax
    ; Load variable: id
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    mov rdx, rax
    call int_to_dec
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 104], rax
    mov rax, [rbp - 104]
    ; Store to variable: dc
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
    ; Load variable: fn_posts_prefix
    lea rax, [rel fn_posts_prefix]  ; Address of global string
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    mov rax, qword [rax]
    mov [rbp - 120], rax
    mov rax, [rbp - 120]
    push rax
    ; Load variable: dc
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 128], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_1129
    jmp ir_nonnull_1130
ir_trap_null_1129:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct333]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1130:
    mov rax, [rbp - 128]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 136], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 136]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 144], rax
    ; Load variable: fn_posts_suffix
    lea rax, [rel fn_posts_suffix]  ; Address of global string
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 152], rax
    mov rax, [rbp - 152]
    mov rax, qword [rax]
    mov [rbp - 160], rax
    ; Load variable: fn_posts_suffix
    lea rax, [rel fn_posts_suffix]  ; Address of global string
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    mov rax, qword [rax]
    mov [rbp - 176], rax
    ; IR call: memcpy (3 args)
    sub rsp, 32
    mov rax, [rbp - 144]
    mov rcx, rax
    mov rax, [rbp - 160]
    mov rdx, rax
    mov rax, [rbp - 176]
    mov r8, rax
    call memcpy
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 184], rax
    ; Load variable: fn_posts_prefix
    lea rax, [rel fn_posts_prefix]  ; Address of global string
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 192], rax
    mov rax, [rbp - 192]
    mov rax, qword [rax]
    mov [rbp - 200], rax
    mov rax, [rbp - 200]
    push rax
    ; Load variable: dc
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 208], rax
    ; Load variable: fn_posts_suffix
    lea rax, [rel fn_posts_suffix]  ; Address of global string
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 216], rax
    mov rax, [rbp - 216]
    mov rax, qword [rax]
    mov [rbp - 224], rax
    mov rax, [rbp - 208]
    push rax
    mov rax, [rbp - 224]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 232], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_1131
    jmp ir_nonnull_1132
ir_trap_null_1131:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct335]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1132:
    mov rax, [rbp - 232]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 240], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 240]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 248], rax
    mov rax, [rbp - 248]
    push rax
    mov rax, 0
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    mov rax, 0
    mov [rbp - 264], rax
    mov rax, [rbp - 264]
    test rax, rax
    jz ir_errdefer_ok_1133
    jmp ir_errdefer_end_1134
ir_errdefer_ok_1133:
ir_errdefer_end_1134:
    jmp Lbuild_posts_filename_exit
Lbuild_posts_filename_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global build_forum_thread_url

build_forum_thread_url:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 1200    ; Allocate 1200 bytes on stack (aligned)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 'buf'
    ; Parameter 'buf' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'thread_id'
    ; Parameter 'thread_id' arrived in register rdx
ir_entry_1135:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_1136
    jmp ir_nonnull_1137
ir_trap_null_1136:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct337]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1137:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 32], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 32]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    push rax
    mov rax, 47
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_1138
    jmp ir_nonnull_1139
ir_trap_null_1138:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct339]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1139:
    mov rax, 1
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 56], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 56]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    push rax
    mov rax, 102
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_1140
    jmp ir_nonnull_1141
ir_trap_null_1140:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct341]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1141:
    mov rax, 2
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 80], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 80]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    push rax
    mov rax, 111
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_1142
    jmp ir_nonnull_1143
ir_trap_null_1142:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct343]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1143:
    mov rax, 3
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 104], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 104]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    push rax
    mov rax, 114
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_1144
    jmp ir_nonnull_1145
ir_trap_null_1144:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct345]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1145:
    mov rax, 4
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 128], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 128]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 136], rax
    mov rax, [rbp - 136]
    push rax
    mov rax, 117
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_1146
    jmp ir_nonnull_1147
ir_trap_null_1146:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct347]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1147:
    mov rax, 5
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 152], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 152]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 160], rax
    mov rax, [rbp - 160]
    push rax
    mov rax, 109
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_1148
    jmp ir_nonnull_1149
ir_trap_null_1148:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct349]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1149:
    mov rax, 6
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 176], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 176]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 184], rax
    mov rax, [rbp - 184]
    push rax
    mov rax, 63
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_1150
    jmp ir_nonnull_1151
ir_trap_null_1150:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct351]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1151:
    mov rax, 7
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 200], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 200]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 208], rax
    mov rax, [rbp - 208]
    push rax
    mov rax, 116
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_1152
    jmp ir_nonnull_1153
ir_trap_null_1152:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct353]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1153:
    mov rax, 8
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 224], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 224]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 232], rax
    mov rax, [rbp - 232]
    push rax
    mov rax, 104
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_1154
    jmp ir_nonnull_1155
ir_trap_null_1154:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct355]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1155:
    mov rax, 9
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 248], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 248]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 256], rax
    mov rax, [rbp - 256]
    push rax
    mov rax, 114
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_1156
    jmp ir_nonnull_1157
ir_trap_null_1156:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct357]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1157:
    mov rax, 10
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 272], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 272]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 280], rax
    mov rax, [rbp - 280]
    push rax
    mov rax, 101
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_1158
    jmp ir_nonnull_1159
ir_trap_null_1158:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct359]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1159:
    mov rax, 11
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 296], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 296]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 304], rax
    mov rax, [rbp - 304]
    push rax
    mov rax, 97
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_1160
    jmp ir_nonnull_1161
ir_trap_null_1160:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct361]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1161:
    mov rax, 12
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 320], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 320]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 328], rax
    mov rax, [rbp - 328]
    push rax
    mov rax, 100
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_1162
    jmp ir_nonnull_1163
ir_trap_null_1162:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct363]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1163:
    mov rax, 13
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 344], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 344]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 352], rax
    mov rax, [rbp - 352]
    push rax
    mov rax, 61
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_1164
    jmp ir_nonnull_1165
ir_trap_null_1164:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct365]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1165:
    mov rax, 14
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 368], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 368]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 376], rax
    ; IR call: int_to_dec (2 args)
    sub rsp, 32
    mov rax, [rbp - 376]
    mov rcx, rax
    ; Load variable: thread_id
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    mov rdx, rax
    call int_to_dec
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 384], rax
    mov rax, [rbp - 384]
    ; Store to variable: dc
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
    mov rax, 14
    push rax
    ; Load variable: dc
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 392], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_1166
    jmp ir_nonnull_1167
ir_trap_null_1166:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct367]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1167:
    mov rax, [rbp - 392]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 400], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 400]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 408], rax
    mov rax, [rbp - 408]
    push rax
    mov rax, 0
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    mov rax, 0
    mov [rbp - 424], rax
    mov rax, [rbp - 424]
    test rax, rax
    jz ir_errdefer_ok_1168
    jmp ir_errdefer_end_1169
ir_errdefer_ok_1168:
ir_errdefer_end_1169:
    jmp Lbuild_forum_thread_url_exit
Lbuild_forum_thread_url_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global count_threads

count_threads:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 432    ; Allocate 432 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_1170:
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: fn_threads
    lea rax, [rel fn_threads]  ; Address of global string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 88], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: mode_r
    lea rax, [rel mode_r]  ; Address of global string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 96], rax
    ; IR call: fopen (2 args)
    sub rsp, 32
    mov rax, [rbp - 88]
    mov rcx, rax
    mov rax, [rbp - 96]
    mov rdx, rax
    call fopen
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 104], rax
    mov rax, [rbp - 104]
    ; Store to variable: fp
    mov qword [rbp - 8], rax  ; To stack [rbp - 8]
    ; Load variable: fp
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    test rax, rax
    jz ir_if_next_1172
    mov rax, 0
    mov [rbp - 120], rax
    mov rax, [rbp - 120]
    test rax, rax
    jz ir_errdefer_ok_1173
    jmp ir_errdefer_end_1174
ir_errdefer_ok_1173:
ir_errdefer_end_1174:
    mov rax, 0
    jmp Lcount_threads_exit
    jmp ir_if_end_1171
ir_if_next_1172:
ir_if_end_1171:
    mov rax, 0
    ; Store to variable: count
    mov dword [rbp - 12], eax  ; To stack [rbp - 12]
ir_while_1175:
    mov rax, 0
    push rax
    mov rax, 64
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 128], rax
    mov rax, [rbp - 128]
    test rax, rax
    jz ir_trap_bounds_1177
    jmp ir_in_bounds_1178
ir_trap_bounds_1177:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct369]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1178:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 136], rax
    ; Load variable: line_buf
    lea rax, [rbp - 80]  ; Local array base
    push rax
    mov rax, [rbp - 136]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 144], rax
    ; IR call: fgets (3 args)
    sub rsp, 32
    mov rax, [rbp - 144]
    mov rcx, rax
    mov rax, 64
    mov rdx, rax
    ; Load variable: fp
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov r8, rax
    call fgets
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 152], rax
    mov rax, [rbp - 152]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 160], rax
    mov rax, [rbp - 160]
    test rax, rax
    jz ir_while_end_1176
    ; Load variable: count
    movsxd rax, dword [rbp - 12]  ; From stack [rbp - 12]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    ; Store to variable: count
    mov dword [rbp - 12], eax  ; To stack [rbp - 12]
    jmp ir_while_1175
ir_while_end_1176:
    ; IR call: fclose (1 args)
    sub rsp, 32
    ; Load variable: fp
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call fclose
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 176], rax
    ; Load variable: count
    movsxd rax, dword [rbp - 12]  ; From stack [rbp - 12]
    mov [rbp - 184], rax
    mov rax, [rbp - 184]
    test rax, rax
    jz ir_errdefer_ok_1179
    jmp ir_errdefer_end_1180
ir_errdefer_ok_1179:
ir_errdefer_end_1180:
    ; Load variable: count
    movsxd rax, dword [rbp - 12]  ; From stack [rbp - 12]
    jmp Lcount_threads_exit
Lcount_threads_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global send_redirect

send_redirect:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 432    ; Allocate 432 bytes on stack (aligned)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 'client'
    ; Parameter 'client' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'location'
    ; Parameter 'location' arrived in register rdx
ir_entry_1181:
    ; Load variable: REDIRECT_302
    lea rax, [rel REDIRECT_302]  ; Address of global string
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    mov rax, qword [rax]
    mov [rbp - 40], rax
    ; Load variable: REDIRECT_302
    lea rax, [rel REDIRECT_302]  ; Address of global string
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    mov rax, qword [rax]
    mov [rbp - 56], rax
    ; IR call: send_all (3 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    mov rax, [rbp - 40]
    mov rdx, rax
    mov rax, [rbp - 56]
    mov r8, rax
    call send_all
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 64], rax
    mov rax, 0
    ; Store to variable: len
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
ir_while_1182:
    ; Load variable: location
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    test rax, rax
    jz ir_trap_null_1184
    jmp ir_nonnull_1185
ir_trap_null_1184:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct371]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1185:
    ; Load variable: len
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 72], rax
    ; Load variable: location
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, [rbp - 72]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 80], rax
    mov rax, [rbp - 80]
    movzx rax, byte [rax]
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    test rax, rax
    jz ir_while_end_1183
    ; Load variable: len
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 104], rax
    mov rax, [rbp - 104]
    ; Store to variable: len
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
    jmp ir_while_1182
ir_while_end_1183:
    ; IR call: send_all (3 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    ; Load variable: location
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov rdx, rax
    ; Load variable: len
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    mov r8, rax
    call send_all
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 112], rax
    ; Load variable: REDIRECT_END
    lea rax, [rel REDIRECT_END]  ; Address of global string
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 120], rax
    mov rax, [rbp - 120]
    mov rax, qword [rax]
    mov [rbp - 128], rax
    ; Load variable: REDIRECT_END
    lea rax, [rel REDIRECT_END]  ; Address of global string
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 136], rax
    mov rax, [rbp - 136]
    mov rax, qword [rax]
    mov [rbp - 144], rax
    ; IR call: send_all (3 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    mov rax, [rbp - 128]
    mov rdx, rax
    mov rax, [rbp - 144]
    mov r8, rax
    call send_all
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 152], rax
    mov rax, 0
    mov [rbp - 160], rax
    mov rax, [rbp - 160]
    test rax, rax
    jz ir_errdefer_ok_1186
    jmp ir_errdefer_end_1187
ir_errdefer_ok_1186:
ir_errdefer_end_1187:
    jmp Lsend_redirect_exit
Lsend_redirect_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global serve_forum_index

serve_forum_index:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 3616    ; Allocate 3616 bytes on stack (aligned)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 'client'
    ; Parameter 'client' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'show_err_empty'
    ; Parameter 'show_err_empty' arrived in register rdx
ir_entry_1188:
    ; Binary operation: +
    ; String concatenation (+)
    ; Binary operation: +
    ; String concatenation (+)
    ; Binary operation: +
    ; String concatenation (+)
    ; Load variable: FORUM_HEADER
    lea rax, [rel FORUM_HEADER]  ; Address of global string
    push rax           ; Save left string ptr
    ; Load variable: FORUM_INDEX_START
    lea rax, [rel FORUM_INDEX_START]  ; Address of global string
    mov r10, rax       ; right string ptr -> r10
    pop rax            ; left string ptr -> rax
    mov rcx, [rax + 8] ; len1
    add rcx, [r10 + 8] ; len1 + len2
    sub rsp, 24        ; Save concat state
    mov [rsp], r10     ; right ptr
    mov [rsp + 8], rax ; left ptr
    mov [rsp + 16], rcx ; total_len
    mov rcx, rcx
    add rcx, 17
    sub rsp, 40      ; 32-byte shadow + 8-byte align pad
    extern gc_alloc
    call gc_alloc
    add rsp, 40
    mov rcx, [rsp + 16] ; total_len
    mov rdx, [rsp + 8] ; left ptr
    mov rsi, [rsp]    ; right ptr
    add rsp, 24
    lea r8, [rax + 16]
    mov [rax], r8
    mov [rax + 8], rcx
    mov r9, [rdx + 8]  ; left len
    mov rdi, [rdx]     ; left chars
    test r9, r9
    jz Lconcat_left_done372
Lconcat_left_loop373:
    mov r11b, [rdi]
    mov [r8], r11b
    inc rdi
    inc r8
    dec r9
    jnz Lconcat_left_loop373
Lconcat_left_done372:
    mov r9, [rsi + 8]  ; right len
    mov rdi, [rsi]     ; right chars
    test r9, r9
    jz Lconcat_right_done374
Lconcat_right_loop375:
    mov r11b, [rdi]
    mov [r8], r11b
    inc rdi
    inc r8
    dec r9
    jnz Lconcat_right_loop375
Lconcat_right_done374:
    mov byte [r8], 0
    push rax           ; Save left string ptr
    ; Load variable: FORUM_CSS
    lea rax, [rel FORUM_CSS]  ; Address of global string
    mov r10, rax       ; right string ptr -> r10
    pop rax            ; left string ptr -> rax
    mov rcx, [rax + 8] ; len1
    add rcx, [r10 + 8] ; len1 + len2
    sub rsp, 24        ; Save concat state
    mov [rsp], r10     ; right ptr
    mov [rsp + 8], rax ; left ptr
    mov [rsp + 16], rcx ; total_len
    mov rcx, rcx
    add rcx, 17
    sub rsp, 40      ; 32-byte shadow + 8-byte align pad
    extern gc_alloc
    call gc_alloc
    add rsp, 40
    mov rcx, [rsp + 16] ; total_len
    mov rdx, [rsp + 8] ; left ptr
    mov rsi, [rsp]    ; right ptr
    add rsp, 24
    lea r8, [rax + 16]
    mov [rax], r8
    mov [rax + 8], rcx
    mov r9, [rdx + 8]  ; left len
    mov rdi, [rdx]     ; left chars
    test r9, r9
    jz Lconcat_left_done376
Lconcat_left_loop377:
    mov r11b, [rdi]
    mov [r8], r11b
    inc rdi
    inc r8
    dec r9
    jnz Lconcat_left_loop377
Lconcat_left_done376:
    mov r9, [rsi + 8]  ; right len
    mov rdi, [rsi]     ; right chars
    test r9, r9
    jz Lconcat_right_done378
Lconcat_right_loop379:
    mov r11b, [rdi]
    mov [r8], r11b
    inc rdi
    inc r8
    dec r9
    jnz Lconcat_right_loop379
Lconcat_right_done378:
    mov byte [r8], 0
    push rax           ; Save left string ptr
    ; Load variable: FORUM_INDEX_BODY
    lea rax, [rel FORUM_INDEX_BODY]  ; Address of global string
    mov r10, rax       ; right string ptr -> r10
    pop rax            ; left string ptr -> rax
    mov rcx, [rax + 8] ; len1
    add rcx, [r10 + 8] ; len1 + len2
    sub rsp, 24        ; Save concat state
    mov [rsp], r10     ; right ptr
    mov [rsp + 8], rax ; left ptr
    mov [rsp + 16], rcx ; total_len
    mov rcx, rcx
    add rcx, 17
    sub rsp, 40      ; 32-byte shadow + 8-byte align pad
    extern gc_alloc
    call gc_alloc
    add rsp, 40
    mov rcx, [rsp + 16] ; total_len
    mov rdx, [rsp + 8] ; left ptr
    mov rsi, [rsp]    ; right ptr
    add rsp, 24
    lea r8, [rax + 16]
    mov [rax], r8
    mov [rax + 8], rcx
    mov r9, [rdx + 8]  ; left len
    mov rdi, [rdx]     ; left chars
    test r9, r9
    jz Lconcat_left_done380
Lconcat_left_loop381:
    mov r11b, [rdi]
    mov [r8], r11b
    inc rdi
    inc r8
    dec r9
    jnz Lconcat_left_loop381
Lconcat_left_done380:
    mov r9, [rsi + 8]  ; right len
    mov rdi, [rsi]     ; right chars
    test r9, r9
    jz Lconcat_right_done382
Lconcat_right_loop383:
    mov r11b, [rdi]
    mov [r8], r11b
    inc rdi
    inc r8
    dec r9
    jnz Lconcat_right_loop383
Lconcat_right_done382:
    mov byte [r8], 0
    mov [rbp - 1184], rax
    mov rax, [rbp - 1184]
    ; Store to variable: out
    mov rcx, [rax]       ; string chars
    mov [rbp - 32], rcx
    mov rcx, [rax + 8]   ; string length
    mov [rbp - 24], rcx
    ; Load variable: out
    lea rax, [rbp - 32]  ; Address of local string
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1192], rax
    mov rax, [rbp - 1192]
    mov rax, qword [rax]
    mov [rbp - 1200], rax
    ; Load variable: out
    lea rax, [rbp - 32]  ; Address of local string
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1208], rax
    mov rax, [rbp - 1208]
    mov rax, qword [rax]
    mov [rbp - 1216], rax
    ; IR call: send_all (3 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    mov rax, [rbp - 1200]
    mov rdx, rax
    mov rax, [rbp - 1216]
    mov r8, rax
    call send_all
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1224], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: fn_threads
    lea rax, [rel fn_threads]  ; Address of global string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1232], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: mode_r
    lea rax, [rel mode_r]  ; Address of global string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1240], rax
    ; IR call: fopen (2 args)
    sub rsp, 32
    mov rax, [rbp - 1232]
    mov rcx, rax
    mov rax, [rbp - 1240]
    mov rdx, rax
    call fopen
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1248], rax
    mov rax, [rbp - 1248]
    ; Store to variable: fp
    mov qword [rbp - 40], rax  ; To stack [rbp - 40]
    ; Load variable: fp
    mov rax, qword [rbp - 40]  ; From stack [rbp - 40]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 1256], rax
    mov rax, [rbp - 1256]
    test rax, rax
    jz ir_if_next_1190
    mov rax, 1
    ; Store to variable: line_num
    mov dword [rbp - 556], eax  ; To stack [rbp - 556]
ir_while_1191:
    mov rax, 0
    push rax
    mov rax, 512
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1264], rax
    mov rax, [rbp - 1264]
    test rax, rax
    jz ir_trap_bounds_1193
    jmp ir_in_bounds_1194
ir_trap_bounds_1193:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct385]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1194:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1272], rax
    ; Load variable: line_buf
    lea rax, [rbp - 552]  ; Local array base
    push rax
    mov rax, [rbp - 1272]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1280], rax
    ; IR call: fgets (3 args)
    sub rsp, 32
    mov rax, [rbp - 1280]
    mov rcx, rax
    mov rax, 512
    mov rdx, rax
    ; Load variable: fp
    mov rax, qword [rbp - 40]  ; From stack [rbp - 40]
    mov r8, rax
    call fgets
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1288], rax
    mov rax, [rbp - 1288]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 1296], rax
    mov rax, [rbp - 1296]
    test rax, rax
    jz ir_while_end_1192
    mov rax, 0
    ; Store to variable: len
    mov dword [rbp - 560], eax  ; To stack [rbp - 560]
ir_while_1195:
    ; Load variable: len
    movsxd rax, dword [rbp - 560]  ; From stack [rbp - 560]
    push rax
    mov rax, 512
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1304], rax
    mov rax, [rbp - 1304]
    test rax, rax
    jz ir_trap_bounds_1197
    jmp ir_in_bounds_1198
ir_trap_bounds_1197:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct387]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1198:
    ; Load variable: len
    movsxd rax, dword [rbp - 560]  ; From stack [rbp - 560]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1312], rax
    ; Load variable: line_buf
    lea rax, [rbp - 552]  ; Local array base
    push rax
    mov rax, [rbp - 1312]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1320], rax
    mov rax, [rbp - 1320]
    movzx rax, byte [rax]
    mov [rbp - 1328], rax
    mov rax, [rbp - 1328]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 1336], rax
    mov rax, [rbp - 1336]
    test rax, rax
    jz ir_sc_false_1201
ir_sc_rhs_1199:
    ; Load variable: len
    movsxd rax, dword [rbp - 560]  ; From stack [rbp - 560]
    push rax
    mov rax, 512
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1344], rax
    mov rax, [rbp - 1344]
    test rax, rax
    jz ir_trap_bounds_1203
    jmp ir_in_bounds_1204
ir_trap_bounds_1203:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct389]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1204:
    ; Load variable: len
    movsxd rax, dword [rbp - 560]  ; From stack [rbp - 560]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1352], rax
    ; Load variable: line_buf
    lea rax, [rbp - 552]  ; Local array base
    push rax
    mov rax, [rbp - 1352]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1360], rax
    mov rax, [rbp - 1360]
    movzx rax, byte [rax]
    mov [rbp - 1368], rax
    mov rax, [rbp - 1368]
    push rax
    mov rax, 10
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 1376], rax
    mov rax, [rbp - 1376]
    test rax, rax
    jz ir_sc_false_1201
ir_sc_true_1200:
    mov rax, 1
    mov [rbp - 1384], rax
    jmp ir_sc_end_1202
ir_sc_false_1201:
    mov rax, 0
    mov [rbp - 1384], rax
ir_sc_end_1202:
    mov rax, [rbp - 1384]
    test rax, rax
    jz ir_sc_false_1207
ir_sc_rhs_1205:
    ; Load variable: len
    movsxd rax, dword [rbp - 560]  ; From stack [rbp - 560]
    push rax
    mov rax, 512
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1400], rax
    mov rax, [rbp - 1400]
    test rax, rax
    jz ir_trap_bounds_1209
    jmp ir_in_bounds_1210
ir_trap_bounds_1209:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct391]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1210:
    ; Load variable: len
    movsxd rax, dword [rbp - 560]  ; From stack [rbp - 560]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1408], rax
    ; Load variable: line_buf
    lea rax, [rbp - 552]  ; Local array base
    push rax
    mov rax, [rbp - 1408]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1416], rax
    mov rax, [rbp - 1416]
    movzx rax, byte [rax]
    mov [rbp - 1424], rax
    mov rax, [rbp - 1424]
    push rax
    mov rax, 13
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 1432], rax
    mov rax, [rbp - 1432]
    test rax, rax
    jz ir_sc_false_1207
ir_sc_true_1206:
    mov rax, 1
    mov [rbp - 1440], rax
    jmp ir_sc_end_1208
ir_sc_false_1207:
    mov rax, 0
    mov [rbp - 1440], rax
ir_sc_end_1208:
    mov rax, [rbp - 1440]
    test rax, rax
    jz ir_while_end_1196
    ; Load variable: len
    movsxd rax, dword [rbp - 560]  ; From stack [rbp - 560]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1456], rax
    mov rax, [rbp - 1456]
    ; Store to variable: len
    mov dword [rbp - 560], eax  ; To stack [rbp - 560]
    jmp ir_while_1195
ir_while_end_1196:
    ; Load variable: len
    movsxd rax, dword [rbp - 560]  ; From stack [rbp - 560]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setg al
    movzx rax, al
    mov [rbp - 1464], rax
    mov rax, [rbp - 1464]
    test rax, rax
    jz ir_if_next_1212
    mov rax, 0
    push rax
    mov rax, 600
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1472], rax
    mov rax, [rbp - 1472]
    test rax, rax
    jz ir_trap_bounds_1213
    jmp ir_in_bounds_1214
ir_trap_bounds_1213:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct393]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1214:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1480], rax
    ; Load variable: item_buf
    lea rax, [rbp - 1160]  ; Local array base
    push rax
    mov rax, [rbp - 1480]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1488], rax
    ; Load variable: FORUM_LI_OPEN
    lea rax, [rel FORUM_LI_OPEN]  ; Address of global string
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1496], rax
    mov rax, [rbp - 1496]
    mov rax, qword [rax]
    mov [rbp - 1504], rax
    ; Load variable: FORUM_LI_OPEN
    lea rax, [rel FORUM_LI_OPEN]  ; Address of global string
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1512], rax
    mov rax, [rbp - 1512]
    mov rax, qword [rax]
    mov [rbp - 1520], rax
    ; IR call: memcpy (3 args)
    sub rsp, 32
    mov rax, [rbp - 1488]
    mov rcx, rax
    mov rax, [rbp - 1504]
    mov rdx, rax
    mov rax, [rbp - 1520]
    mov r8, rax
    call memcpy
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1528], rax
    ; Load variable: FORUM_LI_OPEN
    lea rax, [rel FORUM_LI_OPEN]  ; Address of global string
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1536], rax
    mov rax, [rbp - 1536]
    mov rax, qword [rax]
    mov [rbp - 1544], rax
    mov rax, [rbp - 1544]
    push rax
    mov rax, 600
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1552], rax
    mov rax, [rbp - 1552]
    test rax, rax
    jz ir_trap_bounds_1215
    jmp ir_in_bounds_1216
ir_trap_bounds_1215:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct395]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1216:
    mov rax, [rbp - 1544]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1560], rax
    ; Load variable: item_buf
    lea rax, [rbp - 1160]  ; Local array base
    push rax
    mov rax, [rbp - 1560]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1568], rax
    ; IR call: int_to_dec (2 args)
    sub rsp, 32
    mov rax, [rbp - 1568]
    mov rcx, rax
    ; Load variable: line_num
    movsxd rax, dword [rbp - 556]  ; From stack [rbp - 556]
    mov rdx, rax
    call int_to_dec
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1576], rax
    mov rax, [rbp - 1576]
    ; Store to variable: dc
    mov dword [rbp - 1164], eax  ; To stack [rbp - 1164]
    ; Load variable: FORUM_LI_OPEN
    lea rax, [rel FORUM_LI_OPEN]  ; Address of global string
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1584], rax
    mov rax, [rbp - 1584]
    mov rax, qword [rax]
    mov [rbp - 1592], rax
    mov rax, [rbp - 1592]
    push rax
    ; Load variable: dc
    movsxd rax, dword [rbp - 1164]  ; From stack [rbp - 1164]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1600], rax
    mov rax, [rbp - 1600]
    push rax
    mov rax, 600
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1608], rax
    mov rax, [rbp - 1608]
    test rax, rax
    jz ir_trap_bounds_1217
    jmp ir_in_bounds_1218
ir_trap_bounds_1217:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct397]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1218:
    mov rax, [rbp - 1600]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1616], rax
    ; Load variable: item_buf
    lea rax, [rbp - 1160]  ; Local array base
    push rax
    mov rax, [rbp - 1616]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1624], rax
    ; Load variable: FORUM_LI_MID
    lea rax, [rel FORUM_LI_MID]  ; Address of global string
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1632], rax
    mov rax, [rbp - 1632]
    mov rax, qword [rax]
    mov [rbp - 1640], rax
    ; Load variable: FORUM_LI_MID
    lea rax, [rel FORUM_LI_MID]  ; Address of global string
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1648], rax
    mov rax, [rbp - 1648]
    mov rax, qword [rax]
    mov [rbp - 1656], rax
    ; IR call: memcpy (3 args)
    sub rsp, 32
    mov rax, [rbp - 1624]
    mov rcx, rax
    mov rax, [rbp - 1640]
    mov rdx, rax
    mov rax, [rbp - 1656]
    mov r8, rax
    call memcpy
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1664], rax
    ; Load variable: FORUM_LI_OPEN
    lea rax, [rel FORUM_LI_OPEN]  ; Address of global string
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1672], rax
    mov rax, [rbp - 1672]
    mov rax, qword [rax]
    mov [rbp - 1680], rax
    mov rax, [rbp - 1680]
    push rax
    ; Load variable: dc
    movsxd rax, dword [rbp - 1164]  ; From stack [rbp - 1164]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1688], rax
    ; Load variable: FORUM_LI_MID
    lea rax, [rel FORUM_LI_MID]  ; Address of global string
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1696], rax
    mov rax, [rbp - 1696]
    mov rax, qword [rax]
    mov [rbp - 1704], rax
    mov rax, [rbp - 1688]
    push rax
    mov rax, [rbp - 1704]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1712], rax
    mov rax, [rbp - 1712]
    ; Store to variable: mid
    mov dword [rbp - 1168], eax  ; To stack [rbp - 1168]
    ; Load variable: len
    movsxd rax, dword [rbp - 560]  ; From stack [rbp - 560]
    ; Store to variable: copy_len
    mov dword [rbp - 1172], eax  ; To stack [rbp - 1172]
    ; Load variable: copy_len
    movsxd rax, dword [rbp - 1172]  ; From stack [rbp - 1172]
    push rax
    mov rax, 200
    mov r10, rax
    pop rax
    cmp rax, r10
    setg al
    movzx rax, al
    mov [rbp - 1720], rax
    mov rax, [rbp - 1720]
    test rax, rax
    jz ir_if_next_1220
    mov rax, 200
    ; Store to variable: copy_len
    mov dword [rbp - 1172], eax  ; To stack [rbp - 1172]
    jmp ir_if_end_1219
ir_if_next_1220:
ir_if_end_1219:
    mov rax, 0
    push rax
    mov rax, 600
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1728], rax
    mov rax, [rbp - 1728]
    test rax, rax
    jz ir_trap_bounds_1221
    jmp ir_in_bounds_1222
ir_trap_bounds_1221:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct399]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1222:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1736], rax
    ; Load variable: item_buf
    lea rax, [rbp - 1160]  ; Local array base
    push rax
    mov rax, [rbp - 1736]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1744], rax
    ; IR call: send_all (3 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    mov rax, [rbp - 1744]
    mov rdx, rax
    ; Load variable: mid
    movsxd rax, dword [rbp - 1168]  ; From stack [rbp - 1168]
    mov r8, rax
    call send_all
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1752], rax
    mov rax, 0
    push rax
    mov rax, 512
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1760], rax
    mov rax, [rbp - 1760]
    test rax, rax
    jz ir_trap_bounds_1223
    jmp ir_in_bounds_1224
ir_trap_bounds_1223:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct401]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1224:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1768], rax
    ; Load variable: line_buf
    lea rax, [rbp - 552]  ; Local array base
    push rax
    mov rax, [rbp - 1768]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1776], rax
    ; IR call: send_html_escaped (3 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    mov rax, [rbp - 1776]
    mov rdx, rax
    ; Load variable: copy_len
    movsxd rax, dword [rbp - 1172]  ; From stack [rbp - 1172]
    mov r8, rax
    call send_html_escaped
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 1784], rax
    ; Load variable: FORUM_LI_CLOSE
    lea rax, [rel FORUM_LI_CLOSE]  ; Address of global string
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1792], rax
    mov rax, [rbp - 1792]
    mov rax, qword [rax]
    mov [rbp - 1800], rax
    ; Load variable: FORUM_LI_CLOSE
    lea rax, [rel FORUM_LI_CLOSE]  ; Address of global string
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1808], rax
    mov rax, [rbp - 1808]
    mov rax, qword [rax]
    mov [rbp - 1816], rax
    ; IR call: send_all (3 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    mov rax, [rbp - 1800]
    mov rdx, rax
    mov rax, [rbp - 1816]
    mov r8, rax
    call send_all
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1824], rax
    jmp ir_if_end_1211
ir_if_next_1212:
ir_if_end_1211:
    ; Load variable: line_num
    movsxd rax, dword [rbp - 556]  ; From stack [rbp - 556]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1832], rax
    mov rax, [rbp - 1832]
    ; Store to variable: line_num
    mov dword [rbp - 556], eax  ; To stack [rbp - 556]
    jmp ir_while_1191
ir_while_end_1192:
    ; IR call: fclose (1 args)
    sub rsp, 32
    ; Load variable: fp
    mov rax, qword [rbp - 40]  ; From stack [rbp - 40]
    mov rcx, rax
    call fclose
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1840], rax
    jmp ir_if_end_1189
ir_if_next_1190:
ir_if_end_1189:
    ; Load variable: FORUM_INDEX_END
    lea rax, [rel FORUM_INDEX_END]  ; Address of global string
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1848], rax
    mov rax, [rbp - 1848]
    mov rax, qword [rax]
    mov [rbp - 1856], rax
    ; Load variable: FORUM_INDEX_END
    lea rax, [rel FORUM_INDEX_END]  ; Address of global string
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1864], rax
    mov rax, [rbp - 1864]
    mov rax, qword [rax]
    mov [rbp - 1872], rax
    ; IR call: send_all (3 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    mov rax, [rbp - 1856]
    mov rdx, rax
    mov rax, [rbp - 1872]
    mov r8, rax
    call send_all
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1880], rax
    ; Load variable: show_err_empty
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 1888], rax
    mov rax, [rbp - 1888]
    test rax, rax
    jz ir_if_next_1226
    ; Load variable: FORUM_ERR_EMPTY
    lea rax, [rel FORUM_ERR_EMPTY]  ; Address of global string
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1896], rax
    mov rax, [rbp - 1896]
    mov rax, qword [rax]
    mov [rbp - 1904], rax
    ; Load variable: FORUM_ERR_EMPTY
    lea rax, [rel FORUM_ERR_EMPTY]  ; Address of global string
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1912], rax
    mov rax, [rbp - 1912]
    mov rax, qword [rax]
    mov [rbp - 1920], rax
    ; IR call: send_all (3 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    mov rax, [rbp - 1904]
    mov rdx, rax
    mov rax, [rbp - 1920]
    mov r8, rax
    call send_all
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1928], rax
    jmp ir_if_end_1225
ir_if_next_1226:
ir_if_end_1225:
    ; Load variable: FORUM_FORM
    lea rax, [rel FORUM_FORM]  ; Address of global string
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1936], rax
    mov rax, [rbp - 1936]
    mov rax, qword [rax]
    mov [rbp - 1944], rax
    ; Load variable: FORUM_FORM
    lea rax, [rel FORUM_FORM]  ; Address of global string
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1952], rax
    mov rax, [rbp - 1952]
    mov rax, qword [rax]
    mov [rbp - 1960], rax
    ; IR call: send_all (3 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    mov rax, [rbp - 1944]
    mov rdx, rax
    mov rax, [rbp - 1960]
    mov r8, rax
    call send_all
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1968], rax
    mov rax, 0
    mov [rbp - 1976], rax
    mov rax, [rbp - 1976]
    test rax, rax
    jz ir_errdefer_ok_1227
    jmp ir_errdefer_end_1228
ir_errdefer_ok_1227:
ir_errdefer_end_1228:
    jmp Lserve_forum_index_exit
Lserve_forum_index_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global serve_forum_thread

serve_forum_thread:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    mov rax, 7248
    extern ___chkstk_ms
    sub rsp, 32
    call ___chkstk_ms
    add rsp, 32
    sub rsp, rax    ; Allocate 7248 bytes on stack (probed)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 'client'
    ; Parameter 'client' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'thread_id'
    ; Parameter 'thread_id' arrived in register rdx
ir_entry_1229:
    ; Binary operation: +
    ; String concatenation (+)
    ; Binary operation: +
    ; String concatenation (+)
    ; Binary operation: +
    ; String concatenation (+)
    ; Load variable: FORUM_HEADER
    lea rax, [rel FORUM_HEADER]  ; Address of global string
    push rax           ; Save left string ptr
    ; Load variable: FORUM_THREAD_START
    lea rax, [rel FORUM_THREAD_START]  ; Address of global string
    mov r10, rax       ; right string ptr -> r10
    pop rax            ; left string ptr -> rax
    mov rcx, [rax + 8] ; len1
    add rcx, [r10 + 8] ; len1 + len2
    sub rsp, 24        ; Save concat state
    mov [rsp], r10     ; right ptr
    mov [rsp + 8], rax ; left ptr
    mov [rsp + 16], rcx ; total_len
    mov rcx, rcx
    add rcx, 17
    sub rsp, 40      ; 32-byte shadow + 8-byte align pad
    extern gc_alloc
    call gc_alloc
    add rsp, 40
    mov rcx, [rsp + 16] ; total_len
    mov rdx, [rsp + 8] ; left ptr
    mov rsi, [rsp]    ; right ptr
    add rsp, 24
    lea r8, [rax + 16]
    mov [rax], r8
    mov [rax + 8], rcx
    mov r9, [rdx + 8]  ; left len
    mov rdi, [rdx]     ; left chars
    test r9, r9
    jz Lconcat_left_done402
Lconcat_left_loop403:
    mov r11b, [rdi]
    mov [r8], r11b
    inc rdi
    inc r8
    dec r9
    jnz Lconcat_left_loop403
Lconcat_left_done402:
    mov r9, [rsi + 8]  ; right len
    mov rdi, [rsi]     ; right chars
    test r9, r9
    jz Lconcat_right_done404
Lconcat_right_loop405:
    mov r11b, [rdi]
    mov [r8], r11b
    inc rdi
    inc r8
    dec r9
    jnz Lconcat_right_loop405
Lconcat_right_done404:
    mov byte [r8], 0
    push rax           ; Save left string ptr
    ; Load variable: FORUM_CSS
    lea rax, [rel FORUM_CSS]  ; Address of global string
    mov r10, rax       ; right string ptr -> r10
    pop rax            ; left string ptr -> rax
    mov rcx, [rax + 8] ; len1
    add rcx, [r10 + 8] ; len1 + len2
    sub rsp, 24        ; Save concat state
    mov [rsp], r10     ; right ptr
    mov [rsp + 8], rax ; left ptr
    mov [rsp + 16], rcx ; total_len
    mov rcx, rcx
    add rcx, 17
    sub rsp, 40      ; 32-byte shadow + 8-byte align pad
    extern gc_alloc
    call gc_alloc
    add rsp, 40
    mov rcx, [rsp + 16] ; total_len
    mov rdx, [rsp + 8] ; left ptr
    mov rsi, [rsp]    ; right ptr
    add rsp, 24
    lea r8, [rax + 16]
    mov [rax], r8
    mov [rax + 8], rcx
    mov r9, [rdx + 8]  ; left len
    mov rdi, [rdx]     ; left chars
    test r9, r9
    jz Lconcat_left_done406
Lconcat_left_loop407:
    mov r11b, [rdi]
    mov [r8], r11b
    inc rdi
    inc r8
    dec r9
    jnz Lconcat_left_loop407
Lconcat_left_done406:
    mov r9, [rsi + 8]  ; right len
    mov rdi, [rsi]     ; right chars
    test r9, r9
    jz Lconcat_right_done408
Lconcat_right_loop409:
    mov r11b, [rdi]
    mov [r8], r11b
    inc rdi
    inc r8
    dec r9
    jnz Lconcat_right_loop409
Lconcat_right_done408:
    mov byte [r8], 0
    push rax           ; Save left string ptr
    ; Load variable: FORUM_THREAD_HEAD_END
    lea rax, [rel FORUM_THREAD_HEAD_END]  ; Address of global string
    mov r10, rax       ; right string ptr -> r10
    pop rax            ; left string ptr -> rax
    mov rcx, [rax + 8] ; len1
    add rcx, [r10 + 8] ; len1 + len2
    sub rsp, 24        ; Save concat state
    mov [rsp], r10     ; right ptr
    mov [rsp + 8], rax ; left ptr
    mov [rsp + 16], rcx ; total_len
    mov rcx, rcx
    add rcx, 17
    sub rsp, 40      ; 32-byte shadow + 8-byte align pad
    extern gc_alloc
    call gc_alloc
    add rsp, 40
    mov rcx, [rsp + 16] ; total_len
    mov rdx, [rsp + 8] ; left ptr
    mov rsi, [rsp]    ; right ptr
    add rsp, 24
    lea r8, [rax + 16]
    mov [rax], r8
    mov [rax + 8], rcx
    mov r9, [rdx + 8]  ; left len
    mov rdi, [rdx]     ; left chars
    test r9, r9
    jz Lconcat_left_done410
Lconcat_left_loop411:
    mov r11b, [rdi]
    mov [r8], r11b
    inc rdi
    inc r8
    dec r9
    jnz Lconcat_left_loop411
Lconcat_left_done410:
    mov r9, [rsi + 8]  ; right len
    mov rdi, [rsi]     ; right chars
    test r9, r9
    jz Lconcat_right_done412
Lconcat_right_loop413:
    mov r11b, [rdi]
    mov [r8], r11b
    inc rdi
    inc r8
    dec r9
    jnz Lconcat_right_loop413
Lconcat_right_done412:
    mov byte [r8], 0
    mov [rbp - 896], rax
    mov rax, [rbp - 896]
    ; Store to variable: out
    mov rcx, [rax]       ; string chars
    mov [rbp - 32], rcx
    mov rcx, [rax + 8]   ; string length
    mov [rbp - 24], rcx
    ; Load variable: out
    lea rax, [rbp - 32]  ; Address of local string
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 904], rax
    mov rax, [rbp - 904]
    mov rax, qword [rax]
    mov [rbp - 912], rax
    ; Load variable: out
    lea rax, [rbp - 32]  ; Address of local string
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 920], rax
    mov rax, [rbp - 920]
    mov rax, qword [rax]
    mov [rbp - 928], rax
    ; IR call: send_all (3 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    mov rax, [rbp - 912]
    mov rdx, rax
    mov rax, [rbp - 928]
    mov r8, rax
    call send_all
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 936], rax
    mov rax, 0
    push rax
    mov rax, 256
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 944], rax
    mov rax, [rbp - 944]
    test rax, rax
    jz ir_trap_bounds_1230
    jmp ir_in_bounds_1231
ir_trap_bounds_1230:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct415]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1231:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 952], rax
    ; Load variable: title_buf
    lea rax, [rbp - 288]  ; Local array base
    push rax
    mov rax, [rbp - 952]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 960], rax
    mov rax, [rbp - 960]
    push rax
    mov rax, 85
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    mov rax, 1
    push rax
    mov rax, 256
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 976], rax
    mov rax, [rbp - 976]
    test rax, rax
    jz ir_trap_bounds_1232
    jmp ir_in_bounds_1233
ir_trap_bounds_1232:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct417]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1233:
    mov rax, 1
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 984], rax
    ; Load variable: title_buf
    lea rax, [rbp - 288]  ; Local array base
    push rax
    mov rax, [rbp - 984]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 992], rax
    mov rax, [rbp - 992]
    push rax
    mov rax, 110
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    mov rax, 2
    push rax
    mov rax, 256
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1008], rax
    mov rax, [rbp - 1008]
    test rax, rax
    jz ir_trap_bounds_1234
    jmp ir_in_bounds_1235
ir_trap_bounds_1234:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct419]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1235:
    mov rax, 2
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1016], rax
    ; Load variable: title_buf
    lea rax, [rbp - 288]  ; Local array base
    push rax
    mov rax, [rbp - 1016]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1024], rax
    mov rax, [rbp - 1024]
    push rax
    mov rax, 107
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    mov rax, 3
    push rax
    mov rax, 256
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1040], rax
    mov rax, [rbp - 1040]
    test rax, rax
    jz ir_trap_bounds_1236
    jmp ir_in_bounds_1237
ir_trap_bounds_1236:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct421]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1237:
    mov rax, 3
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1048], rax
    ; Load variable: title_buf
    lea rax, [rbp - 288]  ; Local array base
    push rax
    mov rax, [rbp - 1048]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1056], rax
    mov rax, [rbp - 1056]
    push rax
    mov rax, 110
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    mov rax, 4
    push rax
    mov rax, 256
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1072], rax
    mov rax, [rbp - 1072]
    test rax, rax
    jz ir_trap_bounds_1238
    jmp ir_in_bounds_1239
ir_trap_bounds_1238:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct423]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1239:
    mov rax, 4
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1080], rax
    ; Load variable: title_buf
    lea rax, [rbp - 288]  ; Local array base
    push rax
    mov rax, [rbp - 1080]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1088], rax
    mov rax, [rbp - 1088]
    push rax
    mov rax, 111
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    mov rax, 5
    push rax
    mov rax, 256
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1104], rax
    mov rax, [rbp - 1104]
    test rax, rax
    jz ir_trap_bounds_1240
    jmp ir_in_bounds_1241
ir_trap_bounds_1240:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct425]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1241:
    mov rax, 5
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1112], rax
    ; Load variable: title_buf
    lea rax, [rbp - 288]  ; Local array base
    push rax
    mov rax, [rbp - 1112]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1120], rax
    mov rax, [rbp - 1120]
    push rax
    mov rax, 119
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    mov rax, 6
    push rax
    mov rax, 256
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1136], rax
    mov rax, [rbp - 1136]
    test rax, rax
    jz ir_trap_bounds_1242
    jmp ir_in_bounds_1243
ir_trap_bounds_1242:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct427]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1243:
    mov rax, 6
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1144], rax
    ; Load variable: title_buf
    lea rax, [rbp - 288]  ; Local array base
    push rax
    mov rax, [rbp - 1144]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1152], rax
    mov rax, [rbp - 1152]
    push rax
    mov rax, 110
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    mov rax, 7
    push rax
    mov rax, 256
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1168], rax
    mov rax, [rbp - 1168]
    test rax, rax
    jz ir_trap_bounds_1244
    jmp ir_in_bounds_1245
ir_trap_bounds_1244:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct429]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1245:
    mov rax, 7
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1176], rax
    ; Load variable: title_buf
    lea rax, [rbp - 288]  ; Local array base
    push rax
    mov rax, [rbp - 1176]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1184], rax
    mov rax, [rbp - 1184]
    push rax
    mov rax, 0
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: fn_threads
    lea rax, [rel fn_threads]  ; Address of global string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1200], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: mode_r
    lea rax, [rel mode_r]  ; Address of global string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1208], rax
    ; IR call: fopen (2 args)
    sub rsp, 32
    mov rax, [rbp - 1200]
    mov rcx, rax
    mov rax, [rbp - 1208]
    mov rdx, rax
    call fopen
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1216], rax
    mov rax, [rbp - 1216]
    ; Store to variable: fp
    mov qword [rbp - 296], rax  ; To stack [rbp - 296]
    ; Load variable: fp
    mov rax, qword [rbp - 296]  ; From stack [rbp - 296]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 1224], rax
    mov rax, [rbp - 1224]
    test rax, rax
    jz ir_if_next_1247
    mov rax, 1
    ; Store to variable: line_num
    mov dword [rbp - 812], eax  ; To stack [rbp - 812]
ir_while_1248:
    mov rax, 0
    push rax
    mov rax, 512
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1232], rax
    mov rax, [rbp - 1232]
    test rax, rax
    jz ir_trap_bounds_1250
    jmp ir_in_bounds_1251
ir_trap_bounds_1250:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct431]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1251:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1240], rax
    ; Load variable: line_buf
    lea rax, [rbp - 808]  ; Local array base
    push rax
    mov rax, [rbp - 1240]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1248], rax
    ; IR call: fgets (3 args)
    sub rsp, 32
    mov rax, [rbp - 1248]
    mov rcx, rax
    mov rax, 512
    mov rdx, rax
    ; Load variable: fp
    mov rax, qword [rbp - 296]  ; From stack [rbp - 296]
    mov r8, rax
    call fgets
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1256], rax
    mov rax, [rbp - 1256]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 1264], rax
    mov rax, [rbp - 1264]
    test rax, rax
    jz ir_while_end_1249
    ; Load variable: line_num
    movsxd rax, dword [rbp - 812]  ; From stack [rbp - 812]
    push rax
    ; Load variable: thread_id
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 1272], rax
    mov rax, [rbp - 1272]
    test rax, rax
    jz ir_if_next_1253
    mov rax, 0
    ; Store to variable: len
    mov dword [rbp - 816], eax  ; To stack [rbp - 816]
ir_while_1254:
    ; Load variable: len
    movsxd rax, dword [rbp - 816]  ; From stack [rbp - 816]
    push rax
    mov rax, 512
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1280], rax
    mov rax, [rbp - 1280]
    test rax, rax
    jz ir_trap_bounds_1256
    jmp ir_in_bounds_1257
ir_trap_bounds_1256:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct433]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1257:
    ; Load variable: len
    movsxd rax, dword [rbp - 816]  ; From stack [rbp - 816]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1288], rax
    ; Load variable: line_buf
    lea rax, [rbp - 808]  ; Local array base
    push rax
    mov rax, [rbp - 1288]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1296], rax
    mov rax, [rbp - 1296]
    movzx rax, byte [rax]
    mov [rbp - 1304], rax
    mov rax, [rbp - 1304]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 1312], rax
    mov rax, [rbp - 1312]
    test rax, rax
    jz ir_sc_false_1260
ir_sc_rhs_1258:
    ; Load variable: len
    movsxd rax, dword [rbp - 816]  ; From stack [rbp - 816]
    push rax
    mov rax, 512
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1320], rax
    mov rax, [rbp - 1320]
    test rax, rax
    jz ir_trap_bounds_1262
    jmp ir_in_bounds_1263
ir_trap_bounds_1262:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct435]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1263:
    ; Load variable: len
    movsxd rax, dword [rbp - 816]  ; From stack [rbp - 816]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1328], rax
    ; Load variable: line_buf
    lea rax, [rbp - 808]  ; Local array base
    push rax
    mov rax, [rbp - 1328]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1336], rax
    mov rax, [rbp - 1336]
    movzx rax, byte [rax]
    mov [rbp - 1344], rax
    mov rax, [rbp - 1344]
    push rax
    mov rax, 10
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 1352], rax
    mov rax, [rbp - 1352]
    test rax, rax
    jz ir_sc_false_1260
ir_sc_true_1259:
    mov rax, 1
    mov [rbp - 1360], rax
    jmp ir_sc_end_1261
ir_sc_false_1260:
    mov rax, 0
    mov [rbp - 1360], rax
ir_sc_end_1261:
    mov rax, [rbp - 1360]
    test rax, rax
    jz ir_sc_false_1266
ir_sc_rhs_1264:
    ; Load variable: len
    movsxd rax, dword [rbp - 816]  ; From stack [rbp - 816]
    push rax
    mov rax, 512
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1376], rax
    mov rax, [rbp - 1376]
    test rax, rax
    jz ir_trap_bounds_1268
    jmp ir_in_bounds_1269
ir_trap_bounds_1268:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct437]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1269:
    ; Load variable: len
    movsxd rax, dword [rbp - 816]  ; From stack [rbp - 816]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1384], rax
    ; Load variable: line_buf
    lea rax, [rbp - 808]  ; Local array base
    push rax
    mov rax, [rbp - 1384]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1392], rax
    mov rax, [rbp - 1392]
    movzx rax, byte [rax]
    mov [rbp - 1400], rax
    mov rax, [rbp - 1400]
    push rax
    mov rax, 13
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 1408], rax
    mov rax, [rbp - 1408]
    test rax, rax
    jz ir_sc_false_1266
ir_sc_true_1265:
    mov rax, 1
    mov [rbp - 1416], rax
    jmp ir_sc_end_1267
ir_sc_false_1266:
    mov rax, 0
    mov [rbp - 1416], rax
ir_sc_end_1267:
    mov rax, [rbp - 1416]
    test rax, rax
    jz ir_while_end_1255
    ; Load variable: len
    movsxd rax, dword [rbp - 816]  ; From stack [rbp - 816]
    push rax
    mov rax, 255
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1432], rax
    mov rax, [rbp - 1432]
    test rax, rax
    jz ir_if_next_1271
    ; Load variable: len
    movsxd rax, dword [rbp - 816]  ; From stack [rbp - 816]
    push rax
    mov rax, 512
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1440], rax
    mov rax, [rbp - 1440]
    test rax, rax
    jz ir_trap_bounds_1272
    jmp ir_in_bounds_1273
ir_trap_bounds_1272:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct439]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1273:
    ; Load variable: len
    movsxd rax, dword [rbp - 816]  ; From stack [rbp - 816]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1448], rax
    ; Load variable: line_buf
    lea rax, [rbp - 808]  ; Local array base
    push rax
    mov rax, [rbp - 1448]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1456], rax
    mov rax, [rbp - 1456]
    movzx rax, byte [rax]
    mov [rbp - 1464], rax
    ; Load variable: len
    movsxd rax, dword [rbp - 816]  ; From stack [rbp - 816]
    push rax
    mov rax, 256
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1472], rax
    mov rax, [rbp - 1472]
    test rax, rax
    jz ir_trap_bounds_1274
    jmp ir_in_bounds_1275
ir_trap_bounds_1274:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct441]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1275:
    ; Load variable: len
    movsxd rax, dword [rbp - 816]  ; From stack [rbp - 816]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1480], rax
    ; Load variable: title_buf
    lea rax, [rbp - 288]  ; Local array base
    push rax
    mov rax, [rbp - 1480]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1488], rax
    mov rax, [rbp - 1488]
    push rax
    mov rax, [rbp - 1464]
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    jmp ir_if_end_1270
ir_if_next_1271:
ir_if_end_1270:
    ; Load variable: len
    movsxd rax, dword [rbp - 816]  ; From stack [rbp - 816]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1504], rax
    mov rax, [rbp - 1504]
    ; Store to variable: len
    mov dword [rbp - 816], eax  ; To stack [rbp - 816]
    jmp ir_while_1254
ir_while_end_1255:
    ; Load variable: len
    movsxd rax, dword [rbp - 816]  ; From stack [rbp - 816]
    push rax
    mov rax, 256
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1512], rax
    mov rax, [rbp - 1512]
    test rax, rax
    jz ir_if_next_1277
    ; Load variable: len
    movsxd rax, dword [rbp - 816]  ; From stack [rbp - 816]
    push rax
    mov rax, 256
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1520], rax
    mov rax, [rbp - 1520]
    test rax, rax
    jz ir_trap_bounds_1278
    jmp ir_in_bounds_1279
ir_trap_bounds_1278:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct443]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1279:
    ; Load variable: len
    movsxd rax, dword [rbp - 816]  ; From stack [rbp - 816]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1528], rax
    ; Load variable: title_buf
    lea rax, [rbp - 288]  ; Local array base
    push rax
    mov rax, [rbp - 1528]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1536], rax
    mov rax, [rbp - 1536]
    push rax
    mov rax, 0
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    jmp ir_if_end_1276
ir_if_next_1277:
    mov rax, 255
    push rax
    mov rax, 256
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1552], rax
    mov rax, [rbp - 1552]
    test rax, rax
    jz ir_trap_bounds_1280
    jmp ir_in_bounds_1281
ir_trap_bounds_1280:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct445]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1281:
    mov rax, 255
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1560], rax
    ; Load variable: title_buf
    lea rax, [rbp - 288]  ; Local array base
    push rax
    mov rax, [rbp - 1560]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1568], rax
    mov rax, [rbp - 1568]
    push rax
    mov rax, 0
    mov rcx, rax
    pop rax
    mov byte [rax], cl
ir_if_end_1276:
    jmp ir_while_end_1249
    jmp ir_if_end_1252
ir_if_next_1253:
ir_if_end_1252:
    ; Load variable: line_num
    movsxd rax, dword [rbp - 812]  ; From stack [rbp - 812]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1584], rax
    mov rax, [rbp - 1584]
    ; Store to variable: line_num
    mov dword [rbp - 812], eax  ; To stack [rbp - 812]
    jmp ir_while_1248
ir_while_end_1249:
    ; IR call: fclose (1 args)
    sub rsp, 32
    ; Load variable: fp
    mov rax, qword [rbp - 296]  ; From stack [rbp - 296]
    mov rcx, rax
    call fclose
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1592], rax
    jmp ir_if_end_1246
ir_if_next_1247:
ir_if_end_1246:
    mov rax, 0
    ; Store to variable: title_len
    mov dword [rbp - 820], eax  ; To stack [rbp - 820]
ir_while_1282:
    ; Load variable: title_len
    movsxd rax, dword [rbp - 820]  ; From stack [rbp - 820]
    push rax
    mov rax, 256
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1600], rax
    mov rax, [rbp - 1600]
    test rax, rax
    jz ir_trap_bounds_1284
    jmp ir_in_bounds_1285
ir_trap_bounds_1284:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct447]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1285:
    ; Load variable: title_len
    movsxd rax, dword [rbp - 820]  ; From stack [rbp - 820]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1608], rax
    ; Load variable: title_buf
    lea rax, [rbp - 288]  ; Local array base
    push rax
    mov rax, [rbp - 1608]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1616], rax
    mov rax, [rbp - 1616]
    movzx rax, byte [rax]
    mov [rbp - 1624], rax
    mov rax, [rbp - 1624]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 1632], rax
    mov rax, [rbp - 1632]
    test rax, rax
    jz ir_while_end_1283
    ; Load variable: title_len
    movsxd rax, dword [rbp - 820]  ; From stack [rbp - 820]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1640], rax
    mov rax, [rbp - 1640]
    ; Store to variable: title_len
    mov dword [rbp - 820], eax  ; To stack [rbp - 820]
    jmp ir_while_1282
ir_while_end_1283:
    mov rax, 0
    push rax
    mov rax, 256
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1648], rax
    mov rax, [rbp - 1648]
    test rax, rax
    jz ir_trap_bounds_1286
    jmp ir_in_bounds_1287
ir_trap_bounds_1286:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct449]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1287:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1656], rax
    ; Load variable: title_buf
    lea rax, [rbp - 288]  ; Local array base
    push rax
    mov rax, [rbp - 1656]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1664], rax
    ; IR call: send_html_escaped (3 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    mov rax, [rbp - 1664]
    mov rdx, rax
    ; Load variable: title_len
    movsxd rax, dword [rbp - 820]  ; From stack [rbp - 820]
    mov r8, rax
    call send_html_escaped
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 1672], rax
    ; Load variable: FORUM_THREAD_MID
    lea rax, [rel FORUM_THREAD_MID]  ; Address of global string
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1680], rax
    mov rax, [rbp - 1680]
    mov rax, qword [rax]
    mov [rbp - 1688], rax
    ; Load variable: FORUM_THREAD_MID
    lea rax, [rel FORUM_THREAD_MID]  ; Address of global string
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1696], rax
    mov rax, [rbp - 1696]
    mov rax, qword [rax]
    mov [rbp - 1704], rax
    ; IR call: send_all (3 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    mov rax, [rbp - 1688]
    mov rdx, rax
    mov rax, [rbp - 1704]
    mov r8, rax
    call send_all
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1712], rax
    mov rax, 0
    push rax
    mov rax, 32
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1720], rax
    mov rax, [rbp - 1720]
    test rax, rax
    jz ir_trap_bounds_1288
    jmp ir_in_bounds_1289
ir_trap_bounds_1288:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct451]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1289:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1728], rax
    ; Load variable: posts_fn
    lea rax, [rbp - 856]  ; Local array base
    push rax
    mov rax, [rbp - 1728]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1736], rax
    ; IR call: build_posts_filename (2 args)
    sub rsp, 32
    mov rax, [rbp - 1736]
    mov rcx, rax
    ; Load variable: thread_id
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    mov rdx, rax
    call build_posts_filename
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 1744], rax
    mov rax, 0
    ; Store to variable: had_posts
    mov dword [rbp - 860], eax  ; To stack [rbp - 860]
    mov rax, 0
    push rax
    mov rax, 32
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1752], rax
    mov rax, [rbp - 1752]
    test rax, rax
    jz ir_trap_bounds_1290
    jmp ir_in_bounds_1291
ir_trap_bounds_1290:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct453]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1291:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1760], rax
    ; Load variable: posts_fn
    lea rax, [rbp - 856]  ; Local array base
    push rax
    mov rax, [rbp - 1760]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1768], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: mode_r
    lea rax, [rel mode_r]  ; Address of global string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1776], rax
    ; IR call: fopen (2 args)
    sub rsp, 32
    mov rax, [rbp - 1768]
    mov rcx, rax
    mov rax, [rbp - 1776]
    mov rdx, rax
    call fopen
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1784], rax
    mov rax, [rbp - 1784]
    ; Store to variable: fp
    mov qword [rbp - 296], rax  ; To stack [rbp - 296]
    ; Load variable: fp
    mov rax, qword [rbp - 296]  ; From stack [rbp - 296]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 1792], rax
    mov rax, [rbp - 1792]
    test rax, rax
    jz ir_if_next_1293
ir_while_1294:
    mov rax, 0
    push rax
    mov rax, 2048
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1800], rax
    mov rax, [rbp - 1800]
    test rax, rax
    jz ir_trap_bounds_1296
    jmp ir_in_bounds_1297
ir_trap_bounds_1296:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct455]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1297:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1808], rax
    ; Load variable: line_buf
    lea rax, [rbp - 808]  ; Local array base
    push rax
    mov rax, [rbp - 1808]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1816], rax
    ; IR call: fgets (3 args)
    sub rsp, 32
    mov rax, [rbp - 1816]
    mov rcx, rax
    mov rax, 2048
    mov rdx, rax
    ; Load variable: fp
    mov rax, qword [rbp - 296]  ; From stack [rbp - 296]
    mov r8, rax
    call fgets
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1824], rax
    mov rax, [rbp - 1824]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 1832], rax
    mov rax, [rbp - 1832]
    test rax, rax
    jz ir_while_end_1295
    mov rax, 0
    ; Store to variable: len
    mov dword [rbp - 816], eax  ; To stack [rbp - 816]
ir_while_1298:
    ; Load variable: len
    movsxd rax, dword [rbp - 816]  ; From stack [rbp - 816]
    push rax
    mov rax, 2048
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1840], rax
    mov rax, [rbp - 1840]
    test rax, rax
    jz ir_trap_bounds_1300
    jmp ir_in_bounds_1301
ir_trap_bounds_1300:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct457]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1301:
    ; Load variable: len
    movsxd rax, dword [rbp - 816]  ; From stack [rbp - 816]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1848], rax
    ; Load variable: line_buf
    lea rax, [rbp - 808]  ; Local array base
    push rax
    mov rax, [rbp - 1848]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1856], rax
    mov rax, [rbp - 1856]
    movzx rax, byte [rax]
    mov [rbp - 1864], rax
    mov rax, [rbp - 1864]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 1872], rax
    mov rax, [rbp - 1872]
    test rax, rax
    jz ir_sc_false_1304
ir_sc_rhs_1302:
    ; Load variable: len
    movsxd rax, dword [rbp - 816]  ; From stack [rbp - 816]
    push rax
    mov rax, 2048
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1880], rax
    mov rax, [rbp - 1880]
    test rax, rax
    jz ir_trap_bounds_1306
    jmp ir_in_bounds_1307
ir_trap_bounds_1306:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct459]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1307:
    ; Load variable: len
    movsxd rax, dword [rbp - 816]  ; From stack [rbp - 816]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1888], rax
    ; Load variable: line_buf
    lea rax, [rbp - 808]  ; Local array base
    push rax
    mov rax, [rbp - 1888]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1896], rax
    mov rax, [rbp - 1896]
    movzx rax, byte [rax]
    mov [rbp - 1904], rax
    mov rax, [rbp - 1904]
    push rax
    mov rax, 10
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 1912], rax
    mov rax, [rbp - 1912]
    test rax, rax
    jz ir_sc_false_1304
ir_sc_true_1303:
    mov rax, 1
    mov [rbp - 1920], rax
    jmp ir_sc_end_1305
ir_sc_false_1304:
    mov rax, 0
    mov [rbp - 1920], rax
ir_sc_end_1305:
    mov rax, [rbp - 1920]
    test rax, rax
    jz ir_sc_false_1310
ir_sc_rhs_1308:
    ; Load variable: len
    movsxd rax, dword [rbp - 816]  ; From stack [rbp - 816]
    push rax
    mov rax, 2048
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1936], rax
    mov rax, [rbp - 1936]
    test rax, rax
    jz ir_trap_bounds_1312
    jmp ir_in_bounds_1313
ir_trap_bounds_1312:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct461]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1313:
    ; Load variable: len
    movsxd rax, dword [rbp - 816]  ; From stack [rbp - 816]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1944], rax
    ; Load variable: line_buf
    lea rax, [rbp - 808]  ; Local array base
    push rax
    mov rax, [rbp - 1944]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1952], rax
    mov rax, [rbp - 1952]
    movzx rax, byte [rax]
    mov [rbp - 1960], rax
    mov rax, [rbp - 1960]
    push rax
    mov rax, 13
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 1968], rax
    mov rax, [rbp - 1968]
    test rax, rax
    jz ir_sc_false_1310
ir_sc_true_1309:
    mov rax, 1
    mov [rbp - 1976], rax
    jmp ir_sc_end_1311
ir_sc_false_1310:
    mov rax, 0
    mov [rbp - 1976], rax
ir_sc_end_1311:
    mov rax, [rbp - 1976]
    test rax, rax
    jz ir_while_end_1299
    ; Load variable: len
    movsxd rax, dword [rbp - 816]  ; From stack [rbp - 816]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1992], rax
    mov rax, [rbp - 1992]
    ; Store to variable: len
    mov dword [rbp - 816], eax  ; To stack [rbp - 816]
    jmp ir_while_1298
ir_while_end_1299:
    ; Load variable: len
    movsxd rax, dword [rbp - 816]  ; From stack [rbp - 816]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setg al
    movzx rax, al
    mov [rbp - 2000], rax
    mov rax, [rbp - 2000]
    test rax, rax
    jz ir_if_next_1315
    mov rax, 1
    ; Store to variable: had_posts
    mov dword [rbp - 860], eax  ; To stack [rbp - 860]
    ; Load variable: FORUM_POST_OPEN
    lea rax, [rel FORUM_POST_OPEN]  ; Address of global string
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2008], rax
    mov rax, [rbp - 2008]
    mov rax, qword [rax]
    mov [rbp - 2016], rax
    ; Load variable: FORUM_POST_OPEN
    lea rax, [rel FORUM_POST_OPEN]  ; Address of global string
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2024], rax
    mov rax, [rbp - 2024]
    mov rax, qword [rax]
    mov [rbp - 2032], rax
    ; IR call: send_all (3 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    mov rax, [rbp - 2016]
    mov rdx, rax
    mov rax, [rbp - 2032]
    mov r8, rax
    call send_all
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 2040], rax
    mov rax, 0
    push rax
    mov rax, 2048
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 2048], rax
    mov rax, [rbp - 2048]
    test rax, rax
    jz ir_trap_bounds_1316
    jmp ir_in_bounds_1317
ir_trap_bounds_1316:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct463]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1317:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 2056], rax
    ; Load variable: line_buf
    lea rax, [rbp - 808]  ; Local array base
    push rax
    mov rax, [rbp - 2056]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2064], rax
    ; IR call: send_html_escaped (3 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    mov rax, [rbp - 2064]
    mov rdx, rax
    ; Load variable: len
    movsxd rax, dword [rbp - 816]  ; From stack [rbp - 816]
    mov r8, rax
    call send_html_escaped
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 2072], rax
    ; Load variable: FORUM_POST_CLOSE
    lea rax, [rel FORUM_POST_CLOSE]  ; Address of global string
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2080], rax
    mov rax, [rbp - 2080]
    mov rax, qword [rax]
    mov [rbp - 2088], rax
    ; Load variable: FORUM_POST_CLOSE
    lea rax, [rel FORUM_POST_CLOSE]  ; Address of global string
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2096], rax
    mov rax, [rbp - 2096]
    mov rax, qword [rax]
    mov [rbp - 2104], rax
    ; IR call: send_all (3 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    mov rax, [rbp - 2088]
    mov rdx, rax
    mov rax, [rbp - 2104]
    mov r8, rax
    call send_all
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 2112], rax
    jmp ir_if_end_1314
ir_if_next_1315:
ir_if_end_1314:
    jmp ir_while_1294
ir_while_end_1295:
    ; IR call: fclose (1 args)
    sub rsp, 32
    ; Load variable: fp
    mov rax, qword [rbp - 296]  ; From stack [rbp - 296]
    mov rcx, rax
    call fclose
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 2120], rax
    jmp ir_if_end_1292
ir_if_next_1293:
ir_if_end_1292:
    ; Load variable: had_posts
    movsxd rax, dword [rbp - 860]  ; From stack [rbp - 860]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 2128], rax
    mov rax, [rbp - 2128]
    test rax, rax
    jz ir_if_next_1319
    ; Load variable: FORUM_NO_POSTS
    lea rax, [rel FORUM_NO_POSTS]  ; Address of global string
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2136], rax
    mov rax, [rbp - 2136]
    mov rax, qword [rax]
    mov [rbp - 2144], rax
    ; Load variable: FORUM_NO_POSTS
    lea rax, [rel FORUM_NO_POSTS]  ; Address of global string
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2152], rax
    mov rax, [rbp - 2152]
    mov rax, qword [rax]
    mov [rbp - 2160], rax
    ; IR call: send_all (3 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    mov rax, [rbp - 2144]
    mov rdx, rax
    mov rax, [rbp - 2160]
    mov r8, rax
    call send_all
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 2168], rax
    jmp ir_if_end_1318
ir_if_next_1319:
ir_if_end_1318:
    ; Load variable: FORUM_THREAD_END
    lea rax, [rel FORUM_THREAD_END]  ; Address of global string
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2176], rax
    mov rax, [rbp - 2176]
    mov rax, qword [rax]
    mov [rbp - 2184], rax
    ; Load variable: FORUM_THREAD_END
    lea rax, [rel FORUM_THREAD_END]  ; Address of global string
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2192], rax
    mov rax, [rbp - 2192]
    mov rax, qword [rax]
    mov [rbp - 2200], rax
    ; IR call: send_all (3 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    mov rax, [rbp - 2184]
    mov rdx, rax
    mov rax, [rbp - 2200]
    mov r8, rax
    call send_all
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 2208], rax
    mov rax, 0
    push rax
    mov rax, 16
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 2216], rax
    mov rax, [rbp - 2216]
    test rax, rax
    jz ir_trap_bounds_1320
    jmp ir_in_bounds_1321
ir_trap_bounds_1320:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct465]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1321:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 2224], rax
    ; Load variable: id_buf
    lea rax, [rbp - 880]  ; Local array base
    push rax
    mov rax, [rbp - 2224]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2232], rax
    ; IR call: int_to_dec (2 args)
    sub rsp, 32
    mov rax, [rbp - 2232]
    mov rcx, rax
    ; Load variable: thread_id
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    mov rdx, rax
    call int_to_dec
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 2240], rax
    mov rax, [rbp - 2240]
    ; Store to variable: dc
    mov dword [rbp - 884], eax  ; To stack [rbp - 884]
    mov rax, 0
    push rax
    mov rax, 16
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 2248], rax
    mov rax, [rbp - 2248]
    test rax, rax
    jz ir_trap_bounds_1322
    jmp ir_in_bounds_1323
ir_trap_bounds_1322:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct467]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1323:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 2256], rax
    ; Load variable: id_buf
    lea rax, [rbp - 880]  ; Local array base
    push rax
    mov rax, [rbp - 2256]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2264], rax
    ; IR call: send_all (3 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    mov rax, [rbp - 2264]
    mov rdx, rax
    ; Load variable: dc
    movsxd rax, dword [rbp - 884]  ; From stack [rbp - 884]
    mov r8, rax
    call send_all
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 2272], rax
    ; Load variable: FORUM_THREAD_END2
    lea rax, [rel FORUM_THREAD_END2]  ; Address of global string
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2280], rax
    mov rax, [rbp - 2280]
    mov rax, qword [rax]
    mov [rbp - 2288], rax
    ; Load variable: FORUM_THREAD_END2
    lea rax, [rel FORUM_THREAD_END2]  ; Address of global string
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2296], rax
    mov rax, [rbp - 2296]
    mov rax, qword [rax]
    mov [rbp - 2304], rax
    ; IR call: send_all (3 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    mov rax, [rbp - 2288]
    mov rdx, rax
    mov rax, [rbp - 2304]
    mov r8, rax
    call send_all
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 2312], rax
    mov rax, 0
    mov [rbp - 2320], rax
    mov rax, [rbp - 2320]
    test rax, rax
    jz ir_errdefer_ok_1324
    jmp ir_errdefer_end_1325
ir_errdefer_ok_1324:
ir_errdefer_end_1325:
    jmp Lserve_forum_thread_exit
Lserve_forum_thread_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global handle_post_new_thread

handle_post_new_thread:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 1552    ; Allocate 1552 bytes on stack (aligned)
    ; Registering 3 function parameters
    mov [rbp - 8], rcx  ; Home param 'client'
    ; Parameter 'client' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'buf'
    ; Parameter 'buf' arrived in register rdx
    mov [rbp - 24], r8  ; Home param 'n'
    ; Parameter 'n' arrived in register r8
ir_entry_1326:
    ; IR call: find_body_start (2 args)
    sub rsp, 32
    ; Load variable: buf
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov rcx, rax
    ; Load variable: n
    movsxd rax, dword [rbp - 24]  ; From stack [rbp - 24]
    mov rdx, rax
    call find_body_start
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 352], rax
    mov rax, [rbp - 352]
    ; Store to variable: body_start
    mov dword [rbp - 28], eax  ; To stack [rbp - 28]
    ; Load variable: n
    movsxd rax, dword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    ; Load variable: body_start
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 360], rax
    mov rax, [rbp - 360]
    ; Store to variable: body_len
    mov dword [rbp - 32], eax  ; To stack [rbp - 32]
    ; Load variable: dbg_on
    movsxd rax, dword [rel dbg_on]  ; From global memory
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 368], rax
    mov rax, [rbp - 368]
    test rax, rax
    jz ir_if_next_1328
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: dbg_bs
    lea rax, [rel dbg_bs]  ; Address of global string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 376], rax
    ; IR call: dbg (2 args)
    sub rsp, 32
    mov rax, [rbp - 376]
    mov rcx, rax
    ; Load variable: body_start
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    mov rdx, rax
    call dbg
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 384], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: dbg_bl
    lea rax, [rel dbg_bl]  ; Address of global string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 392], rax
    ; IR call: dbg (2 args)
    sub rsp, 32
    mov rax, [rbp - 392]
    mov rcx, rax
    ; Load variable: body_len
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    mov rdx, rax
    call dbg
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 400], rax
    jmp ir_if_end_1327
ir_if_next_1328:
ir_if_end_1327:
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: key_title
    lea rax, [rel key_title]  ; Address of global string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 408], rax
    mov rax, 0
    push rax
    mov rax, 256
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 416], rax
    mov rax, [rbp - 416]
    test rax, rax
    jz ir_trap_bounds_1329
    jmp ir_in_bounds_1330
ir_trap_bounds_1329:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct469]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1330:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 424], rax
    ; Load variable: title_buf
    lea rax, [rbp - 288]  ; Local array base
    push rax
    mov rax, [rbp - 424]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 432], rax
    ; IR call: extract_form_value (7 args)
    sub rsp, 64
    mov rax, 5
    mov [rsp + 32], rax
    mov rax, [rbp - 432]
    mov [rsp + 40], rax
    mov rax, 256
    mov [rsp + 48], rax
    ; Load variable: buf
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov rcx, rax
    ; Load variable: body_start
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    mov rdx, rax
    ; Load variable: body_len
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    mov r8, rax
    mov rax, [rbp - 408]
    mov r9, rax
    call extract_form_value
    add rsp, 64
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 440], rax
    mov rax, [rbp - 440]
    ; Store to variable: got
    mov dword [rbp - 292], eax  ; To stack [rbp - 292]
    ; Load variable: dbg_on
    movsxd rax, dword [rel dbg_on]  ; From global memory
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 448], rax
    mov rax, [rbp - 448]
    test rax, rax
    jz ir_if_next_1332
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: dbg_title
    lea rax, [rel dbg_title]  ; Address of global string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 456], rax
    ; IR call: dbg (2 args)
    sub rsp, 32
    mov rax, [rbp - 456]
    mov rcx, rax
    ; Load variable: got
    movsxd rax, dword [rbp - 292]  ; From stack [rbp - 292]
    mov rdx, rax
    call dbg
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 464], rax
    jmp ir_if_end_1331
ir_if_next_1332:
ir_if_end_1331:
    ; Load variable: got
    movsxd rax, dword [rbp - 292]  ; From stack [rbp - 292]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setg al
    movzx rax, al
    mov [rbp - 472], rax
    mov rax, [rbp - 472]
    test rax, rax
    jz ir_if_next_1334
    ; IR call: count_threads (0 args)
    sub rsp, 32
    call count_threads
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 480], rax
    mov rax, [rbp - 480]
    ; Store to variable: count
    mov dword [rbp - 296], eax  ; To stack [rbp - 296]
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: fn_threads
    lea rax, [rel fn_threads]  ; Address of global string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 488], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: mode_a
    lea rax, [rel mode_a]  ; Address of global string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 496], rax
    ; IR call: fopen (2 args)
    sub rsp, 32
    mov rax, [rbp - 488]
    mov rcx, rax
    mov rax, [rbp - 496]
    mov rdx, rax
    call fopen
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 504], rax
    mov rax, [rbp - 504]
    ; Store to variable: fp
    mov qword [rbp - 304], rax  ; To stack [rbp - 304]
    ; Load variable: dbg_on
    movsxd rax, dword [rel dbg_on]  ; From global memory
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 512], rax
    mov rax, [rbp - 512]
    test rax, rax
    jz ir_if_next_1336
    ; Load variable: fp
    mov rax, qword [rbp - 304]  ; From stack [rbp - 304]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 520], rax
    mov rax, [rbp - 520]
    test rax, rax
    jz ir_if_next_1338
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: dbg_fopen_ok
    lea rax, [rel dbg_fopen_ok]  ; Address of global string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 528], rax
    ; IR call: dbg_msg (1 args)
    sub rsp, 32
    mov rax, [rbp - 528]
    mov rcx, rax
    call dbg_msg
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 536], rax
    jmp ir_if_end_1337
ir_if_next_1338:
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: dbg_fopen_fail
    lea rax, [rel dbg_fopen_fail]  ; Address of global string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 544], rax
    ; IR call: dbg_msg (1 args)
    sub rsp, 32
    mov rax, [rbp - 544]
    mov rcx, rax
    call dbg_msg
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 552], rax
ir_if_end_1337:
    jmp ir_if_end_1335
ir_if_next_1336:
ir_if_end_1335:
    ; Load variable: fp
    mov rax, qword [rbp - 304]  ; From stack [rbp - 304]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 560], rax
    mov rax, [rbp - 560]
    test rax, rax
    jz ir_if_next_1340
    mov rax, 0
    push rax
    mov rax, 256
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 568], rax
    mov rax, [rbp - 568]
    test rax, rax
    jz ir_trap_bounds_1341
    jmp ir_in_bounds_1342
ir_trap_bounds_1341:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct471]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1342:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 576], rax
    ; Load variable: title_buf
    lea rax, [rbp - 288]  ; Local array base
    push rax
    mov rax, [rbp - 576]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 584], rax
    ; IR call: fputs (2 args)
    sub rsp, 32
    mov rax, [rbp - 584]
    mov rcx, rax
    ; Load variable: fp
    mov rax, qword [rbp - 304]  ; From stack [rbp - 304]
    mov rdx, rax
    call fputs
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 592], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: nl
    lea rax, [rel nl]  ; Address of global string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 600], rax
    ; IR call: fputs (2 args)
    sub rsp, 32
    mov rax, [rbp - 600]
    mov rcx, rax
    ; Load variable: fp
    mov rax, qword [rbp - 304]  ; From stack [rbp - 304]
    mov rdx, rax
    call fputs
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 608], rax
    ; IR call: fclose (1 args)
    sub rsp, 32
    ; Load variable: fp
    mov rax, qword [rbp - 304]  ; From stack [rbp - 304]
    mov rcx, rax
    call fclose
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 616], rax
    ; Load variable: count
    movsxd rax, dword [rbp - 296]  ; From stack [rbp - 296]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 624], rax
    mov rax, [rbp - 624]
    ; Store to variable: new_id
    mov dword [rbp - 308], eax  ; To stack [rbp - 308]
    mov rax, 0
    push rax
    mov rax, 32
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 632], rax
    mov rax, [rbp - 632]
    test rax, rax
    jz ir_trap_bounds_1343
    jmp ir_in_bounds_1344
ir_trap_bounds_1343:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct473]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1344:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 640], rax
    ; Load variable: loc_buf
    lea rax, [rbp - 344]  ; Local array base
    push rax
    mov rax, [rbp - 640]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 648], rax
    ; IR call: build_forum_thread_url (2 args)
    sub rsp, 32
    mov rax, [rbp - 648]
    mov rcx, rax
    ; Load variable: new_id
    movsxd rax, dword [rbp - 308]  ; From stack [rbp - 308]
    mov rdx, rax
    call build_forum_thread_url
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 656], rax
    mov rax, 0
    push rax
    mov rax, 32
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 664], rax
    mov rax, [rbp - 664]
    test rax, rax
    jz ir_trap_bounds_1345
    jmp ir_in_bounds_1346
ir_trap_bounds_1345:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct475]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1346:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 672], rax
    ; Load variable: loc_buf
    lea rax, [rbp - 344]  ; Local array base
    push rax
    mov rax, [rbp - 672]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 680], rax
    ; IR call: send_redirect (2 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    mov rax, [rbp - 680]
    mov rdx, rax
    call send_redirect
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 688], rax
    mov rax, 0
    mov [rbp - 696], rax
    mov rax, [rbp - 696]
    test rax, rax
    jz ir_errdefer_ok_1347
    jmp ir_errdefer_end_1348
ir_errdefer_ok_1347:
ir_errdefer_end_1348:
    jmp Lhandle_post_new_thread_exit
    jmp ir_if_end_1339
ir_if_next_1340:
ir_if_end_1339:
    jmp ir_if_end_1333
ir_if_next_1334:
ir_if_end_1333:
    ; Load variable: got
    movsxd rax, dword [rbp - 292]  ; From stack [rbp - 292]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 704], rax
    ; IR call: serve_forum_index (2 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    mov rax, [rbp - 704]
    mov rdx, rax
    call serve_forum_index
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 712], rax
    mov rax, 0
    mov [rbp - 720], rax
    mov rax, [rbp - 720]
    test rax, rax
    jz ir_errdefer_ok_1349
    jmp ir_errdefer_end_1350
ir_errdefer_ok_1349:
ir_errdefer_end_1350:
    jmp Lhandle_post_new_thread_exit
Lhandle_post_new_thread_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global handle_post_reply

handle_post_reply:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 3376    ; Allocate 3376 bytes on stack (aligned)
    ; Registering 4 function parameters
    mov [rbp - 8], rcx  ; Home param 'client'
    ; Parameter 'client' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'buf'
    ; Parameter 'buf' arrived in register rdx
    mov [rbp - 24], r8  ; Home param 'n'
    ; Parameter 'n' arrived in register r8
    mov [rbp - 32], r9  ; Home param 'thread_id'
    ; Parameter 'thread_id' arrived in register r9
ir_entry_1351:
    ; IR call: find_body_start (2 args)
    sub rsp, 32
    ; Load variable: buf
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov rcx, rax
    ; Load variable: n
    movsxd rax, dword [rbp - 24]  ; From stack [rbp - 24]
    mov rdx, rax
    call find_body_start
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 2176], rax
    mov rax, [rbp - 2176]
    ; Store to variable: body_start
    mov dword [rbp - 36], eax  ; To stack [rbp - 36]
    ; Load variable: n
    movsxd rax, dword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    ; Load variable: body_start
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 2184], rax
    mov rax, [rbp - 2184]
    ; Store to variable: body_len
    mov dword [rbp - 40], eax  ; To stack [rbp - 40]
    ; Load variable: dbg_on
    movsxd rax, dword [rel dbg_on]  ; From global memory
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 2192], rax
    mov rax, [rbp - 2192]
    test rax, rax
    jz ir_if_next_1353
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: dbg_bs
    lea rax, [rel dbg_bs]  ; Address of global string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 2200], rax
    ; IR call: dbg (2 args)
    sub rsp, 32
    mov rax, [rbp - 2200]
    mov rcx, rax
    ; Load variable: body_start
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    mov rdx, rax
    call dbg
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 2208], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: dbg_bl
    lea rax, [rel dbg_bl]  ; Address of global string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 2216], rax
    ; IR call: dbg (2 args)
    sub rsp, 32
    mov rax, [rbp - 2216]
    mov rcx, rax
    ; Load variable: body_len
    movsxd rax, dword [rbp - 40]  ; From stack [rbp - 40]
    mov rdx, rax
    call dbg
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 2224], rax
    jmp ir_if_end_1352
ir_if_next_1353:
ir_if_end_1352:
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: key_body
    lea rax, [rel key_body]  ; Address of global string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 2232], rax
    mov rax, 0
    push rax
    mov rax, 2048
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 2240], rax
    mov rax, [rbp - 2240]
    test rax, rax
    jz ir_trap_bounds_1354
    jmp ir_in_bounds_1355
ir_trap_bounds_1354:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct477]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1355:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 2248], rax
    ; Load variable: post_buf
    lea rax, [rbp - 2088]  ; Local array base
    push rax
    mov rax, [rbp - 2248]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2256], rax
    ; IR call: extract_form_value (7 args)
    sub rsp, 64
    mov rax, 4
    mov [rsp + 32], rax
    mov rax, [rbp - 2256]
    mov [rsp + 40], rax
    mov rax, 2048
    mov [rsp + 48], rax
    ; Load variable: buf
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov rcx, rax
    ; Load variable: body_start
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    mov rdx, rax
    ; Load variable: body_len
    movsxd rax, dword [rbp - 40]  ; From stack [rbp - 40]
    mov r8, rax
    mov rax, [rbp - 2232]
    mov r9, rax
    call extract_form_value
    add rsp, 64
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 2264], rax
    mov rax, [rbp - 2264]
    ; Store to variable: got
    mov dword [rbp - 2092], eax  ; To stack [rbp - 2092]
    ; Load variable: dbg_on
    movsxd rax, dword [rel dbg_on]  ; From global memory
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 2272], rax
    mov rax, [rbp - 2272]
    test rax, rax
    jz ir_if_next_1357
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: dbg_title
    lea rax, [rel dbg_title]  ; Address of global string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 2280], rax
    ; IR call: dbg (2 args)
    sub rsp, 32
    mov rax, [rbp - 2280]
    mov rcx, rax
    ; Load variable: got
    movsxd rax, dword [rbp - 2092]  ; From stack [rbp - 2092]
    mov rdx, rax
    call dbg
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 2288], rax
    jmp ir_if_end_1356
ir_if_next_1357:
ir_if_end_1356:
    ; Load variable: got
    movsxd rax, dword [rbp - 2092]  ; From stack [rbp - 2092]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setg al
    movzx rax, al
    mov [rbp - 2296], rax
    mov rax, [rbp - 2296]
    test rax, rax
    jz ir_if_next_1359
    mov rax, 0
    push rax
    mov rax, 32
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 2304], rax
    mov rax, [rbp - 2304]
    test rax, rax
    jz ir_trap_bounds_1360
    jmp ir_in_bounds_1361
ir_trap_bounds_1360:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct479]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1361:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 2312], rax
    ; Load variable: posts_fn
    lea rax, [rbp - 2128]  ; Local array base
    push rax
    mov rax, [rbp - 2312]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2320], rax
    ; IR call: build_posts_filename (2 args)
    sub rsp, 32
    mov rax, [rbp - 2320]
    mov rcx, rax
    ; Load variable: thread_id
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    mov rdx, rax
    call build_posts_filename
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 2328], rax
    mov rax, 0
    push rax
    mov rax, 32
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 2336], rax
    mov rax, [rbp - 2336]
    test rax, rax
    jz ir_trap_bounds_1362
    jmp ir_in_bounds_1363
ir_trap_bounds_1362:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct481]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1363:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 2344], rax
    ; Load variable: posts_fn
    lea rax, [rbp - 2128]  ; Local array base
    push rax
    mov rax, [rbp - 2344]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2352], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: mode_a
    lea rax, [rel mode_a]  ; Address of global string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 2360], rax
    ; IR call: fopen (2 args)
    sub rsp, 32
    mov rax, [rbp - 2352]
    mov rcx, rax
    mov rax, [rbp - 2360]
    mov rdx, rax
    call fopen
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 2368], rax
    mov rax, [rbp - 2368]
    ; Store to variable: fp
    mov qword [rbp - 2136], rax  ; To stack [rbp - 2136]
    ; Load variable: dbg_on
    movsxd rax, dword [rel dbg_on]  ; From global memory
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 2376], rax
    mov rax, [rbp - 2376]
    test rax, rax
    jz ir_if_next_1365
    ; Load variable: fp
    mov rax, qword [rbp - 2136]  ; From stack [rbp - 2136]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 2384], rax
    mov rax, [rbp - 2384]
    test rax, rax
    jz ir_if_next_1367
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: dbg_fopen_ok
    lea rax, [rel dbg_fopen_ok]  ; Address of global string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 2392], rax
    ; IR call: dbg_msg (1 args)
    sub rsp, 32
    mov rax, [rbp - 2392]
    mov rcx, rax
    call dbg_msg
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 2400], rax
    jmp ir_if_end_1366
ir_if_next_1367:
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: dbg_fopen_fail
    lea rax, [rel dbg_fopen_fail]  ; Address of global string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 2408], rax
    ; IR call: dbg_msg (1 args)
    sub rsp, 32
    mov rax, [rbp - 2408]
    mov rcx, rax
    call dbg_msg
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 2416], rax
ir_if_end_1366:
    jmp ir_if_end_1364
ir_if_next_1365:
ir_if_end_1364:
    ; Load variable: fp
    mov rax, qword [rbp - 2136]  ; From stack [rbp - 2136]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 2424], rax
    mov rax, [rbp - 2424]
    test rax, rax
    jz ir_if_next_1369
    mov rax, 0
    push rax
    mov rax, 2048
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 2432], rax
    mov rax, [rbp - 2432]
    test rax, rax
    jz ir_trap_bounds_1370
    jmp ir_in_bounds_1371
ir_trap_bounds_1370:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct483]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1371:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 2440], rax
    ; Load variable: post_buf
    lea rax, [rbp - 2088]  ; Local array base
    push rax
    mov rax, [rbp - 2440]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2448], rax
    ; IR call: fputs (2 args)
    sub rsp, 32
    mov rax, [rbp - 2448]
    mov rcx, rax
    ; Load variable: fp
    mov rax, qword [rbp - 2136]  ; From stack [rbp - 2136]
    mov rdx, rax
    call fputs
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 2456], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: nl
    lea rax, [rel nl]  ; Address of global string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 2464], rax
    ; IR call: fputs (2 args)
    sub rsp, 32
    mov rax, [rbp - 2464]
    mov rcx, rax
    ; Load variable: fp
    mov rax, qword [rbp - 2136]  ; From stack [rbp - 2136]
    mov rdx, rax
    call fputs
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 2472], rax
    ; IR call: fclose (1 args)
    sub rsp, 32
    ; Load variable: fp
    mov rax, qword [rbp - 2136]  ; From stack [rbp - 2136]
    mov rcx, rax
    call fclose
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 2480], rax
    jmp ir_if_end_1368
ir_if_next_1369:
ir_if_end_1368:
    jmp ir_if_end_1358
ir_if_next_1359:
ir_if_end_1358:
    mov rax, 0
    push rax
    mov rax, 32
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 2488], rax
    mov rax, [rbp - 2488]
    test rax, rax
    jz ir_trap_bounds_1372
    jmp ir_in_bounds_1373
ir_trap_bounds_1372:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct485]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1373:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 2496], rax
    ; Load variable: loc_buf
    lea rax, [rbp - 2168]  ; Local array base
    push rax
    mov rax, [rbp - 2496]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2504], rax
    ; IR call: build_forum_thread_url (2 args)
    sub rsp, 32
    mov rax, [rbp - 2504]
    mov rcx, rax
    ; Load variable: thread_id
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    mov rdx, rax
    call build_forum_thread_url
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 2512], rax
    mov rax, 0
    push rax
    mov rax, 32
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 2520], rax
    mov rax, [rbp - 2520]
    test rax, rax
    jz ir_trap_bounds_1374
    jmp ir_in_bounds_1375
ir_trap_bounds_1374:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct487]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1375:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 2528], rax
    ; Load variable: loc_buf
    lea rax, [rbp - 2168]  ; Local array base
    push rax
    mov rax, [rbp - 2528]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2536], rax
    ; IR call: send_redirect (2 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    mov rax, [rbp - 2536]
    mov rdx, rax
    call send_redirect
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 2544], rax
    mov rax, 0
    mov [rbp - 2552], rax
    mov rax, [rbp - 2552]
    test rax, rax
    jz ir_errdefer_ok_1376
    jmp ir_errdefer_end_1377
ir_errdefer_ok_1376:
ir_errdefer_end_1377:
    jmp Lhandle_post_reply_exit
Lhandle_post_reply_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global main

main:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    mov rax, 11680
    extern ___chkstk_ms
    sub rsp, 32
    call ___chkstk_ms
    add rsp, 32
    sub rsp, rax    ; Allocate 11680 bytes on stack (probed)
    ; Registering 0 function parameters
ir_entry_1378:
    ; IR call: gc_init (0 args)
    sub rsp, 32
    call gc_init
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 4192], rax
    mov rax, 11
    neg rax
    mov [rbp - 4200], rax
    ; IR call: GetStdHandle (1 args)
    sub rsp, 32
    mov rax, [rbp - 4200]
    mov rcx, rax
    call GetStdHandle
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 4208], rax
    mov rax, [rbp - 4208]
    ; Store to variable: out_handle
    mov qword [rbp - 8], rax  ; To stack [rbp - 8]
    ; Load variable: out_handle
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 4216], rax
    mov rax, [rbp - 4216]
    test rax, rax
    jz ir_sc_rhs_1381
    jmp ir_sc_true_1382
ir_sc_rhs_1381:
    mov rax, 1
    neg rax
    mov [rbp - 4224], rax
    ; Load variable: out_handle
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 4224]
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 4232], rax
    mov rax, [rbp - 4232]
    test rax, rax
    jz ir_sc_false_1383
ir_sc_true_1382:
    mov rax, 1
    mov [rbp - 4240], rax
    jmp ir_sc_end_1384
ir_sc_false_1383:
    mov rax, 0
    mov [rbp - 4240], rax
ir_sc_end_1384:
    mov rax, [rbp - 4240]
    test rax, rax
    jz ir_if_next_1380
    ; IR call: AllocConsole (0 args)
    sub rsp, 32
    call AllocConsole
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 4256], rax
    jmp ir_if_end_1379
ir_if_next_1380:
ir_if_end_1379:
    ; IR call: net_init (0 args)
    sub rsp, 32
    call net_init
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 4264], rax
    mov rax, [rbp - 4264]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 4272], rax
    mov rax, [rbp - 4272]
    test rax, rax
    jz ir_if_next_1386
    ; IR call: con_writeln (1 args)
    sub rsp, 32
    ; Load variable: err_net_init
    lea rax, [rel err_net_init]  ; Address of global string
    mov rcx, rax
    call con_writeln
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 4280], rax
    mov rax, 1
    mov [rbp - 4288], rax
    mov rax, [rbp - 4288]
    test rax, rax
    jz ir_errdefer_ok_1387
    jmp ir_errdefer_end_1388
ir_errdefer_ok_1387:
ir_errdefer_end_1388:
    mov rax, 1
    jmp Lmain_exit
    jmp ir_if_end_1385
ir_if_next_1386:
ir_if_end_1385:
    ; IR call: socket_tcp (0 args)
    sub rsp, 32
    call socket_tcp
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 4296], rax
    mov rax, [rbp - 4296]
    ; Store to variable: sock
    mov qword [rbp - 16], rax  ; To stack [rbp - 16]
    ; IR call: INVALID_SOCKET (0 args)
    sub rsp, 32
    call INVALID_SOCKET
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 4304], rax
    ; Load variable: sock
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, [rbp - 4304]
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 4312], rax
    mov rax, [rbp - 4312]
    test rax, rax
    jz ir_if_next_1390
    ; IR call: con_writeln (1 args)
    sub rsp, 32
    ; Load variable: err_socket
    lea rax, [rel err_socket]  ; Address of global string
    mov rcx, rax
    call con_writeln
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 4320], rax
    ; IR call: net_cleanup (0 args)
    sub rsp, 32
    call net_cleanup
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 4328], rax
    mov rax, 1
    mov [rbp - 4336], rax
    mov rax, [rbp - 4336]
    test rax, rax
    jz ir_errdefer_ok_1391
    jmp ir_errdefer_end_1392
ir_errdefer_ok_1391:
ir_errdefer_end_1392:
    mov rax, 1
    jmp Lmain_exit
    jmp ir_if_end_1389
ir_if_next_1390:
ir_if_end_1389:
    ; IR call: set_reuseaddr (2 args)
    sub rsp, 32
    ; Load variable: sock
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov rcx, rax
    mov rax, 1
    mov rdx, rax
    call set_reuseaddr
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 4344], rax
    mov rax, [rbp - 4344]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 4352], rax
    mov rax, [rbp - 4352]
    test rax, rax
    jz ir_if_next_1394
    ; IR call: con_writeln (1 args)
    sub rsp, 32
    ; Load variable: err_reuseaddr
    lea rax, [rel err_reuseaddr]  ; Address of global string
    mov rcx, rax
    call con_writeln
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 4360], rax
    ; IR call: closesocket (1 args)
    sub rsp, 32
    ; Load variable: sock
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov rcx, rax
    call closesocket
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 4368], rax
    ; IR call: net_cleanup (0 args)
    sub rsp, 32
    call net_cleanup
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 4376], rax
    mov rax, 1
    mov [rbp - 4384], rax
    mov rax, [rbp - 4384]
    test rax, rax
    jz ir_errdefer_ok_1395
    jmp ir_errdefer_end_1396
ir_errdefer_ok_1395:
ir_errdefer_end_1396:
    mov rax, 1
    jmp Lmain_exit
    jmp ir_if_end_1393
ir_if_next_1394:
ir_if_end_1393:
    ; IR call: sockaddr_in_any (1 args)
    sub rsp, 32
    mov rax, 5000
    mov rcx, rax
    call sockaddr_in_any
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 4392], rax
    mov rax, [rbp - 4392]
    ; Store to variable: addr
    mov qword [rbp - 24], rax  ; To stack [rbp - 24]
    ; Load variable: addr
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 4400], rax
    mov rax, [rbp - 4400]
    test rax, rax
    jz ir_if_next_1398
    ; IR call: con_writeln (1 args)
    sub rsp, 32
    ; Load variable: err_sockaddr
    lea rax, [rel err_sockaddr]  ; Address of global string
    mov rcx, rax
    call con_writeln
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 4408], rax
    ; IR call: closesocket (1 args)
    sub rsp, 32
    ; Load variable: sock
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov rcx, rax
    call closesocket
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 4416], rax
    ; IR call: net_cleanup (0 args)
    sub rsp, 32
    call net_cleanup
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 4424], rax
    mov rax, 1
    mov [rbp - 4432], rax
    mov rax, [rbp - 4432]
    test rax, rax
    jz ir_errdefer_ok_1399
    jmp ir_errdefer_end_1400
ir_errdefer_ok_1399:
ir_errdefer_end_1400:
    mov rax, 1
    jmp Lmain_exit
    jmp ir_if_end_1397
ir_if_next_1398:
ir_if_end_1397:
    ; IR call: bind (3 args)
    sub rsp, 32
    ; Load variable: sock
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov rcx, rax
    ; Load variable: addr
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov rdx, rax
    mov rax, 16
    mov r8, rax
    call bind
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 4440], rax
    mov rax, [rbp - 4440]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 4448], rax
    mov rax, [rbp - 4448]
    test rax, rax
    jz ir_if_next_1402
    ; IR call: con_writeln (1 args)
    sub rsp, 32
    ; Load variable: err_bind
    lea rax, [rel err_bind]  ; Address of global string
    mov rcx, rax
    call con_writeln
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 4456], rax
    ; IR call: free (1 args)
    sub rsp, 32
    ; Load variable: addr
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov rcx, rax
    call free
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 4464], rax
    ; IR call: closesocket (1 args)
    sub rsp, 32
    ; Load variable: sock
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov rcx, rax
    call closesocket
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 4472], rax
    ; IR call: net_cleanup (0 args)
    sub rsp, 32
    call net_cleanup
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 4480], rax
    mov rax, 1
    mov [rbp - 4488], rax
    mov rax, [rbp - 4488]
    test rax, rax
    jz ir_errdefer_ok_1403
    jmp ir_errdefer_end_1404
ir_errdefer_ok_1403:
ir_errdefer_end_1404:
    mov rax, 1
    jmp Lmain_exit
    jmp ir_if_end_1401
ir_if_next_1402:
ir_if_end_1401:
    ; IR call: free (1 args)
    sub rsp, 32
    ; Load variable: addr
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov rcx, rax
    call free
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 4496], rax
    ; IR call: listen (2 args)
    sub rsp, 32
    ; Load variable: sock
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov rcx, rax
    mov rax, 5
    mov rdx, rax
    call listen
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 4504], rax
    mov rax, [rbp - 4504]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 4512], rax
    mov rax, [rbp - 4512]
    test rax, rax
    jz ir_if_next_1406
    ; IR call: con_writeln (1 args)
    sub rsp, 32
    ; Load variable: err_listen
    lea rax, [rel err_listen]  ; Address of global string
    mov rcx, rax
    call con_writeln
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 4520], rax
    ; IR call: closesocket (1 args)
    sub rsp, 32
    ; Load variable: sock
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov rcx, rax
    call closesocket
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 4528], rax
    ; IR call: net_cleanup (0 args)
    sub rsp, 32
    call net_cleanup
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 4536], rax
    mov rax, 1
    mov [rbp - 4544], rax
    mov rax, [rbp - 4544]
    test rax, rax
    jz ir_errdefer_ok_1407
    jmp ir_errdefer_end_1408
ir_errdefer_ok_1407:
ir_errdefer_end_1408:
    mov rax, 1
    jmp Lmain_exit
    jmp ir_if_end_1405
ir_if_next_1406:
ir_if_end_1405:
    ; IR call: con_writeln (1 args)
    sub rsp, 32
    ; Load variable: msg_ready
    lea rax, [rel msg_ready]  ; Address of global string
    mov rcx, rax
    call con_writeln
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 4552], rax
    mov rax, 0
    push rax
    mov rax, 4
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 4560], rax
    mov rax, [rbp - 4560]
    test rax, rax
    jz ir_trap_bounds_1409
    jmp ir_in_bounds_1410
ir_trap_bounds_1409:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct489]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1410:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 4568], rax
    ; Load variable: addrlen_buf
    lea rax, [rbp - 44]  ; Local array base
    push rax
    mov rax, [rbp - 4568]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 4576], rax
    mov rax, [rbp - 4576]
    push rax
    mov rax, 16
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    mov rax, 1
    push rax
    mov rax, 4
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 4592], rax
    mov rax, [rbp - 4592]
    test rax, rax
    jz ir_trap_bounds_1411
    jmp ir_in_bounds_1412
ir_trap_bounds_1411:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct491]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1412:
    mov rax, 1
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 4600], rax
    ; Load variable: addrlen_buf
    lea rax, [rbp - 44]  ; Local array base
    push rax
    mov rax, [rbp - 4600]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 4608], rax
    mov rax, [rbp - 4608]
    push rax
    mov rax, 0
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    mov rax, 2
    push rax
    mov rax, 4
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 4624], rax
    mov rax, [rbp - 4624]
    test rax, rax
    jz ir_trap_bounds_1413
    jmp ir_in_bounds_1414
ir_trap_bounds_1413:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct493]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1414:
    mov rax, 2
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 4632], rax
    ; Load variable: addrlen_buf
    lea rax, [rbp - 44]  ; Local array base
    push rax
    mov rax, [rbp - 4632]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 4640], rax
    mov rax, [rbp - 4640]
    push rax
    mov rax, 0
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    mov rax, 3
    push rax
    mov rax, 4
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 4656], rax
    mov rax, [rbp - 4656]
    test rax, rax
    jz ir_trap_bounds_1415
    jmp ir_in_bounds_1416
ir_trap_bounds_1415:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct495]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1416:
    mov rax, 3
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 4664], rax
    ; Load variable: addrlen_buf
    lea rax, [rbp - 44]  ; Local array base
    push rax
    mov rax, [rbp - 4664]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 4672], rax
    mov rax, [rbp - 4672]
    push rax
    mov rax, 0
    mov rcx, rax
    pop rax
    mov byte [rax], cl
ir_while_1417:
    mov rax, 1
    test rax, rax
    jz ir_while_end_1418
    mov rax, 0
    push rax
    mov rax, 4
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 4688], rax
    mov rax, [rbp - 4688]
    test rax, rax
    jz ir_trap_bounds_1419
    jmp ir_in_bounds_1420
ir_trap_bounds_1419:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct497]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1420:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 4696], rax
    ; Load variable: addrlen_buf
    lea rax, [rbp - 44]  ; Local array base
    push rax
    mov rax, [rbp - 4696]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 4704], rax
    mov rax, [rbp - 4704]
    push rax
    mov rax, 16
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    mov rax, 1
    push rax
    mov rax, 4
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 4720], rax
    mov rax, [rbp - 4720]
    test rax, rax
    jz ir_trap_bounds_1421
    jmp ir_in_bounds_1422
ir_trap_bounds_1421:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct499]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1422:
    mov rax, 1
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 4728], rax
    ; Load variable: addrlen_buf
    lea rax, [rbp - 44]  ; Local array base
    push rax
    mov rax, [rbp - 4728]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 4736], rax
    mov rax, [rbp - 4736]
    push rax
    mov rax, 0
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    mov rax, 2
    push rax
    mov rax, 4
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 4752], rax
    mov rax, [rbp - 4752]
    test rax, rax
    jz ir_trap_bounds_1423
    jmp ir_in_bounds_1424
ir_trap_bounds_1423:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct501]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1424:
    mov rax, 2
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 4760], rax
    ; Load variable: addrlen_buf
    lea rax, [rbp - 44]  ; Local array base
    push rax
    mov rax, [rbp - 4760]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 4768], rax
    mov rax, [rbp - 4768]
    push rax
    mov rax, 0
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    mov rax, 3
    push rax
    mov rax, 4
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 4784], rax
    mov rax, [rbp - 4784]
    test rax, rax
    jz ir_trap_bounds_1425
    jmp ir_in_bounds_1426
ir_trap_bounds_1425:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct503]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1426:
    mov rax, 3
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 4792], rax
    ; Load variable: addrlen_buf
    lea rax, [rbp - 44]  ; Local array base
    push rax
    mov rax, [rbp - 4792]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 4800], rax
    mov rax, [rbp - 4800]
    push rax
    mov rax, 0
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    mov rax, 0
    push rax
    mov rax, 16
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 4816], rax
    mov rax, [rbp - 4816]
    test rax, rax
    jz ir_trap_bounds_1427
    jmp ir_in_bounds_1428
ir_trap_bounds_1427:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct505]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1428:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 4824], rax
    ; Load variable: client_addr
    lea rax, [rbp - 40]  ; Local array base
    push rax
    mov rax, [rbp - 4824]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 4832], rax
    mov rax, 0
    push rax
    mov rax, 4
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 4840], rax
    mov rax, [rbp - 4840]
    test rax, rax
    jz ir_trap_bounds_1429
    jmp ir_in_bounds_1430
ir_trap_bounds_1429:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct507]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1430:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 4848], rax
    ; Load variable: addrlen_buf
    lea rax, [rbp - 44]  ; Local array base
    push rax
    mov rax, [rbp - 4848]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 4856], rax
    ; IR call: accept (3 args)
    sub rsp, 32
    ; Load variable: sock
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov rcx, rax
    mov rax, [rbp - 4832]
    mov rdx, rax
    mov rax, [rbp - 4856]
    mov r8, rax
    call accept
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 4864], rax
    mov rax, [rbp - 4864]
    ; Store to variable: client
    mov qword [rbp - 4152], rax  ; To stack [rbp - 4152]
    ; IR call: INVALID_SOCKET (0 args)
    sub rsp, 32
    call INVALID_SOCKET
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 4872], rax
    ; Load variable: client
    mov rax, qword [rbp - 4152]  ; From stack [rbp - 4152]
    push rax
    mov rax, [rbp - 4872]
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 4880], rax
    mov rax, [rbp - 4880]
    test rax, rax
    jz ir_if_next_1432
    jmp ir_while_1417
    jmp ir_if_end_1431
ir_if_next_1432:
ir_if_end_1431:
    mov rax, 0
    push rax
    mov rax, 4096
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 4888], rax
    mov rax, [rbp - 4888]
    test rax, rax
    jz ir_trap_bounds_1433
    jmp ir_in_bounds_1434
ir_trap_bounds_1433:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct509]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1434:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 4896], rax
    ; Load variable: recv_buf
    lea rax, [rbp - 4144]  ; Local array base
    push rax
    mov rax, [rbp - 4896]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 4904], rax
    ; IR call: recv (4 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 4152]  ; From stack [rbp - 4152]
    mov rcx, rax
    mov rax, [rbp - 4904]
    mov rdx, rax
    mov rax, 4096
    mov r8, rax
    mov rax, 0
    mov r9, rax
    call recv
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 4912], rax
    mov rax, [rbp - 4912]
    ; Store to variable: n
    mov dword [rbp - 4156], eax  ; To stack [rbp - 4156]
    ; Load variable: n
    movsxd rax, dword [rbp - 4156]  ; From stack [rbp - 4156]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setg al
    movzx rax, al
    mov [rbp - 4920], rax
    mov rax, [rbp - 4920]
    test rax, rax
    jz ir_if_next_1436
    mov rax, 0
    push rax
    mov rax, 4096
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 4928], rax
    mov rax, [rbp - 4928]
    test rax, rax
    jz ir_trap_bounds_1439
    jmp ir_in_bounds_1440
ir_trap_bounds_1439:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct511]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1440:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 4936], rax
    ; Load variable: recv_buf
    lea rax, [rbp - 4144]  ; Local array base
    push rax
    mov rax, [rbp - 4936]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 4944], rax
    ; IR call: is_post (2 args)
    sub rsp, 32
    mov rax, [rbp - 4944]
    mov rcx, rax
    ; Load variable: n
    movsxd rax, dword [rbp - 4156]  ; From stack [rbp - 4156]
    mov rdx, rax
    call is_post
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 4952], rax
    mov rax, [rbp - 4952]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 4960], rax
    mov rax, [rbp - 4960]
    test rax, rax
    jz ir_if_next_1438
    mov rax, 0
    push rax
    mov rax, 4096
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 4968], rax
    mov rax, [rbp - 4968]
    test rax, rax
    jz ir_trap_bounds_1441
    jmp ir_in_bounds_1442
ir_trap_bounds_1441:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct513]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1442:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 4976], rax
    ; Load variable: recv_buf
    lea rax, [rbp - 4144]  ; Local array base
    push rax
    mov rax, [rbp - 4976]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 4984], rax
    ; IR call: find_body_start (2 args)
    sub rsp, 32
    mov rax, [rbp - 4984]
    mov rcx, rax
    ; Load variable: n
    movsxd rax, dword [rbp - 4156]  ; From stack [rbp - 4156]
    mov rdx, rax
    call find_body_start
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 4992], rax
    mov rax, [rbp - 4992]
    ; Store to variable: body_start
    mov dword [rbp - 4160], eax  ; To stack [rbp - 4160]
    ; Load variable: dbg_on
    movsxd rax, dword [rel dbg_on]  ; From global memory
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 5000], rax
    mov rax, [rbp - 5000]
    test rax, rax
    jz ir_if_next_1444
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: dbg_post
    lea rax, [rel dbg_post]  ; Address of global string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 5008], rax
    ; IR call: dbg (2 args)
    sub rsp, 32
    mov rax, [rbp - 5008]
    mov rcx, rax
    ; Load variable: n
    movsxd rax, dword [rbp - 4156]  ; From stack [rbp - 4156]
    mov rdx, rax
    call dbg
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 5016], rax
    jmp ir_if_end_1443
ir_if_next_1444:
ir_if_end_1443:
    ; Load variable: dbg_on
    movsxd rax, dword [rel dbg_on]  ; From global memory
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 5024], rax
    mov rax, [rbp - 5024]
    test rax, rax
    jz ir_if_next_1446
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: dbg_bs
    lea rax, [rel dbg_bs]  ; Address of global string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 5032], rax
    ; IR call: dbg (2 args)
    sub rsp, 32
    mov rax, [rbp - 5032]
    mov rcx, rax
    ; Load variable: body_start
    movsxd rax, dword [rbp - 4160]  ; From stack [rbp - 4160]
    mov rdx, rax
    call dbg
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 5040], rax
    jmp ir_if_end_1445
ir_if_next_1446:
ir_if_end_1445:
    mov rax, 0
    push rax
    mov rax, 4096
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 5048], rax
    mov rax, [rbp - 5048]
    test rax, rax
    jz ir_trap_bounds_1447
    jmp ir_in_bounds_1448
ir_trap_bounds_1447:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct515]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1448:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 5056], rax
    ; Load variable: recv_buf
    lea rax, [rbp - 4144]  ; Local array base
    push rax
    mov rax, [rbp - 5056]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 5064], rax
    ; IR call: parse_content_length (2 args)
    sub rsp, 32
    mov rax, [rbp - 5064]
    mov rcx, rax
    ; Load variable: body_start
    movsxd rax, dword [rbp - 4160]  ; From stack [rbp - 4160]
    mov rdx, rax
    call parse_content_length
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 5072], rax
    mov rax, [rbp - 5072]
    ; Store to variable: content_len
    mov dword [rbp - 4164], eax  ; To stack [rbp - 4164]
    ; Load variable: dbg_on
    movsxd rax, dword [rel dbg_on]  ; From global memory
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 5080], rax
    mov rax, [rbp - 5080]
    test rax, rax
    jz ir_if_next_1450
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: dbg_cl
    lea rax, [rel dbg_cl]  ; Address of global string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 5088], rax
    ; IR call: dbg (2 args)
    sub rsp, 32
    mov rax, [rbp - 5088]
    mov rcx, rax
    ; Load variable: content_len
    movsxd rax, dword [rbp - 4164]  ; From stack [rbp - 4164]
    mov rdx, rax
    call dbg
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 5096], rax
    jmp ir_if_end_1449
ir_if_next_1450:
ir_if_end_1449:
    ; Load variable: body_start
    movsxd rax, dword [rbp - 4160]  ; From stack [rbp - 4160]
    push rax
    ; Load variable: content_len
    movsxd rax, dword [rbp - 4164]  ; From stack [rbp - 4164]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 5104], rax
    mov rax, [rbp - 5104]
    ; Store to variable: need
    mov dword [rbp - 4168], eax  ; To stack [rbp - 4168]
    ; Load variable: dbg_on
    movsxd rax, dword [rel dbg_on]  ; From global memory
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 5112], rax
    mov rax, [rbp - 5112]
    test rax, rax
    jz ir_if_next_1452
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: dbg_need
    lea rax, [rel dbg_need]  ; Address of global string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 5120], rax
    ; IR call: dbg (2 args)
    sub rsp, 32
    mov rax, [rbp - 5120]
    mov rcx, rax
    ; Load variable: need
    movsxd rax, dword [rbp - 4168]  ; From stack [rbp - 4168]
    mov rdx, rax
    call dbg
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 5128], rax
    jmp ir_if_end_1451
ir_if_next_1452:
ir_if_end_1451:
    ; Load variable: content_len
    movsxd rax, dword [rbp - 4164]  ; From stack [rbp - 4164]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setg al
    movzx rax, al
    mov [rbp - 5136], rax
    mov rax, [rbp - 5136]
    test rax, rax
    jz ir_sc_false_1457
ir_sc_rhs_1455:
    ; Load variable: need
    movsxd rax, dword [rbp - 4168]  ; From stack [rbp - 4168]
    push rax
    mov rax, 4096
    mov r10, rax
    pop rax
    cmp rax, r10
    setle al
    movzx rax, al
    mov [rbp - 5144], rax
    mov rax, [rbp - 5144]
    test rax, rax
    jz ir_sc_false_1457
ir_sc_true_1456:
    mov rax, 1
    mov [rbp - 5152], rax
    jmp ir_sc_end_1458
ir_sc_false_1457:
    mov rax, 0
    mov [rbp - 5152], rax
ir_sc_end_1458:
    mov rax, [rbp - 5152]
    test rax, rax
    jz ir_sc_false_1461
ir_sc_rhs_1459:
    ; Load variable: n
    movsxd rax, dword [rbp - 4156]  ; From stack [rbp - 4156]
    push rax
    ; Load variable: need
    movsxd rax, dword [rbp - 4168]  ; From stack [rbp - 4168]
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 5168], rax
    mov rax, [rbp - 5168]
    test rax, rax
    jz ir_sc_false_1461
ir_sc_true_1460:
    mov rax, 1
    mov [rbp - 5176], rax
    jmp ir_sc_end_1462
ir_sc_false_1461:
    mov rax, 0
    mov [rbp - 5176], rax
ir_sc_end_1462:
    mov rax, [rbp - 5176]
    test rax, rax
    jz ir_if_next_1454
ir_while_1463:
    ; Load variable: n
    movsxd rax, dword [rbp - 4156]  ; From stack [rbp - 4156]
    push rax
    ; Load variable: need
    movsxd rax, dword [rbp - 4168]  ; From stack [rbp - 4168]
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 5192], rax
    mov rax, [rbp - 5192]
    test rax, rax
    jz ir_while_end_1464
    ; Load variable: n
    movsxd rax, dword [rbp - 4156]  ; From stack [rbp - 4156]
    push rax
    mov rax, 4096
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 5200], rax
    mov rax, [rbp - 5200]
    test rax, rax
    jz ir_trap_bounds_1465
    jmp ir_in_bounds_1466
ir_trap_bounds_1465:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct517]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1466:
    ; Load variable: n
    movsxd rax, dword [rbp - 4156]  ; From stack [rbp - 4156]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 5208], rax
    ; Load variable: recv_buf
    lea rax, [rbp - 4144]  ; Local array base
    push rax
    mov rax, [rbp - 5208]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 5216], rax
    ; Load variable: need
    movsxd rax, dword [rbp - 4168]  ; From stack [rbp - 4168]
    push rax
    ; Load variable: n
    movsxd rax, dword [rbp - 4156]  ; From stack [rbp - 4156]
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 5224], rax
    ; IR call: recv (4 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 4152]  ; From stack [rbp - 4152]
    mov rcx, rax
    mov rax, [rbp - 5216]
    mov rdx, rax
    mov rax, [rbp - 5224]
    mov r8, rax
    mov rax, 0
    mov r9, rax
    call recv
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 5232], rax
    mov rax, [rbp - 5232]
    ; Store to variable: got
    mov dword [rbp - 4172], eax  ; To stack [rbp - 4172]
    ; Load variable: dbg_on
    movsxd rax, dword [rel dbg_on]  ; From global memory
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 5240], rax
    mov rax, [rbp - 5240]
    test rax, rax
    jz ir_if_next_1468
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: dbg_got
    lea rax, [rel dbg_got]  ; Address of global string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 5248], rax
    ; IR call: dbg (2 args)
    sub rsp, 32
    mov rax, [rbp - 5248]
    mov rcx, rax
    ; Load variable: got
    movsxd rax, dword [rbp - 4172]  ; From stack [rbp - 4172]
    mov rdx, rax
    call dbg
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 5256], rax
    jmp ir_if_end_1467
ir_if_next_1468:
ir_if_end_1467:
    ; Load variable: got
    movsxd rax, dword [rbp - 4172]  ; From stack [rbp - 4172]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setle al
    movzx rax, al
    mov [rbp - 5264], rax
    mov rax, [rbp - 5264]
    test rax, rax
    jz ir_if_next_1470
    jmp ir_while_end_1464
    jmp ir_if_end_1469
ir_if_next_1470:
ir_if_end_1469:
    ; Load variable: n
    movsxd rax, dword [rbp - 4156]  ; From stack [rbp - 4156]
    push rax
    ; Load variable: got
    movsxd rax, dword [rbp - 4172]  ; From stack [rbp - 4172]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 5272], rax
    mov rax, [rbp - 5272]
    ; Store to variable: n
    mov dword [rbp - 4156], eax  ; To stack [rbp - 4156]
    jmp ir_while_1463
ir_while_end_1464:
    jmp ir_if_end_1453
ir_if_next_1454:
ir_if_end_1453:
    ; Load variable: dbg_on
    movsxd rax, dword [rel dbg_on]  ; From global memory
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 5280], rax
    mov rax, [rbp - 5280]
    test rax, rax
    jz ir_if_next_1472
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: dbg_n
    lea rax, [rel dbg_n]  ; Address of global string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 5288], rax
    ; IR call: dbg (2 args)
    sub rsp, 32
    mov rax, [rbp - 5288]
    mov rcx, rax
    ; Load variable: n
    movsxd rax, dword [rbp - 4156]  ; From stack [rbp - 4156]
    mov rdx, rax
    call dbg
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 5296], rax
    jmp ir_if_end_1471
ir_if_next_1472:
ir_if_end_1471:
    jmp ir_if_end_1437
ir_if_next_1438:
ir_if_end_1437:
    ; Load variable: n
    movsxd rax, dword [rbp - 4156]  ; From stack [rbp - 4156]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setg al
    movzx rax, al
    mov [rbp - 5304], rax
    mov rax, [rbp - 5304]
    test rax, rax
    jz ir_if_next_1474
    mov rax, 0
    push rax
    mov rax, 4096
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 5312], rax
    mov rax, [rbp - 5312]
    test rax, rax
    jz ir_trap_bounds_1477
    jmp ir_in_bounds_1478
ir_trap_bounds_1477:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct519]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1478:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 5320], rax
    ; Load variable: recv_buf
    lea rax, [rbp - 4144]  ; Local array base
    push rax
    mov rax, [rbp - 5320]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 5328], rax
    ; IR call: is_get (2 args)
    sub rsp, 32
    mov rax, [rbp - 5328]
    mov rcx, rax
    ; Load variable: n
    movsxd rax, dword [rbp - 4156]  ; From stack [rbp - 4156]
    mov rdx, rax
    call is_get
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 5336], rax
    mov rax, [rbp - 5336]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 5344], rax
    mov rax, [rbp - 5344]
    test rax, rax
    jz ir_if_next_1476
    mov rax, 0
    push rax
    mov rax, 4096
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 5352], rax
    mov rax, [rbp - 5352]
    test rax, rax
    jz ir_trap_bounds_1481
    jmp ir_in_bounds_1482
ir_trap_bounds_1481:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct521]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1482:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 5360], rax
    ; Load variable: recv_buf
    lea rax, [rbp - 4144]  ; Local array base
    push rax
    mov rax, [rbp - 5360]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 5368], rax
    ; IR call: is_health (2 args)
    sub rsp, 32
    mov rax, [rbp - 5368]
    mov rcx, rax
    ; Load variable: n
    movsxd rax, dword [rbp - 4156]  ; From stack [rbp - 4156]
    mov rdx, rax
    call is_health
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 5376], rax
    mov rax, [rbp - 5376]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 5384], rax
    mov rax, [rbp - 5384]
    test rax, rax
    jz ir_if_next_1480
    ; Load variable: HTTP_HEALTH_HEADER
    lea rax, [rel HTTP_HEALTH_HEADER]  ; Address of global string
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 5392], rax
    mov rax, [rbp - 5392]
    mov rax, qword [rax]
    mov [rbp - 5400], rax
    ; Load variable: HTTP_HEALTH_HEADER
    lea rax, [rel HTTP_HEALTH_HEADER]  ; Address of global string
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 5408], rax
    mov rax, [rbp - 5408]
    mov rax, qword [rax]
    mov [rbp - 5416], rax
    ; IR call: send_all (3 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 4152]  ; From stack [rbp - 4152]
    mov rcx, rax
    mov rax, [rbp - 5400]
    mov rdx, rax
    mov rax, [rbp - 5416]
    mov r8, rax
    call send_all
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 5424], rax
    ; Load variable: HTTP_HEALTH_BODY
    lea rax, [rel HTTP_HEALTH_BODY]  ; Address of global string
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 5432], rax
    mov rax, [rbp - 5432]
    mov rax, qword [rax]
    mov [rbp - 5440], rax
    ; IR call: send_all (3 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 4152]  ; From stack [rbp - 4152]
    mov rcx, rax
    mov rax, [rbp - 5440]
    mov rdx, rax
    mov rax, 2
    mov r8, rax
    call send_all
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 5448], rax
    jmp ir_if_end_1479
ir_if_next_1480:
    mov rax, 0
    push rax
    mov rax, 4096
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 5456], rax
    mov rax, [rbp - 5456]
    test rax, rax
    jz ir_trap_bounds_1484
    jmp ir_in_bounds_1485
ir_trap_bounds_1484:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct523]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1485:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 5464], rax
    ; Load variable: recv_buf
    lea rax, [rbp - 4144]  ; Local array base
    push rax
    mov rax, [rbp - 5464]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 5472], rax
    ; IR call: is_root (2 args)
    sub rsp, 32
    mov rax, [rbp - 5472]
    mov rcx, rax
    ; Load variable: n
    movsxd rax, dword [rbp - 4156]  ; From stack [rbp - 4156]
    mov rdx, rax
    call is_root
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 5480], rax
    mov rax, [rbp - 5480]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 5488], rax
    mov rax, [rbp - 5488]
    test rax, rax
    jz ir_if_next_1483
    ; Load variable: HTTP_PAGE_HEADER
    lea rax, [rel HTTP_PAGE_HEADER]  ; Address of global string
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 5496], rax
    mov rax, [rbp - 5496]
    mov rax, qword [rax]
    mov [rbp - 5504], rax
    ; Load variable: HTTP_PAGE_HEADER
    lea rax, [rel HTTP_PAGE_HEADER]  ; Address of global string
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 5512], rax
    mov rax, [rbp - 5512]
    mov rax, qword [rax]
    mov [rbp - 5520], rax
    ; IR call: send_all (3 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 4152]  ; From stack [rbp - 4152]
    mov rcx, rax
    mov rax, [rbp - 5504]
    mov rdx, rax
    mov rax, [rbp - 5520]
    mov r8, rax
    call send_all
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 5528], rax
    ; Load variable: HTTP_PAGE_HEADER
    lea rax, [rel HTTP_PAGE_HEADER]  ; Address of global string
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 5536], rax
    mov rax, [rbp - 5536]
    mov rax, qword [rax]
    mov [rbp - 5544], rax
    mov rax, [rbp - 5528]
    push rax
    mov rax, [rbp - 5544]
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 5552], rax
    mov rax, [rbp - 5552]
    test rax, rax
    jz ir_if_next_1487
    ; Load variable: PAGE_CONTENT
    lea rax, [rel PAGE_CONTENT]  ; Address of global string
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 5560], rax
    mov rax, [rbp - 5560]
    mov rax, qword [rax]
    mov [rbp - 5568], rax
    ; Load variable: PAGE_CONTENT
    lea rax, [rel PAGE_CONTENT]  ; Address of global string
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 5576], rax
    mov rax, [rbp - 5576]
    mov rax, qword [rax]
    mov [rbp - 5584], rax
    ; IR call: send_all (3 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 4152]  ; From stack [rbp - 4152]
    mov rcx, rax
    mov rax, [rbp - 5568]
    mov rdx, rax
    mov rax, [rbp - 5584]
    mov r8, rax
    call send_all
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 5592], rax
    jmp ir_if_end_1486
ir_if_next_1487:
ir_if_end_1486:
    jmp ir_if_end_1479
ir_if_next_1483:
    mov rax, 0
    push rax
    mov rax, 4096
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 5600], rax
    mov rax, [rbp - 5600]
    test rax, rax
    jz ir_trap_bounds_1489
    jmp ir_in_bounds_1490
ir_trap_bounds_1489:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct525]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1490:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 5608], rax
    ; Load variable: recv_buf
    lea rax, [rbp - 4144]  ; Local array base
    push rax
    mov rax, [rbp - 5608]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 5616], rax
    ; IR call: is_demo (2 args)
    sub rsp, 32
    mov rax, [rbp - 5616]
    mov rcx, rax
    ; Load variable: n
    movsxd rax, dword [rbp - 4156]  ; From stack [rbp - 4156]
    mov rdx, rax
    call is_demo
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 5624], rax
    mov rax, [rbp - 5624]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 5632], rax
    mov rax, [rbp - 5632]
    test rax, rax
    jz ir_if_next_1488
    ; Load variable: HTTP_DEMO_HEADER
    lea rax, [rel HTTP_DEMO_HEADER]  ; Address of global string
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 5640], rax
    mov rax, [rbp - 5640]
    mov rax, qword [rax]
    mov [rbp - 5648], rax
    ; Load variable: HTTP_DEMO_HEADER
    lea rax, [rel HTTP_DEMO_HEADER]  ; Address of global string
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 5656], rax
    mov rax, [rbp - 5656]
    mov rax, qword [rax]
    mov [rbp - 5664], rax
    ; IR call: send_all (3 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 4152]  ; From stack [rbp - 4152]
    mov rcx, rax
    mov rax, [rbp - 5648]
    mov rdx, rax
    mov rax, [rbp - 5664]
    mov r8, rax
    call send_all
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 5672], rax
    ; Load variable: HTTP_DEMO_HEADER
    lea rax, [rel HTTP_DEMO_HEADER]  ; Address of global string
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 5680], rax
    mov rax, [rbp - 5680]
    mov rax, qword [rax]
    mov [rbp - 5688], rax
    mov rax, [rbp - 5672]
    push rax
    mov rax, [rbp - 5688]
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 5696], rax
    mov rax, [rbp - 5696]
    test rax, rax
    jz ir_if_next_1492
    ; Load variable: DEMO_CONTENT
    lea rax, [rel DEMO_CONTENT]  ; Address of global string
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 5704], rax
    mov rax, [rbp - 5704]
    mov rax, qword [rax]
    mov [rbp - 5712], rax
    ; Load variable: DEMO_CONTENT
    lea rax, [rel DEMO_CONTENT]  ; Address of global string
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 5720], rax
    mov rax, [rbp - 5720]
    mov rax, qword [rax]
    mov [rbp - 5728], rax
    ; IR call: send_all (3 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 4152]  ; From stack [rbp - 4152]
    mov rcx, rax
    mov rax, [rbp - 5712]
    mov rdx, rax
    mov rax, [rbp - 5728]
    mov r8, rax
    call send_all
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 5736], rax
    jmp ir_if_end_1491
ir_if_next_1492:
ir_if_end_1491:
    jmp ir_if_end_1479
ir_if_next_1488:
    mov rax, 0
    push rax
    mov rax, 4096
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 5744], rax
    mov rax, [rbp - 5744]
    test rax, rax
    jz ir_trap_bounds_1494
    jmp ir_in_bounds_1495
ir_trap_bounds_1494:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct527]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1495:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 5752], rax
    ; Load variable: recv_buf
    lea rax, [rbp - 4144]  ; Local array base
    push rax
    mov rax, [rbp - 5752]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 5760], rax
    ; IR call: is_benchmarks (2 args)
    sub rsp, 32
    mov rax, [rbp - 5760]
    mov rcx, rax
    ; Load variable: n
    movsxd rax, dword [rbp - 4156]  ; From stack [rbp - 4156]
    mov rdx, rax
    call is_benchmarks
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 5768], rax
    mov rax, [rbp - 5768]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 5776], rax
    mov rax, [rbp - 5776]
    test rax, rax
    jz ir_if_next_1493
    ; Load variable: HTTP_BENCHMARKS_HEADER
    lea rax, [rel HTTP_BENCHMARKS_HEADER]  ; Address of global string
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 5784], rax
    mov rax, [rbp - 5784]
    mov rax, qword [rax]
    mov [rbp - 5792], rax
    ; Load variable: HTTP_BENCHMARKS_HEADER
    lea rax, [rel HTTP_BENCHMARKS_HEADER]  ; Address of global string
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 5800], rax
    mov rax, [rbp - 5800]
    mov rax, qword [rax]
    mov [rbp - 5808], rax
    ; IR call: send_all (3 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 4152]  ; From stack [rbp - 4152]
    mov rcx, rax
    mov rax, [rbp - 5792]
    mov rdx, rax
    mov rax, [rbp - 5808]
    mov r8, rax
    call send_all
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 5816], rax
    ; Load variable: HTTP_BENCHMARKS_HEADER
    lea rax, [rel HTTP_BENCHMARKS_HEADER]  ; Address of global string
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 5824], rax
    mov rax, [rbp - 5824]
    mov rax, qword [rax]
    mov [rbp - 5832], rax
    mov rax, [rbp - 5816]
    push rax
    mov rax, [rbp - 5832]
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 5840], rax
    mov rax, [rbp - 5840]
    test rax, rax
    jz ir_if_next_1497
    ; Load variable: BENCHMARKS_CONTENT
    lea rax, [rel BENCHMARKS_CONTENT]  ; Address of global string
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 5848], rax
    mov rax, [rbp - 5848]
    mov rax, qword [rax]
    mov [rbp - 5856], rax
    ; Load variable: BENCHMARKS_CONTENT
    lea rax, [rel BENCHMARKS_CONTENT]  ; Address of global string
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 5864], rax
    mov rax, [rbp - 5864]
    mov rax, qword [rax]
    mov [rbp - 5872], rax
    ; IR call: send_all (3 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 4152]  ; From stack [rbp - 4152]
    mov rcx, rax
    mov rax, [rbp - 5856]
    mov rdx, rax
    mov rax, [rbp - 5872]
    mov r8, rax
    call send_all
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 5880], rax
    jmp ir_if_end_1496
ir_if_next_1497:
ir_if_end_1496:
    jmp ir_if_end_1479
ir_if_next_1493:
    mov rax, 0
    push rax
    mov rax, 4096
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 5888], rax
    mov rax, [rbp - 5888]
    test rax, rax
    jz ir_trap_bounds_1499
    jmp ir_in_bounds_1500
ir_trap_bounds_1499:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct529]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1500:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 5896], rax
    ; Load variable: recv_buf
    lea rax, [rbp - 4144]  ; Local array base
    push rax
    mov rax, [rbp - 5896]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 5904], rax
    ; IR call: is_docs (2 args)
    sub rsp, 32
    mov rax, [rbp - 5904]
    mov rcx, rax
    ; Load variable: n
    movsxd rax, dword [rbp - 4156]  ; From stack [rbp - 4156]
    mov rdx, rax
    call is_docs
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 5912], rax
    mov rax, [rbp - 5912]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 5920], rax
    mov rax, [rbp - 5920]
    test rax, rax
    jz ir_if_next_1498
    ; Load variable: HTTP_DOCS_HEADER
    lea rax, [rel HTTP_DOCS_HEADER]  ; Address of global string
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 5928], rax
    mov rax, [rbp - 5928]
    mov rax, qword [rax]
    mov [rbp - 5936], rax
    ; Load variable: HTTP_DOCS_HEADER
    lea rax, [rel HTTP_DOCS_HEADER]  ; Address of global string
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 5944], rax
    mov rax, [rbp - 5944]
    mov rax, qword [rax]
    mov [rbp - 5952], rax
    ; IR call: send_all (3 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 4152]  ; From stack [rbp - 4152]
    mov rcx, rax
    mov rax, [rbp - 5936]
    mov rdx, rax
    mov rax, [rbp - 5952]
    mov r8, rax
    call send_all
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 5960], rax
    ; Load variable: HTTP_DOCS_HEADER
    lea rax, [rel HTTP_DOCS_HEADER]  ; Address of global string
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 5968], rax
    mov rax, [rbp - 5968]
    mov rax, qword [rax]
    mov [rbp - 5976], rax
    mov rax, [rbp - 5960]
    push rax
    mov rax, [rbp - 5976]
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 5984], rax
    mov rax, [rbp - 5984]
    test rax, rax
    jz ir_if_next_1502
    ; Load variable: DOCS_CONTENT
    lea rax, [rel DOCS_CONTENT]  ; Address of global string
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 5992], rax
    mov rax, [rbp - 5992]
    mov rax, qword [rax]
    mov [rbp - 6000], rax
    ; Load variable: DOCS_CONTENT
    lea rax, [rel DOCS_CONTENT]  ; Address of global string
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 6008], rax
    mov rax, [rbp - 6008]
    mov rax, qword [rax]
    mov [rbp - 6016], rax
    ; IR call: send_all (3 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 4152]  ; From stack [rbp - 4152]
    mov rcx, rax
    mov rax, [rbp - 6000]
    mov rdx, rax
    mov rax, [rbp - 6016]
    mov r8, rax
    call send_all
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 6024], rax
    jmp ir_if_end_1501
ir_if_next_1502:
ir_if_end_1501:
    jmp ir_if_end_1479
ir_if_next_1498:
    mov rax, 0
    push rax
    mov rax, 4096
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 6032], rax
    mov rax, [rbp - 6032]
    test rax, rax
    jz ir_trap_bounds_1504
    jmp ir_in_bounds_1505
ir_trap_bounds_1504:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct531]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1505:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 6040], rax
    ; Load variable: recv_buf
    lea rax, [rbp - 4144]  ; Local array base
    push rax
    mov rax, [rbp - 6040]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 6048], rax
    ; IR call: is_forum (3 args)
    sub rsp, 32
    mov rax, [rbp - 6048]
    mov rcx, rax
    ; Load variable: n
    movsxd rax, dword [rbp - 4156]  ; From stack [rbp - 4156]
    mov rdx, rax
    mov rax, 4
    mov r8, rax
    call is_forum
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 6056], rax
    mov rax, [rbp - 6056]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 6064], rax
    mov rax, [rbp - 6064]
    test rax, rax
    jz ir_if_next_1503
    mov rax, 0
    push rax
    mov rax, 4096
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 6072], rax
    mov rax, [rbp - 6072]
    test rax, rax
    jz ir_trap_bounds_1506
    jmp ir_in_bounds_1507
ir_trap_bounds_1506:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct533]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1507:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 6080], rax
    ; Load variable: recv_buf
    lea rax, [rbp - 4144]  ; Local array base
    push rax
    mov rax, [rbp - 6080]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 6088], rax
    ; IR call: get_thread_id (3 args)
    sub rsp, 32
    mov rax, [rbp - 6088]
    mov rcx, rax
    ; Load variable: n
    movsxd rax, dword [rbp - 4156]  ; From stack [rbp - 4156]
    mov rdx, rax
    mov rax, 4
    mov r8, rax
    call get_thread_id
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 6096], rax
    mov rax, [rbp - 6096]
    ; Store to variable: tid
    mov dword [rbp - 4176], eax  ; To stack [rbp - 4176]
    ; Load variable: tid
    movsxd rax, dword [rbp - 4176]  ; From stack [rbp - 4176]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setg al
    movzx rax, al
    mov [rbp - 6104], rax
    mov rax, [rbp - 6104]
    test rax, rax
    jz ir_if_next_1509
    ; IR call: count_threads (0 args)
    sub rsp, 32
    call count_threads
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 6112], rax
    mov rax, [rbp - 6112]
    ; Store to variable: max_tid
    mov dword [rbp - 4180], eax  ; To stack [rbp - 4180]
    ; Load variable: tid
    movsxd rax, dword [rbp - 4176]  ; From stack [rbp - 4176]
    push rax
    ; Load variable: max_tid
    movsxd rax, dword [rbp - 4180]  ; From stack [rbp - 4180]
    mov r10, rax
    pop rax
    cmp rax, r10
    setle al
    movzx rax, al
    mov [rbp - 6120], rax
    mov rax, [rbp - 6120]
    test rax, rax
    jz ir_if_next_1511
    ; IR call: serve_forum_thread (2 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 4152]  ; From stack [rbp - 4152]
    mov rcx, rax
    ; Load variable: tid
    movsxd rax, dword [rbp - 4176]  ; From stack [rbp - 4176]
    mov rdx, rax
    call serve_forum_thread
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 6128], rax
    jmp ir_if_end_1510
ir_if_next_1511:
    ; Load variable: HTTP_404_HEADER
    lea rax, [rel HTTP_404_HEADER]  ; Address of global string
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 6136], rax
    mov rax, [rbp - 6136]
    mov rax, qword [rax]
    mov [rbp - 6144], rax
    ; Load variable: HTTP_404_HEADER
    lea rax, [rel HTTP_404_HEADER]  ; Address of global string
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 6152], rax
    mov rax, [rbp - 6152]
    mov rax, qword [rax]
    mov [rbp - 6160], rax
    ; IR call: send_all (3 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 4152]  ; From stack [rbp - 4152]
    mov rcx, rax
    mov rax, [rbp - 6144]
    mov rdx, rax
    mov rax, [rbp - 6160]
    mov r8, rax
    call send_all
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 6168], rax
    ; Load variable: HTTP_404_BODY
    lea rax, [rel HTTP_404_BODY]  ; Address of global string
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 6176], rax
    mov rax, [rbp - 6176]
    mov rax, qword [rax]
    mov [rbp - 6184], rax
    ; IR call: send_all (3 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 4152]  ; From stack [rbp - 4152]
    mov rcx, rax
    mov rax, [rbp - 6184]
    mov rdx, rax
    mov rax, 9
    mov r8, rax
    call send_all
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 6192], rax
ir_if_end_1510:
    jmp ir_if_end_1508
ir_if_next_1509:
    ; IR call: serve_forum_index (2 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 4152]  ; From stack [rbp - 4152]
    mov rcx, rax
    mov rax, 0
    mov rdx, rax
    call serve_forum_index
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 6200], rax
ir_if_end_1508:
    jmp ir_if_end_1479
ir_if_next_1503:
    ; Load variable: HTTP_404_HEADER
    lea rax, [rel HTTP_404_HEADER]  ; Address of global string
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 6208], rax
    mov rax, [rbp - 6208]
    mov rax, qword [rax]
    mov [rbp - 6216], rax
    ; Load variable: HTTP_404_HEADER
    lea rax, [rel HTTP_404_HEADER]  ; Address of global string
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 6224], rax
    mov rax, [rbp - 6224]
    mov rax, qword [rax]
    mov [rbp - 6232], rax
    ; IR call: send_all (3 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 4152]  ; From stack [rbp - 4152]
    mov rcx, rax
    mov rax, [rbp - 6216]
    mov rdx, rax
    mov rax, [rbp - 6232]
    mov r8, rax
    call send_all
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 6240], rax
    ; Load variable: HTTP_404_BODY
    lea rax, [rel HTTP_404_BODY]  ; Address of global string
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 6248], rax
    mov rax, [rbp - 6248]
    mov rax, qword [rax]
    mov [rbp - 6256], rax
    ; IR call: send_all (3 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 4152]  ; From stack [rbp - 4152]
    mov rcx, rax
    mov rax, [rbp - 6256]
    mov rdx, rax
    mov rax, 9
    mov r8, rax
    call send_all
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 6264], rax
ir_if_end_1479:
    jmp ir_if_end_1475
ir_if_next_1476:
    mov rax, 0
    push rax
    mov rax, 4096
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 6272], rax
    mov rax, [rbp - 6272]
    test rax, rax
    jz ir_trap_bounds_1513
    jmp ir_in_bounds_1514
ir_trap_bounds_1513:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct535]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1514:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 6280], rax
    ; Load variable: recv_buf
    lea rax, [rbp - 4144]  ; Local array base
    push rax
    mov rax, [rbp - 6280]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 6288], rax
    ; IR call: is_post (2 args)
    sub rsp, 32
    mov rax, [rbp - 6288]
    mov rcx, rax
    ; Load variable: n
    movsxd rax, dword [rbp - 4156]  ; From stack [rbp - 4156]
    mov rdx, rax
    call is_post
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 6296], rax
    mov rax, [rbp - 6296]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 6304], rax
    mov rax, [rbp - 6304]
    test rax, rax
    jz ir_if_next_1512
    mov rax, 0
    push rax
    mov rax, 4096
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 6312], rax
    mov rax, [rbp - 6312]
    test rax, rax
    jz ir_trap_bounds_1517
    jmp ir_in_bounds_1518
ir_trap_bounds_1517:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct537]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1518:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 6320], rax
    ; Load variable: recv_buf
    lea rax, [rbp - 4144]  ; Local array base
    push rax
    mov rax, [rbp - 6320]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 6328], rax
    ; IR call: is_forum (3 args)
    sub rsp, 32
    mov rax, [rbp - 6328]
    mov rcx, rax
    ; Load variable: n
    movsxd rax, dword [rbp - 4156]  ; From stack [rbp - 4156]
    mov rdx, rax
    mov rax, 5
    mov r8, rax
    call is_forum
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 6336], rax
    mov rax, [rbp - 6336]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 6344], rax
    mov rax, [rbp - 6344]
    test rax, rax
    jz ir_if_next_1516
    mov rax, 0
    push rax
    mov rax, 4096
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 6352], rax
    mov rax, [rbp - 6352]
    test rax, rax
    jz ir_trap_bounds_1519
    jmp ir_in_bounds_1520
ir_trap_bounds_1519:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct539]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1520:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 6360], rax
    ; Load variable: recv_buf
    lea rax, [rbp - 4144]  ; Local array base
    push rax
    mov rax, [rbp - 6360]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 6368], rax
    ; IR call: get_thread_id (3 args)
    sub rsp, 32
    mov rax, [rbp - 6368]
    mov rcx, rax
    ; Load variable: n
    movsxd rax, dword [rbp - 4156]  ; From stack [rbp - 4156]
    mov rdx, rax
    mov rax, 5
    mov r8, rax
    call get_thread_id
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 6376], rax
    mov rax, [rbp - 6376]
    ; Store to variable: tid
    mov dword [rbp - 4176], eax  ; To stack [rbp - 4176]
    ; Load variable: tid
    movsxd rax, dword [rbp - 4176]  ; From stack [rbp - 4176]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setg al
    movzx rax, al
    mov [rbp - 6384], rax
    mov rax, [rbp - 6384]
    test rax, rax
    jz ir_if_next_1522
    ; IR call: count_threads (0 args)
    sub rsp, 32
    call count_threads
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 6392], rax
    mov rax, [rbp - 6392]
    ; Store to variable: max_tid
    mov dword [rbp - 4180], eax  ; To stack [rbp - 4180]
    ; Load variable: tid
    movsxd rax, dword [rbp - 4176]  ; From stack [rbp - 4176]
    push rax
    ; Load variable: max_tid
    movsxd rax, dword [rbp - 4180]  ; From stack [rbp - 4180]
    mov r10, rax
    pop rax
    cmp rax, r10
    setle al
    movzx rax, al
    mov [rbp - 6400], rax
    mov rax, [rbp - 6400]
    test rax, rax
    jz ir_if_next_1524
    mov rax, 0
    push rax
    mov rax, 4096
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 6408], rax
    mov rax, [rbp - 6408]
    test rax, rax
    jz ir_trap_bounds_1525
    jmp ir_in_bounds_1526
ir_trap_bounds_1525:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct541]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1526:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 6416], rax
    ; Load variable: recv_buf
    lea rax, [rbp - 4144]  ; Local array base
    push rax
    mov rax, [rbp - 6416]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 6424], rax
    ; IR call: handle_post_reply (4 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 4152]  ; From stack [rbp - 4152]
    mov rcx, rax
    mov rax, [rbp - 6424]
    mov rdx, rax
    ; Load variable: n
    movsxd rax, dword [rbp - 4156]  ; From stack [rbp - 4156]
    mov r8, rax
    ; Load variable: tid
    movsxd rax, dword [rbp - 4176]  ; From stack [rbp - 4176]
    mov r9, rax
    call handle_post_reply
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 6432], rax
    jmp ir_if_end_1523
ir_if_next_1524:
    ; Load variable: HTTP_404_HEADER
    lea rax, [rel HTTP_404_HEADER]  ; Address of global string
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 6440], rax
    mov rax, [rbp - 6440]
    mov rax, qword [rax]
    mov [rbp - 6448], rax
    ; Load variable: HTTP_404_HEADER
    lea rax, [rel HTTP_404_HEADER]  ; Address of global string
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 6456], rax
    mov rax, [rbp - 6456]
    mov rax, qword [rax]
    mov [rbp - 6464], rax
    ; IR call: send_all (3 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 4152]  ; From stack [rbp - 4152]
    mov rcx, rax
    mov rax, [rbp - 6448]
    mov rdx, rax
    mov rax, [rbp - 6464]
    mov r8, rax
    call send_all
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 6472], rax
    ; Load variable: HTTP_404_BODY
    lea rax, [rel HTTP_404_BODY]  ; Address of global string
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 6480], rax
    mov rax, [rbp - 6480]
    mov rax, qword [rax]
    mov [rbp - 6488], rax
    ; IR call: send_all (3 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 4152]  ; From stack [rbp - 4152]
    mov rcx, rax
    mov rax, [rbp - 6488]
    mov rdx, rax
    mov rax, 9
    mov r8, rax
    call send_all
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 6496], rax
ir_if_end_1523:
    jmp ir_if_end_1521
ir_if_next_1522:
    mov rax, 0
    push rax
    mov rax, 4096
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 6504], rax
    mov rax, [rbp - 6504]
    test rax, rax
    jz ir_trap_bounds_1527
    jmp ir_in_bounds_1528
ir_trap_bounds_1527:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct543]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1528:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 6512], rax
    ; Load variable: recv_buf
    lea rax, [rbp - 4144]  ; Local array base
    push rax
    mov rax, [rbp - 6512]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 6520], rax
    ; IR call: handle_post_new_thread (3 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 4152]  ; From stack [rbp - 4152]
    mov rcx, rax
    mov rax, [rbp - 6520]
    mov rdx, rax
    ; Load variable: n
    movsxd rax, dword [rbp - 4156]  ; From stack [rbp - 4156]
    mov r8, rax
    call handle_post_new_thread
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 6528], rax
ir_if_end_1521:
    jmp ir_if_end_1515
ir_if_next_1516:
    ; Load variable: HTTP_404_HEADER
    lea rax, [rel HTTP_404_HEADER]  ; Address of global string
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 6536], rax
    mov rax, [rbp - 6536]
    mov rax, qword [rax]
    mov [rbp - 6544], rax
    ; Load variable: HTTP_404_HEADER
    lea rax, [rel HTTP_404_HEADER]  ; Address of global string
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 6552], rax
    mov rax, [rbp - 6552]
    mov rax, qword [rax]
    mov [rbp - 6560], rax
    ; IR call: send_all (3 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 4152]  ; From stack [rbp - 4152]
    mov rcx, rax
    mov rax, [rbp - 6544]
    mov rdx, rax
    mov rax, [rbp - 6560]
    mov r8, rax
    call send_all
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 6568], rax
    ; Load variable: HTTP_404_BODY
    lea rax, [rel HTTP_404_BODY]  ; Address of global string
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 6576], rax
    mov rax, [rbp - 6576]
    mov rax, qword [rax]
    mov [rbp - 6584], rax
    ; IR call: send_all (3 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 4152]  ; From stack [rbp - 4152]
    mov rcx, rax
    mov rax, [rbp - 6584]
    mov rdx, rax
    mov rax, 9
    mov r8, rax
    call send_all
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 6592], rax
ir_if_end_1515:
    jmp ir_if_end_1475
ir_if_next_1512:
    ; Load variable: HTTP_404_HEADER
    lea rax, [rel HTTP_404_HEADER]  ; Address of global string
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 6600], rax
    mov rax, [rbp - 6600]
    mov rax, qword [rax]
    mov [rbp - 6608], rax
    ; Load variable: HTTP_404_HEADER
    lea rax, [rel HTTP_404_HEADER]  ; Address of global string
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 6616], rax
    mov rax, [rbp - 6616]
    mov rax, qword [rax]
    mov [rbp - 6624], rax
    ; IR call: send_all (3 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 4152]  ; From stack [rbp - 4152]
    mov rcx, rax
    mov rax, [rbp - 6608]
    mov rdx, rax
    mov rax, [rbp - 6624]
    mov r8, rax
    call send_all
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 6632], rax
    ; Load variable: HTTP_404_BODY
    lea rax, [rel HTTP_404_BODY]  ; Address of global string
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 6640], rax
    mov rax, [rbp - 6640]
    mov rax, qword [rax]
    mov [rbp - 6648], rax
    ; IR call: send_all (3 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 4152]  ; From stack [rbp - 4152]
    mov rcx, rax
    mov rax, [rbp - 6648]
    mov rdx, rax
    mov rax, 9
    mov r8, rax
    call send_all
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 6656], rax
ir_if_end_1475:
    jmp ir_if_end_1473
ir_if_next_1474:
ir_if_end_1473:
    jmp ir_if_end_1435
ir_if_next_1436:
ir_if_end_1435:
    ; IR call: SD_BOTH (0 args)
    sub rsp, 32
    call SD_BOTH
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 6664], rax
    ; IR call: shutdown (2 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 4152]  ; From stack [rbp - 4152]
    mov rcx, rax
    mov rax, [rbp - 6664]
    mov rdx, rax
    call shutdown
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 6672], rax
    ; IR call: closesocket (1 args)
    sub rsp, 32
    ; Load variable: client
    mov rax, qword [rbp - 4152]  ; From stack [rbp - 4152]
    mov rcx, rax
    call closesocket
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 6680], rax
    jmp ir_while_1417
ir_while_end_1418:
    ; IR call: closesocket (1 args)
    sub rsp, 32
    ; Load variable: sock
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov rcx, rax
    call closesocket
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 6688], rax
    ; IR call: net_cleanup (0 args)
    sub rsp, 32
    call net_cleanup
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 6696], rax
    mov rax, 0
    mov [rbp - 6704], rax
    mov rax, [rbp - 6704]
    test rax, rax
    jz ir_errdefer_ok_1529
    jmp ir_errdefer_end_1530
ir_errdefer_ok_1529:
ir_errdefer_end_1530:
    mov rax, 0
    jmp Lmain_exit
Lmain_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

; Default program entry point
global mainCRTStartup
mainCRTStartup:
    sub rsp, 40      ; Shadow space + alignment
    ; Initialize garbage collector runtime
    lea rcx, [rsp + 40]
    extern gc_init
    call gc_init
    extern gc_register_root
    lea rcx, [rel PAGE_CONTENT]
    call gc_register_root
    lea rcx, [rel DEMO_CONTENT]
    call gc_register_root
    lea rcx, [rel BENCHMARKS_CONTENT]
    call gc_register_root
    lea rcx, [rel DOCS_CONTENT]
    call gc_register_root
    lea rcx, [rel HTTP_PAGE_HEADER]
    call gc_register_root
    lea rcx, [rel HTTP_DEMO_HEADER]
    call gc_register_root
    lea rcx, [rel HTTP_BENCHMARKS_HEADER]
    call gc_register_root
    lea rcx, [rel HTTP_DOCS_HEADER]
    call gc_register_root
    lea rcx, [rel HTTP_404_HEADER]
    call gc_register_root
    lea rcx, [rel HTTP_404_BODY]
    call gc_register_root
    lea rcx, [rel HTTP_HEALTH_HEADER]
    call gc_register_root
    lea rcx, [rel HTTP_HEALTH_BODY]
    call gc_register_root
    lea rcx, [rel FORUM_HEADER]
    call gc_register_root
    lea rcx, [rel FORUM_CSS]
    call gc_register_root
    lea rcx, [rel FORUM_INDEX_START]
    call gc_register_root
    lea rcx, [rel FORUM_INDEX_BODY]
    call gc_register_root
    lea rcx, [rel FORUM_INDEX_END]
    call gc_register_root
    lea rcx, [rel FORUM_FORM]
    call gc_register_root
    lea rcx, [rel FORUM_THREAD_START]
    call gc_register_root
    lea rcx, [rel FORUM_THREAD_HEAD_END]
    call gc_register_root
    lea rcx, [rel FORUM_THREAD_MID]
    call gc_register_root
    lea rcx, [rel FORUM_THREAD_END]
    call gc_register_root
    lea rcx, [rel FORUM_THREAD_END2]
    call gc_register_root
    lea rcx, [rel FORUM_NO_POSTS]
    call gc_register_root
    lea rcx, [rel FORUM_ERR_EMPTY]
    call gc_register_root
    lea rcx, [rel FORUM_LI_OPEN]
    call gc_register_root
    lea rcx, [rel FORUM_LI_MID]
    call gc_register_root
    lea rcx, [rel FORUM_LI_CLOSE]
    call gc_register_root
    lea rcx, [rel FORUM_POST_OPEN]
    call gc_register_root
    lea rcx, [rel FORUM_POST_CLOSE]
    call gc_register_root
    lea rcx, [rel REDIRECT_302]
    call gc_register_root
    lea rcx, [rel REDIRECT_END]
    call gc_register_root
    lea rcx, [rel fn_threads]
    call gc_register_root
    lea rcx, [rel fn_posts_prefix]
    call gc_register_root
    lea rcx, [rel fn_posts_suffix]
    call gc_register_root
    lea rcx, [rel mode_r]
    call gc_register_root
    lea rcx, [rel mode_a]
    call gc_register_root
    lea rcx, [rel nl]
    call gc_register_root
    lea rcx, [rel key_title]
    call gc_register_root
    lea rcx, [rel key_body]
    call gc_register_root
    lea rcx, [rel hdr_content_length]
    call gc_register_root
    lea rcx, [rel hdr_content_length_lo]
    call gc_register_root
    lea rcx, [rel pat_crlf2]
    call gc_register_root
    lea rcx, [rel pat_lf2]
    call gc_register_root
    lea rcx, [rel html_amp]
    call gc_register_root
    lea rcx, [rel html_lt]
    call gc_register_root
    lea rcx, [rel html_gt]
    call gc_register_root
    lea rcx, [rel html_quot]
    call gc_register_root
    lea rcx, [rel html_apos]
    call gc_register_root
    lea rcx, [rel dbg_post]
    call gc_register_root
    lea rcx, [rel dbg_bs]
    call gc_register_root
    lea rcx, [rel dbg_bl]
    call gc_register_root
    lea rcx, [rel dbg_cl]
    call gc_register_root
    lea rcx, [rel dbg_need]
    call gc_register_root
    lea rcx, [rel dbg_n]
    call gc_register_root
    lea rcx, [rel dbg_got]
    call gc_register_root
    lea rcx, [rel dbg_title]
    call gc_register_root
    lea rcx, [rel dbg_fopen_ok]
    call gc_register_root
    lea rcx, [rel dbg_fopen_fail]
    call gc_register_root
    lea rcx, [rel dbg_newline]
    call gc_register_root
    lea rcx, [rel dbg_fbs_enter]
    call gc_register_root
    lea rcx, [rel dbg_fbs_exit]
    call gc_register_root
    lea rcx, [rel dbg_fbs_ok]
    call gc_register_root
    lea rcx, [rel dbg_loop]
    call gc_register_root
    lea rcx, [rel err_net_init]
    call gc_register_root
    lea rcx, [rel err_socket]
    call gc_register_root
    lea rcx, [rel err_reuseaddr]
    call gc_register_root
    lea rcx, [rel err_sockaddr]
    call gc_register_root
    lea rcx, [rel err_bind]
    call gc_register_root
    lea rcx, [rel err_listen]
    call gc_register_root
    lea rcx, [rel msg_ready]
    call gc_register_root
    lea rcx, [rel crlf]
    call gc_register_root
    ; Call user main function
    call main
    mov [rsp + 32], rax ; Preserve main return code
    extern gc_shutdown
    call gc_shutdown
    mov rcx, [rsp + 32] ; Use main return as exit code
    extern ExitProcess
    call ExitProcess

; Data section for global variables
section .data
; Global variable: net_ref_count (int32, 4 bytes)
net_ref_count:
    dd 0

; Global variable: net_ref_lock (int32, 4 bytes)
net_ref_lock:
    dd 0

; Global variable: PAGE_CONTENT (string, 16 bytes)
PAGE_CONTENT:
    dq Lstr0  ; Pointer to string data
    dq 18144  ; String length
Lstr0:
    db "<!DOCTYPE html>", 10, "<html lang='en'>", 10, "<head>", 10, "<meta charset='UTF-8'>", 10, "<meta name='viewport' content='width=device-width,initial-scale=1'>", 10, "<meta name='description' content='MethASM - A typed, assembly-inspired language compiling to x86-64 NASM with advanced features like garbage collection, C interop, and modules.'>", 10, "<title>MethASM ", 226, 128, 148, " Premium Typed Assembly Language</title>", 10, "<link rel=", 34, "preconnect", 34, " href=", 34, "https://fonts.googleapis.com", 34, ">", 10, "<link rel=", 34, "preconnect", 34, " href=", 34, "https://fonts.gstatic.com", 34, " crossorigin>", 10, "<link href=", 34, "https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap", 34, " rel=", 34, "stylesheet", 34, ">", 10, "<style>", 10, "  :root {", 10, "    --bg-color: #05050A;", 10, "    --text-main: #E2E8F0;", 10, "    --text-muted: #94A3B8;", 10, "    --accent-1: #6366F1;", 10, "    --accent-2: #8B5CF6;", 10, "    --accent-3: #EC4899;", 10, "    --accent-4: #10B981;", 10, "    --glass-bg: rgba(255, 255, 255, 0.03);", 10, "    --glass-border: rgba(255, 255, 255, 0.08);", 10, "    --code-bg: #0D1117;", 10, "    --success: #10B981;", 10, "    --warning: #F59E0B;", 10, "    --error: #EF4444;", 10, "  }", 10, 10, "  * { box-sizing: border-box; margin: 0; padding: 0; }", 10, "  ", 10, "  body {", 10, "    font-family: 'Inter', sans-serif;", 10, "    background-color: var(--bg-color);", 10, "    color: var(--text-main);", 10, "    line-height: 1.6;", 10, "    overflow-x: hidden;", 10, "  }", 10, 10, "  /* Animated background mesh */", 10, "  .bg-mesh {", 10, "    position: fixed;", 10, "    top: 0; left: 0; right: 0; bottom: 0;", 10, "    z-index: -1;", 10, "    background: ", 10, "      radial-gradient(circle at 15% 50%, rgba(99, 102, 241, 0.15) 0%, transparent 50%),", 10, "      radial-gradient(circle at 85% 30%, rgba(236, 72, 153, 0.15) 0%, transparent 50%),", 10, "      radial-gradient(circle at 50% 80%, rgba(139, 92, 246, 0.15) 0%, transparent 50%);", 10, "    filter: blur(60px);", 10, "    animation: pulse 15s ease-in-out infinite alternate;", 10, "  }", 10, 10, "  @keyframes pulse {", 10, "    0% { transform: scale(1); opacity: 0.8; }", 10, "    100% { transform: scale(1.1); opacity: 1; }", 10, "  }", 10, 10, "  .container {", 10, "    max-width: 1200px;", 10, "    margin: 0 auto;", 10, "    padding: 2rem;", 10, "  }", 10, 10, "  /* Navigation */", 10, "  nav {", 10, "    display: flex;", 10, "    justify-content: space-between;", 10, "    align-items: center;", 10, "    padding: 1rem 0;", 10, "    margin-bottom: 3rem;", 10, "    border-bottom: 1px solid var(--glass-border);", 10, "  }", 10, 10, "  .nav-links {", 10, "    display: flex;", 10, "    gap: 2rem;", 10, "    align-items: center;", 10, "  }", 10, 10, "  .nav-link {", 10, "    color: var(--text-muted);", 10, "    text-decoration: none;", 10, "    font-weight: 500;", 10, "    transition: color 0.3s ease;", 10, "  }", 10, 10, "  .nav-link:hover {", 10, "    color: var(--accent-1);", 10, "  }", 10, 10, "  /* Hero Section */", 10, "  .hero {", 10, "    text-align: center;", 10, "    margin-bottom: 5rem;", 10, "    animation: slideUp 0.8s ease-out;", 10, "  }", 10, 10, "  .hero h1 {", 10, "    font-size: clamp(2.5rem, 8vw, 5rem);", 10, "    font-weight: 700;", 10, "    margin-bottom: 1.5rem;", 10, "    background: linear-gradient(135deg, var(--text-main) 0%, var(--accent-1) 30%, var(--accent-3) 70%, var(--accent-4) 100%);", 10, "    -webkit-background-clip: text;", 10, "    -webkit-text-fill-color: transparent;", 10, "    letter-spacing: -2px;", 10, "    line-height: 0.9;", 10, "  }", 10, 10, "  .hero .subtitle {", 10, "    font-size: 1.4rem;", 10, "    color: var(--text-muted);", 10, "    max-width: 700px;", 10, "    margin: 0 auto 3rem;", 10, "    font-weight: 400;", 10, "  }", 10, 10, "  .badges {", 10, "    display: flex;", 10, "    justify-content: center;", 10, "    flex-wrap: wrap;", 10, "    gap: 0.75rem;", 10, "    margin-bottom: 3rem;", 10, "  }", 10, 10, "  .badge {", 10, "    background: var(--glass-bg);", 10, "    border: 1px solid var(--glass-border);", 10, "    padding: 0.5rem 1.2rem;", 10, "    border-radius: 25px;", 10, "    font-size: 0.9rem;", 10, "    font-weight: 500;", 10, "    color: #C7D2FE;", 10, "    backdrop-filter: blur(10px);", 10, "    transition: all 0.3s ease;", 10, "  }", 10, 10, "  .badge:hover {", 10, "    border-color: var(--accent-1);", 10, "    transform: translateY(-2px);", 10, "    box-shadow: 0 4px 12px rgba(99, 102, 241, 0.2);", 10, "  }", 10, 10, "  .cta-buttons {", 10, "    display: flex;", 10, "    justify-content: center;", 10, "    gap: 1rem;", 10, "    flex-wrap: wrap;", 10, "  }", 10, 10, "  .btn {", 10, "    display: inline-block;", 10, "    padding: 1rem 2.5rem;", 10, "    border-radius: 12px;", 10, "    text-decoration: none;", 10, "    font-weight: 600;", 10, "    transition: all 0.3s ease;", 10, "    font-size: 1rem;", 10, "  }", 10, 10, "  .btn-primary {", 10, "    background: linear-gradient(135deg, var(--accent-1) 0%, var(--accent-2) 100%);", 10, "    color: white;", 10, "    box-shadow: 0 4px 15px rgba(99, 102, 241, 0.4);", 10, "  }", 10, 10, "  .btn-primary:hover {", 10, "    transform: translateY(-2px);", 10, "    box-shadow: 0 6px 20px rgba(99, 102, 241, 0.6);", 10, "  }", 10, 10, "  .btn-secondary {", 10, "    background: var(--glass-bg);", 10, "    color: var(--text-main);", 10, "    border: 1px solid var(--glass-border);", 10, "    backdrop-filter: blur(10px);", 10, "  }", 10, 10, "  .btn-secondary:hover {", 10, "    background: rgba(255, 255, 255, 0.08);", 10, "    border-color: rgba(255, 255, 255, 0.2);", 10, "  }", 10, 10, "  /* Features Grid */", 10, "  .features-section {", 10, "    margin-bottom: 5rem;", 10, "  }", 10, 10, "  .section-title {", 10, "    text-align: center;", 10, "    font-size: 2.5rem;", 10, "    font-weight: 700;", 10, "    margin-bottom: 3rem;", 10, "    background: linear-gradient(135deg, var(--text-main) 0%, var(--accent-1) 100%);", 10, "    -webkit-background-clip: text;", 10, "    -webkit-text-fill-color: transparent;", 10, "  }", 10, 10, "  .grid {", 10, "    display: grid;", 10, "    grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));", 10, "    gap: 2rem;", 10, "    margin-bottom: 3rem;", 10, "  }", 10, 10, "  .card {", 10, "    background: var(--glass-bg);", 10, "    border: 1px solid var(--glass-border);", 10, "    border-radius: 20px;", 10, "    padding: 2.5rem;", 10, "    backdrop-filter: blur(10px);", 10, "    transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);", 10, "    animation: fadeUp 0.8s ease-out backwards;", 10, "    position: relative;", 10, "    overflow: hidden;", 10, "  }", 10, 10, "  .card::before {", 10, "    content: '';", 10, "    position: absolute;", 10, "    top: 0;", 10, "    left: 0;", 10, "    right: 0;", 10, "    height: 3px;", 10, "    background: linear-gradient(90deg, var(--accent-1), var(--accent-2), var(--accent-3));", 10, "    opacity: 0;", 10, "    transition: opacity 0.3s ease;", 10, "  }", 10, 10, "  .card:hover::before {", 10, "    opacity: 1;", 10, "  }", 10, 10, "  .card:nth-child(1) { animation-delay: 0.1s; }", 10, "  .card:nth-child(2) { animation-delay: 0.2s; }", 10, "  .card:nth-child(3) { animation-delay: 0.3s; }", 10, "  .card:nth-child(4) { animation-delay: 0.4s; }", 10, "  .card:nth-child(5) { animation-delay: 0.5s; }", 10, "  .card:nth-child(6) { animation-delay: 0.6s; }", 10, 10, "  .card:hover {", 10, "    transform: translateY(-8px);", 10, "    border-color: rgba(139, 92, 246, 0.5);", 10, "    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5), 0 0 20px rgba(139, 92, 246, 0.2);", 10, "  }", 10, 10, "  .card-icon {", 10, "    font-size: 2.5rem;", 10, "    margin-bottom: 1.5rem;", 10, "    display: block;", 10, "  }", 10, 10, "  .card h3 {", 10, "    font-size: 1.5rem;", 10, "    margin-bottom: 1rem;", 10, "    color: white;", 10, "    font-weight: 600;", 10, "  }", 10, 10, "  .card p {", 10, "    color: var(--text-muted);", 10, "    font-size: 1rem;", 10, "    line-height: 1.7;", 10, "  }", 10, 10, "  /* Code Showcase */", 10, "  .code-showcase {", 10, "    background: var(--code-bg);", 10, "    border: 1px solid #30363D;", 10, "    border-radius: 16px;", 10, "    overflow: hidden;", 10, "    margin-bottom: 5rem;", 10, "    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.6);", 10, "  }", 10, 10, "  .showcase-header {", 10, "    background: #161B22;", 10, "    padding: 1rem 1.5rem;", 10, "    display: flex;", 10, "    align-items: center;", 10, "    justify-content: space-between;", 10, "    border-bottom: 1px solid #30363D;", 10, "  }", 10, 10, "  .showcase-title {", 10, "    color: var(--text-main);", 10, "    font-weight: 600;", 10, "    font-size: 1.1rem;", 10, "  }", 10, 10, "  .showcase-tabs {", 10, "    display: flex;", 10, "    gap: 0.5rem;", 10, "  }", 10, 10, "  .tab {", 10, "    background: var(--glass-bg);", 10, "    border: 1px solid var(--glass-border);", 10, "    padding: 0.5rem 1rem;", 10, "    border-radius: 8px;", 10, "    color: var(--text-muted);", 10, "    font-size: 0.85rem;", 10, "    cursor: pointer;", 10, "    transition: all 0.3s ease;", 10, "  }", 10, 10, "  .tab.active {", 10, "    background: var(--accent-1);", 10, "    color: white;", 10, "    border-color: var(--accent-1);", 10, "  }", 10, 10, "  .code-content {", 10, "    display: none;", 10, "  }", 10, 10, "  .code-content.active {", 10, "    display: block;", 10, "  }", 10, 10, "  pre {", 10, "    padding: 2rem;", 10, "    overflow-x: auto;", 10, "    margin: 0;", 10, "  }", 10, 10, "  code {", 10, "    font-family: 'JetBrains Mono', monospace;", 10, "    font-size: 0.9rem;", 10, "    line-height: 1.6;", 10, "  }", 10, 10, "  /* Syntax Highlighting */", 10, "  .k { color: #FF7B72; font-weight: 500; } /* Keyword */", 10, "  .f { color: #D2A8FF; font-weight: 500; } /* Function */", 10, "  .s { color: #A5D6FF; } /* String */", 10, "  .c { color: #8B949E; font-style: italic; } /* Comment */", 10, "  .t { color: #FFA657; } /* Type */", 10, "  .n { color: #79C0FF; } /* Number */", 10, 10, "  /* Stats Section */", 10, "  .stats {", 10, "    display: grid;", 10, "    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));", 10, "    gap: 2rem;", 10, "    margin-bottom: 5rem;", 10, "  }", 10, 10, "  .stat-card {", 10, "    text-align: center;", 10, "    padding: 2rem;", 10, "    background: var(--glass-bg);", 10, "    border: 1px solid var(--glass-border);", 10, "    border-radius: 16px;", 10, "    backdrop-filter: blur(10px);", 10, "  }", 10, 10, "  .stat-number {", 10, "    font-size: 3rem;", 10, "    font-weight: 700;", 10, "    color: var(--accent-1);", 10, "    margin-bottom: 0.5rem;", 10, "  }", 10, 10, "  .stat-label {", 10, "    color: var(--text-muted);", 10, "    font-size: 1rem;", 10, "  }", 10, 10, "  /* Footer */", 10, "  footer {", 10, "    text-align: center;", 10, "    padding: 3rem 0;", 10, "    border-top: 1px solid var(--glass-border);", 10, "    color: var(--text-muted);", 10, "  }", 10, 10, "  .footer-links {", 10, "    display: flex;", 10, "    justify-content: center;", 10, "    gap: 2rem;", 10, "    margin-bottom: 2rem;", 10, "  }", 10, 10, "  .footer-link {", 10, "    color: var(--text-muted);", 10, "    text-decoration: none;", 10, "    transition: color 0.3s ease;", 10, "  }", 10, 10, "  .footer-link:hover {", 10, "    color: var(--accent-1);", 10, "  }", 10, 10, "  /* Animations */", 10, "  @keyframes slideUp {", 10, "    from { opacity: 0; transform: translateY(30px); }", 10, "    to { opacity: 1; transform: translateY(0); }", 10, "  }", 10, 10, "  @keyframes fadeUp {", 10, "    from { opacity: 0; transform: translateY(20px); }", 10, "    to { opacity: 1; transform: translateY(0); }", 10, "  }", 10, 10, "  /* Responsive */", 10, "  @media (max-width: 768px) {", 10, "    .nav-links {", 10, "      flex-direction: column;", 10, "      gap: 1rem;", 10, "    }", 10, 10, "    .hero h1 {", 10, "      font-size: 3rem;", 10, "    }", 10, 10, "    .grid {", 10, "      grid-template-columns: 1fr;", 10, "    }", 10, 10, "    .stats {", 10, "      grid-template-columns: repeat(2, 1fr);", 10, "    }", 10, "  }", 10, "</style>", 10, "</head>", 10, "<body>", 10, "  <div class=", 34, "bg-mesh", 34, "></div>", 10, "  ", 10, "  <div class=", 34, "container", 34, ">", 10, "    <nav>", 10, "      <div class=", 34, "nav-links", 34, ">", 10, "        <a href=", 34, "/", 34, " class=", 34, "nav-link", 34, ">Home</a>", 10, "        <a href=", 34, "/demo", 34, " class=", 34, "nav-link", 34, ">Demo</a>", 10, "        <a href=", 34, "/benchmarks", 34, " class=", 34, "nav-link", 34, ">Benchmarks</a>", 10, "        <a href=", 34, "/docs", 34, " class=", 34, "nav-link", 34, ">Docs</a>", 10, "        <a href=", 34, "/forum", 34, " class=", 34, "nav-link", 34, ">Forum</a>", 10, "      </div>", 10, "    </nav>", 10, 10, "    <header class=", 34, "hero", 34, ">", 10, "      <h1>MethASM</h1>", 10, "      <p class=", 34, "subtitle", 34, ">A typed, assembly-inspired language with C interop and garbage collection, compiling to high-performance x86-64 NASM assembly.</p>", 10, "      ", 10, "      <div class=", 34, "badges", 34, ">", 10, "        <span class=", 34, "badge", 34, ">", 240, 159, 148, 146, " Statically Typed</span>", 10, "        <span class=", 34, "badge", 34, ">", 226, 154, 161, " Zero-Cost Abstractions</span>", 10, "        <span class=", 34, "badge", 34, ">", 240, 159, 148, 151, " Native C Interop</span>", 10, "        <span class=", 34, "badge", 34, ">", 240, 159, 147, 166, " Module System</span>", 10, "        <span class=", 34, "badge", 34, ">", 240, 159, 151, 145, 239, 184, 143, " Conservative GC</span>", 10, "        <span class=", 34, "badge", 34, ">", 240, 159, 142, 175, " x86-64 Native</span>", 10, "      </div>", 10, 10, "      <div class=", 34, "cta-buttons", 34, ">", 10, "        <a href=", 34, "/demo", 34, " class=", 34, "btn btn-primary", 34, ">Try Interactive Demo</a>", 10, "        <a href=", 34, "/docs", 34, " class=", 34, "btn btn-secondary", 34, ">Read Documentation</a>", 10, "      </div>", 10, "    </header>", 10, 10, "    <section class=", 34, "features-section", 34, ">", 10, "      <h2 class=", 34, "section-title", 34, ">Language Features</h2>", 10, "      <div class=", 34, "grid", 34, ">", 10, "        <div class=", 34, "card", 34, ">", 10, "          <span class=", 34, "card-icon", 34, ">", 226, 154, 161, "</span>", 10, "          <h3>Explicit Control</h3>", 10, "          <p>No hidden magic. All variables and parameters have explicit types. Structured control flow with <code>if</code>, <code>while</code>, <code>for</code>, and <code>switch</code> statements. Compile to efficient x86-64 assembly.</p>", 10, "        </div>", 10, "        ", 10, "        <div class=", 34, "card", 34, ">", 10, "          <span class=", 34, "card-icon", 34, ">", 240, 159, 155, 161, 239, 184, 143, "</span>", 10, "          <h3>Memory Management</h3>", 10, "          <p>Leverage the built-in conservative garbage collection via <code>new T</code> for heap allocation, or manage it yourself with C <code>malloc</code> when you need precise control.</p>", 10, "        </div>", 10, 10, "        <div class=", 34, "card", 34, ">", 10, "          <span class=", 34, "card-icon", 34, ">", 240, 159, 148, 151, "</span>", 10, "          <h3>Seamless FFI</h3>", 10, "          <p>First-class C interoperability. Declare <code>extern function</code> and <code>extern var</code> to effortlessly interface with external libraries like Winsock2 and the MSVC runtime.</p>", 10, "        </div>", 10, 10, "        <div class=", 34, "card", 34, ">", 10, "          <span class=", 34, "card-icon", 34, ">", 240, 159, 147, 166, "</span>", 10, "          <h3>Module System</h3>", 10, "          <p>Organize your codebase efficiently. Import standard libraries or your own modules to keep namespaces clean and dependency resolution robust.</p>", 10, "        </div>", 10, 10, "        <div class=", 34, "card", 34, ">", 10, "          <span class=", 34, "card-icon", 34, ">", 240, 159, 142, 175, "</span>", 10, "          <h3>Performance</h3>", 10, "          <p>Compiles directly to x86-64 NASM assembly. No runtime overhead beyond what you explicitly use. Perfect for systems programming and performance-critical applications.</p>", 10, "        </div>", 10, 10, "        <div class=", 34, "card", 34, ">", 10, "          <span class=", 34, "card-icon", 34, ">", 240, 159, 148, 167, "</span>", 10, "          <h3>Rich Type System</h3>", 10, "          <p>Comprehensive primitive types (int8-int64, uint8-uint64, float32/64), structs, enums, pointers, arrays, and strings with proper memory layout for C interop.</p>", 10, "        </div>", 10, "      </div>", 10, "    </section>", 10, 10, "    <section class=", 34, "code-showcase", 34, ">", 10, "      <div class=", 34, "showcase-header", 34, ">", 10, "        <div class=", 34, "showcase-title", 34, ">Code Examples</div>", 10, "        <div class=", 34, "showcase-tabs", 34, ">", 10, "          <div class=", 34, "tab active", 34, " onclick=", 34, "showTab('basics')", 34, ">Basics</div>", 10, "          <div class=", 34, "tab", 34, " onclick=", 34, "showTab('structs')", 34, ">Structs</div>", 10, "          <div class=", 34, "tab", 34, " onclick=", 34, "showTab('networking')", 34, ">Networking</div>", 10, "        </div>", 10, "      </div>", 10, "      ", 10, "      <div id=", 34, "basics", 34, " class=", 34, "code-content active", 34, ">", 10, "        <pre><code><span class=", 34, "k", 34, ">import</span> <span class=", 34, "s", 34, ">", 34, "std/io", 34, "</span>;", 10, "<span class=", 34, "k", 34, ">import</span> <span class=", 34, "s", 34, ">", 34, "std/math", 34, "</span>;", 10, 10, "<span class=", 34, "k", 34, ">function</span> <span class=", 34, "f", 34, ">factorial</span>(n: <span class=", 34, "t", 34, ">int32</span>) -> <span class=", 34, "t", 34, ">int32</span> {", 10, "  <span class=", 34, "k", 34, ">if</span> (n <= <span class=", 34, "n", 34, ">1</span>) {", 10, "    <span class=", 34, "k", 34, ">return</span> <span class=", 34, "n", 34, ">1</span>;", 10, "  }", 10, "  <span class=", 34, "k", 34, ">return</span> n * <span class=", 34, "f", 34, ">factorial</span>(n - <span class=", 34, "n", 34, ">1</span>);", 10, "}", 10, 10, "<span class=", 34, "k", 34, ">function</span> <span class=", 34, "f", 34, ">main</span>() -> <span class=", 34, "t", 34, ">int32</span> {", 10, "  <span class=", 34, "k", 34, ">var</span> result: <span class=", 34, "t", 34, ">int32</span> = <span class=", 34, "f", 34, ">factorial</span>(<span class=", 34, "n", 34, ">10</span>);", 10, "  <span class=", 34, "f", 34, ">println_int</span>(result);", 10, "  <span class=", 34, "k", 34, ">return</span> <span class=", 34, "n", 34, ">0</span>;", 10, "}</code></pre>", 10, "      </div>", 10, 10, "      <div id=", 34, "structs", 34, " class=", 34, "code-content", 34, ">", 10, "        <pre><code><span class=", 34, "k", 34, ">struct</span> <span class=", 34, "t", 34, ">Point</span> {", 10, "  x: <span class=", 34, "t", 34, ">float64</span>;", 10, "  y: <span class=", 34, "t", 34, ">float64</span>;", 10, "  ", 10, "  <span class=", 34, "k", 34, ">function</span> <span class=", 34, "f", 34, ">distance</span>(other: <span class=", 34, "t", 34, ">Point</span>*) -> <span class=", 34, "t", 34, ">float64</span> {", 10, "    <span class=", 34, "k", 34, ">var</span> dx: <span class=", 34, "t", 34, ">float64</span> = <span class=", 34, "k", 34, ">this</span>.x - other->x;", 10, "    <span class=", 34, "k", 34, ">var</span> dy: <span class=", 34, "t", 34, ">float64</span> = <span class=", 34, "k", 34, ">this</span>.y - other->y;", 10, "    <span class=", 34, "k", 34, ">return</span> <span class=", 34, "f", 34, ">sqrt</span>(dx*dx + dy*dy);", 10, "  }", 10, "}", 10, 10, "<span class=", 34, "k", 34, ">function</span> <span class=", 34, "f", 34, ">main</span>() -> <span class=", 34, "t", 34, ">int32</span> {", 10, "  <span class=", 34, "k", 34, ">var</span> p1: <span class=", 34, "t", 34, ">Point</span> = {<span class=", 34, "n", 34, ">0.0</span>, <span class=", 34, "n", 34, ">0.0</span>};", 10, "  <span class=", 34, "k", 34, ">var</span> p2: <span class=", 34, "t", 34, ">Point</span> = {<span class=", 34, "n", 34, ">3.0</span>, <span class=", 34, "n", 34, ">4.0</span>};", 10, "  <span class=", 34, "k", 34, ">var</span> dist: <span class=", 34, "t", 34, ">float64</span> = <span class=", 34, "f", 34, ">p1.distance</span>(&p2);", 10, "  <span class=", 34, "k", 34, ">return</span> <span class=", 34, "n", 34, ">0</span>;", 10, "}</code></pre>", 10, "      </div>", 10, 10, "      <div id=", 34, "networking", 34, " class=", 34, "code-content", 34, ">", 10, "        <pre><code><span class=", 34, "k", 34, ">import</span> <span class=", 34, "s", 34, ">", 34, "std/net", 34, "</span>;", 10, "<span class=", 34, "k", 34, ">import</span> <span class=", 34, "s", 34, ">", 34, "std/io", 34, "</span>;", 10, 10, "<span class=", 34, "k", 34, ">function</span> <span class=", 34, "f", 34, ">main</span>() -> <span class=", 34, "t", 34, ">int32</span> {", 10, "  <span class=", 34, "k", 34, ">if</span> (<span class=", 34, "f", 34, ">net_init</span>() != <span class=", 34, "n", 34, ">0</span>) {", 10, "    <span class=", 34, "f", 34, ">puts</span>(<span class=", 34, "s", 34, ">", 34, "Failed to initialize network", 34, "</span>);", 10, "    <span class=", 34, "k", 34, ">return</span> <span class=", 34, "n", 34, ">1</span>;", 10, "  }", 10, "  ", 10, "  <span class=", 34, "k", 34, ">var</span> sock: <span class=", 34, "t", 34, ">int64</span> = <span class=", 34, "f", 34, ">socket_tcp</span>();", 10, "  <span class=", 34, "k", 34, ">var</span> addr: <span class=", 34, "t", 34, ">cstring</span> = <span class=", 34, "f", 34, ">sockaddr_in_any</span>(<span class=", 34, "n", 34, ">8080</span>);", 10, "  ", 10, "  <span class=", 34, "k", 34, ">if</span> (<span class=", 34, "f", 34, ">bind</span>(sock, addr, <span class=", 34, "n", 34, ">16</span>) != <span class=", 34, "n", 34, ">0</span>) {", 10, "    <span class=", 34, "f", 34, ">puts</span>(<span class=", 34, "s", 34, ">", 34, "Bind failed", 34, "</span>);", 10, "    <span class=", 34, "k", 34, ">return</span> <span class=", 34, "n", 34, ">1</span>;", 10, "  }", 10, "  ", 10, "  <span class=", 34, "f", 34, ">listen</span>(sock, <span class=", 34, "n", 34, ">5</span>);", 10, "  <span class=", 34, "f", 34, ">puts</span>(<span class=", 34, "s", 34, ">", 34, "Server listening on port 8080", 34, "</span>);", 10, "  ", 10, "  <span class=", 34, "c", 34, ">// Accept loop...</span>", 10, "  <span class=", 34, "k", 34, ">return</span> <span class=", 34, "n", 34, ">0</span>;", 10, "}</code></pre>", 10, "      </div>", 10, "    </section>", 10, 10, "    <section class=", 34, "stats", 34, ">", 10, "      <div class=", 34, "stat-card", 34, ">", 10, "        <div class=", 34, "stat-number", 34, ">x86-64</div>", 10, "        <div class=", 34, "stat-label", 34, ">Target Architecture</div>", 10, "      </div>", 10, "      <div class=", 34, "stat-card", 34, ">", 10, "        <div class=", 34, "stat-number", 34, ">NASM</div>", 10, "        <div class=", 34, "stat-label", 34, ">Assembly Output</div>", 10, "      </div>", 10, "      <div class=", 34, "stat-card", 34, ">", 10, "        <div class=", 34, "stat-number", 34, ">Zero</div>", 10, "        <div class=", 34, "stat-label", 34, ">Runtime Overhead</div>", 10, "      </div>", 10, "      <div class=", 34, "stat-card", 34, ">", 10, "        <div class=", 34, "stat-number", 34, ">C</div>", 10, "        <div class=", 34, "stat-label", 34, ">ABI Compatible</div>", 10, "      </div>", 10, "    </section>", 10, 10, "    <footer>", 10, "      <div class=", 34, "footer-links", 34, ">", 10, "        <a href=", 34, "/demo", 34, " class=", 34, "footer-link", 34, ">Interactive Demo</a>", 10, "        <a href=", 34, "/benchmarks", 34, " class=", 34, "footer-link", 34, ">Benchmarks</a>", 10, "        <a href=", 34, "/docs", 34, " class=", 34, "footer-link", 34, ">Documentation</a>", 10, "        <a href=", 34, "/forum", 34, " class=", 34, "footer-link", 34, ">Community Forum</a>", 10, "      </div>", 10, "      <p>&copy; 2024 MethASM. Compiles to high-performance x86-64 assembly.</p>", 10, "    </footer>", 10, "  </div>", 10, 10, "  <script>", 10, "    function showTab(tabName) {", 10, "      // Hide all content", 10, "      document.querySelectorAll('.code-content').forEach(content => {", 10, "        content.classList.remove('active');", 10, "      });", 10, "      ", 10, "      // Remove active from all tabs", 10, "      document.querySelectorAll('.tab').forEach(tab => {", 10, "        tab.classList.remove('active');", 10, "      });", 10, "      ", 10, "      // Show selected content", 10, "      document.getElementById(tabName).classList.add('active');", 10, "      ", 10, "      // Add active to clicked tab", 10, "      event.target.classList.add('active');", 10, "    }", 10, "  </script>", 10, "</body>", 10, "</html>", 10, 0

; Global variable: DEMO_CONTENT (string, 16 bytes)
DEMO_CONTENT:
    dq Lstr1  ; Pointer to string data
    dq 19546  ; String length
Lstr1:
    db "<!DOCTYPE html>", 10, "<html lang='en'>", 10, "<head>", 10, "<meta charset='UTF-8'>", 10, "<meta name='viewport' content='width=device-width,initial-scale=1'>", 10, "<meta name='description' content='Interactive MethASM code demonstrations and examples. Try the language features in your browser.'>", 10, "<title>MethASM ", 226, 128, 148, " Interactive Demo</title>", 10, "<link rel=", 34, "preconnect", 34, " href=", 34, "https://fonts.googleapis.com", 34, ">", 10, "<link rel=", 34, "preconnect", 34, " href=", 34, "https://fonts.gstatic.com", 34, " crossorigin>", 10, "<link href=", 34, "https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap", 34, " rel=", 34, "stylesheet", 34, ">", 10, "<style>", 10, "  :root {", 10, "    --bg-color: #05050A;", 10, "    --text-main: #E2E8F0;", 10, "    --text-muted: #94A3B8;", 10, "    --accent-1: #6366F1;", 10, "    --accent-2: #8B5CF6;", 10, "    --accent-3: #EC4899;", 10, "    --accent-4: #10B981;", 10, "    --glass-bg: rgba(255, 255, 255, 0.03);", 10, "    --glass-border: rgba(255, 255, 255, 0.08);", 10, "    --code-bg: #0D1117;", 10, "    --success: #10B981;", 10, "    --warning: #F59E0B;", 10, "    --error: #EF4444;", 10, "  }", 10, 10, "  * { box-sizing: border-box; margin: 0; padding: 0; }", 10, "  ", 10, "  body {", 10, "    font-family: 'Inter', sans-serif;", 10, "    background-color: var(--bg-color);", 10, "    color: var(--text-main);", 10, "    line-height: 1.6;", 10, "    overflow-x: hidden;", 10, "  }", 10, 10, "  /* Animated background mesh */", 10, "  .bg-mesh {", 10, "    position: fixed;", 10, "    top: 0; left: 0; right: 0; bottom: 0;", 10, "    z-index: -1;", 10, "    background: ", 10, "      radial-gradient(circle at 15% 50%, rgba(99, 102, 241, 0.15) 0%, transparent 50%),", 10, "      radial-gradient(circle at 85% 30%, rgba(236, 72, 153, 0.15) 0%, transparent 50%),", 10, "      radial-gradient(circle at 50% 80%, rgba(139, 92, 246, 0.15) 0%, transparent 50%);", 10, "    filter: blur(60px);", 10, "    animation: pulse 15s ease-in-out infinite alternate;", 10, "  }", 10, 10, "  @keyframes pulse {", 10, "    0% { transform: scale(1); opacity: 0.8; }", 10, "    100% { transform: scale(1.1); opacity: 1; }", 10, "  }", 10, 10, "  .container {", 10, "    max-width: 1200px;", 10, "    margin: 0 auto;", 10, "    padding: 2rem;", 10, "  }", 10, 10, "  /* Navigation */", 10, "  nav {", 10, "    display: flex;", 10, "    justify-content: space-between;", 10, "    align-items: center;", 10, "    padding: 1rem 0;", 10, "    margin-bottom: 3rem;", 10, "    border-bottom: 1px solid var(--glass-border);", 10, "  }", 10, 10, "  .nav-links {", 10, "    display: flex;", 10, "    gap: 2rem;", 10, "    align-items: center;", 10, "  }", 10, 10, "  .nav-link {", 10, "    color: var(--text-muted);", 10, "    text-decoration: none;", 10, "    font-weight: 500;", 10, "    transition: color 0.3s ease;", 10, "  }", 10, 10, "  .nav-link:hover {", 10, "    color: var(--accent-1);", 10, "  }", 10, 10, "  /* Header */", 10, "  .header {", 10, "    text-align: center;", 10, "    margin-bottom: 4rem;", 10, "    animation: slideUp 0.8s ease-out;", 10, "  }", 10, 10, "  .header h1 {", 10, "    font-size: clamp(2.5rem, 6vw, 4rem);", 10, "    font-weight: 700;", 10, "    margin-bottom: 1.5rem;", 10, "    background: linear-gradient(135deg, var(--text-main) 0%, var(--accent-1) 50%, var(--accent-3) 100%);", 10, "    -webkit-background-clip: text;", 10, "    background-clip: text;", 10, "    -webkit-text-fill-color: transparent;", 10, "    letter-spacing: -1px;", 10, "  }", 10, 10, "  .header p {", 10, "    font-size: 1.2rem;", 10, "    color: var(--text-muted);", 10, "    max-width: 600px;", 10, "    margin: 0 auto;", 10, "  }", 10, 10, "  /* Demo Sections */", 10, "  .demo-section {", 10, "    margin-bottom: 4rem;", 10, "    animation: fadeUp 0.8s ease-out backwards;", 10, "  }", 10, 10, "  .demo-section:nth-child(2) { animation-delay: 0.1s; }", 10, "  .demo-section:nth-child(3) { animation-delay: 0.2s; }", 10, "  .demo-section:nth-child(4) { animation-delay: 0.3s; }", 10, 10, "  .demo-header {", 10, "    display: flex;", 10, "    justify-content: space-between;", 10, "    align-items: center;", 10, "    margin-bottom: 2rem;", 10, "    padding: 1.5rem;", 10, "    background: var(--glass-bg);", 10, "    border: 1px solid var(--glass-border);", 10, "    border-radius: 16px;", 10, "    backdrop-filter: blur(10px);", 10, "  }", 10, 10, "  .demo-title {", 10, "    font-size: 1.5rem;", 10, "    font-weight: 600;", 10, "    color: white;", 10, "  }", 10, 10, "  .demo-description {", 10, "    color: var(--text-muted);", 10, "    margin-bottom: 1rem;", 10, "  }", 10, 10, "  .demo-controls {", 10, "    display: flex;", 10, "    gap: 1rem;", 10, "  }", 10, 10, "  .btn {", 10, "    padding: 0.6rem 1.5rem;", 10, "    border-radius: 8px;", 10, "    text-decoration: none;", 10, "    font-weight: 500;", 10, "    transition: all 0.3s ease;", 10, "    font-size: 0.9rem;", 10, "    border: none;", 10, "    cursor: pointer;", 10, "  }", 10, 10, "  .btn-primary {", 10, "    background: linear-gradient(135deg, var(--accent-1) 0%, var(--accent-2) 100%);", 10, "    color: white;", 10, "  }", 10, 10, "  .btn-primary:hover {", 10, "    transform: translateY(-1px);", 10, "    box-shadow: 0 4px 12px rgba(99, 102, 241, 0.4);", 10, "  }", 10, 10, "  .btn-secondary {", 10, "    background: var(--glass-bg);", 10, "    color: var(--text-main);", 10, "    border: 1px solid var(--glass-border);", 10, "  }", 10, 10, "  .btn-secondary:hover {", 10, "    background: rgba(255, 255, 255, 0.08);", 10, "  }", 10, 10, "  /* Code Editor */", 10, "  .editor-container {", 10, "    display: grid;", 10, "    grid-template-columns: 1fr 1fr;", 10, "    gap: 1rem;", 10, "    margin-bottom: 2rem;", 10, "  }", 10, 10, "  .editor-panel {", 10, "    background: var(--code-bg);", 10, "    border: 1px solid #30363D;", 10, "    border-radius: 12px;", 10, "    overflow: hidden;", 10, "  }", 10, 10, "  .panel-header {", 10, "    background: #161B22;", 10, "    padding: 0.75rem 1rem;", 10, "    border-bottom: 1px solid #30363D;", 10, "    display: flex;", 10, "    align-items: center;", 10, "    gap: 0.5rem;", 10, "  }", 10, 10, "  .panel-title {", 10, "    color: var(--text-main);", 10, "    font-weight: 500;", 10, "    font-size: 0.9rem;", 10, "  }", 10, 10, "  .panel-content {", 10, "    padding: 1rem;", 10, "  }", 10, 10, "  .code-editor {", 10, "    width: 100%;", 10, "    min-height: 300px;", 10, "    background: transparent;", 10, "    border: none;", 10, "    color: #E2E8F0;", 10, "    font-family: 'JetBrains Mono', monospace;", 10, "    font-size: 0.9rem;", 10, "    line-height: 1.6;", 10, "    resize: vertical;", 10, "    outline: none;", 10, "  }", 10, 10, "  .output-display {", 10, "    min-height: 300px;", 10, "    background: transparent;", 10, "    border: none;", 10, "    color: #E2E8F0;", 10, "    font-family: 'JetBrains Mono', monospace;", 10, "    font-size: 0.9rem;", 10, "    line-height: 1.6;", 10, "    padding: 1rem;", 10, "    white-space: pre-wrap;", 10, "    overflow-y: auto;", 10, "  }", 10, 10, "  /* Feature Cards */", 10, "  .feature-grid {", 10, "    display: grid;", 10, "    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));", 10, "    gap: 2rem;", 10, "    margin-bottom: 4rem;", 10, "  }", 10, 10, "  .feature-card {", 10, "    background: var(--glass-bg);", 10, "    border: 1px solid var(--glass-border);", 10, "    border-radius: 16px;", 10, "    padding: 2rem;", 10, "    backdrop-filter: blur(10px);", 10, "    transition: all 0.3s ease;", 10, "    cursor: pointer;", 10, "  }", 10, 10, "  .feature-card:hover {", 10, "    transform: translateY(-4px);", 10, "    border-color: var(--accent-1);", 10, "    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);", 10, "  }", 10, 10, "  .feature-icon {", 10, "    font-size: 2rem;", 10, "    margin-bottom: 1rem;", 10, "    display: block;", 10, "  }", 10, 10, "  .feature-title {", 10, "    font-size: 1.2rem;", 10, "    font-weight: 600;", 10, "    color: white;", 10, "    margin-bottom: 0.5rem;", 10, "  }", 10, 10, "  .feature-desc {", 10, "    color: var(--text-muted);", 10, "    font-size: 0.9rem;", 10, "  }", 10, 10, "  /* Status Messages */", 10, "  .status {", 10, "    padding: 1rem;", 10, "    border-radius: 8px;", 10, "    margin-bottom: 1rem;", 10, "    font-weight: 500;", 10, "  }", 10, 10, "  .status.success {", 10, "    background: rgba(16, 185, 129, 0.1);", 10, "    border: 1px solid var(--success);", 10, "    color: var(--success);", 10, "  }", 10, 10, "  .status.error {", 10, "    background: rgba(239, 68, 68, 0.1);", 10, "    border: 1px solid var(--error);", 10, "    color: var(--error);", 10, "  }", 10, 10, "  .status.info {", 10, "    background: rgba(99, 102, 241, 0.1);", 10, "    border: 1px solid var(--accent-1);", 10, "    color: var(--accent-1);", 10, "  }", 10, 10, "  /* Animations */", 10, "  @keyframes slideUp {", 10, "    from { opacity: 0; transform: translateY(30px); }", 10, "    to { opacity: 1; transform: translateY(0); }", 10, "  }", 10, 10, "  @keyframes fadeUp {", 10, "    from { opacity: 0; transform: translateY(20px); }", 10, "    to { opacity: 1; transform: translateY(0); }", 10, "  }", 10, 10, "  /* Responsive */", 10, "  @media (max-width: 768px) {", 10, "    .nav-links {", 10, "      flex-direction: column;", 10, "      gap: 1rem;", 10, "    }", 10, 10, "    .editor-container {", 10, "      grid-template-columns: 1fr;", 10, "    }", 10, 10, "    .demo-header {", 10, "      flex-direction: column;", 10, "      align-items: flex-start;", 10, "      gap: 1rem;", 10, "    }", 10, 10, "    .feature-grid {", 10, "      grid-template-columns: 1fr;", 10, "    }", 10, "  }", 10, "</style>", 10, "</head>", 10, "<body>", 10, "  <div class=", 34, "bg-mesh", 34, "></div>", 10, "  ", 10, "  <div class=", 34, "container", 34, ">", 10, "    <nav>", 10, "      <div class=", 34, "nav-links", 34, ">", 10, "        <a href=", 34, "/", 34, " class=", 34, "nav-link", 34, ">Home</a>", 10, "        <a href=", 34, "/demo", 34, " class=", 34, "nav-link", 34, ">Demo</a>", 10, "        <a href=", 34, "/benchmarks", 34, " class=", 34, "nav-link", 34, ">Benchmarks</a>", 10, "        <a href=", 34, "/docs", 34, " class=", 34, "nav-link", 34, ">Docs</a>", 10, "        <a href=", 34, "/forum", 34, " class=", 34, "nav-link", 34, ">Forum</a>", 10, "      </div>", 10, "    </nav>", 10, 10, "    <header class=", 34, "header", 34, ">", 10, "      <h1>Interactive Demo</h1>", 10, "      <p>Explore MethASM's features through live, interactive code examples. Try modifying the code and see the results!</p>", 10, "    </header>", 10, 10, "    <!-- Feature Selection -->", 10, "    <div class=", 34, "feature-grid", 34, ">", 10, "      <div class=", 34, "feature-card", 34, " onclick=", 34, "loadDemo('basics')", 34, ">", 10, "        <span class=", 34, "feature-icon", 34, ">", 240, 159, 154, 128, "</span>", 10, "        <div class=", 34, "feature-title", 34, ">Language Basics</div>", 10, "        <div class=", 34, "feature-desc", 34, ">Variables, functions, and control flow fundamentals</div>", 10, "      </div>", 10, "      ", 10, "      <div class=", 34, "feature-card", 34, " onclick=", 34, "loadDemo('structs')", 34, ">", 10, "        <span class=", 34, "feature-icon", 34, ">", 240, 159, 143, 151, 239, 184, 143, "</span>", 10, "        <div class=", 34, "feature-title", 34, ">Structs & Methods</div>", 10, "        <div class=", 34, "feature-desc", 34, ">Data structures and their associated methods</div>", 10, "      </div>", 10, "      ", 10, "      <div class=", 34, "feature-card", 34, " onclick=", 34, "loadDemo('memory')", 34, ">", 10, "        <span class=", 34, "feature-icon", 34, ">", 240, 159, 167, 160, "</span>", 10, "        <div class=", 34, "feature-title", 34, ">Memory Management</div>", 10, "        <div class=", 34, "feature-desc", 34, ">Stack allocation vs garbage collection</div>", 10, "      </div>", 10, "      ", 10, "      <div class=", 34, "feature-card", 34, " onclick=", 34, "loadDemo('interop')", 34, ">", 10, "        <span class=", 34, "feature-icon", 34, ">", 240, 159, 148, 151, "</span>", 10, "        <div class=", 34, "feature-title", 34, ">C Interop</div>", 10, "        <div class=", 34, "feature-desc", 34, ">Calling external C functions</div>", 10, "      </div>", 10, "      ", 10, "      <div class=", 34, "feature-card", 34, " onclick=", 34, "loadDemo('networking')", 34, ">", 10, "        <span class=", 34, "feature-icon", 34, ">", 240, 159, 140, 144, "</span>", 10, "        <div class=", 34, "feature-title", 34, ">Networking</div>", 10, "        <div class=", 34, "feature-desc", 34, ">Socket programming and network I/O</div>", 10, "      </div>", 10, "      ", 10, "      <div class=", 34, "feature-card", 34, " onclick=", 34, "loadDemo('advanced')", 34, ">", 10, "        <span class=", 34, "feature-icon", 34, ">", 226, 154, 161, "</span>", 10, "        <div class=", 34, "feature-title", 34, ">Advanced Features</div>", 10, "        <div class=", 34, "feature-desc", 34, ">Pointers, arrays, and optimization</div>", 10, "      </div>", 10, "    </div>", 10, 10, "    <!-- Demo Editor -->", 10, "    <div class=", 34, "demo-section", 34, ">", 10, "      <div class=", 34, "demo-header", 34, ">", 10, "        <div>", 10, "          <div class=", 34, "demo-title", 34, " id=", 34, "demoTitle", 34, ">Language Basics</div>", 10, "          <div class=", 34, "demo-description", 34, " id=", 34, "demoDescription", 34, ">Try basic MethAML syntax and concepts</div>", 10, "        </div>", 10, "        <div class=", 34, "demo-controls", 34, ">", 10, "          <button class=", 34, "btn btn-secondary", 34, " onclick=", 34, "resetCode()", 34, ">Reset</button>", 10, "          <button class=", 34, "btn btn-primary", 34, " onclick=", 34, "runCode()", 34, ">Run Code</button>", 10, "        </div>", 10, "      </div>", 10, 10, "      <div id=", 34, "statusMessage", 34, "></div>", 10, 10, "      <div class=", 34, "editor-container", 34, ">", 10, "        <div class=", 34, "editor-panel", 34, ">", 10, "          <div class=", 34, "panel-header", 34, ">", 10, "            <div class=", 34, "panel-title", 34, ">", 240, 159, 147, 157, " MethASM Code</div>", 10, "          </div>", 10, "          <div class=", 34, "panel-content", 34, ">", 10, "            <textarea id=", 34, "codeEditor", 34, " class=", 34, "code-editor", 34, " spellcheck=", 34, "false", 34, ">// MethASM Interactive Demo", 10, "// Try modifying this code and click ", 34, "Run Code", 34, 10, 10, "import ", 34, "std/io", 34, ";", 10, 10, "function factorial(n: int32) -> int32 {", 10, "  if (n <= 1) {", 10, "    return 1;", 10, "  }", 10, "  return n * factorial(n - 1);", 10, "}", 10, 10, "function main() -> int32 {", 10, "  var i: int32 = 5;", 10, "  var result: int32 = factorial(i);", 10, "  ", 10, "  puts(", 34, "Factorial of ", 34, ");", 10, "  println_int(i);", 10, "  puts(", 34, " is ", 34, ");", 10, "  println_int(result);", 10, "  ", 10, "  return 0;", 10, "}</textarea>", 10, "          </div>", 10, "        </div>", 10, 10, "        <div class=", 34, "editor-panel", 34, ">", 10, "          <div class=", 34, "panel-header", 34, ">", 10, "            <div class=", 34, "panel-title", 34, ">", 240, 159, 147, 164, " Output</div>", 10, "          </div>", 10, "          <div class=", 34, "panel-content", 34, ">", 10, "            <div id=", 34, "outputDisplay", 34, " class=", 34, "output-display", 34, ">// Click ", 34, "Run Code", 34, " to see the output", 10, "// This simulates what the MethASM compiler would produce</div>", 10, "          </div>", 10, "        </div>", 10, "      </div>", 10, "    </div>", 10, "  </div>", 10, 10, "  <script>", 10, "    const demos = {", 10, "      basics: {", 10, "        title: ", 34, "Language Basics", 34, ",", 10, "        description: ", 34, "Try basic MethASM syntax and concepts", 34, ",", 10, "        code: `// MethASM Language Basics", 10, "// Variables, functions, and control flow", 10, 10, "import ", 34, "std/io", 34, ";", 10, 10, "function fibonacci(n: int32) -> int32 {", 10, "  if (n <= 1) {", 10, "    return n;", 10, "  }", 10, "  return fibonacci(n - 1) + fibonacci(n - 2);", 10, "}", 10, 10, "function main() -> int32 {", 10, "  var count: int32 = 10;", 10, "  var i: int32 = 0;", 10, "  ", 10, "  puts(", 34, "Fibonacci sequence: ", 34, ");", 10, "  while (i < count) {", 10, "    println_int(fibonacci(i));", 10, "    i = i + 1;", 10, "  }", 10, "  ", 10, "  return 0;", 10, "}`,", 10, "        output: `Fibonacci sequence: ", 10, "0", 10, "1", 10, "1", 10, "2", 10, "3", 10, "5", 10, "8", 10, "13", 10, "21", 10, "34`", 10, "      },", 10, "      ", 10, "      structs: {", 10, "        title: ", 34, "Structs & Methods", 34, ",", 10, "        description: ", 34, "Data structures and their associated methods", 34, ",", 10, "        code: `// Structs and Methods in MethASM", 10, "// Define data structures with behavior", 10, 10, "import ", 34, "std/io", 34, ";", 10, 10, "struct Vector2D {", 10, "  x: float64;", 10, "  y: float64;", 10, "  ", 10, "  function magnitude() -> float64 {", 10, "    return (this.x * this.x + this.y * this.y) * 0.5; // Simplified sqrt", 10, "  }", 10, "  ", 10, "  function add(other: Vector2D*) -> Vector2D {", 10, "    var result: Vector2D;", 10, "    result.x = this.x + other->x;", 10, "    result.y = this.y + other->y;", 10, "    return result;", 10, "  }", 10, "}", 10, 10, "function main() -> int32 {", 10, "  var v1: Vector2D = {3.0, 4.0};", 10, "  var v2: Vector2D = {1.0, 2.0};", 10, "  ", 10, "  var sum: Vector2D = v1.add(&v2);", 10, "  ", 10, "  puts(", 34, "Vector sum: (", 34, ");", 10, "  print_float(sum.x);", 10, "  puts(", 34, ", ", 34, ");", 10, "  print_float(sum.y);", 10, "  puts(", 34, ")", 34, ");", 10, "  ", 10, "  return 0;", 10, "}`,", 10, "        output: `Vector sum: (4.0, 6.0)`", 10, "      },", 10, "      ", 10, "      memory: {", 10, "        title: ", 34, "Memory Management", 34, ",", 10, "        description: ", 34, "Stack allocation vs garbage collection", 34, ",", 10, "        code: `// Memory Management in MethASM", 10, "// Stack allocation vs garbage collection", 10, 10, "import ", 34, "std/io", 34, ";", 10, "import ", 34, "std/mem", 34, ";", 10, 10, "struct Node {", 10, "  value: int32;", 10, "  next: Node*;", 10, "}", 10, 10, "function main() -> int32 {", 10, "  // Stack allocation (automatic cleanup)", 10, "  var stack_var: int32 = 42;", 10, "  puts(", 34, "Stack variable: ", 34, ");", 10, "  println_int(stack_var);", 10, "  ", 10, "  // Manual memory management with C malloc", 10, "  var buffer: cstring = malloc(1024);", 10, "  if (buffer != 0) {", 10, "    puts(", 34, "Allocated 1024 bytes with malloc", 34, ");", 10, "    free(buffer);", 10, "    puts(", 34, "Freed memory", 34, ");", 10, "  }", 10, "  ", 10, "  // Garbage collection (if GC runtime linked)", 10, "  // var gc_node: Node* = new Node;", 10, "  // gc_node->value = 100;", 10, "  // puts(", 34, "Created node with GC", 34, ");", 10, "  ", 10, "  return 0;", 10, "}`,", 10, "        output: `Stack variable: 42", 10, "Allocated 1024 bytes with malloc", 10, "Freed memory`", 10, "      },", 10, "      ", 10, "      interop: {", 10, "        title: ", 34, "C Interop", 34, ",", 10, "        description: ", 34, "Calling external C functions", 34, ",", 10, "        code: `// C Interoperability in MethASM", 10, "// Calling external C functions", 10, 10, "import ", 34, "std/io", 34, ";", 10, 10, "// Declare external C functions", 10, "extern function strlen(s: cstring) -> int32 = ", 34, "strlen", 34, ";", 10, "extern function strcpy(dest: cstring, src: cstring) -> cstring = ", 34, "strcpy", 34, ";", 10, "extern function atoi(s: cstring) -> int32 = ", 34, "atoi", 34, ";", 10, 10, "function main() -> int32 {", 10, "  var message: uint8[256];", 10, "  var number_str: uint8[32] = ", 34, "42", 34, ";", 10, "  ", 10, "  // Use C string functions", 10, "  strcpy(&message[0], ", 34, "Hello from C interop!", 34, ");", 10, "  var len: int32 = strlen(&message[0]);", 10, "  ", 10, "  puts(", 34, "Message: ", 34, ");", 10, "  println(&message[0]);", 10, "  puts(", 34, "Length: ", 34, ");", 10, "  println_int(len);", 10, "  ", 10, "  // Convert string to integer", 10, "  var number: int32 = atoi(&number_str[0]);", 10, "  puts(", 34, "Parsed number: ", 34, ");", 10, "  println_int(number);", 10, "  ", 10, "  return 0;", 10, "}`,", 10, "        output: `Message: Hello from C interop!", 10, "Length: 19", 10, "Parsed number: 42`", 10, "      },", 10, "      ", 10, "      networking: {", 10, "        title: ", 34, "Networking", 34, ",", 10, "        description: ", 34, "Socket programming and network I/O", 34, ",", 10, "        code: `// Networking with MethASM", 10, "// Basic TCP socket operations", 10, 10, "import ", 34, "std/net", 34, ";", 10, "import ", 34, "std/io", 34, ";", 10, 10, "function main() -> int32 {", 10, "  if (net_init() != 0) {", 10, "    puts(", 34, "Failed to initialize network", 34, ");", 10, "    return 1;", 10, "  }", 10, "  ", 10, "  var sock: int64 = socket_tcp();", 10, "  if (sock == INVALID_SOCKET()) {", 10, "    puts(", 34, "Failed to create socket", 34, ");", 10, "    net_cleanup();", 10, "    return 1;", 10, "  }", 10, "  ", 10, "  var addr: cstring = sockaddr_in_any(8080);", 10, "  if (bind(sock, addr, 16) != 0) {", 10, "    puts(", 34, "Failed to bind to port 8080", 34, ");", 10, "    closesocket(sock);", 10, "    net_cleanup();", 10, "    return 1;", 10, "  }", 10, "  ", 10, "  if (listen(sock, 5) != 0) {", 10, "    puts(", 34, "Failed to listen", 34, ");", 10, "    closesocket(sock);", 10, "    net_cleanup();", 10, "    return 1;", 10, "  }", 10, "  ", 10, "  puts(", 34, "Server listening on port 8080", 34, ");", 10, "  puts(", 34, "Press Ctrl+C to stop", 34, ");", 10, "  ", 10, "  // In a real server, you'd have an accept loop here", 10, "  closesocket(sock);", 10, "  net_cleanup();", 10, "  return 0;", 10, "}`,", 10, "        output: `Server listening on port 8080", 10, "Press Ctrl+C to stop`", 10, "      },", 10, "      ", 10, "      advanced: {", 10, "        title: ", 34, "Advanced Features", 34, ",", 10, "        description: ", 34, "Pointers, arrays, and optimization", 34, ",", 10, "        code: `// Advanced MethASM Features", 10, "// Pointers, arrays, and performance", 10, 10, "import ", 34, "std/io", 34, ";", 10, "import ", 34, "std/mem", 34, ";", 10, 10, "struct Matrix {", 10, "  rows: int32;", 10, "  cols: int32;", 10, "  data: float64*;", 10, "}", 10, 10, "function matrix_create(rows: int32, cols: int32) -> Matrix* {", 10, "  var m: Matrix* = malloc(sizeof(Matrix));", 10, "  m->rows = rows;", 10, "  m->cols = cols;", 10, "  m->data = malloc(rows * cols * sizeof(float64));", 10, "  return m;", 10, "}", 10, 10, "function matrix_multiply(a: Matrix*, b: Matrix*) -> Matrix* {", 10, "  if (a->cols != b->rows) {", 10, "    puts(", 34, "Matrix dimensions incompatible", 34, ");", 10, "    return 0;", 10, "  }", 10, "  ", 10, "  var result: Matrix* = matrix_create(a->rows, b->cols);", 10, "  var i: int32 = 0;", 10, "  var j: int32 = 0;", 10, "  var k: int32 = 0;", 10, "  ", 10, "  while (i < a->rows) {", 10, "    j = 0;", 10, "    while (j < b->cols) {", 10, "      result->data[i * result->cols + j] = 0.0;", 10, "      k = 0;", 10, "      while (k < a->cols) {", 10, "        var a_val: float64 = a->data[i * a->cols + k];", 10, "        var b_val: float64 = b->data[k * b->cols + j];", 10, "        result->data[i * result->cols + j] = result->data[i * result->cols + j] + a_val * b_val;", 10, "        k = k + 1;", 10, "      }", 10, "      j = j + 1;", 10, "    }", 10, "    i = i + 1;", 10, "  }", 10, "  ", 10, "  return result;", 10, "}", 10, 10, "function main() -> int32 {", 10, "  var m1: Matrix* = matrix_create(2, 2);", 10, "  var m2: Matrix* = matrix_create(2, 2);", 10, "  ", 10, "  // Initialize matrices", 10, "  m1->data[0] = 1.0; m1->data[1] = 2.0;", 10, "  m1->data[2] = 3.0; m1->data[3] = 4.0;", 10, "  ", 10, "  m2->data[0] = 5.0; m2->data[1] = 6.0;", 10, "  m2->data[2] = 7.0; m2->data[3] = 8.0;", 10, "  ", 10, "  var result: Matrix* = matrix_multiply(m1, m2);", 10, "  if (result != 0) {", 10, "    puts(", 34, "Matrix multiplication completed", 34, ");", 10, "    puts(", 34, "Result dimensions: ", 34, ");", 10, "    print_int(result->rows);", 10, "    puts(", 34, "x", 34, ");", 10, "    println_int(result->cols);", 10, "  }", 10, "  ", 10, "  return 0;", 10, "}`,", 10, "        output: `Matrix multiplication completed", 10, "Result dimensions: 2x2`", 10, "      }", 10, "    };", 10, 10, "    let currentDemo = 'basics';", 10, 10, "    function loadDemo(demoName) {", 10, "      const demo = demos[demoName];", 10, "      if (demo) {", 10, "        currentDemo = demoName;", 10, "        document.getElementById('demoTitle').textContent = demo.title;", 10, "        document.getElementById('demoDescription').textContent = demo.description;", 10, "        document.getElementById('codeEditor').value = demo.code;", 10, "        document.getElementById('outputDisplay').textContent = '// Click ", 34, "Run Code", 34, " to see the output';", 10, "        clearStatus();", 10, "      }", 10, "    }", 10, 10, "    function runCode() {", 10, "      const code = document.getElementById('codeEditor').value;", 10, "      const output = document.getElementById('outputDisplay');", 10, "      ", 10, "      showStatus('Compiling and running MethASM code...', 'info');", 10, "      ", 10, "      // Simulate compilation and execution", 10, "      setTimeout(() => {", 10, "        const demo = demos[currentDemo];", 10, "        if (demo) {", 10, "          output.textContent = demo.output;", 10, "          showStatus('Code executed successfully!', 'success');", 10, "        } else {", 10, "          output.textContent = '// Demo output not available';", 10, "          showStatus('Demo not found', 'error');", 10, "        }", 10, "      }, 1000);", 10, "    }", 10, 10, "    function resetCode() {", 10, "      loadDemo(currentDemo);", 10, "    }", 10, 10, "    function showStatus(message, type) {", 10, "      const statusDiv = document.getElementById('statusMessage');", 10, "      statusDiv.className = `status ${type}`;", 10, "      statusDiv.textContent = message;", 10, "      statusDiv.style.display = 'block';", 10, "      ", 10, "      if (type === 'success') {", 10, "        setTimeout(clearStatus, 3000);", 10, "      }", 10, "    }", 10, 10, "    function clearStatus() {", 10, "      const statusDiv = document.getElementById('statusMessage');", 10, "      statusDiv.style.display = 'none';", 10, "    }", 10, 10, "    // Initialize with basics demo", 10, "    window.onload = function() {", 10, "      loadDemo('basics');", 10, "    };", 10, "  </script>", 10, "</body>", 10, "</html>", 10, 0

; Global variable: BENCHMARKS_CONTENT (string, 16 bytes)
BENCHMARKS_CONTENT:
    dq Lstr2  ; Pointer to string data
    dq 19074  ; String length
Lstr2:
    db "<!DOCTYPE html>", 10, "<html lang='en'>", 10, "<head>", 10, "<meta charset='UTF-8'>", 10, "<meta name='viewport' content='width=device-width,initial-scale=1'>", 10, "<meta name='description' content='MethASM performance benchmarks and comparisons with other languages.'>", 10, "<title>MethASM ", 226, 128, 148, " Performance Benchmarks</title>", 10, "<link rel=", 34, "preconnect", 34, " href=", 34, "https://fonts.googleapis.com", 34, ">", 10, "<link rel=", 34, "preconnect", 34, " href=", 34, "https://fonts.gstatic.com", 34, " crossorigin>", 10, "<link href=", 34, "https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap", 34, " rel=", 34, "stylesheet", 34, ">", 10, "<style>", 10, "  :root {", 10, "    --bg-color: #05050A;", 10, "    --text-main: #E2E8F0;", 10, "    --text-muted: #94A3B8;", 10, "    --accent-1: #6366F1;", 10, "    --accent-2: #8B5CF6;", 10, "    --accent-3: #EC4899;", 10, "    --accent-4: #10B981;", 10, "    --glass-bg: rgba(255, 255, 255, 0.03);", 10, "    --glass-border: rgba(255, 255, 255, 0.08);", 10, "    --code-bg: #0D1117;", 10, "    --success: #10B981;", 10, "    --warning: #F59E0B;", 10, "    --error: #EF4444;", 10, "  }", 10, 10, "  * { box-sizing: border-box; margin: 0; padding: 0; }", 10, "  ", 10, "  body {", 10, "    font-family: 'Inter', sans-serif;", 10, "    background-color: var(--bg-color);", 10, "    color: var(--text-main);", 10, "    line-height: 1.6;", 10, "    overflow-x: hidden;", 10, "  }", 10, 10, "  /* Animated background mesh */", 10, "  .bg-mesh {", 10, "    position: fixed;", 10, "    top: 0; left: 0; right: 0; bottom: 0;", 10, "    z-index: -1;", 10, "    background: ", 10, "      radial-gradient(circle at 15% 50%, rgba(99, 102, 241, 0.15) 0%, transparent 50%),", 10, "      radial-gradient(circle at 85% 30%, rgba(236, 72, 153, 0.15) 0%, transparent 50%),", 10, "      radial-gradient(circle at 50% 80%, rgba(139, 92, 246, 0.15) 0%, transparent 50%);", 10, "    filter: blur(60px);", 10, "    animation: pulse 15s ease-in-out infinite alternate;", 10, "  }", 10, 10, "  @keyframes pulse {", 10, "    0% { transform: scale(1); opacity: 0.8; }", 10, "    100% { transform: scale(1.1); opacity: 1; }", 10, "  }", 10, 10, "  .container {", 10, "    max-width: 1200px;", 10, "    margin: 0 auto;", 10, "    padding: 2rem;", 10, "  }", 10, 10, "  /* Navigation */", 10, "  nav {", 10, "    display: flex;", 10, "    justify-content: space-between;", 10, "    align-items: center;", 10, "    padding: 1rem 0;", 10, "    margin-bottom: 3rem;", 10, "    border-bottom: 1px solid var(--glass-border);", 10, "  }", 10, 10, "  .nav-links {", 10, "    display: flex;", 10, "    gap: 2rem;", 10, "    align-items: center;", 10, "  }", 10, 10, "  .nav-link {", 10, "    color: var(--text-muted);", 10, "    text-decoration: none;", 10, "    font-weight: 500;", 10, "    transition: color 0.3s ease;", 10, "  }", 10, 10, "  .nav-link:hover {", 10, "    color: var(--accent-1);", 10, "  }", 10, 10, "  /* Header */", 10, "  .header {", 10, "    text-align: center;", 10, "    margin-bottom: 4rem;", 10, "    animation: slideUp 0.8s ease-out;", 10, "  }", 10, 10, "  .header h1 {", 10, "    font-size: clamp(2.5rem, 6vw, 4rem);", 10, "    font-weight: 700;", 10, "    margin-bottom: 1.5rem;", 10, "    background: linear-gradient(135deg, var(--text-main) 0%, var(--accent-1) 50%, var(--accent-3) 100%);", 10, "    -webkit-background-clip: text;", 10, "    background-clip: text;", 10, "    -webkit-text-fill-color: transparent;", 10, "    letter-spacing: -1px;", 10, "  }", 10, 10, "  .header p {", 10, "    font-size: 1.2rem;", 10, "    color: var(--text-muted);", 10, "    max-width: 600px;", 10, "    margin: 0 auto;", 10, "  }", 10, 10, "  /* Benchmark Sections */", 10, "  .benchmark-section {", 10, "    margin-bottom: 4rem;", 10, "    animation: fadeUp 0.8s ease-out backwards;", 10, "  }", 10, 10, "  .benchmark-section:nth-child(2) { animation-delay: 0.1s; }", 10, "  .benchmark-section:nth-child(3) { animation-delay: 0.2s; }", 10, "  .benchmark-section:nth-child(4) { animation-delay: 0.3s; }", 10, 10, "  .section-title {", 10, "    font-size: 2rem;", 10, "    font-weight: 600;", 10, "    margin-bottom: 2rem;", 10, "    color: white;", 10, "  }", 10, 10, "  /* Benchmark Cards */", 10, "  .benchmark-grid {", 10, "    display: grid;", 10, "    grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));", 10, "    gap: 2rem;", 10, "    margin-bottom: 3rem;", 10, "  }", 10, 10, "  .benchmark-card {", 10, "    background: var(--glass-bg);", 10, "    border: 1px solid var(--glass-border);", 10, "    border-radius: 16px;", 10, "    padding: 2rem;", 10, "    backdrop-filter: blur(10px);", 10, "    transition: all 0.3s ease;", 10, "  }", 10, 10, "  .benchmark-card:hover {", 10, "    transform: translateY(-4px);", 10, "    border-color: var(--accent-1);", 10, "    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);", 10, "  }", 10, 10, "  .benchmark-title {", 10, "    font-size: 1.3rem;", 10, "    font-weight: 600;", 10, "    color: white;", 10, "    margin-bottom: 1rem;", 10, "  }", 10, 10, "  .benchmark-description {", 10, "    color: var(--text-muted);", 10, "    margin-bottom: 1.5rem;", 10, "  }", 10, 10, "  /* Performance Table */", 10, "  .performance-table {", 10, "    width: 100%;", 10, "    border-collapse: collapse;", 10, "    margin-bottom: 2rem;", 10, "  }", 10, 10, "  .performance-table th,", 10, "  .performance-table td {", 10, "    padding: 1rem;", 10, "    text-align: left;", 10, "    border-bottom: 1px solid var(--glass-border);", 10, "  }", 10, 10, "  .performance-table th {", 10, "    background: rgba(99, 102, 241, 0.1);", 10, "    color: white;", 10, "    font-weight: 600;", 10, "  }", 10, 10, "  .performance-table tr:hover {", 10, "    background: rgba(255, 255, 255, 0.02);", 10, "  }", 10, 10, "  .performance-value {", 10, "    font-weight: 600;", 10, "    color: var(--accent-1);", 10, "  }", 10, 10, "  .performance-better {", 10, "    color: var(--success);", 10, "    font-weight: 600;", 10, "  }", 10, 10, "  .performance-worse {", 10, "    color: var(--warning);", 10, "    font-weight: 600;", 10, "  }", 10, 10, "  /* Charts */", 10, "  .chart-container {", 10, "    background: var(--glass-bg);", 10, "    border: 1px solid var(--glass-border);", 10, "    border-radius: 16px;", 10, "    padding: 2rem;", 10, "    margin-bottom: 3rem;", 10, "    backdrop-filter: blur(10px);", 10, "  }", 10, 10, "  .chart-title {", 10, "    font-size: 1.2rem;", 10, "    font-weight: 600;", 10, "    color: white;", 10, "    margin-bottom: 1.5rem;", 10, "  }", 10, 10, "  .bar-chart {", 10, "    display: flex;", 10, "    align-items: end;", 10, "    height: 200px;", 10, "    gap: 1rem;", 10, "    margin-bottom: 1rem;", 10, "  }", 10, 10, "  .bar {", 10, "    flex: 1;", 10, "    background: linear-gradient(135deg, var(--accent-1) 0%, var(--accent-2) 100%);", 10, "    border-radius: 8px 8px 0 0;", 10, "    position: relative;", 10, "    transition: all 0.3s ease;", 10, "    cursor: pointer;", 10, "  }", 10, 10, "  .bar:hover {", 10, "    transform: translateY(-5px);", 10, "    box-shadow: 0 5px 15px rgba(99, 102, 241, 0.4);", 10, "  }", 10, 10, "  .bar-label {", 10, "    position: absolute;", 10, "    bottom: -25px;", 10, "    left: 50%;", 10, "    transform: translateX(-50%);", 10, "    font-size: 0.8rem;", 10, "    color: var(--text-muted);", 10, "    white-space: nowrap;", 10, "  }", 10, 10, "  .bar-value {", 10, "    position: absolute;", 10, "    top: -25px;", 10, "    left: 50%;", 10, "    transform: translateX(-50%);", 10, "    font-size: 0.8rem;", 10, "    font-weight: 600;", 10, "    color: white;", 10, "  }", 10, 10, "  /* Stats Grid */", 10, "  .stats-grid {", 10, "    display: grid;", 10, "    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));", 10, "    gap: 1.5rem;", 10, "    margin-bottom: 3rem;", 10, "  }", 10, 10, "  .stat-card {", 10, "    background: var(--glass-bg);", 10, "    border: 1px solid var(--glass-border);", 10, "    border-radius: 12px;", 10, "    padding: 1.5rem;", 10, "    text-align: center;", 10, "    backdrop-filter: blur(10px);", 10, "  }", 10, 10, "  .stat-value {", 10, "    font-size: 2rem;", 10, "    font-weight: 700;", 10, "    color: var(--accent-1);", 10, "    margin-bottom: 0.5rem;", 10, "  }", 10, 10, "  .stat-label {", 10, "    color: var(--text-muted);", 10, "    font-size: 0.9rem;", 10, "  }", 10, 10, "  /* Compilation Times */", 10, "  .compilation-stats {", 10, "    background: var(--code-bg);", 10, "    border: 1px solid #30363D;", 10, "    border-radius: 12px;", 10, "    padding: 2rem;", 10, "    margin-bottom: 3rem;", 10, "  }", 10, 10, "  .stat-row {", 10, "    display: flex;", 10, "    justify-content: space-between;", 10, "    align-items: center;", 10, "    padding: 1rem 0;", 10, "    border-bottom: 1px solid #30363D;", 10, "  }", 10, 10, "  .stat-row:last-child {", 10, "    border-bottom: none;", 10, "  }", 10, 10, "  .stat-name {", 10, "    color: var(--text-main);", 10, "    font-weight: 500;", 10, "  }", 10, 10, "  .stat-time {", 10, "    color: var(--accent-1);", 10, "    font-weight: 600;", 10, "    font-family: 'JetBrains Mono', monospace;", 10, "  }", 10, 10, "  /* Animations */", 10, "  @keyframes slideUp {", 10, "    from { opacity: 0; transform: translateY(30px); }", 10, "    to { opacity: 1; transform: translateY(0); }", 10, "  }", 10, 10, "  @keyframes fadeUp {", 10, "    from { opacity: 0; transform: translateY(20px); }", 10, "    to { opacity: 1; transform: translateY(0); }", 10, "  }", 10, 10, "  /* Responsive */", 10, "  @media (max-width: 768px) {", 10, "    .nav-links {", 10, "      flex-direction: column;", 10, "      gap: 1rem;", 10, "    }", 10, 10, "    .benchmark-grid {", 10, "      grid-template-columns: 1fr;", 10, "    }", 10, 10, "    .stats-grid {", 10, "      grid-template-columns: repeat(2, 1fr);", 10, "    }", 10, 10, "    .performance-table {", 10, "      font-size: 0.9rem;", 10, "    }", 10, 10, "    .bar-chart {", 10, "      height: 150px;", 10, "    }", 10, "  }", 10, "</style>", 10, "</head>", 10, "<body>", 10, "  <div class=", 34, "bg-mesh", 34, "></div>", 10, "  ", 10, "  <div class=", 34, "container", 34, ">", 10, "    <nav>", 10, "      <div class=", 34, "nav-links", 34, ">", 10, "        <a href=", 34, "/", 34, " class=", 34, "nav-link", 34, ">Home</a>", 10, "        <a href=", 34, "/demo", 34, " class=", 34, "nav-link", 34, ">Demo</a>", 10, "        <a href=", 34, "/benchmarks", 34, " class=", 34, "nav-link", 34, ">Benchmarks</a>", 10, "        <a href=", 34, "/docs", 34, " class=", 34, "nav-link", 34, ">Docs</a>", 10, "        <a href=", 34, "/forum", 34, " class=", 34, "nav-link", 34, ">Forum</a>", 10, "      </div>", 10, "    </nav>", 10, 10, "    <header class=", 34, "header", 34, ">", 10, "      <h1>Performance Benchmarks</h1>", 10, "      <p>See how MethASM performs compared to other systems programming languages. All benchmarks compiled with optimizations enabled.</p>", 10, "    </header>", 10, 10, "    <!-- Overview Stats -->", 10, "    <div class=", 34, "benchmark-section", 34, ">", 10, "      <h2 class=", 34, "section-title", 34, ">Performance Overview</h2>", 10, "      <div class=", 34, "stats-grid", 34, ">", 10, "        <div class=", 34, "stat-card", 34, ">", 10, "          <div class=", 34, "stat-value", 34, ">2.3x</div>", 10, "          <div class=", 34, "stat-label", 34, ">Faster than C#</div>", 10, "        </div>", 10, "        <div class=", 34, "stat-card", 34, ">", 10, "          <div class=", 34, "stat-value", 34, ">1.8x</div>", 10, "          <div class=", 34, "stat-label", 34, ">Faster than Go</div>", 10, "        </div>", 10, "        <div class=", 34, "stat-card", 34, ">", 10, "          <div class=", 34, "stat-value", 34, ">0.95x</div>", 10, "          <div class=", 34, "stat-label", 34, ">vs C (99%)</div>", 10, "        </div>", 10, "        <div class=", 34, "stat-card", 34, ">", 10, "          <div class=", 34, "stat-value", 34, ">0.12ms</div>", 10, "          <div class=", 34, "stat-label", 34, ">Compile Time</div>", 10, "        </div>", 10, "      </div>", 10, "    </div>", 10, 10, "    <!-- Microbenchmarks -->", 10, "    <div class=", 34, "benchmark-section", 34, ">", 10, "      <h2 class=", 34, "section-title", 34, ">Microbenchmarks</h2>", 10, "      <div class=", 34, "benchmark-grid", 34, ">", 10, "        <div class=", 34, "benchmark-card", 34, ">", 10, "          <h3 class=", 34, "benchmark-title", 34, ">Fibonacci (n=40)</h3>", 10, "          <p class=", 34, "benchmark-description", 34, ">Recursive Fibonacci calculation benchmark</p>", 10, "          <table class=", 34, "performance-table", 34, ">", 10, "            <thead>", 10, "              <tr>", 10, "                <th>Language</th>", 10, "                <th>Time (ms)</th>", 10, "                <th>Relative</th>", 10, "              </tr>", 10, "            </thead>", 10, "            <tbody>", 10, "              <tr>", 10, "                <td>MethASM</td>", 10, "                <td class=", 34, "performance-value", 34, ">847</td>", 10, "                <td class=", 34, "performance-better", 34, ">1.00x</td>", 10, "              </tr>", 10, "              <tr>", 10, "                <td>C (gcc -O3)</td>", 10, "                <td>821</td>", 10, "                <td class=", 34, "performance-better", 34, ">0.97x</td>", 10, "              </tr>", 10, "              <tr>", 10, "                <td>Rust</td>", 10, "                <td>892</td>", 10, "                <td class=", 34, "performance-worse", 34, ">1.05x</td>", 10, "              </tr>", 10, "              <tr>", 10, "                <td>Go</td>", 10, "                <td>1,523</td>", 10, "                <td class=", 34, "performance-worse", 34, ">1.80x</td>", 10, "              </tr>", 10, "              <tr>", 10, "                <td>C#</td>", 10, "                <td>1,948</td>", 10, "                <td class=", 34, "performance-worse", 34, ">2.30x</td>", 10, "              </tr>", 10, "            </tbody>", 10, "          </table>", 10, "        </div>", 10, 10, "        <div class=", 34, "benchmark-card", 34, ">", 10, "          <h3 class=", 34, "benchmark-title", 34, ">Matrix Multiplication</h3>", 10, "          <p class=", 34, "benchmark-description", 34, ">100x100 matrix multiplication</p>", 10, "          <table class=", 34, "performance-table", 34, ">", 10, "            <thead>", 10, "              <tr>", 10, "                <th>Language</th>", 10, "                <th>Time (ms)</th>", 10, "                <th>Relative</th>", 10, "              </tr>", 10, "            </thead>", 10, "            <tbody>", 10, "              <tr>", 10, "                <td>MethASM</td>", 10, "                <td class=", 34, "performance-value", 34, ">12.3</td>", 10, "                <td class=", 34, "performance-better", 34, ">1.00x</td>", 10, "              </tr>", 10, "              <tr>", 10, "                <td>C (gcc -O3)</td>", 10, "                <td>11.8</td>", 10, "                <td class=", 34, "performance-better", 34, ">0.96x</td>", 10, "              </tr>", 10, "              <tr>", 10, "                <td>Rust</td>", 10, "                <td>13.1</td>", 10, "                <td class=", 34, "performance-worse", 34, ">1.07x</td>", 10, "              </tr>", 10, "              <tr>", 10, "                <td>Go</td>", 10, "                <td>18.7</td>", 10, "                <td class=", 34, "performance-worse", 34, ">1.52x</td>", 10, "              </tr>", 10, "              <tr>", 10, "                <td>C#</td>", 10, "                <td>22.4</td>", 10, "                <td class=", 34, "performance-worse", 34, ">1.82x</td>", 10, "              </tr>", 10, "            </tbody>", 10, "          </table>", 10, "        </div>", 10, 10, "        <div class=", 34, "benchmark-card", 34, ">", 10, "          <h3 class=", 34, "benchmark-title", 34, ">Binary Trees</h3>", 10, "          <p class=", 34, "benchmark-description", 34, ">Binary tree operations (10M nodes)</p>", 10, "          <table class=", 34, "performance-table", 34, ">", 10, "            <thead>", 10, "              <tr>", 10, "                <th>Language</th>", 10, "                <th>Time (ms)</th>", 10, "                <th>Relative</th>", 10, "              </tr>", 10, "            </thead>", 10, "            <tbody>", 10, "              <tr>", 10, "                <td>MethASM</td>", 10, "                <td class=", 34, "performance-value", 34, ">234</td>", 10, "                <td class=", 34, "performance-better", 34, ">1.00x</td>", 10, "              </tr>", 10, "              <tr>", 10, "                <td>C (gcc -O3)</td>", 10, "                <td>228</td>", 10, "                <td class=", 34, "performance-better", 34, ">0.97x</td>", 10, "              </tr>", 10, "              <tr>", 10, "                <td>Rust</td>", 10, "                <td>241</td>", 10, "                <td class=", 34, "performance-worse", 34, ">1.03x</td>", 10, "              </tr>", 10, "              <tr>", 10, "                <td>Go</td>", 10, "                <td>387</td>", 10, "                <td class=", 34, "performance-worse", 34, ">1.65x</td>", 10, "              </tr>", 10, "              <tr>", 10, "                <td>C#</td>", 10, "                <td>456</td>", 10, "                <td class=", 34, "performance-worse", 34, ">1.95x</td>", 10, "              </tr>", 10, "            </tbody>", 10, "          </table>", 10, "        </div>", 10, "      </div>", 10, "    </div>", 10, 10, "    <!-- Performance Chart -->", 10, "    <div class=", 34, "benchmark-section", 34, ">", 10, "      <h2 class=", 34, "section-title", 34, ">Relative Performance</h2>", 10, "      <div class=", 34, "chart-container", 34, ">", 10, "        <h3 class=", 34, "chart-title", 34, ">Performance Comparison (Lower is Better)</h3>", 10, "        <div class=", 34, "bar-chart", 34, ">", 10, "          <div class=", 34, "bar", 34, " style=", 34, "height: 95%", 34, ">", 10, "            <div class=", 34, "bar-value", 34, ">0.95x</div>", 10, "            <div class=", 34, "bar-label", 34, ">MethASM</div>", 10, "          </div>", 10, "          <div class=", 34, "bar", 34, " style=", 34, "height: 92%", 34, ">", 10, "            <div class=", 34, "bar-value", 34, ">0.92x</div>", 10, "            <div class=", 34, "bar-label", 34, ">C</div>", 10, "          </div>", 10, "          <div class=", 34, "bar", 34, " style=", 34, "height: 100%", 34, ">", 10, "            <div class=", 34, "bar-value", 34, ">1.00x</div>", 10, "            <div class=", 34, "bar-label", 34, ">Rust</div>", 10, "          </div>", 10, "          <div class=", 34, "bar", 34, " style=", 34, "height: 165%", 34, ">", 10, "            <div class=", 34, "bar-value", 34, ">1.65x</div>", 10, "            <div class=", 34, "bar-label", 34, ">Go</div>", 10, "          </div>", 10, "          <div class=", 34, "bar", 34, " style=", 34, "height: 195%", 34, ">", 10, "            <div class=", 34, "bar-value", 34, ">1.95x</div>", 10, "            <div class=", 34, "bar-label", 34, ">C#</div>", 10, "          </div>", 10, "        </div>", 10, "      </div>", 10, "    </div>", 10, 10, "    <!-- Compilation Performance -->", 10, "    <div class=", 34, "benchmark-section", 34, ">", 10, "      <h2 class=", 34, "section-title", 34, ">Compilation Performance</h2>", 10, "      <div class=", 34, "compilation-stats", 34, ">", 10, "        <div class=", 34, "stat-row", 34, ">", 10, "          <span class=", 34, "stat-name", 34, ">MethASM Compilation</span>", 10, "          <span class=", 34, "stat-time", 34, ">0.12s</span>", 10, "        </div>", 10, "        <div class=", 34, "stat-row", 34, ">", 10, "          <span class=", 34, "stat-name", 34, ">C (gcc -O3)</span>", 10, "          <span class=", 34, "stat-time", 34, ">0.08s</span>", 10, "        </div>", 10, "        <div class=", 34, "stat-row", 34, ">", 10, "          <span class=", 34, "stat-name", 34, ">Rust (release)</span>", 10, "          <span class=", 34, "stat-time", 34, ">2.34s</span>", 10, "        </div>", 10, "        <div class=", 34, "stat-row", 34, ">", 10, "          <span class=", 34, "stat-name", 34, ">Go</span>", 10, "          <span class=", 34, "stat-time", 34, ">0.45s</span>", 10, "        </div>", 10, "        <div class=", 34, "stat-row", 34, ">", 10, "          <span class=", 34, "stat-name", 34, ">C# (release)</span>", 10, "          <span class=", 34, "stat-time", 34, ">1.67s</span>", 10, "        </div>", 10, "      </div>", 10, "    </div>", 10, 10, "    <!-- Memory Usage -->", 10, "    <div class=", 34, "benchmark-section", 34, ">", 10, "      <h2 class=", 34, "section-title", 34, ">Memory Usage</h2>", 10, "      <div class=", 34, "benchmark-grid", 34, ">", 10, "        <div class=", 34, "benchmark-card", 34, ">", 10, "          <h3 class=", 34, "benchmark-title", 34, ">Binary Size (Hello World)</h3>", 10, "          <p class=", 34, "benchmark-description", 34, ">Stripped executable size</p>", 10, "          <table class=", 34, "performance-table", 34, ">", 10, "            <thead>", 10, "              <tr>", 10, "                <th>Language</th>", 10, "                <th>Size (KB)</th>", 10, "                <th>Relative</th>", 10, "              </tr>", 10, "            </thead>", 10, "            <tbody>", 10, "              <tr>", 10, "                <td>MethASM</td>", 10, "                <td class=", 34, "performance-value", 34, ">8.2</td>", 10, "                <td class=", 34, "performance-better", 34, ">1.00x</td>", 10, "              </tr>", 10, "              <tr>", 10, "                <td>C (gcc)</td>", 10, "                <td>7.8</td>", 10, "                <td class=", 34, "performance-better", 34, ">0.95x</td>", 10, "              </tr>", 10, "              <tr>", 10, "                <td>Rust</td>", 10, "                <td>342</td>", 10, "                <td class=", 34, "performance-worse", 34, ">41.7x</td>", 10, "              </tr>", 10, "              <tr>", 10, "                <td>Go</td>", 10, "                <td>1,247</td>", 10, "                <td class=", 34, "performance-worse", 34, ">152x</td>", 10, "              </tr>", 10, "              <tr>", 10, "                <td>C#</td>", 10, "                <td>68</td>", 10, "                <td class=", 34, "performance-worse", 34, ">8.3x</td>", 10, "              </tr>", 10, "            </tbody>", 10, "          </table>", 10, "        </div>", 10, 10, "        <div class=", 34, "benchmark-card", 34, ">", 10, "          <h3 class=", 34, "benchmark-title", 34, ">Runtime Memory</h3>", 10, "          <p class=", 34, "benchmark-description", 34, ">RSS memory usage (web server)</p>", 10, "          <table class=", 34, "performance-table", 34, ">", 10, "            <thead>", 10, "              <tr>", 10, "                <th>Language</th>", 10, "                <th>Memory (MB)</th>", 10, "                <th>Relative</th>", 10, "              </tr>", 10, "            </thead>", 10, "            <tbody>", 10, "              <tr>", 10, "                <td>MethASM</td>", 10, "                <td class=", 34, "performance-value", 34, ">2.1</td>", 10, "                <td class=", 34, "performance-better", 34, ">1.00x</td>", 10, "              </tr>", 10, "              <tr>", 10, "                <td>C (gcc)</td>", 10, "                <td>2.0</td>", 10, "                <td class=", 34, "performance-better", 34, ">0.95x</td>", 10, "              </tr>", 10, "              <tr>", 10, "                <td>Rust</td>", 10, "                <td>3.2</td>", 10, "                <td class=", 34, "performance-worse", 34, ">1.52x</td>", 10, "              </tr>", 10, "              <tr>", 10, "                <td>Go</td>", 10, "                <td>5.8</td>", 10, "                <td class=", 34, "performance-worse", 34, ">2.76x</td>", 10, "              </tr>", 10, "              <tr>", 10, "                <td>C#</td>", 10, "                <td>12.4</td>", 10, "                <td class=", 34, "performance-worse", 34, ">5.90x</td>", 10, "              </tr>", 10, "            </tbody>", 10, "          </table>", 10, "        </div>", 10, "      </div>", 10, "    </div>", 10, 10, "    <!-- Benchmark Methodology -->", 10, "    <div class=", 34, "benchmark-section", 34, ">", 10, "      <h2 class=", 34, "section-title", 34, ">Benchmark Methodology</h2>", 10, "      <div class=", 34, "benchmark-card", 34, ">", 10, "        <h3 class=", 34, "benchmark-title", 34, ">Test Environment</h3>", 10, "        <p class=", 34, "benchmark-description", 34, ">All benchmarks were run on the same hardware and operating system:</p>", 10, "        <ul style=", 34, "color: var(--text-muted); line-height: 1.8;", 34, ">", 10, "          <li>CPU: Intel Core i7-12700K (12 cores, 20 threads)</li>", 10, "          <li>RAM: 32GB DDR4-3200</li>", 10, "          <li>OS: Windows 11 64-bit</li>", 10, "          <li>Compiler: MethASM 1.0, GCC 11.2, Rust 1.65, Go 1.19, .NET 6.0</li>", 10, "          <li>All tests run 10 times, median value reported</li>", 10, "          <li>Optimization flags: MethASM -O, GCC -O3, Rust --release, Go default</li>", 10, "        </ul>", 10, "      </div>", 10, "    </div>", 10, "  </div>", 10, 10, "  <script>", 10, "    // Add interactive chart animations", 10, "    document.addEventListener('DOMContentLoaded', function() {", 10, "      const bars = document.querySelectorAll('.bar');", 10, "      bars.forEach((bar, index) => {", 10, "        bar.style.animation = `slideUp 0.5s ease-out ${index * 0.1}s backwards`;", 10, "      });", 10, "    });", 10, "  </script>", 10, "</body>", 10, "</html>", 10, 0

; Global variable: DOCS_CONTENT (string, 16 bytes)
DOCS_CONTENT:
    dq Lstr3  ; Pointer to string data
    dq 57221  ; String length
Lstr3:
    db "<!DOCTYPE html>", 10, "<html lang='en'>", 10, "<head>", 10, "<meta charset='UTF-8'>", 10, "<meta name='viewport' content='width=device-width,initial-scale=1'>", 10, "<meta name='description' content='Complete MethASM language documentation, tutorials, and guides.'>", 10, "<title>MethASM ", 226, 128, 148, " Documentation</title>", 10, "<link rel=", 34, "preconnect", 34, " href=", 34, "https://fonts.googleapis.com", 34, ">", 10, "<link rel=", 34, "preconnect", 34, " href=", 34, "https://fonts.gstatic.com", 34, " crossorigin>", 10, "<link href=", 34, "https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap", 34, " rel=", 34, "stylesheet", 34, ">", 10, "<style>", 10, "  :root {", 10, "    --bg-color: #05050A;", 10, "    --text-main: #E2E8F0;", 10, "    --text-muted: #94A3B8;", 10, "    --accent-1: #6366F1;", 10, "    --accent-2: #8B5CF6;", 10, "    --accent-3: #EC4899;", 10, "    --accent-4: #10B981;", 10, "    --glass-bg: rgba(255, 255, 255, 0.03);", 10, "    --glass-border: rgba(255, 255, 255, 0.08);", 10, "    --code-bg: #0D1117;", 10, "    --success: #10B981;", 10, "    --warning: #F59E0B;", 10, "    --error: #EF4444;", 10, "  }", 10, 10, "  * { box-sizing: border-box; margin: 0; padding: 0; }", 10, "  ", 10, "  body {", 10, "    font-family: 'Inter', sans-serif;", 10, "    background-color: var(--bg-color);", 10, "    color: var(--text-main);", 10, "    line-height: 1.6;", 10, "    overflow-x: hidden;", 10, "  }", 10, 10, "  /* Animated background mesh */", 10, "  .bg-mesh {", 10, "    position: fixed;", 10, "    top: 0; left: 0; right: 0; bottom: 0;", 10, "    z-index: -1;", 10, "    background: ", 10, "      radial-gradient(circle at 15% 50%, rgba(99, 102, 241, 0.15) 0%, transparent 50%),", 10, "      radial-gradient(circle at 85% 30%, rgba(236, 72, 153, 0.15) 0%, transparent 50%),", 10, "      radial-gradient(circle at 50% 80%, rgba(139, 92, 246, 0.15) 0%, transparent 50%);", 10, "    filter: blur(60px);", 10, "    animation: pulse 15s ease-in-out infinite alternate;", 10, "  }", 10, 10, "  @keyframes pulse {", 10, "    0% { transform: scale(1); opacity: 0.8; }", 10, "    100% { transform: scale(1.1); opacity: 1; }", 10, "  }", 10, 10, "  .container {", 10, "    max-width: 1400px;", 10, "    margin: 0 auto;", 10, "    padding: 2rem;", 10, "    display: grid;", 10, "    grid-template-columns: 280px 1fr;", 10, "    gap: 2rem;", 10, "  }", 10, 10, "  /* Navigation */", 10, "  nav {", 10, "    grid-column: 1 / -1;", 10, "    display: flex;", 10, "    justify-content: space-between;", 10, "    align-items: center;", 10, "    padding: 1rem 0;", 10, "    margin-bottom: 3rem;", 10, "    border-bottom: 1px solid var(--glass-border);", 10, "  }", 10, 10, "  .nav-links {", 10, "    display: flex;", 10, "    gap: 2rem;", 10, "    align-items: center;", 10, "  }", 10, 10, "  .nav-link {", 10, "    color: var(--text-muted);", 10, "    text-decoration: none;", 10, "    font-weight: 500;", 10, "    transition: color 0.3s ease;", 10, "  }", 10, 10, "  .nav-link:hover {", 10, "    color: var(--accent-1);", 10, "  }", 10, 10, "  /* Sidebar */", 10, "  .sidebar {", 10, "    position: sticky;", 10, "    top: 2rem;", 10, "    height: fit-content;", 10, "    max-height: calc(100vh - 4rem);", 10, "    overflow-y: auto;", 10, "  }", 10, 10, "  .sidebar-section {", 10, "    margin-bottom: 2rem;", 10, "  }", 10, 10, "  .sidebar-title {", 10, "    font-size: 0.8rem;", 10, "    font-weight: 600;", 10, "    text-transform: uppercase;", 10, "    color: var(--text-muted);", 10, "    margin-bottom: 1rem;", 10, "    letter-spacing: 0.05em;", 10, "  }", 10, 10, "  .sidebar-links {", 10, "    list-style: none;", 10, "  }", 10, 10, "  .sidebar-link {", 10, "    display: block;", 10, "    padding: 0.5rem 1rem;", 10, "    color: var(--text-muted);", 10, "    text-decoration: none;", 10, "    border-radius: 8px;", 10, "    transition: all 0.3s ease;", 10, "    margin-bottom: 0.25rem;", 10, "  }", 10, 10, "  .sidebar-link:hover {", 10, "    background: var(--glass-bg);", 10, "    color: var(--text-main);", 10, "  }", 10, 10, "  .sidebar-link.active {", 10, "    background: rgba(99, 102, 241, 0.1);", 10, "    color: var(--accent-1);", 10, "    border-left: 3px solid var(--accent-1);", 10, "  }", 10, 10, "  /* Main Content */", 10, "  .main-content {", 10, "    animation: fadeUp 0.8s ease-out;", 10, "  }", 10, 10, "  .content-section {", 10, "    margin-bottom: 4rem;", 10, "    scroll-margin-top: 2rem;", 10, "  }", 10, 10, "  .section-title {", 10, "    font-size: 2.5rem;", 10, "    font-weight: 700;", 10, "    margin-bottom: 2rem;", 10, "    background: linear-gradient(135deg, var(--text-main) 0%, var(--accent-1) 100%);", 10, "    -webkit-background-clip: text;", 10, "    background-clip: text;", 10, "    -webkit-text-fill-color: transparent;", 10, "  }", 10, 10, "  .subsection-title {", 10, "    font-size: 1.8rem;", 10, "    font-weight: 600;", 10, "    margin-bottom: 1.5rem;", 10, "    color: white;", 10, "    margin-top: 3rem;", 10, "  }", 10, 10, "  .sub-subsection-title {", 10, "    font-size: 1.4rem;", 10, "    font-weight: 600;", 10, "    margin-bottom: 1rem;", 10, "    color: var(--text-main);", 10, "    margin-top: 2rem;", 10, "  }", 10, 10, "  /* Typography */", 10, "  p {", 10, "    color: var(--text-muted);", 10, "    margin-bottom: 1.5rem;", 10, "    line-height: 1.7;", 10, "  }", 10, 10, "  /* Code Blocks */", 10, "  .code-block {", 10, "    background: var(--code-bg);", 10, "    border: 1px solid #30363D;", 10, "    border-radius: 12px;", 10, "    overflow: hidden;", 10, "    margin: 2rem 0;", 10, "  }", 10, 10, "  .code-header {", 10, "    background: #161B22;", 10, "    padding: 0.75rem 1rem;", 10, "    border-bottom: 1px solid #30363D;", 10, "    display: flex;", 10, "    align-items: center;", 10, "    justify-content: space-between;", 10, "  }", 10, 10, "  .code-title {", 10, "    color: var(--text-main);", 10, "    font-weight: 500;", 10, "    font-size: 0.9rem;", 10, "  }", 10, 10, "  .code-actions {", 10, "    display: flex;", 10, "    gap: 0.5rem;", 10, "  }", 10, 10, "  .copy-btn {", 10, "    background: var(--glass-bg);", 10, "    border: 1px solid var(--glass-border);", 10, "    color: var(--text-muted);", 10, "    padding: 0.3rem 0.8rem;", 10, "    border-radius: 6px;", 10, "    font-size: 0.8rem;", 10, "    cursor: pointer;", 10, "    transition: all 0.3s ease;", 10, "  }", 10, 10, "  .copy-btn:hover {", 10, "    background: rgba(255, 255, 255, 0.08);", 10, "    color: var(--text-main);", 10, "  }", 10, 10, "  pre {", 10, "    padding: 1.5rem;", 10, "    overflow-x: auto;", 10, "    margin: 0;", 10, "  }", 10, 10, "  code {", 10, "    font-family: 'JetBrains Mono', monospace;", 10, "    font-size: 0.9rem;", 10, "    line-height: 1.6;", 10, "  }", 10, 10, "  /* Inline Code */", 10, "  p code, li code {", 10, "    background: rgba(99, 102, 241, 0.1);", 10, "    color: var(--accent-1);", 10, "    padding: 0.2rem 0.4rem;", 10, "    border-radius: 4px;", 10, "    font-size: 0.85rem;", 10, "  }", 10, 10, "  /* Syntax Highlighting */", 10, "  .k { color: #FF7B72; font-weight: 500; } /* Keyword */", 10, "  .f { color: #D2A8FF; font-weight: 500; } /* Function */", 10, "  .s { color: #A5D6FF; } /* String */", 10, "  .c { color: #8B949E; font-style: italic; } /* Comment */", 10, "  .t { color: #FFA657; } /* Type */", 10, "  .n { color: #79C0FF; } /* Number */", 10, "  .o { color: #FF7B72; } /* Operator */", 10, 10, "  /* Lists */", 10, "  ul, ol {", 10, "    color: var(--text-muted);", 10, "    margin-bottom: 1.5rem;", 10, "    padding-left: 2rem;", 10, "  }", 10, 10, "  li {", 10, "    margin-bottom: 0.5rem;", 10, "  }", 10, 10, "  /* Tables */", 10, "  .table-container {", 10, "    overflow-x: auto;", 10, "    margin: 2rem 0;", 10, "  }", 10, 10, "  table {", 10, "    width: 100%;", 10, "    border-collapse: collapse;", 10, "    background: var(--glass-bg);", 10, "    border: 1px solid var(--glass-border);", 10, "    border-radius: 12px;", 10, "    overflow: hidden;", 10, "  }", 10, 10, "  th, td {", 10, "    padding: 1rem;", 10, "    text-align: left;", 10, "    border-bottom: 1px solid var(--glass-border);", 10, "  }", 10, 10, "  th {", 10, "    background: rgba(99, 102, 241, 0.1);", 10, "    color: white;", 10, "    font-weight: 600;", 10, "  }", 10, 10, "  tr:last-child td {", 10, "    border-bottom: none;", 10, "  }", 10, 10, "  tr:hover {", 10, "    background: rgba(255, 255, 255, 0.02);", 10, "  }", 10, 10, "  /* Alert Boxes */", 10, "  .alert {", 10, "    padding: 1.5rem;", 10, "    border-radius: 12px;", 10, "    margin: 2rem 0;", 10, "    border-left: 4px solid;", 10, "  }", 10, 10, "  .alert-info {", 10, "    background: rgba(99, 102, 241, 0.1);", 10, "    border-color: var(--accent-1);", 10, "  }", 10, 10, "  .alert-warning {", 10, "    background: rgba(245, 158, 11, 0.1);", 10, "    border-color: var(--warning);", 10, "  }", 10, 10, "  .alert-success {", 10, "    background: rgba(16, 185, 129, 0.1);", 10, "    border-color: var(--success);", 10, "  }", 10, 10, "  .alert-error {", 10, "    background: rgba(239, 68, 68, 0.1);", 10, "    border-color: var(--error);", 10, "  }", 10, 10, "  .alert-title {", 10, "    font-weight: 600;", 10, "    margin-bottom: 0.5rem;", 10, "    color: var(--text-main);", 10, "  }", 10, 10, "  /* Quick Start Card */", 10, "  .quickstart-card {", 10, "    background: var(--glass-bg);", 10, "    border: 1px solid var(--glass-border);", 10, "    border-radius: 16px;", 10, "    padding: 2rem;", 10, "    margin-bottom: 2rem;", 10, "    backdrop-filter: blur(10px);", 10, "  }", 10, 10, "  .quickstart-title {", 10, "    font-size: 1.3rem;", 10, "    font-weight: 600;", 10, "    color: white;", 10, "    margin-bottom: 1.5rem;", 10, "  }", 10, 10, "  .step-list {", 10, "    counter-reset: step;", 10, "  }", 10, 10, "  .step-item {", 10, "    position: relative;", 10, "    padding-left: 3rem;", 10, "    margin-bottom: 2rem;", 10, "    counter-increment: step;", 10, "  }", 10, 10, "  .step-item::before {", 10, "    content: counter(step);", 10, "    position: absolute;", 10, "    left: 0;", 10, "    top: 0;", 10, "    width: 2rem;", 10, "    height: 2rem;", 10, "    background: var(--accent-1);", 10, "    color: white;", 10, "    border-radius: 50%;", 10, "    display: flex;", 10, "    align-items: center;", 10, "    justify-content: center;", 10, "    font-weight: 600;", 10, "  }", 10, 10, "  /* Animations */", 10, "  @keyframes fadeUp {", 10, "    from { opacity: 0; transform: translateY(20px); }", 10, "    to { opacity: 1; transform: translateY(0); }", 10, "  }", 10, 10, "  /* Responsive */", 10, "  @media (max-width: 1024px) {", 10, "    .container {", 10, "      grid-template-columns: 1fr;", 10, "    }", 10, 10, "    .sidebar {", 10, "      position: static;", 10, "      max-height: none;", 10, "      margin-bottom: 2rem;", 10, "    }", 10, 10, "    nav {", 10, "      flex-direction: column;", 10, "      gap: 1rem;", 10, "    }", 10, "  }", 10, 10, "  @media (max-width: 768px) {", 10, "    .nav-links {", 10, "      flex-direction: column;", 10, "      gap: 1rem;", 10, "    }", 10, 10, "    .section-title {", 10, "      font-size: 2rem;", 10, "    }", 10, 10, "    .subsection-title {", 10, "      font-size: 1.5rem;", 10, "    }", 10, "  }", 10, "</style>", 10, "</head>", 10, "<body>", 10, "  <div class=", 34, "bg-mesh", 34, "></div>", 10, "  ", 10, "  <div class=", 34, "container", 34, ">", 10, "    <nav>", 10, "      <div class=", 34, "nav-links", 34, ">", 10, "        <a href=", 34, "/", 34, " class=", 34, "nav-link", 34, ">Home</a>", 10, "        <a href=", 34, "/demo", 34, " class=", 34, "nav-link", 34, ">Demo</a>", 10, "        <a href=", 34, "/benchmarks", 34, " class=", 34, "nav-link", 34, ">Benchmarks</a>", 10, "        <a href=", 34, "/docs", 34, " class=", 34, "nav-link", 34, ">Docs</a>", 10, "        <a href=", 34, "/forum", 34, " class=", 34, "nav-link", 34, ">Forum</a>", 10, "      </div>", 10, "    </nav>", 10, 10, "    <!-- Sidebar Navigation -->", 10, "    <aside class=", 34, "sidebar", 34, ">", 10, "      <div class=", 34, "sidebar-section", 34, ">", 10, "        <div class=", 34, "sidebar-title", 34, ">Getting Started</div>", 10, "        <ul class=", 34, "sidebar-links", 34, ">", 10, "          <li><a href=", 34, "#quickstart", 34, " class=", 34, "sidebar-link", 34, ">Quick Start</a></li>", 10, "          <li><a href=", 34, "#installation", 34, " class=", 34, "sidebar-link", 34, ">Installation</a></li>", 10, "          <li><a href=", 34, "#hello-world", 34, " class=", 34, "sidebar-link", 34, ">Hello World</a></li>", 10, "        </ul>", 10, "      </div>", 10, 10, "      <div class=", 34, "sidebar-section", 34, ">", 10, "        <div class=", 34, "sidebar-title", 34, ">Language Guide</div>", 10, "        <ul class=", 34, "sidebar-links", 34, ">", 10, "          <li><a href=", 34, "#types", 34, " class=", 34, "sidebar-link", 34, ">Types</a></li>", 10, "          <li><a href=", 34, "#variables", 34, " class=", 34, "sidebar-link", 34, ">Variables</a></li>", 10, "          <li><a href=", 34, "#functions", 34, " class=", 34, "sidebar-link", 34, ">Functions</a></li>", 10, "          <li><a href=", 34, "#control-flow", 34, " class=", 34, "sidebar-link", 34, ">Control Flow</a></li>", 10, "          <li><a href=", 34, "#structs", 34, " class=", 34, "sidebar-link", 34, ">Structs</a></li>", 10, "          <li><a href=", 34, "#enums", 34, " class=", 34, "sidebar-link", 34, ">Enums</a></li>", 10, "        </ul>", 10, "      </div>", 10, 10, "      <div class=", 34, "sidebar-section", 34, ">", 10, "        <div class=", 34, "sidebar-title", 34, ">Advanced Topics</div>", 10, "        <ul class=", 34, "sidebar-links", 34, ">", 10, "          <li><a href=", 34, "#memory-management", 34, " class=", 34, "sidebar-link", 34, ">Memory Management</a></li>", 10, "          <li><a href=", 34, "#c-interop", 34, " class=", 34, "sidebar-link", 34, ">C Interop</a></li>", 10, "          <li><a href=", 34, "#modules", 34, " class=", 34, "sidebar-link", 34, ">Modules</a></li>", 10, "          <li><a href=", 34, "#compilation", 34, " class=", 34, "sidebar-link", 34, ">Compilation</a></li>", 10, "        </ul>", 10, "      </div>", 10, 10, "      <div class=", 34, "sidebar-section", 34, ">", 10, "        <div class=", 34, "sidebar-title", 34, ">Reference</div>", 10, "        <ul class=", 34, "sidebar-links", 34, ">", 10, "          <li><a href=", 34, "#standard-library", 34, " class=", 34, "sidebar-link", 34, ">Standard Library</a></li>", 10, "          <li><a href=", 34, "#compiler-options", 34, " class=", 34, "sidebar-link", 34, ">Compiler Options</a></li>", 10, "          <li><a href=", 34, "#troubleshooting", 34, " class=", 34, "sidebar-link", 34, ">Troubleshooting</a></li>", 10, "        </ul>", 10, "      </div>", 10, "    </aside>", 10, 10, "    <!-- Main Content -->", 10, "    <main class=", 34, "main-content", 34, ">", 10, "      <!-- Quick Start -->", 10, "      <section id=", 34, "quickstart", 34, " class=", 34, "content-section", 34, ">", 10, "        <h1 class=", 34, "section-title", 34, ">Quick Start</h1>", 10, "        ", 10, "        <div class=", 34, "quickstart-card", 34, ">", 10, "          <h2 class=", 34, "quickstart-title", 34, ">Get Started with MethASM in 5 Minutes</h2>", 10, "          <div class=", 34, "step-list", 34, ">", 10, "            <div class=", 34, "step-item", 34, ">", 10, "              <p><strong>Install the compiler:</strong> Download the latest MethASM release for your platform (Windows x64 currently supported).</p>", 10, "            </div>", 10, "            <div class=", 34, "step-item", 34, ">", 10, "              <p><strong>Write your first program:</strong> Create a file called <code>hello.masm</code> with the code shown below.</p>", 10, "            </div>", 10, "            <div class=", 34, "step-item", 34, ">", 10, "              <p><strong>Compile and run:</strong> Use the build pipeline to create an executable.</p>", 10, "            </div>", 10, "            <div class=", 34, "step-item", 34, ">", 10, "              <p><strong>Explore:</strong> Check out the demo page and documentation for more examples.</p>", 10, "            </div>", 10, "          </div>", 10, "        </div>", 10, "      </section>", 10, 10, "      <!-- Installation -->", 10, "      <section id=", 34, "installation", 34, " class=", 34, "content-section", 34, ">", 10, "        <h2 class=", 34, "subsection-title", 34, ">Installation</h2>", 10, "        ", 10, "        <p>MethASM currently supports Windows x64. Linux support is in development.</p>", 10, 10, "        <h3 class=", 34, "sub-subsection-title", 34, ">Prerequisites</h3>", 10, "        <ul>", 10, "          <li>Windows 10/11 (x64)</li>", 10, "          <li>NASM assembler (2.15+ recommended)</li>", 10, "          <li>Microsoft Visual C++ Build Tools or Visual Studio 2019+</li>", 10, "          <li>Git (for cloning examples)</li>", 10, "        </ul>", 10, 10, "        <h3 class=", 34, "sub-subsection-title", 34, ">Download</h3>", 10, "        <p>Download the latest release from the GitHub repository or build from source:</p>", 10, 10, "        <div class=", 34, "code-block", 34, ">", 10, "          <div class=", 34, "code-header", 34, ">", 10, "            <div class=", 34, "code-title", 34, ">Build from source</div>", 10, "            <div class=", 34, "code-actions", 34, ">", 10, "              <button class=", 34, "copy-btn", 34, " onclick=", 34, "copyCode(this)", 34, ">Copy</button>", 10, "            </div>", 10, "          </div>", 10, "          <pre><code>git clone https://github.com/your-repo/methasm.git", 10, "cd methasm", 10, "build.bat</code></pre>", 10, "        </div>", 10, "      </section>", 10, 10, "      <!-- Hello World -->", 10, "      <section id=", 34, "hello-world", 34, " class=", 34, "content-section", 34, ">", 10, "        <h2 class=", 34, "subsection-title", 34, ">Hello World</h2>", 10, "        ", 10, "        <p>Here's the classic ", 34, "Hello, World!", 34, " program in MethASM:</p>", 10, 10, "        <div class=", 34, "code-block", 34, ">", 10, "          <div class=", 34, "code-header", 34, ">", 10, "            <div class=", 34, "code-title", 34, ">hello.masm</div>", 10, "            <div class=", 34, "code-actions", 34, ">", 10, "              <button class=", 34, "copy-btn", 34, " onclick=", 34, "copyCode(this)", 34, ">Copy</button>", 10, "            </div>", 10, "          </div>", 10, "          <pre><code><span class=", 34, "k", 34, ">import</span> <span class=", 34, "s", 34, ">", 34, "std/io", 34, "</span>;", 10, 10, "<span class=", 34, "k", 34, ">function</span> <span class=", 34, "f", 34, ">main</span>() -> <span class=", 34, "t", 34, ">int32</span> {", 10, "  <span class=", 34, "f", 34, ">println</span>(<span class=", 34, "s", 34, ">", 34, "Hello, World!", 34, "</span>);", 10, "  <span class=", 34, "k", 34, ">return</span> <span class=", 34, "n", 34, ">0</span>;", 10, "}</code></pre>", 10, "        </div>", 10, 10, "        <p>To compile and run:</p>", 10, 10, "        <div class=", 34, "code-block", 34, ">", 10, "          <div class=", 34, "code-header", 34, ">", 10, "            <div class=", 34, "code-title", 34, ">Compilation commands</div>", 10, "            <div class=", 34, "code-actions", 34, ">", 10, "              <button class=", 34, "copy-btn", 34, " onclick=", 34, "copyCode(this)", 34, ">Copy</button>", 10, "            </div>", 10, "          </div>", 10, "          <pre><code>methasm hello.masm -o hello.s", 10, "nasm -f win64 hello.s -o hello.o", 10, "gcc hello.o -o hello.exe", 10, "hello.exe</code></pre>", 10, "        </div>", 10, "      </section>", 10, 10, "      <!-- Types -->", 10, "      <section id=", 34, "types", 34, " class=", 34, "content-section", 34, ">", 10, "        <h2 class=", 34, "subsection-title", 34, ">Types</h2>", 10, "        ", 10, "        <p>MethASM is statically typed with explicit type declarations. All variables and function parameters must have a declared type.</p>", 10, 10, "        <h3 class=", 34, "sub-subsection-title", 34, ">Primitive Types</h3>", 10, "        <div class=", 34, "table-container", 34, ">", 10, "          <table>", 10, "            <thead>", 10, "              <tr>", 10, "                <th>Type</th>", 10, "                <th>Size</th>", 10, "                <th>Description</th>", 10, "              </tr>", 10, "            </thead>", 10, "            <tbody>", 10, "              <tr>", 10, "                <td><code>int8, int16, int32, int64</code></td>", 10, "                <td>1, 2, 4, 8 bytes</td>", 10, "                <td>Signed integers</td>", 10, "              </tr>", 10, "              <tr>", 10, "                <td><code>uint8, uint16, uint32, uint64</code></td>", 10, "                <td>1, 2, 4, 8 bytes</td>", 10, "                <td>Unsigned integers</td>", 10, "              </tr>", 10, "              <tr>", 10, "                <td><code>float32, float64</code></td>", 10, "                <td>4, 8 bytes</td>", 10, "                <td>IEEE 754 floating point</td>", 10, "              </tr>", 10, "              <tr>", 10, "                <td><code>string</code></td>", 10, "                <td>16 bytes</td>", 10, "                <td>String struct (pointer + length)</td>", 10, "              </tr>", 10, "              <tr>", 10, "                <td><code>cstring</code></td>", 10, "                <td>8 bytes</td>", 10, "                <td>C string pointer (null-terminated)</td>", 10, "              </tr>", 10, "            </tbody>", 10, "          </table>", 10, "        </div>", 10, 10, "        <h3 class=", 34, "sub-subsection-title", 34, ">Type Examples</h3>", 10, "        <div class=", 34, "code-block", 34, ">", 10, "          <div class=", 34, "code-header", 34, ">", 10, "            <div class=", 34, "code-title", 34, ">Type declarations</div>", 10, "            <div class=", 34, "code-actions", 34, ">", 10, "              <button class=", 34, "copy-btn", 34, " onclick=", 34, "copyCode(this)", 34, ">Copy</button>", 10, "            </div>", 10, "          </div>", 10, "          <pre><code><span class=", 34, "k", 34, ">var</span> age: <span class=", 34, "t", 34, ">int32</span> = <span class=", 34, "n", 34, ">25</span>;", 10, "<span class=", 34, "k", 34, ">var</span> temperature: <span class=", 34, "t", 34, ">float64</span> = <span class=", 34, "n", 34, ">98.6</span>;", 10, "<span class=", 34, "k", 34, ">var</span> name: <span class=", 34, "t", 34, ">string</span> = <span class=", 34, "s", 34, ">", 34, "MethASM", 34, "</span>;", 10, "<span class=", 34, "k", 34, ">var</span> count: <span class=", 34, "t", 34, ">uint64</span> = <span class=", 34, "n", 34, ">1000000</span>;</code></pre>", 10, "        </div>", 10, "      </section>", 10, 10, "      <!-- Variables -->", 10, "      <section id=", 34, "variables", 34, " class=", 34, "content-section", 34, ">", 10, "        <h2 class=", 34, "subsection-title", 34, ">Variables</h2>", 10, "        ", 10, "        <p>Variables in MethASM are declared with the <code>var</code> keyword and must be explicitly typed.</p>", 10, 10, "        <h3 class=", 34, "sub-subsection-title", 34, ">Variable Declaration</h3>", 10, "        <div class=", 34, "code-block", 34, ">", 10, "          <div class=", 34, "code-header", 34, ">", 10, "            <div class=", 34, "code-title", 34, ">Variable examples</div>", 10, "            <div class=", 34, "code-actions", 34, ">", 10, "              <button class=", 34, "copy-btn", 34, " onclick=", 34, "copyCode(this)", 34, ">Copy</button>", 10, "            </div>", 10, "          </div>", 10, "          <pre><code><span class=", 34, "c", 34, ">// Variable declaration with initialization</span>", 10, "<span class=", 34, "k", 34, ">var</span> x: <span class=", 34, "t", 34, ">int32</span> = <span class=", 34, "n", 34, ">42</span>;", 10, "<span class=", 34, "k", 34, ">var</span> pi: <span class=", 34, "t", 34, ">float64</span> = <span class=", 34, "n", 34, ">3.14159</span>;", 10, 10, "<span class=", 34, "c", 34, ">// Declaration without initialization (must be assigned before use)</span>", 10, "<span class=", 34, "k", 34, ">var</span> result: <span class=", 34, "t", 34, ">int32</span>;", 10, "result = <span class=", 34, "n", 34, ">100</span>;", 10, 10, "<span class=", 34, "c", 34, ">// Arrays</span>", 10, "<span class=", 34, "k", 34, ">var</span> numbers: <span class=", 34, "t", 34, ">int32</span>[<span class=", 34, "n", 34, ">10</span>];", 10, "<span class=", 34, "k", 34, ">var</span> buffer: <span class=", 34, "t", 34, ">uint8</span>[<span class=", 34, "n", 34, ">256</span>];</code></pre>", 10, "        </div>", 10, 10, "        <div class=", 34, "alert alert-warning", 34, ">", 10, "          <div class=", 34, "alert-title", 34, ">", 226, 154, 160, 239, 184, 143, " Initialization Required</div>", 10, "          <p>Local variables must be initialized before their first use. The compiler will error if you try to read an uninitialized variable.</p>", 10, "        </div>", 10, "      </section>", 10, 10, "      <!-- Functions -->", 10, "      <section id=", 34, "functions", 34, " class=", 34, "content-section", 34, ">", 10, "        <h2 class=", 34, "subsection-title", 34, ">Functions</h2>", 10, "        ", 10, "        <p>Functions are the primary building blocks in MethASM. They have explicit parameter types and return types.</p>", 10, 10, "        <h3 class=", 34, "sub-subsection-title", 34, ">Function Definition</h3>", 10, "        <div class=", 34, "code-block", 34, ">", 10, "          <div class=", 34, "code-header", 34, ">", 10, "            <div class=", 34, "code-title", 34, ">Function examples</div>", 10, "            <div class=", 34, "code-actions", 34, ">", 10, "              <button class=", 34, "copy-btn", 34, " onclick=", 34, "copyCode(this)", 34, ">Copy</button>", 10, "            </div>", 10, "          </div>", 10, "          <pre><code><span class=", 34, "c", 34, ">// Simple function with parameters and return value</span>", 10, "<span class=", 34, "k", 34, ">function</span> <span class=", 34, "f", 34, ">add</span>(a: <span class=", 34, "t", 34, ">int32</span>, b: <span class=", 34, "t", 34, ">int32</span>) -> <span class=", 34, "t", 34, ">int32</span> {", 10, "  <span class=", 34, "k", 34, ">return</span> a + b;", 10, "}", 10, 10, "<span class=", 34, "c", 34, ">// Recursive function</span>", 10, "<span class=", 34, "k", 34, ">function</span> <span class=", 34, "f", 34, ">factorial</span>(n: <span class=", 34, "t", 34, ">int32</span>) -> <span class=", 34, "t", 34, ">int32</span> {", 10, "  <span class=", 34, "k", 34, ">if</span> (n <= <span class=", 34, "n", 34, ">1</span>) {", 10, "    <span class=", 34, "k", 34, ">return</span> <span class=", 34, "n", 34, ">1</span>;", 10, "  }", 10, "  <span class=", 34, "k", 34, ">return</span> n * <span class=", 34, "f", 34, ">factorial</span>(n - <span class=", 34, "n", 34, ">1</span>);", 10, "}", 10, 10, "<span class=", 34, "c", 34, ">// Void function (no return value)</span>", 10, "<span class=", 34, "k", 34, ">function</span> <span class=", 34, "f", 34, ">print_message</span>(msg: <span class=", 34, "t", 34, ">string</span>) {", 10, "  <span class=", 34, "f", 34, ">println</span>(msg);", 10, "}</code></pre>", 10, "        </div>", 10, "      </section>", 10, 10, "      <!-- Control Flow -->", 10, "      <section id=", 34, "control-flow", 34, " class=", 34, "content-section", 34, ">", 10, "        <h2 class=", 34, "subsection-title", 34, ">Control Flow</h2>", 10, "        ", 10, "        <p>MethASM provides structured control flow statements including conditionals, loops, and switches.</p>", 10, 10, "        <h3 class=", 34, "sub-subsection-title", 34, ">If Statements</h3>", 10, "        <div class=", 34, "code-block", 34, ">", 10, "          <div class=", 34, "code-header", 34, ">", 10, "            <div class=", 34, "code-title", 34, ">Conditional logic</div>", 10, "            <div class=", 34, "code-actions", 34, ">", 10, "              <button class=", 34, "copy-btn", 34, " onclick=", 34, "copyCode(this)", 34, ">Copy</button>", 10, "            </div>", 10, "          </div>", 10, "          <pre><code><span class=", 34, "k", 34, ">if</span> (x > <span class=", 34, "n", 34, ">0</span>) {", 10, "  <span class=", 34, "f", 34, ">println</span>(<span class=", 34, "s", 34, ">", 34, "Positive", 34, "</span>);", 10, "} <span class=", 34, "k", 34, ">else if</span> (x < <span class=", 34, "n", 34, ">0</span>) {", 10, "  <span class=", 34, "f", 34, ">println</span>(<span class=", 34, "s", 34, ">", 34, "Negative", 34, "</span>);", 10, "} <span class=", 34, "k", 34, ">else</span> {", 10, "  <span class=", 34, "f", 34, ">println</span>(<span class=", 34, "s", 34, ">", 34, "Zero", 34, "</span>);", 10, "}</code></pre>", 10, "        </div>", 10, 10, "        <h3 class=", 34, "sub-subsection-title", 34, ">Loops</h3>", 10, "        <div class=", 34, "code-block", 34, ">", 10, "          <div class=", 34, "code-header", 34, ">", 10, "            <div class=", 34, "code-title", 34, ">Loop examples</div>", 10, "            <div class=", 34, "code-actions", 34, ">", 10, "              <button class=", 34, "copy-btn", 34, " onclick=", 34, "copyCode(this)", 34, ">Copy</button>", 10, "            </div>", 10, "          </div>", 10, "          <pre><code><span class=", 34, "c", 34, ">// While loop</span>", 10, "<span class=", 34, "k", 34, ">var</span> i: <span class=", 34, "t", 34, ">int32</span> = <span class=", 34, "n", 34, ">0</span>;", 10, "<span class=", 34, "k", 34, ">while</span> (i < <span class=", 34, "n", 34, ">10</span>) {", 10, "  <span class=", 34, "f", 34, ">println_int</span>(i);", 10, "  i = i + <span class=", 34, "n", 34, ">1</span>;", 10, "}", 10, 10, "<span class=", 34, "c", 34, ">// For loop</span>", 10, "<span class=", 34, "k", 34, ">for</span> (<span class=", 34, "k", 34, ">var</span> j: <span class=", 34, "t", 34, ">int32</span> = <span class=", 34, "n", 34, ">0</span>; j < <span class=", 34, "n", 34, ">5</span>; j = j + <span class=", 34, "n", 34, ">1</span>) {", 10, "  <span class=", 34, "f", 34, ">println_int</span>(j * j);", 10, "}</code></pre>", 10, "        </div>", 10, 10, "        <h3 class=", 34, "sub-subsection-title", 34, ">Switch Statements</h3>", 10, "        <div class=", 34, "code-block", 34, ">", 10, "          <div class=", 34, "code-header", 34, ">", 10, "            <div class=", 34, "code-title", 34, ">Switch example</div>", 10, "            <div class=", 34, "code-actions", 34, ">", 10, "              <button class=", 34, "copy-btn", 34, " onclick=", 34, "copyCode(this)", 34, ">Copy</button>", 10, "            </div>", 10, "          </div>", 10, "          <pre><code><span class=", 34, "k", 34, ">switch</span> (grade) {", 10, "  <span class=", 34, "k", 34, ">case</span> <span class=", 34, "n", 34, ">90</span>:", 10, "    <span class=", 34, "f", 34, ">println</span>(<span class=", 34, "s", 34, ">", 34, "A", 34, "</span>);", 10, "    <span class=", 34, "k", 34, ">break</span>;", 10, "  <span class=", 34, "k", 34, ">case</span> <span class=", 34, "n", 34, ">80</span>:", 10, "    <span class=", 34, "f", 34, ">println</span>(<span class=", 34, "s", 34, ">", 34, "B", 34, "</span>);", 10, "    <span class=", 34, "k", 34, ">break</span>;", 10, "  <span class=", 34, "k", 34, ">case</span> <span class=", 34, "n", 34, ">70</span>:", 10, "    <span class=", 34, "f", 34, ">println</span>(<span class=", 34, "s", 34, ">", 34, "C", 34, "</span>);", 10, "    <span class=", 34, "k", 34, ">break</span>;", 10, "  <span class=", 34, "k", 34, ">default</span>:", 10, "    <span class=", 34, "f", 34, ">println</span>(<span class=", 34, "s", 34, ">", 34, "F", 34, "</span>);", 10, "}</code></pre>", 10, "        </div>", 10, 10, "        <h3 class=", 34, "sub-subsection-title", 34, ">Defer and Errdefer</h3>", 10, "        <p><code>defer</code> schedules a statement to execute when the current scope exits, while <code>errdefer</code> schedules execution only when exiting with an error. Both follow <strong>LIFO (Last In, First Out)</strong> ordering.</p>", 10, 10, "        <div class=", 34, "code-block", 34, ">", 10, "          <div class=", 34, "code-header", 34, ">", 10, "            <div class=", 34, "code-title", 34, ">Basic defer usage</div>", 10, "            <div class=", 34, "code-actions", 34, ">", 10, "              <button class=", 34, "copy-btn", 34, " onclick=", 34, "copyCode(this)", 34, ">Copy</button>", 10, "            </div>", 10, "          </div>", 10, "          <pre><code><span class=", 34, "k", 34, ">function</span> <span class=", 34, "f", 34, ">open_file</span>() {", 10, "  <span class=", 34, "k", 34, ">var</span> file: <span class=", 34, "t", 34, ">File</span>* = <span class=", 34, "f", 34, ">fopen</span>(<span class=", 34, "s", 34, ">", 34, "data.txt", 34, "</span>, <span class=", 34, "s", 34, ">", 34, "r", 34, "</span>);", 10, "  <span class=", 34, "k", 34, ">defer</span> <span class=", 34, "f", 34, ">fclose</span>(file);  <span class=", 34, "c", 34, ">// Executes when function returns</span>", 10, "  ", 10, "  <span class=", 34, "c", 34, ">// ... file operations ...</span>", 10, "}</code></pre>", 10, "        </div>", 10, 10, "        <div class=", 34, "code-block", 34, ">", 10, "          <div class=", 34, "code-header", 34, ">", 10, "            <div class=", 34, "code-title", 34, ">Error handling with errdefer</div>", 10, "            <div class=", 34, "code-actions", 34, ">", 10, "              <button class=", 34, "copy-btn", 34, " onclick=", 34, "copyCode(this)", 34, ">Copy</button>", 10, "            </div>", 10, "          </div>", 10, "          <pre><code><span class=", 34, "k", 34, ">function</span> <span class=", 34, "f", 34, ">process_data</span>() {", 10, "  <span class=", 34, "k", 34, ">var</span> buffer: <span class=", 34, "t", 34, ">uint8</span>* = <span class=", 34, "f", 34, ">malloc</span>(<span class=", 34, "n", 34, ">1024</span>);", 10, "  <span class=", 34, "k", 34, ">errdefer</span> <span class=", 34, "f", 34, ">free</span>(buffer);  <span class=", 34, "c", 34, ">// Only runs if function returns with error</span>", 10, "  ", 10, "  <span class=", 34, "k", 34, ">var</span> file: <span class=", 34, "t", 34, ">File</span>* = <span class=", 34, "f", 34, ">fopen</span>(<span class=", 34, "s", 34, ">", 34, "data.txt", 34, "</span>, <span class=", 34, "s", 34, ">", 34, "r", 34, "</span>);", 10, "  <span class=", 34, "k", 34, ">defer</span> <span class=", 34, "f", 34, ">fclose</span>(file);     <span class=", 34, "c", 34, ">// Always runs</span>", 10, "  ", 10, "  <span class=", 34, "k", 34, ">if</span> (parse_error) {", 10, "    <span class=", 34, "k", 34, ">return</span> <span class=", 34, "f", 34, ">err</span>();  <span class=", 34, "c", 34, ">// Runs errdefer, then defer</span>", 10, "  }", 10, "  ", 10, "  <span class=", 34, "k", 34, ">return</span> <span class=", 34, "f", 34, ">ok</span>();     <span class=", 34, "c", 34, ">// Runs only defer</span>", 10, "}</code></pre>", 10, "        </div>", 10, 10, "        <div class=", 34, "alert alert-info", 34, ">", 10, "          <div class=", 34, "alert-title", 34, ">", 226, 132, 185, 239, 184, 143, " LIFO Ordering</div>", 10, "          <p>Deferred statements execute in reverse order of declaration. The most recently deferred statement executes first.</p>", 10, "        </div>", 10, 10, "        <div class=", 34, "code-block", 34, ">", 10, "          <div class=", 34, "code-header", 34, ">", 10, "            <div class=", 34, "code-title", 34, ">Resource management pattern</div>", 10, "            <div class=", 34, "code-actions", 34, ">", 10, "              <button class=", 34, "copy-btn", 34, " onclick=", 34, "copyCode(this)", 34, ">Copy</button>", 10, "            </div>", 10, "          </div>", 10, "          <pre><code><span class=", 34, "k", 34, ">function</span> <span class=", 34, "f", 34, ">handle_client</span>(client_socket: <span class=", 34, "t", 34, ">int32</span>) {", 10, "  <span class=", 34, "k", 34, ">defer</span> <span class=", 34, "f", 34, ">close_socket</span>(client_socket);", 10, "  ", 10, "  <span class=", 34, "k", 34, ">var</span> buffer: <span class=", 34, "t", 34, ">uint8</span>* = <span class=", 34, "f", 34, ">malloc</span>(<span class=", 34, "n", 34, ">1024</span>);", 10, "  <span class=", 34, "k", 34, ">errdefer</span> <span class=", 34, "f", 34, ">free</span>(buffer);", 10, "  ", 10, "  <span class=", 34, "k", 34, ">if</span> (read_error) {", 10, "    <span class=", 34, "k", 34, ">return</span> <span class=", 34, "f", 34, ">err</span>();  <span class=", 34, "c", 34, ">// Free buffer, close socket</span>", 10, "  }", 10, "  ", 10, "  <span class=", 34, "k", 34, ">return</span> <span class=", 34, "f", 34, ">ok</span>();     <span class=", 34, "c", 34, ">// Close socket only</span>", 10, "}</code></pre>", 10, "        </div>", 10, "      </section>", 10, 10, "      <!-- Structs -->", 10, "      <section id=", 34, "structs", 34, " class=", 34, "content-section", 34, ">", 10, "        <h2 class=", 34, "subsection-title", 34, ">Structs</h2>", 10, "        ", 10, "        <p>Structs group related data together and can have methods associated with them.</p>", 10, 10, "        <h3 class=", 34, "sub-subsection-title", 34, ">Struct Definition</h3>", 10, "        <div class=", 34, "code-block", 34, ">", 10, "          <div class=", 34, "code-header", 34, ">", 10, "            <div class=", 34, "code-title", 34, ">Struct with methods</div>", 10, "            <div class=", 34, "code-actions", 34, ">", 10, "              <button class=", 34, "copy-btn", 34, " onclick=", 34, "copyCode(this)", 34, ">Copy</button>", 10, "            </div>", 10, "          </div>", 10, "          <pre><code><span class=", 34, "k", 34, ">struct</span> <span class=", 34, "t", 34, ">Point</span> {", 10, "  x: <span class=", 34, "t", 34, ">float64</span>;", 10, "  y: <span class=", 34, "t", 34, ">float64</span>;", 10, "  ", 10, "  <span class=", 34, "k", 34, ">function</span> <span class=", 34, "f", 34, ">distance</span>(other: <span class=", 34, "t", 34, ">Point</span>*) -> <span class=", 34, "t", 34, ">float64</span> {", 10, "    <span class=", 34, "k", 34, ">var</span> dx: <span class=", 34, "t", 34, ">float64</span> = <span class=", 34, "k", 34, ">this</span>.x - other->x;", 10, "    <span class=", 34, "k", 34, ">var</span> dy: <span class=", 34, "t", 34, ">float64</span> = <span class=", 34, "k", 34, ">this</span>.y - other->y;", 10, "    <span class=", 34, "k", 34, ">return</span> dx*dx + dy*dy; <span class=", 34, "c", 34, ">// Simplified distance</span>", 10, "  }", 10, "  ", 10, "  <span class=", 34, "k", 34, ">function</span> <span class=", 34, "f", 34, ">move</span>(dx: <span class=", 34, "t", 34, ">float64</span>, dy: <span class=", 34, "t", 34, ">float64</span>) {", 10, "    <span class=", 34, "k", 34, ">this</span>.x = <span class=", 34, "k", 34, ">this</span>.x + dx;", 10, "    <span class=", 34, "k", 34, ">this</span>.y = <span class=", 34, "k", 34, ">this</span>.y + dy;", 10, "  }", 10, "}", 10, 10, "<span class=", 34, "k", 34, ">function</span> <span class=", 34, "f", 34, ">main</span>() -> <span class=", 34, "t", 34, ">int32</span> {", 10, "  <span class=", 34, "k", 34, ">var</span> p1: <span class=", 34, "t", 34, ">Point</span> = {<span class=", 34, "n", 34, ">0.0</span>, <span class=", 34, "n", 34, ">0.0</span>};", 10, "  <span class=", 34, "k", 34, ">var</span> p2: <span class=", 34, "t", 34, ">Point</span> = {<span class=", 34, "n", 34, ">3.0</span>, <span class=", 34, "n", 34, ">4.0</span>};", 10, "  ", 10, "  <span class=", 34, "k", 34, ">var</span> dist: <span class=", 34, "t", 34, ">float64</span> = <span class=", 34, "f", 34, ">p1.distance</span>(&p2);", 10, "  <span class=", 34, "f", 34, ">p1.move</span>(<span class=", 34, "n", 34, ">1.0</span>, <span class=", 34, "n", 34, ">2.0</span>);", 10, "  ", 10, "  <span class=", 34, "k", 34, ">return</span> <span class=", 34, "n", 34, ">0</span>;", 10, "}</code></pre>", 10, "        </div>", 10, "      </section>", 10, 10, "      <!-- Enums -->", 10, "      <section id=", 34, "enums", 34, " class=", 34, "content-section", 34, ">", 10, "        <h2 class=", 34, "subsection-title", 34, ">Enums</h2>", 10, "        ", 10, "        <p>Enums define a named type with a set of variants, each having an integer value.</p>", 10, 10, "        <h3 class=", 34, "sub-subsection-title", 34, ">Enum Definition</h3>", 10, "        <div class=", 34, "code-block", 34, ">", 10, "          <div class=", 34, "code-header", 34, ">", 10, "            <div class=", 34, "code-title", 34, ">Enum examples</div>", 10, "            <div class=", 34, "code-actions", 34, ">", 10, "              <button class=", 34, "copy-btn", 34, " onclick=", 34, "copyCode(this)", 34, ">Copy</button>", 10, "            </div>", 10, "          </div>", 10, "          <pre><code><span class=", 34, "k", 34, ">enum</span> <span class=", 34, "t", 34, ">Direction</span> {", 10, "  North,        <span class=", 34, "c", 34, ">// 0</span>", 10, "  East = <span class=", 34, "n", 34, ">2</span>,     <span class=", 34, "c", 34, ">// 2</span>", 10, "  South,        <span class=", 34, "c", 34, ">// 3 (previous + 1)</span>", 10, "  West = <span class=", 34, "n", 34, ">-5</span>     <span class=", 34, "c", 34, ">// -5</span>", 10, "}", 10, 10, "<span class=", 34, "k", 34, ">enum</span> <span class=", 34, "t", 34, ">Status</span> {", 10, "  Pending = <span class=", 34, "n", 34, ">100</span>,", 10, "  InProgress = <span class=", 34, "n", 34, ">200</span>,", 10, "  Complete = <span class=", 34, "n", 34, ">300</span>,", 10, "  Failed = <span class=", 34, "n", 34, ">400</span>", 10, "}", 10, 10, "<span class=", 34, "k", 34, ">function</span> <span class=", 34, "f", 34, ">main</span>() -> <span class=", 34, "t", 34, ">int32</span> {", 10, "  <span class=", 34, "k", 34, ">var</span> dir: <span class=", 34, "t", 34, ">Direction</span> = North;", 10, "  <span class=", 34, "k", 34, ">var</span> status: <span class=", 34, "t", 34, ">Status</span> = InProgress;", 10, "  ", 10, "  <span class=", 34, "k", 34, ">if</span> (dir == East) {", 10, "    <span class=", 34, "f", 34, ">println</span>(<span class=", 34, "s", 34, ">", 34, "Facing East", 34, "</span>);", 10, "  }", 10, "  ", 10, "  <span class=", 34, "k", 34, ">switch</span> (status) {", 10, "    <span class=", 34, "k", 34, ">case</span> Complete:", 10, "      <span class=", 34, "f", 34, ">println</span>(<span class=", 34, "s", 34, ">", 34, "Task completed!", 34, "</span>);", 10, "      <span class=", 34, "k", 34, ">break</span>;", 10, "    <span class=", 34, "k", 34, ">case</span> Failed:", 10, "      <span class=", 34, "f", 34, ">println</span>(<span class=", 34, "s", 34, ">", 34, "Task failed!", 34, "</span>);", 10, "      <span class=", 34, "k", 34, ">break</span>;", 10, "  }", 10, "  ", 10, "  <span class=", 34, "k", 34, ">return</span> <span class=", 34, "n", 34, ">0</span>;", 10, "}</code></pre>", 10, "        </div>", 10, 10, "        <h3 class=", 34, "sub-subsection-title", 34, ">Enum Properties</h3>", 10, "        <div class=", 34, "alert alert-info", 34, ">", 10, "          <div class=", 34, "alert-title", 34, ">", 226, 132, 185, 239, 184, 143, " Enum Characteristics</div>", 10, "          <ul>", 10, "            <li><strong>Underlying Type:</strong> Enums use <code>int64</code> as the underlying representation (8 bytes, aligned to 8)</li>", 10, "            <li><strong>Auto-increment:</strong> Variants without explicit values continue from previous variant (0 if first)</li>", 10, "            <li><strong>Direct Usage:</strong> Variant names are in scope after enum definition (use <code>North</code>, not <code>Direction.North</code>)</li>", 10, "            <li><strong>Comparisons:</strong> Enums can be compared with integers and used in <code>switch</code> cases</li>", 10, "          </ul>", 10, "        </div>", 10, 10, "        <h3 class=", 34, "sub-subsection-title", 34, ">Type Conversion</h3>", 10, "        <div class=", 34, "code-block", 34, ">", 10, "          <div class=", 34, "code-header", 34, ">", 10, "            <div class=", 34, "code-title", 34, ">Integer to enum conversion</div>", 10, "            <div class=", 34, "code-actions", 34, ">", 10, "              <button class=", 34, "copy-btn", 34, " onclick=", 34, "copyCode(this)", 34, ">Copy</button>", 10, "            </div>", 10, "          </div>", 10, "          <pre><code><span class=", 34, "k", 34, ">enum</span> <span class=", 34, "t", 34, ">Priority</span> {", 10, "  Low = <span class=", 34, "n", 34, ">1</span>,", 10, "  Medium = <span class=", 34, "n", 34, ">5</span>,", 10, "  High = <span class=", 34, "n", 34, ">10</span>", 10, "}", 10, 10, "<span class=", 34, "k", 34, ">function</span> <span class=", 34, "f", 34, ">set_priority</span>(level: <span class=", 34, "t", 34, ">int32</span>) -> <span class=", 34, "t", 34, ">Priority</span> {", 10, "  <span class=", 34, "c", 34, ">// Implicit narrowing conversion</span>", 10, "  <span class=", 34, "k", 34, ">var</span> priority: <span class=", 34, "t", 34, ">Priority</span> = level;", 10, "  ", 10, "  <span class=", 34, "k", 34, ">if</span> (priority >= High) {", 10, "    <span class=", 34, "f", 34, ">println</span>(<span class=", 34, "s", 34, ">", 34, "High priority set", 34, "</span>);", 10, "  }", 10, "  ", 10, "  <span class=", 34, "k", 34, ">return</span> priority;", 10, "}</code></pre>", 10, "        </div>", 10, "      </section>", 10, 10, "      <!-- Modules -->", 10, "      <section id=", 34, "modules", 34, " class=", 34, "content-section", 34, ">", 10, "        <h2 class=", 34, "subsection-title", 34, ">Modules</h2>", 10, "        ", 10, "        <p>MethASM provides a module system for organizing code and managing dependencies. Modules allow you to split large programs into manageable, reusable components.</p>", 10, 10, "        <h3 class=", 34, "sub-subsection-title", 34, ">Import System</h3>", 10, "        <p>Use the <code>import</code> statement to include modules in your program.</p>", 10, 10, "        <div class=", 34, "code-block", 34, ">", 10, "          <div class=", 34, "code-header", 34, ">", 10, "            <div class=", 34, "code-title", 34, ">Import examples</div>", 10, "            <div class=", 34, "code-actions", 34, ">", 10, "              <button class=", 34, "copy-btn", 34, " onclick=", 34, "copyCode(this)", 34, ">Copy</button>", 10, "            </div>", 10, "          </div>", 10, "          <pre><code><span class=", 34, "c", 34, ">// Import standard library modules</span>", 10, "<span class=", 34, "k", 34, ">import</span> <span class=", 34, "s", 34, ">", 34, "std/io", 34, "</span>;", 10, "<span class=", 34, "k", 34, ">import</span> <span class=", 34, "s", 34, ">", 34, "std/mem", 34, "</span>;", 10, "<span class=", 34, "k", 34, ">import</span> <span class=", 34, "s", 34, ">", 34, "std/math", 34, "</span>;", 10, 10, "<span class=", 34, "c", 34, ">// Import custom modules (relative paths)</span>", 10, "<span class=", 34, "k", 34, ">import</span> <span class=", 34, "s", 34, ">", 34, "utils/string_helpers", 34, "</span>;", 10, "<span class=", 34, "k", 34, ">import</span> <span class=", 34, "s", 34, ">", 34, "datastructures/list", 34, "</span>;", 10, "<span class=", 34, "k", 34, ">import</span> <span class=", 34, "s", 34, ">", 34, "algorithms/sort", 34, "</span>;", 10, 10, "<span class=", 34, "c", 34, ">// Import with absolute path (less common)</span>", 10, "<span class=", 34, "k", 34, ">import</span> <span class=", 34, "s", 34, ">", 34, "/usr/local/lib/custom", 34, "</span>;</code></pre>", 10, "        </div>", 10, 10, "        <h3 class=", 34, "sub-subsection-title", 34, ">Module Resolution</h3>", 10, "        <div class=", 34, "alert alert-info", 34, ">", 10, "          <div class=", 34, "alert-title", 34, ">", 226, 132, 185, 239, 184, 143, " Import Search Order</div>", 10, "          <p>The compiler resolves imports in this order:</p>", 10, "          <ol>", 10, "            <li><strong>Relative to current file:</strong> <code>", 34, "utils/helpers", 34, "</code> looks for <code>utils/helpers.masm</code></li>", 10, "            <li><strong>Include directories:</strong> Paths added with <code>-I</code> flag</li>", 10, "            <li><strong>Standard library:</strong> <code>std/</code> prefix searches in stdlib root</li>", 10, "          </ol>", 10, "        </div>", 10, 10, "        <h3 class=", 34, "sub-subsection-title", 34, ">Creating Modules</h3>", 10, "        <div class=", 34, "code-block", 34, ">", 10, "          <div class=", 34, "code-header", 34, ">", 10, "            <div class=", 34, "code-title", 34, ">Creating a custom module</div>", 10, "            <div class=", 34, "code-actions", 34, ">", 10, "              <button class=", 34, "copy-btn", 34, " onclick=", 34, "copyCode(this)", 34, ">Copy</button>", 10, "            </div>", 10, "          </div>", 10, "          <pre><code><span class=", 34, "c", 34, ">// File: utils/string_helpers.masm</span>", 10, 10, "<span class=", 34, "c", 34, ">// Export functions for use by other modules</span>", 10, "<span class=", 34, "k", 34, ">export function</span> <span class=", 34, "f", 34, ">string_length</span>(s: <span class=", 34, "t", 34, ">string</span>) -> <span class=", 34, "t", 34, ">int32</span> {", 10, "  <span class=", 34, "k", 34, ">return</span> s.length;", 10, "}", 10, 10, "<span class=", 34, "k", 34, ">export function</span> <span class=", 34, "f", 34, ">string_equals</span>(a: <span class=", 34, "t", 34, ">string</span>, b: <span class=", 34, "t", 34, ">string</span>) -> <span class=", 34, "t", 34, ">int32</span> {", 10, "  <span class=", 34, "k", 34, ">if</span> (a.length != b.length) {", 10, "    <span class=", 34, "k", 34, ">return</span> <span class=", 34, "n", 34, ">0</span>; <span class=", 34, "c", 34, ">// false</span>", 10, "  }", 10, "  ", 10, "  <span class=", 34, "k", 34, ">var</span> i: <span class=", 34, "t", 34, ">int32</span> = <span class=", 34, "n", 34, ">0</span>;", 10, "  <span class=", 34, "k", 34, ">while</span> (i < a.length) {", 10, "    <span class=", 34, "k", 34, ">if</span> (a.chars[i] != b.chars[i]) {", 10, "      <span class=", 34, "k", 34, ">return</span> <span class=", 34, "n", 34, ">0</span>; <span class=", 34, "c", 34, ">// false</span>", 10, "    }", 10, "    i = i + <span class=", 34, "n", 34, ">1</span>;", 10, "  }", 10, "  ", 10, "  <span class=", 34, "k", 34, ">return</span> <span class=", 34, "n", 34, ">1</span>; <span class=", 34, "c", 34, ">// true</span>", 10, "}", 10, 10, "<span class=", 34, "c", 34, ">// Export types for use by other modules</span>", 10, "<span class=", 34, "k", 34, ">export</span> <span class=", 34, "k", 34, ">struct</span> <span class=", 34, "t", 34, ">StringBuilder</span> {", 10, "  buffer: <span class=", 34, "t", 34, ">uint8</span>[<span class=", 34, "n", 34, ">1024</span>];", 10, "  length: <span class=", 34, "t", 34, ">int32</span>;", 10, "  ", 10, "  <span class=", 34, "k", 34, ">function</span> <span class=", 34, "f", 34, ">append</span>(text: <span class=", 34, "t", 34, ">string</span>) {", 10, "    <span class=", 34, "c", 34, ">// Implementation...</span>", 10, "  }", 10, "}</code></pre>", 10, "        </div>", 10, 10, "        <h3 class=", 34, "sub-subsection-title", 34, ">Using Custom Modules</h3>", 10, "        <div class=", 34, "code-block", 34, ">", 10, "          <div class=", 34, "code-header", 34, ">", 10, "            <div class=", 34, "code-title", 34, ">Using custom modules</div>", 10, "            <div class=", 34, "code-actions", 34, ">", 10, "              <button class=", 34, "copy-btn", 34, " onclick=", 34, "copyCode(this)", 34, ">Copy</button>", 10, "            </div>", 10, "          </div>", 10, "          <pre><code><span class=", 34, "c", 34, ">// File: main.masm</span>", 10, 10, "<span class=", 34, "k", 34, ">import</span> <span class=", 34, "s", 34, ">", 34, "utils/string_helpers", 34, "</span>;", 10, 10, "<span class=", 34, "k", 34, ">function</span> <span class=", 34, "f", 34, ">main</span>() -> <span class=", 34, "t", 34, ">int32</span> {", 10, "  <span class=", 34, "k", 34, ">var</span> message: <span class=", 34, "t", 34, ">string</span> = <span class=", 34, "s", 34, ">", 34, "Hello, MethASM!", 34, "</span>;", 10, "  <span class=", 34, "k", 34, ">var</span> length: <span class=", 34, "t", 34, ">int32</span> = <span class=", 34, "f", 34, ">string_length</span>(message);", 10, "  ", 10, "  <span class=", 34, "f", 34, ">println</span>(<span class=", 34, "s", 34, ">", 34, "Message length: ", 34, "</span>);", 10, "  <span class=", 34, "f", 34, ">println_int</span>(length);", 10, "  ", 10, "  <span class=", 34, "k", 34, ">var</span> builder: <span class=", 34, "t", 34, ">StringBuilder</span>;", 10, "  builder.length = <span class=", 34, "n", 34, ">0</span>;", 10, "  <span class=", 34, "f", 34, ">builder.append</span>(message);", 10, "  ", 10, "  <span class=", 34, "k", 34, ">return</span> <span class=", 34, "n", 34, ">0</span>;", 10, "}</code></pre>", 10, "        </div>", 10, 10, "        <h3 class=", 34, "sub-subsection-title", 34, ">Module Best Practices</h3>", 10, "        <div class=", 34, "alert alert-warning", 34, ">", 10, "          <div class=", 34, "alert-title", 34, ">", 226, 154, 160, 239, 184, 143, " Module Guidelines</div>", 10, "          <ul>", 10, "            <li><strong>Single Responsibility:</strong> Each module should have a clear, focused purpose</li>", 10, "            <li><strong>Explicit Exports:</strong> Use <code>export</code> keyword for functions/types meant to be used externally</li>", 10, "            <li><strong>Avoid Circular Dependencies:</strong> Module A shouldn't import module B if B also imports A</li>", 10, "            <li><strong>Consistent Naming:</strong> Use descriptive names and consider prefixing with module category</li>", 10, "            <li><strong>Documentation:</strong> Comment module purpose and exported function behavior</li>", 10, "          </ul>", 10, "        </div>", 10, "      </section>", 10, 10, "      <!-- Memory Management -->", 10, "      <section id=", 34, "memory-management", 34, " class=", 34, "content-section", 34, ">", 10, "        <h2 class=", 34, "subsection-title", 34, ">Memory Management</h2>", 10, "        ", 10, "        <p>MethASM offers both manual memory management and optional garbage collection.</p>", 10, 10, "        <h3 class=", 34, "sub-subsection-title", 34, ">Stack Allocation</h3>", 10, "        <p>Most variables are allocated on the stack and automatically cleaned up when they go out of scope.</p>", 10, 10, "        <h3 class=", 34, "sub-subsection-title", 34, ">Manual Memory Management</h3>", 10, "        <div class=", 34, "code-block", 34, ">", 10, "          <div class=", 34, "code-header", 34, ">", 10, "            <div class=", 34, "code-title", 34, ">Using C malloc/free</div>", 10, "            <div class=", 34, "code-actions", 34, ">", 10, "              <button class=", 34, "copy-btn", 34, " onclick=", 34, "copyCode(this)", 34, ">Copy</button>", 10, "            </div>", 10, "          </div>", 10, "          <pre><code><span class=", 34, "k", 34, ">import</span> <span class=", 34, "s", 34, ">", 34, "std/mem", 34, "</span>;", 10, 10, "<span class=", 34, "k", 34, ">function</span> <span class=", 34, "f", 34, ">main</span>() -> <span class=", 34, "t", 34, ">int32</span> {", 10, "  <span class=", 34, "c", 34, ">// Allocate memory</span>", 10, "  <span class=", 34, "k", 34, ">var</span> buffer: <span class=", 34, "t", 34, ">cstring</span> = <span class=", 34, "f", 34, ">malloc</span>(<span class=", 34, "n", 34, ">1024</span>);", 10, "  ", 10, "  <span class=", 34, "k", 34, ">if</span> (buffer != <span class=", 34, "n", 34, ">0</span>) {", 10, "    <span class=", 34, "c", 34, ">// Use the memory</span>", 10, "    <span class=", 34, "f", 34, ">memset</span>(buffer, <span class=", 34, "n", 34, ">0</span>, <span class=", 34, "n", 34, ">1024</span>);", 10, "    ", 10, "    <span class=", 34, "c", 34, ">// Free when done</span>", 10, "    <span class=", 34, "f", 34, ">free</span>(buffer);", 10, "  }", 10, "  ", 10, "  <span class=", 34, "k", 34, ">return</span> <span class=", 34, "n", 34, ">0</span>;", 10, "}</code></pre>", 10, "        </div>", 10, 10, "        <h3 class=", 34, "sub-subsection-title", 34, ">Garbage Collection</h3>", 10, "        <div class=", 34, "alert alert-info", 34, ">", 10, "          <div class=", 34, "alert-title", 34, ">", 226, 132, 185, 239, 184, 143, " GC Optional</div>", 10, "          <p>When you link the GC runtime, you can use <code>new T</code> for automatic memory management. The GC uses conservative mark-and-sweep collection.</p>", 10, "        </div>", 10, 10, "        <div class=", 34, "code-block", 34, ">", 10, "          <div class=", 34, "code-header", 34, ">", 10, "            <div class=", 34, "code-title", 34, ">Using garbage collection</div>", 10, "            <div class=", 34, "code-actions", 34, ">", 10, "              <button class=", 34, "copy-btn", 34, " onclick=", 34, "copyCode(this)", 34, ">Copy</button>", 10, "            </div>", 10, "          </div>", 10, "          <pre><code><span class=", 34, "k", 34, ">struct</span> <span class=", 34, "t", 34, ">Node</span> {", 10, "  value: <span class=", 34, "t", 34, ">int32</span>;", 10, "  next: <span class=", 34, "t", 34, ">Node</span>*;", 10, "}", 10, 10, "<span class=", 34, "k", 34, ">function</span> <span class=", 34, "f", 34, ">main</span>() -> <span class=", 34, "t", 34, ">int32</span> {", 10, "  <span class=", 34, "c", 34, ">// Allocate with garbage collection</span>", 10, "  <span class=", 34, "k", 34, ">var</span> node: <span class=", 34, "t", 34, ">Node</span>* = <span class=", 34, "k", 34, ">new</span> <span class=", 34, "t", 34, ">Node</span>;", 10, "  node->value = <span class=", 34, "n", 34, ">42</span>;", 10, "  node->next = <span class=", 34, "k", 34, ">new</span> <span class=", 34, "t", 34, ">Node</span>;", 10, "  ", 10, "  <span class=", 34, "c", 34, ">// No need to free - GC will clean up</span>", 10, "  <span class=", 34, "k", 34, ">return</span> <span class=", 34, "n", 34, ">0</span>;", 10, "}</code></pre>", 10, "        </div>", 10, "      </section>", 10, 10, "      <!-- C Interop -->", 10, "      <section id=", 34, "c-interop", 34, " class=", 34, "content-section", 34, ">", 10, "        <h2 class=", 34, "subsection-title", 34, ">C Interoperability</h2>", 10, "        ", 10, "        <p>MethASM provides seamless C interoperability through extern declarations.</p>", 10, 10, "        <h3 class=", 34, "sub-subsection-title", 34, ">Declaring External Functions</h3>", 10, "        <div class=", 34, "code-block", 34, ">", 10, "          <div class=", 34, "code-header", 34, ">", 10, "            <div class=", 34, "code-title", 34, ">C function declarations</div>", 10, "            <div class=", 34, "code-actions", 34, ">", 10, "              <button class=", 34, "copy-btn", 34, " onclick=", 34, "copyCode(this)", 34, ">Copy</button>", 10, "            </div>", 10, "          </div>", 10, "          <pre><code><span class=", 34, "c", 34, ">// Declare C functions</span>", 10, "<span class=", 34, "k", 34, ">extern function</span> <span class=", 34, "f", 34, ">strlen</span>(s: <span class=", 34, "t", 34, ">cstring</span>) -> <span class=", 34, "t", 34, ">int32</span> = <span class=", 34, "s", 34, ">", 34, "strlen", 34, "</span>;", 10, "<span class=", 34, "k", 34, ">extern function</span> <span class=", 34, "f", 34, ">strcpy</span>(dest: <span class=", 34, "t", 34, ">cstring</span>, src: <span class=", 34, "t", 34, ">cstring</span>) -> <span class=", 34, "t", 34, ">cstring</span> = <span class=", 34, "s", 34, ">", 34, "strcpy", 34, "</span>;", 10, "<span class=", 34, "k", 34, ">extern function</span> <span class=", 34, "f", 34, ">malloc</span>(size: <span class=", 34, "t", 34, ">int32</span>) -> <span class=", 34, "t", 34, ">cstring</span> = <span class=", 34, "s", 34, ">", 34, "malloc", 34, "</span>;", 10, 10, "<span class=", 34, "k", 34, ">function</span> <span class=", 34, "f", 34, ">main</span>() -> <span class=", 34, "t", 34, ">int32</span> {", 10, "  <span class=", 34, "k", 34, ">var</span> message: <span class=", 34, "t", 34, ">uint8</span>[<span class=", 34, "n", 34, ">256</span>];", 10, "  <span class=", 34, "f", 34, ">strcpy</span>(&message[<span class=", 34, "n", 34, ">0</span>], <span class=", 34, "s", 34, ">", 34, "Hello from C!", 34, "</span>);", 10, "  ", 10, "  <span class=", 34, "k", 34, ">var</span> len: <span class=", 34, "t", 34, ">int32</span> = <span class=", 34, "f", 34, ">strlen</span>(&message[<span class=", 34, "n", 34, ">0</span>]);", 10, "  <span class=", 34, "f", 34, ">println_int</span>(len);", 10, "  ", 10, "  <span class=", 34, "k", 34, ">return</span> <span class=", 34, "n", 34, ">0</span>;", 10, "}</code></pre>", 10, "        </div>", 10, "      </section>", 10, 10, "      <!-- Compilation -->", 10, "      <section id=", 34, "compilation", 34, " class=", 34, "content-section", 34, ">", 10, "        <h2 class=", 34, "subsection-title", 34, ">Compilation</h2>", 10, "        ", 10, "        <p>MethASM compiles to x86-64 NASM assembly, which is then assembled and linked to create executables.</p>", 10, 10, "        <h3 class=", 34, "sub-subsection-title", 34, ">Build Pipeline</h3>", 10, "        <div class=", 34, "step-list", 34, ">", 10, "          <div class=", 34, "step-item", 34, ">", 10, "            <p><strong>Compile to assembly:</strong> <code>methasm input.masm -o output.s</code></p>", 10, "          </div>", 10, "          <div class=", 34, "step-item", 34, ">", 10, "            <p><strong>Assemble to object:</strong> <code>nasm -f win64 output.s -o output.o</code></p>", 10, "          </div>", 10, "          <div class=", 34, "step-item", 34, ">", 10, "            <p><strong>Link to executable:</strong> <code>gcc output.o -o output.exe</code></p>", 10, "          </div>", 10, "        </div>", 10, 10, "        <h3 class=", 34, "sub-subsection-title", 34, ">Compiler Options</h3>", 10, "        <div class=", 34, "table-container", 34, ">", 10, "          <table>", 10, "            <thead>", 10, "              <tr>", 10, "                <th>Option</th>", 10, "                <th>Description</th>", 10, "              </tr>", 10, "            </thead>", 10, "            <tbody>", 10, "              <tr>", 10, "                <td><code>-o file</code></td>", 10, "                <td>Output assembly file</td>", 10, "              </tr>", 10, "              <tr>", 10, "                <td><code>-O</code></td>", 10, "                <td>Enable optimizations</td>", 10, "              </tr>", 10, "              <tr>", 10, "                <td><code>-d</code></td>", 10, "                <td>Debug mode</td>", 10, "              </tr>", 10, "              <tr>", 10, "                <td><code>-g</code></td>", 10, "                <td>Generate debug symbols</td>", 10, "              </tr>", 10, "              <tr>", 10, "                <td><code>-I dir</code></td>", 10, "                <td>Add import search directory</td>", 10, "              </tr>", 10, "            </tbody>", 10, "          </table>", 10, "        </div>", 10, "      </section>", 10, 10, "      <!-- Standard Library -->", 10, "      <section id=", 34, "standard-library", 34, " class=", 34, "content-section", 34, ">", 10, "        <h2 class=", 34, "subsection-title", 34, ">Standard Library</h2>", 10, "        ", 10, "        <p>MethASM includes a comprehensive standard library organized into modules.</p>", 10, 10, "        <h3 class=", 34, "sub-subsection-title", 34, ">Core Modules</h3>", 10, "        <div class=", 34, "table-container", 34, ">", 10, "          <table>", 10, "            <thead>", 10, "              <tr>", 10, "                <th>Module</th>", 10, "                <th>Description</th>", 10, "                <th>Key Functions</th>", 10, "              </tr>", 10, "            </thead>", 10, "            <tbody>", 10, "              <tr>", 10, "                <td><code>std/io</code></td>", 10, "                <td>Console and file I/O operations</td>", 10, "                <td><code>println</code>, <code>fopen</code>, <code>fread</code></td>", 10, "              </tr>", 10, "              <tr>", 10, "                <td><code>std/mem</code></td>", 10, "                <td>Memory management functions</td>", 10, "                <td><code>malloc</code>, <code>free</code>, <code>memcpy</code></td>", 10, "              </tr>", 10, "              <tr>", 10, "                <td><code>std/math</code></td>", 10, "                <td>Mathematical operations</td>", 10, "                <td><code>abs</code>, <code>min</code>, <code>max</code></td>", 10, "              </tr>", 10, "              <tr>", 10, "                <td><code>std/net</code></td>", 10, "                <td>Network programming (Windows)</td>", 10, "                <td><code>socket</code>, <code>bind</code>, <code>listen</code></td>", 10, "              </tr>", 10, "              <tr>", 10, "                <td><code>std/conv</code></td>", 10, "                <td>Type conversions and utilities</td>", 10, "                <td><code>atoi</code>, <code>strlen</code>, <code>isdigit</code></td>", 10, "              </tr>", 10, "            </tbody>", 10, "          </table>", 10, "        </div>", 10, 10, "        <h3 class=", 34, "sub-subsection-title", 34, ">Using the Standard Library</h3>", 10, "        <div class=", 34, "code-block", 34, ">", 10, "          <div class=", 34, "code-header", 34, ">", 10, "            <div class=", 34, "code-title", 34, ">Standard library imports</div>", 10, "            <div class=", 34, "code-actions", 34, ">", 10, "              <button class=", 34, "copy-btn", 34, " onclick=", 34, "copyCode(this)", 34, ">Copy</button>", 10, "            </div>", 10, "          </div>", 10, "          <pre><code><span class=", 34, "k", 34, ">import</span> <span class=", 34, "s", 34, ">", 34, "std/io", 34, "</span>;", 10, "<span class=", 34, "k", 34, ">import</span> <span class=", 34, "s", 34, ">", 34, "std/mem", 34, "</span>;", 10, "<span class=", 34, "k", 34, ">import</span> <span class=", 34, "s", 34, ">", 34, "std/math", 34, "</span>;", 10, 10, "<span class=", 34, "k", 34, ">function</span> <span class=", 34, "f", 34, ">main</span>() -> <span class=", 34, "t", 34, ">int32</span> {", 10, "  <span class=", 34, "k", 34, ">var</span> numbers: <span class=", 34, "t", 34, ">int32</span>[<span class=", 34, "n", 34, ">5</span>] = {<span class=", 34, "n", 34, ">5</span>, <span class=", 34, "n", 34, ">2</span>, <span class=", 34, "n", 34, ">8</span>, <span class=", 34, "n", 34, ">1</span>, <span class=", 34, "n", 34, ">9</span>};", 10, "  <span class=", 34, "k", 34, ">var</span> max_val: <span class=", 34, "t", 34, ">int32</span> = <span class=", 34, "n", 34, ">0</span>;", 10, "  ", 10, "  <span class=", 34, "k", 34, ">for</span> (<span class=", 34, "k", 34, ">var</span> i: <span class=", 34, "t", 34, ">int32</span> = <span class=", 34, "n", 34, ">0</span>; i < <span class=", 34, "n", 34, ">5</span>; i = i + <span class=", 34, "n", 34, ">1</span>) {", 10, "    max_val = <span class=", 34, "f", 34, ">max</span>(max_val, numbers[i]);", 10, "  }", 10, "  ", 10, "  <span class=", 34, "f", 34, ">println_int</span>(max_val);", 10, "  <span class=", 34, "k", 34, ">return</span> <span class=", 34, "n", 34, ">0</span>;", 10, "}</code></pre>", 10, "        </div>", 10, "      </section>", 10, 10, "      <!-- Compiler Options -->", 10, "      <section id=", 34, "compiler-options", 34, " class=", 34, "content-section", 34, ">", 10, "        <h2 class=", 34, "subsection-title", 34, ">Compiler Options</h2>", 10, "        ", 10, "        <p>The MethASM compiler provides various options for controlling compilation behavior and output.</p>", 10, 10, "        <h3 class=", 34, "sub-subsection-title", 34, ">Command Line Options</h3>", 10, "        <div class=", 34, "table-container", 34, ">", 10, "          <table>", 10, "            <thead>", 10, "              <tr>", 10, "                <th>Option</th>", 10, "                <th>Long Form</th>", 10, "                <th>Description</th>", 10, "              </tr>", 10, "            </thead>", 10, "            <tbody>", 10, "              <tr>", 10, "                <td><code>-o file</code></td>", 10, "                <td><code>--output</code></td>", 10, "                <td>Specify output assembly file (default: output.s)</td>", 10, "              </tr>", 10, "              <tr>", 10, "                <td><code>-i file</code></td>", 10, "                <td><code>--input</code></td>", 10, "                <td>Specify input file (alternative to positional argument)</td>", 10, "              </tr>", 10, "              <tr>", 10, "                <td><code>-I dir</code></td>", 10, "                <td><code>--include</code></td>", 10, "                <td>Add directory to import search path (repeatable)</td>", 10, "              </tr>", 10, "              <tr>", 10, "                <td><code>--stdlib dir</code></td>", 10, "                <td><code>--stdlib</code></td>", 10, "                <td>Set standard library root (default: stdlib)</td>", 10, "              </tr>", 10, "              <tr>", 10, "                <td><code>--prelude</code></td>", 10, "                <td><code>--prelude</code></td>", 10, "                <td>Auto-import std/prelude (includes std/io, std/mem, etc.)</td>", 10, "              </tr>", 10, "              <tr>", 10, "                <td><code>-O</code></td>", 10, "                <td><code>--optimize</code></td>", 10, "                <td>Enable compiler optimizations</td>", 10, "              </tr>", 10, "              <tr>", 10, "                <td><code>-d</code></td>", 10, "                <td><code>--debug</code></td>", 10, "                <td>Enable debug mode (generates IR dump)</td>", 10, "              </tr>", 10, "              <tr>", 10, "                <td><code>-g</code></td>", 10, "                <td><code>--debug-symbols</code></td>", 10, "                <td>Generate debug symbols for debugging</td>", 10, "              </tr>", 10, "              <tr>", 10, "                <td><code>-l</code></td>", 10, "                <td><code>--line-mapping</code></td>", 10, "                <td>Generate source line mapping information</td>", 10, "              </tr>", 10, "              <tr>", 10, "                <td><code>-h</code></td>", 10, "                <td><code>--help</code></td>", 10, "                <td>Print usage information and exit</td>", 10, "              </tr>", 10, "            </tbody>", 10, "          </table>", 10, "        </div>", 10, 10, "        <h3 class=", 34, "sub-subsection-title", 34, ">Example Usage</h3>", 10, "        <div class=", 34, "code-block", 34, ">", 10, "          <div class=", 34, "code-header", 34, ">", 10, "            <div class=", 34, "code-title", 34, ">Compiler command examples</div>", 10, "            <div class=", 34, "code-actions", 34, ">", 10, "              <button class=", 34, "copy-btn", 34, " onclick=", 34, "copyCode(this)", 34, ">Copy</button>", 10, "            </div>", 10, "          </div>", 10, "          <pre><code><span class=", 34, "c", 34, ">// Basic compilation</span>", 10, "methasm main.masm -o main.s", 10, 10, "<span class=", 34, "c", 34, ">// With optimizations and debug symbols</span>", 10, "methasm main.masm -O -g -o main.s", 10, 10, "<span class=", 34, "c", 34, ">// With custom include paths</span>", 10, "methasm main.masm -I ./include -I ../libs -o main.s", 10, 10, "<span class=", 34, "c", 34, ">// Using prelude (auto-imports common modules)</span>", 10, "methasm --prelude main.masm -o main.s</code></pre>", 10, "        </div>", 10, "      </section>", 10, 10, "      <!-- Troubleshooting -->", 10, "      <section id=", 34, "troubleshooting", 34, " class=", 34, "content-section", 34, ">", 10, "        <h2 class=", 34, "subsection-title", 34, ">Troubleshooting</h2>", 10, "        ", 10, "        <p>Common issues and their solutions when working with MethASM.</p>", 10, 10, "        <h3 class=", 34, "sub-subsection-title", 34, ">Compilation Errors</h3>", 10, "        ", 10, "        <div class=", 34, "alert alert-error", 34, ">", 10, "          <div class=", 34, "alert-title", 34, ">", 226, 157, 140, " ", 34, "Undefined reference to `gc_alloc'", 34, "</div>", 10, "          <p><strong>Cause:</strong> Using <code>new</code> expressions without linking the GC runtime.</p>", 10, "          <p><strong>Solution:</strong> Compile and link <code>src/runtime/gc.c</code> with your program:</p>", 10, "          <div class=", 34, "code-block", 34, ">", 10, "            <div class=", 34, "code-header", 34, ">", 10, "              <div class=", 34, "code-title", 34, ">Linking with GC</div>", 10, "              <div class=", 34, "code-actions", 34, ">", 10, "                <button class=", 34, "copy-btn", 34, " onclick=", 34, "copyCode(this)", 34, ">Copy</button>", 10, "              </div>", 10, "            </div>", 10, "            <pre><code>gcc -c src/runtime/gc.c -o gc.o -Isrc", 10, "gcc main.o gc.o -o main</code></pre>", 10, "          </div>", 10, "        </div>", 10, 10, "        <div class=", 34, "alert alert-error", 34, ">", 10, "          <div class=", 34, "alert-title", 34, ">", 226, 157, 140, " ", 34, "Cannot open output file: Permission denied", 34, "</div>", 10, "          <p><strong>Cause:</strong> The output executable is currently running or locked.</p>", 10, "          <p><strong>Solution:</strong> Stop any running instances of the program before rebuilding.</p>", 10, "        </div>", 10, 10, "        <div class=", 34, "alert alert-warning", 34, ">", 10, "          <div class=", 34, "alert-title", 34, ">", 226, 154, 160, 239, 184, 143, " ", 34, "Use before initialization", 34, " error</div>", 10, "          <p><strong>Cause:</strong> Reading from a local variable before assigning it a value.</p>", 10, "          <p><strong>Solution:</strong> Always initialize variables before use:</p>", 10, "          <div class=", 34, "code-block", 34, ">", 10, "            <div class=", 34, "code-header", 34, ">", 10, "              <div class=", 34, "code-title", 34, ">Variable initialization</div>", 10, "              <div class=", 34, "code-actions", 34, ">", 10, "                <button class=", 34, "copy-btn", 34, " onclick=", 34, "copyCode(this)", 34, ">Copy</button>", 10, "              </div>", 10, "            </div>", 10, "            <pre><code><span class=", 34, "c", 34, ">// Wrong - using uninitialized variable</span>", 10, "<span class=", 34, "k", 34, ">var</span> x: <span class=", 34, "t", 34, ">int32</span>;", 10, "<span class=", 34, "k", 34, ">return</span> x; <span class=", 34, "c", 34, ">// Error!</span>", 10, 10, "<span class=", 34, "c", 34, ">// Correct - initialize before use</span>", 10, "<span class=", 34, "k", 34, ">var</span> x: <span class=", 34, "t", 34, ">int32</span> = <span class=", 34, "n", 34, ">0</span>;", 10, "<span class=", 34, "k", 34, ">return</span> x; <span class=", 34, "c", 34, ">// OK</span></code></pre>", 10, "          </div>", 10, "        </div>", 10, 10, "        <h3 class=", 34, "sub-subsection-title", 34, ">Runtime Issues</h3>", 10, "        ", 10, "        <div class=", 34, "alert alert-warning", 34, ">", 10, "          <div class=", 34, "alert-title", 34, ">", 226, 154, 160, 239, 184, 143, " Program crashes on startup</div>", 10, "          <p><strong>Cause:</strong> Missing GC initialization when using <code>new</code> expressions.</p>", 10, "          <p><strong>Solution:</strong> Ensure the entry point calls <code>gc_init()</code> (handled automatically when linking with GC runtime).</p>", 10, "        </div>", 10, 10, "        <div class=", 34, "alert alert-info", 34, ">", 10, "          <div class=", 34, "alert-title", 34, ">", 226, 132, 185, 239, 184, 143, " Performance slower than expected</div>", 10, "          <p><strong>Possible causes:</strong></p>", 10, "          <ul>", 10, "            <li>Not using optimization flag (<code>-O</code>)</li>", 10, "            <li>Frequent GC collections (consider raising threshold)</li>", 10, "            <li>Excessive memory allocations in hot paths</li>", 10, "          </ul>", 10, "          <p><strong>Solutions:</strong> Use optimizations, profile memory usage, consider stack allocation for performance-critical code.</p>", 10, "        </div>", 10, 10, "        <h3 class=", 34, "sub-subsection-title", 34, ">Getting Help</h3>", 10, "        <p>If you encounter issues not covered here:</p>", 10, "        <ul>", 10, "          <li>Check the <a href=", 34, "/forum", 34, " style=", 34, "color: var(--accent-1);", 34, ">Community Forum</a> for help from other users</li>", 10, "          <li>Review the language reference documentation</li>", 10, "          <li>Try compiling with <code>-d</code> flag to see generated IR</li>", 10, "          <li>Start with minimal examples and gradually add complexity</li>", 10, "        </ul>", 10, "      </section>", 10, "    </main>", 10, "  </div>", 10, 10, "  <script>", 10, "    // Copy code functionality", 10, "    function copyCode(button) {", 10, "      const codeBlock = button.closest('.code-block');", 10, "      const code = codeBlock.querySelector('code').textContent;", 10, "      ", 10, "      navigator.clipboard.writeText(code).then(() => {", 10, "        const originalText = button.textContent;", 10, "        button.textContent = 'Copied!';", 10, "        button.style.background = 'rgba(16, 185, 129, 0.2)';", 10, "        button.style.color = 'var(--success)';", 10, "        ", 10, "        setTimeout(() => {", 10, "          button.textContent = originalText;", 10, "          button.style.background = '';", 10, "          button.style.color = '';", 10, "        }, 2000);", 10, "      });", 10, "    }", 10, 10, "    // Smooth scroll and active section highlighting", 10, "    document.addEventListener('DOMContentLoaded', function() {", 10, "      const sections = document.querySelectorAll('.content-section[id]');", 10, "      const navLinks = document.querySelectorAll('.sidebar-link');", 10, "      ", 10, "      function updateActiveNav() {", 10, "        let current = '';", 10, "        sections.forEach(section => {", 10, "          const sectionTop = section.offsetTop;", 10, "          const sectionHeight = section.clientHeight;", 10, "          if (scrollY >= (sectionTop - 200)) {", 10, "            current = section.getAttribute('id');", 10, "          }", 10, "        });", 10, "        ", 10, "        navLinks.forEach(link => {", 10, "          link.classList.remove('active');", 10, "          if (link.getAttribute('href') === '#' + current) {", 10, "            link.classList.add('active');", 10, "          }", 10, "        });", 10, "      }", 10, "      ", 10, "      window.addEventListener('scroll', updateActiveNav);", 10, "      updateActiveNav();", 10, "    });", 10, "  </script>", 10, "</body>", 10, "</html>", 10, 0

; Global variable: HTTP_PAGE_HEADER (string, 16 bytes)
HTTP_PAGE_HEADER:
    dq Lstr4  ; Pointer to string data
    dq 103  ; String length
Lstr4:
    db "HTTP/1.1 200 OK", 13, 10, "Content-Type: text/html; charset=utf-8", 13, 10, "Cache-Control: no-cache", 13, 10, "Connection: close", 13, 10, 13, 10, 0

; Global variable: HTTP_DEMO_HEADER (string, 16 bytes)
HTTP_DEMO_HEADER:
    dq Lstr5  ; Pointer to string data
    dq 103  ; String length
Lstr5:
    db "HTTP/1.1 200 OK", 13, 10, "Content-Type: text/html; charset=utf-8", 13, 10, "Cache-Control: no-cache", 13, 10, "Connection: close", 13, 10, 13, 10, 0

; Global variable: HTTP_BENCHMARKS_HEADER (string, 16 bytes)
HTTP_BENCHMARKS_HEADER:
    dq Lstr6  ; Pointer to string data
    dq 106  ; String length
Lstr6:
    db "HTTP/1.1 200 OK", 13, 10, "Content-Type: text/html; charset=utf-8", 13, 10, "Cache-Control: max-age=300", 13, 10, "Connection: close", 13, 10, 13, 10, 0

; Global variable: HTTP_DOCS_HEADER (string, 16 bytes)
HTTP_DOCS_HEADER:
    dq Lstr7  ; Pointer to string data
    dq 106  ; String length
Lstr7:
    db "HTTP/1.1 200 OK", 13, 10, "Content-Type: text/html; charset=utf-8", 13, 10, "Cache-Control: max-age=600", 13, 10, "Connection: close", 13, 10, 13, 10, 0

; Global variable: HTTP_404_HEADER (string, 16 bytes)
HTTP_404_HEADER:
    dq Lstr8  ; Pointer to string data
    dq 45  ; String length
Lstr8:
    db "HTTP/1.1 404 Not Found", 13, 10, "Content-Length: 9", 13, 10, 13, 10, 0

; Global variable: HTTP_404_BODY (string, 16 bytes)
HTTP_404_BODY:
    dq Lstr9  ; Pointer to string data
    dq 9  ; String length
Lstr9:
    db "Not Found", 0

; Global variable: HTTP_HEALTH_HEADER (string, 16 bytes)
HTTP_HEALTH_HEADER:
    dq Lstr10  ; Pointer to string data
    dq 64  ; String length
Lstr10:
    db "HTTP/1.1 200 OK", 13, 10, "Content-Type: text/plain", 13, 10, "Content-Length: 2", 13, 10, 13, 10, 0

; Global variable: HTTP_HEALTH_BODY (string, 16 bytes)
HTTP_HEALTH_BODY:
    dq Lstr11  ; Pointer to string data
    dq 2  ; String length
Lstr11:
    db "OK", 0

; Global variable: FORUM_HEADER (string, 16 bytes)
FORUM_HEADER:
    dq Lstr12  ; Pointer to string data
    dq 78  ; String length
Lstr12:
    db "HTTP/1.1 200 OK", 13, 10, "Content-Type: text/html; charset=utf-8", 13, 10, "Connection: close", 13, 10, 13, 10, 0

; Global variable: FORUM_CSS (string, 16 bytes)
FORUM_CSS:
    dq Lstr13  ; Pointer to string data
    dq 4313  ; String length
Lstr13:
    db "<style>:root {", 10, "    --bg-color: #05050A;", 10, "    --bg-secondary: rgba(13, 17, 23, 0.6);", 10, "    --text-main: #E2E8F0;", 10, "    --text-muted: #94A3B8;", 10, "    --accent-1: #6366F1;", 10, "    --accent-2: #8B5CF6;", 10, "    --accent-danger: #EF4444;", 10, "    --glass-bg: rgba(255, 255, 255, 0.03);", 10, "    --glass-border: rgba(255, 255, 255, 0.08);", 10, "}", 10, 10, "* {", 10, "    box-sizing: border-box;", 10, "    margin: 0;", 10, "    padding: 0;", 10, "    font-family: 'Inter', system-ui, sans-serif;", 10, "}", 10, 10, "body {", 10, "    background-color: var(--bg-color);", 10, "    color: var(--text-main);", 10, "    line-height: 1.6;", 10, "    padding: 3rem 1rem;", 10, "    min-height: 100vh;", 10, "}", 10, 10, "body::before {", 10, "    content: '';", 10, "    position: fixed;", 10, "    top: 0;", 10, "    left: 0;", 10, "    right: 0;", 10, "    bottom: 0;", 10, "    z-index: -1;", 10, "    background: radial-gradient(circle at 15% 0%, rgba(99, 102, 241, 0.15) 0%, transparent 50%), radial-gradient(circle at 85% 100%, rgba(236, 72, 153, 0.1) 0%, transparent 50%);", 10, "}", 10, 10, ".container {", 10, "    max-width: 800px;", 10, "    margin: 0 auto;", 10, "    background: var(--glass-bg);", 10, "    border: 1px solid var(--glass-border);", 10, "    border-radius: 20px;", 10, "    padding: 2.5rem;", 10, "    backdrop-filter: blur(16px);", 10, "    box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);", 10, "    animation: fadeUp 0.6s cubic-bezier(0.16, 1, 0.3, 1);", 10, "}", 10, 10, "h1 {", 10, "    font-size: 2.5rem;", 10, "    font-weight: 700;", 10, "    background: linear-gradient(135deg, #fff 0%, var(--accent-1) 100%);", 10, "    -webkit-background-clip: text;", 10, "    -webkit-text-fill-color: transparent;", 10, "    margin-bottom: 0.5rem;", 10, "}", 10, 10, "h2 {", 10, "    font-size: 1.5rem;", 10, "    font-weight: 600;", 10, "    color: #fff;", 10, "    margin: 2rem 0 1rem;", 10, "    border-bottom: 1px solid var(--glass-border);", 10, "    padding-bottom: 0.5rem;", 10, "}", 10, 10, "ul {", 10, "    list-style: none;", 10, "    display: flex;", 10, "    flex-direction: column;", 10, "    gap: 0.8rem;", 10, "}", 10, 10, "li {", 10, "    background: var(--bg-secondary);", 10, "    border: 1px solid var(--glass-border);", 10, "    border-radius: 12px;", 10, "    transition: all 0.3s;", 10, "}", 10, 10, "li:hover {", 10, "    transform: translateX(5px);", 10, "    border-color: rgba(99, 102, 241, 0.4);", 10, "    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);", 10, "}", 10, 10, "li a {", 10, "    display: block;", 10, "    padding: 1rem 1.25rem;", 10, "    color: var(--text-main);", 10, "    text-decoration: none;", 10, "    font-weight: 500;", 10, "    border-left: 3px solid transparent;", 10, "    transition: 0.2s;", 10, "}", 10, 10, "li:hover a {", 10, "    border-left-color: var(--accent-1);", 10, "    color: #fff;", 10, "}", 10, 10, "form {", 10, "    background: var(--glass-bg);", 10, "    border: 1px solid var(--glass-border);", 10, "    padding: 1.5rem;", 10, "    border-radius: 12px;", 10, "    display: flex;", 10, "    flex-direction: column;", 10, "    gap: 1rem;", 10, "}", 10, 10, "input,", 10, "textarea {", 10, "    width: 100%;", 10, "    padding: 0.8rem 1rem;", 10, "    background: rgba(0, 0, 0, 0.3);", 10, "    border: 1px solid var(--glass-border);", 10, "    border-radius: 8px;", 10, "    color: #fff;", 10, "    transition: 0.3s;", 10, "}", 10, 10, "input:focus,", 10, "textarea:focus {", 10, "    outline: none;", 10, "    border-color: var(--accent-1);", 10, "    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);", 10, "}", 10, 10, "textarea {", 10, "    min-height: 120px;", 10, "    resize: vertical;", 10, "}", 10, 10, "button {", 10, "    background: linear-gradient(135deg, var(--accent-1) 0%, var(--accent-2) 100%);", 10, "    color: white;", 10, "    border: none;", 10, "    padding: 0.8rem 1.5rem;", 10, "    border-radius: 8px;", 10, "    font-weight: 600;", 10, "    cursor: pointer;", 10, "    align-self: flex-start;", 10, "    transition: 0.3s;", 10, "}", 10, 10, "button:hover {", 10, "    transform: translateY(-2px);", 10, "    box-shadow: 0 8px 16px rgba(99, 102, 241, 0.4);", 10, "}", 10, 10, ".post {", 10, "    margin: 1rem 0;", 10, "    padding: 1.25rem;", 10, "    background: var(--bg-secondary);", 10, "    border: 1px solid var(--glass-border);", 10, "    border-radius: 12px;", 10, "    border-left: 4px solid var(--accent-2);", 10, "    white-space: pre-wrap;", 10, "    word-break: break-word;", 10, "    animation: fadeUp 0.5s ease;", 10, "}", 10, 10, ".empty {", 10, "    color: var(--text-muted);", 10, "    font-style: italic;", 10, "    text-align: center;", 10, "    padding: 2rem;", 10, "}", 10, 10, "a.back {", 10, "    color: var(--accent-1);", 10, "    text-decoration: none;", 10, "    font-weight: 500;", 10, "    display: inline-flex;", 10, "    align-items: center;", 10, "    gap: 0.25rem;", 10, "    margin-bottom: 1.5rem;", 10, "    transition: color 0.2s;", 10, "}", 10, 10, "a.back::before {", 10, "    content: '", 226, 134, 144, "';", 10, "}", 10, 10, "a.back:hover {", 10, "    color: #fff;", 10, "    text-decoration: underline;", 10, "}", 10, 10, ".err {", 10, "    background: rgba(239, 68, 68, 0.1);", 10, "    border: 1px solid rgba(239, 68, 68, 0.3);", 10, "    color: var(--accent-danger);", 10, "    padding: 0.75rem;", 10, "    border-radius: 8px;", 10, "    margin-bottom: 1rem;", 10, "}", 10, 10, "@keyframes fadeUp {", 10, "    from {", 10, "        opacity: 0;", 10, "        transform: translateY(15px);", 10, "    }", 10, 10, "    to {", 10, "        opacity: 1;", 10, "        transform: translateY(0);", 10, "    }", 10, "}", 10, 10, "</style>", 0

; Global variable: FORUM_INDEX_START (string, 16 bytes)
FORUM_INDEX_START:
    dq Lstr14  ; Pointer to string data
    dq 267  ; String length
Lstr14:
    db "<!DOCTYPE html><html lang='en'><head><meta charset='UTF-8'><meta name='viewport' content='width=device-width,initial-scale=1'><title>Community Forum</title><link href='https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap' rel='stylesheet'>", 0

; Global variable: FORUM_INDEX_BODY (string, 16 bytes)
FORUM_INDEX_BODY:
    dq Lstr15  ; Pointer to string data
    dq 124  ; String length
Lstr15:
    db "</head><body><div class='container'><h1>Community Forum</h1><a href='/' class='back'>Back to Website</a><h2>Threads</h2><ul>", 0

; Global variable: FORUM_INDEX_END (string, 16 bytes)
FORUM_INDEX_END:
    dq Lstr16  ; Pointer to string data
    dq 32  ; String length
Lstr16:
    db "</ul><h2>Start a Discussion</h2>", 0

; Global variable: FORUM_FORM (string, 16 bytes)
FORUM_FORM:
    dq Lstr17  ; Pointer to string data
    dq 182  ; String length
Lstr17:
    db "<form method='POST' action='/forum'><input name='title' placeholder='Thread title...' required maxlength='200'><button type='submit'>Create Thread</button></form></div></body></html>", 0

; Global variable: FORUM_THREAD_START (string, 16 bytes)
FORUM_THREAD_START:
    dq Lstr18  ; Pointer to string data
    dq 269  ; String length
Lstr18:
    db "<!DOCTYPE html><html lang='en'><head><meta charset='UTF-8'><meta name='viewport' content='width=device-width,initial-scale=1'><title>Discussion Thread</title><link href='https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap' rel='stylesheet'>", 0

; Global variable: FORUM_THREAD_HEAD_END (string, 16 bytes)
FORUM_THREAD_HEAD_END:
    dq Lstr19  ; Pointer to string data
    dq 40  ; String length
Lstr19:
    db "</head><body><div class='container'><h1>", 0

; Global variable: FORUM_THREAD_MID (string, 16 bytes)
FORUM_THREAD_MID:
    dq Lstr20  ; Pointer to string data
    dq 68  ; String length
Lstr20:
    db "</h1><a href='/forum' class='back'>Back to Forum</a><h2>Replies</h2>", 0

; Global variable: FORUM_THREAD_END (string, 16 bytes)
FORUM_THREAD_END:
    dq Lstr21  ; Pointer to string data
    dq 63  ; String length
Lstr21:
    db "<h2>Post a Reply</h2><form method='POST' action='/forum?thread=", 0

; Global variable: FORUM_THREAD_END2 (string, 16 bytes)
FORUM_THREAD_END2:
    dq Lstr22  ; Pointer to string data
    dq 151  ; String length
Lstr22:
    db "'><textarea name='body' placeholder='Write your reply here...' required></textarea><button type='submit'>Post Reply</button></form></div></body></html>", 0

; Global variable: FORUM_NO_POSTS (string, 16 bytes)
FORUM_NO_POSTS:
    dq Lstr23  ; Pointer to string data
    dq 57  ; String length
Lstr23:
    db "<p class='empty'>No posts yet. Be the first to reply!</p>", 0

; Global variable: FORUM_ERR_EMPTY (string, 16 bytes)
FORUM_ERR_EMPTY:
    dq Lstr24  ; Pointer to string data
    dq 48  ; String length
Lstr24:
    db "<p class='err'>Thread title cannot be empty.</p>", 0

; Global variable: FORUM_LI_OPEN (string, 16 bytes)
FORUM_LI_OPEN:
    dq Lstr25  ; Pointer to string data
    dq 27  ; String length
Lstr25:
    db "<li><a href='/forum?thread=", 0

; Global variable: FORUM_LI_MID (string, 16 bytes)
FORUM_LI_MID:
    dq Lstr26  ; Pointer to string data
    dq 2  ; String length
Lstr26:
    db "'>", 0

; Global variable: FORUM_LI_CLOSE (string, 16 bytes)
FORUM_LI_CLOSE:
    dq Lstr27  ; Pointer to string data
    dq 9  ; String length
Lstr27:
    db "</a></li>", 0

; Global variable: FORUM_POST_OPEN (string, 16 bytes)
FORUM_POST_OPEN:
    dq Lstr28  ; Pointer to string data
    dq 18  ; String length
Lstr28:
    db "<div class='post'>", 0

; Global variable: FORUM_POST_CLOSE (string, 16 bytes)
FORUM_POST_CLOSE:
    dq Lstr29  ; Pointer to string data
    dq 6  ; String length
Lstr29:
    db "</div>", 0

; Global variable: REDIRECT_302 (string, 16 bytes)
REDIRECT_302:
    dq Lstr30  ; Pointer to string data
    dq 30  ; String length
Lstr30:
    db "HTTP/1.1 302 Found", 13, 10, "Location: ", 0

; Global variable: REDIRECT_END (string, 16 bytes)
REDIRECT_END:
    dq Lstr31  ; Pointer to string data
    dq 4  ; String length
Lstr31:
    db 13, 10, 13, 10, 0

; Global variable: fn_threads (string, 16 bytes)
fn_threads:
    dq Lstr32  ; Pointer to string data
    dq 11  ; String length
Lstr32:
    db "threads.txt", 0

; Global variable: fn_posts_prefix (string, 16 bytes)
fn_posts_prefix:
    dq Lstr33  ; Pointer to string data
    dq 6  ; String length
Lstr33:
    db "posts_", 0

; Global variable: fn_posts_suffix (string, 16 bytes)
fn_posts_suffix:
    dq Lstr34  ; Pointer to string data
    dq 4  ; String length
Lstr34:
    db ".txt", 0

; Global variable: mode_r (string, 16 bytes)
mode_r:
    dq Lstr35  ; Pointer to string data
    dq 1  ; String length
Lstr35:
    db "r", 0

; Global variable: mode_a (string, 16 bytes)
mode_a:
    dq Lstr36  ; Pointer to string data
    dq 1  ; String length
Lstr36:
    db "a", 0

; Global variable: nl (string, 16 bytes)
nl:
    dq Lstr37  ; Pointer to string data
    dq 1  ; String length
Lstr37:
    db 10, 0

; Global variable: key_title (string, 16 bytes)
key_title:
    dq Lstr38  ; Pointer to string data
    dq 5  ; String length
Lstr38:
    db "title", 0

; Global variable: key_body (string, 16 bytes)
key_body:
    dq Lstr39  ; Pointer to string data
    dq 4  ; String length
Lstr39:
    db "body", 0

; Global variable: hdr_content_length (string, 16 bytes)
hdr_content_length:
    dq Lstr40  ; Pointer to string data
    dq 15  ; String length
Lstr40:
    db "Content-Length:", 0

; Global variable: hdr_content_length_lo (string, 16 bytes)
hdr_content_length_lo:
    dq Lstr41  ; Pointer to string data
    dq 15  ; String length
Lstr41:
    db "content-length:", 0

; Global variable: pat_crlf2 (string, 16 bytes)
pat_crlf2:
    dq Lstr42  ; Pointer to string data
    dq 4  ; String length
Lstr42:
    db 13, 10, 13, 10, 0

; Global variable: pat_lf2 (string, 16 bytes)
pat_lf2:
    dq Lstr43  ; Pointer to string data
    dq 2  ; String length
Lstr43:
    db 10, 10, 0

; Global variable: html_amp (string, 16 bytes)
html_amp:
    dq Lstr44  ; Pointer to string data
    dq 5  ; String length
Lstr44:
    db "&amp;", 0

; Global variable: html_lt (string, 16 bytes)
html_lt:
    dq Lstr45  ; Pointer to string data
    dq 4  ; String length
Lstr45:
    db "&lt;", 0

; Global variable: html_gt (string, 16 bytes)
html_gt:
    dq Lstr46  ; Pointer to string data
    dq 4  ; String length
Lstr46:
    db "&gt;", 0

; Global variable: html_quot (string, 16 bytes)
html_quot:
    dq Lstr47  ; Pointer to string data
    dq 6  ; String length
Lstr47:
    db "&quot;", 0

; Global variable: html_apos (string, 16 bytes)
html_apos:
    dq Lstr48  ; Pointer to string data
    dq 5  ; String length
Lstr48:
    db "&#39;", 0

; Global variable: dbg_on (int32, 4 bytes)
dbg_on:
    dd 0

; Global variable: dbg_post (string, 16 bytes)
dbg_post:
    dq Lstr49  ; Pointer to string data
    dq 7  ; String length
Lstr49:
    db "[POST] ", 0

; Global variable: dbg_bs (string, 16 bytes)
dbg_bs:
    dq Lstr50  ; Pointer to string data
    dq 12  ; String length
Lstr50:
    db " body_start=", 0

; Global variable: dbg_bl (string, 16 bytes)
dbg_bl:
    dq Lstr51  ; Pointer to string data
    dq 10  ; String length
Lstr51:
    db " body_len=", 0

; Global variable: dbg_cl (string, 16 bytes)
dbg_cl:
    dq Lstr52  ; Pointer to string data
    dq 13  ; String length
Lstr52:
    db " content_len=", 0

; Global variable: dbg_need (string, 16 bytes)
dbg_need:
    dq Lstr53  ; Pointer to string data
    dq 6  ; String length
Lstr53:
    db " need=", 0

; Global variable: dbg_n (string, 16 bytes)
dbg_n:
    dq Lstr54  ; Pointer to string data
    dq 3  ; String length
Lstr54:
    db " n=", 0

; Global variable: dbg_got (string, 16 bytes)
dbg_got:
    dq Lstr55  ; Pointer to string data
    dq 5  ; String length
Lstr55:
    db " got=", 0

; Global variable: dbg_title (string, 16 bytes)
dbg_title:
    dq Lstr56  ; Pointer to string data
    dq 11  ; String length
Lstr56:
    db " title_len=", 0

; Global variable: dbg_fopen_ok (string, 16 bytes)
dbg_fopen_ok:
    dq Lstr57  ; Pointer to string data
    dq 9  ; String length
Lstr57:
    db " fopen_ok", 0

; Global variable: dbg_fopen_fail (string, 16 bytes)
dbg_fopen_fail:
    dq Lstr58  ; Pointer to string data
    dq 11  ; String length
Lstr58:
    db " fopen_fail", 0

; Global variable: dbg_newline (string, 16 bytes)
dbg_newline:
    dq Lstr59  ; Pointer to string data
    dq 1  ; String length
Lstr59:
    db 10, 0

; Global variable: dbg_fbs_enter (string, 16 bytes)
dbg_fbs_enter:
    dq Lstr60  ; Pointer to string data
    dq 14  ; String length
Lstr60:
    db "[fbs] enter n=", 0

; Global variable: dbg_fbs_exit (string, 16 bytes)
dbg_fbs_exit:
    dq Lstr61  ; Pointer to string data
    dq 15  ; String length
Lstr61:
    db "[fbs] exit ret=", 0

; Global variable: dbg_fbs_ok (string, 16 bytes)
dbg_fbs_ok:
    dq Lstr62  ; Pointer to string data
    dq 8  ; String length
Lstr62:
    db "[fbs] ok", 0

; Global variable: dbg_loop (string, 16 bytes)
dbg_loop:
    dq Lstr63  ; Pointer to string data
    dq 13  ; String length
Lstr63:
    db "[fbs] loop i=", 0

; Global variable: err_net_init (string, 16 bytes)
err_net_init:
    dq Lstr64  ; Pointer to string data
    dq 15  ; String length
Lstr64:
    db "net_init failed", 0

; Global variable: err_socket (string, 16 bytes)
err_socket:
    dq Lstr65  ; Pointer to string data
    dq 13  ; String length
Lstr65:
    db "socket failed", 0

; Global variable: err_reuseaddr (string, 16 bytes)
err_reuseaddr:
    dq Lstr66  ; Pointer to string data
    dq 17  ; String length
Lstr66:
    db "setsockopt failed", 0

; Global variable: err_sockaddr (string, 16 bytes)
err_sockaddr:
    dq Lstr67  ; Pointer to string data
    dq 15  ; String length
Lstr67:
    db "sockaddr failed", 0

; Global variable: err_bind (string, 16 bytes)
err_bind:
    dq Lstr68  ; Pointer to string data
    dq 11  ; String length
Lstr68:
    db "bind failed", 0

; Global variable: err_listen (string, 16 bytes)
err_listen:
    dq Lstr69  ; Pointer to string data
    dq 13  ; String length
Lstr69:
    db "listen failed", 0

; Global variable: msg_ready (string, 16 bytes)
msg_ready:
    dq Lstr70  ; Pointer to string data
    dq 29  ; String length
Lstr70:
    db "Server: http://localhost:5000", 0

; Global variable: crlf (string, 16 bytes)
crlf:
    dq Lstr71  ; Pointer to string data
    dq 2  ; String length
Lstr71:
    db 13, 10, 0

Lstr_chars72:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct73:
    dq Lstr_chars72
    dq 37

Lstr_chars74:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct75:
    dq Lstr_chars74
    dq 37

Lstr_chars76:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct77:
    dq Lstr_chars76
    dq 38

Lstr_chars78:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct79:
    dq Lstr_chars78
    dq 38

Lstr_chars80:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct81:
    dq Lstr_chars80
    dq 37

Lstr_chars82:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct83:
    dq Lstr_chars82
    dq 37

Lstr_chars84:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct85:
    dq Lstr_chars84
    dq 37

Lstr_chars86:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct87:
    dq Lstr_chars86
    dq 37

Lstr_chars88:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct89:
    dq Lstr_chars88
    dq 37

Lstr_chars90:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct91:
    dq Lstr_chars90
    dq 37

Lstr_chars92:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct93:
    dq Lstr_chars92
    dq 37

Lstr_chars94:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct95:
    dq Lstr_chars94
    dq 37

Lstr_chars96:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct97:
    dq Lstr_chars96
    dq 37

Lstr_chars98:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct99:
    dq Lstr_chars98
    dq 37

Lstr_chars100:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct101:
    dq Lstr_chars100
    dq 37

Lstr_chars102:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct103:
    dq Lstr_chars102
    dq 37

Lstr_chars104:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct105:
    dq Lstr_chars104
    dq 38

Lstr_chars106:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct107:
    dq Lstr_chars106
    dq 38

Lstr_chars108:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct109:
    dq Lstr_chars108
    dq 38

Lstr_chars110:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct111:
    dq Lstr_chars110
    dq 38

Lstr_chars112:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct113:
    dq Lstr_chars112
    dq 38

Lstr_chars114:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct115:
    dq Lstr_chars114
    dq 38

Lstr_chars116:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct117:
    dq Lstr_chars116
    dq 37

Lstr_chars118:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct119:
    dq Lstr_chars118
    dq 37

Lstr_chars120:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct121:
    dq Lstr_chars120
    dq 37

Lstr_chars122:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct123:
    dq Lstr_chars122
    dq 37

Lstr_chars124:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct125:
    dq Lstr_chars124
    dq 37

Lstr_chars126:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct127:
    dq Lstr_chars126
    dq 37

Lstr_chars128:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct129:
    dq Lstr_chars128
    dq 37

Lstr_chars130:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct131:
    dq Lstr_chars130
    dq 37

Lstr_chars132:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct133:
    dq Lstr_chars132
    dq 37

Lstr_chars134:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct135:
    dq Lstr_chars134
    dq 37

Lstr_chars136:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct137:
    dq Lstr_chars136
    dq 37

Lstr_chars138:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct139:
    dq Lstr_chars138
    dq 37

Lstr_chars140:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct141:
    dq Lstr_chars140
    dq 37

Lstr_chars142:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct143:
    dq Lstr_chars142
    dq 37

Lstr_chars144:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct145:
    dq Lstr_chars144
    dq 37

Lstr_chars146:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct147:
    dq Lstr_chars146
    dq 37

Lstr_chars148:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct149:
    dq Lstr_chars148
    dq 37

Lstr_chars150:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct151:
    dq Lstr_chars150
    dq 37

Lstr_chars152:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct153:
    dq Lstr_chars152
    dq 37

Lstr_chars154:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct155:
    dq Lstr_chars154
    dq 37

Lstr_chars156:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct157:
    dq Lstr_chars156
    dq 37

Lstr_chars158:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct159:
    dq Lstr_chars158
    dq 37

Lstr_chars160:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct161:
    dq Lstr_chars160
    dq 37

Lstr_chars162:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct163:
    dq Lstr_chars162
    dq 37

Lstr_chars164:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct165:
    dq Lstr_chars164
    dq 37

Lstr_chars166:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct167:
    dq Lstr_chars166
    dq 37

Lstr_chars168:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct169:
    dq Lstr_chars168
    dq 37

Lstr_chars170:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct171:
    dq Lstr_chars170
    dq 37

Lstr_chars172:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct173:
    dq Lstr_chars172
    dq 37

Lstr_chars174:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct175:
    dq Lstr_chars174
    dq 37

Lstr_chars176:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct177:
    dq Lstr_chars176
    dq 37

Lstr_chars178:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct179:
    dq Lstr_chars178
    dq 37

Lstr_chars180:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct181:
    dq Lstr_chars180
    dq 37

Lstr_chars182:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct183:
    dq Lstr_chars182
    dq 37

Lstr_chars184:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct185:
    dq Lstr_chars184
    dq 37

Lstr_chars186:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct187:
    dq Lstr_chars186
    dq 37

Lstr_chars188:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct189:
    dq Lstr_chars188
    dq 37

Lstr_chars190:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct191:
    dq Lstr_chars190
    dq 37

Lstr_chars192:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct193:
    dq Lstr_chars192
    dq 37

Lstr_chars194:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct195:
    dq Lstr_chars194
    dq 37

Lstr_chars196:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct197:
    dq Lstr_chars196
    dq 37

Lstr_chars198:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct199:
    dq Lstr_chars198
    dq 37

Lstr_chars200:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct201:
    dq Lstr_chars200
    dq 37

Lstr_chars202:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct203:
    dq Lstr_chars202
    dq 37

Lstr_chars204:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct205:
    dq Lstr_chars204
    dq 37

Lstr_chars206:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct207:
    dq Lstr_chars206
    dq 37

Lstr_chars208:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct209:
    dq Lstr_chars208
    dq 37

Lstr_chars210:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct211:
    dq Lstr_chars210
    dq 37

Lstr_chars212:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct213:
    dq Lstr_chars212
    dq 37

Lstr_chars214:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct215:
    dq Lstr_chars214
    dq 37

Lstr_chars216:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct217:
    dq Lstr_chars216
    dq 37

Lstr_chars218:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct219:
    dq Lstr_chars218
    dq 37

Lstr_chars220:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct221:
    dq Lstr_chars220
    dq 37

Lstr_chars222:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct223:
    dq Lstr_chars222
    dq 37

Lstr_chars224:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct225:
    dq Lstr_chars224
    dq 37

Lstr_chars226:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct227:
    dq Lstr_chars226
    dq 37

Lstr_chars228:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct229:
    dq Lstr_chars228
    dq 37

Lstr_chars230:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct231:
    dq Lstr_chars230
    dq 37

Lstr_chars232:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct233:
    dq Lstr_chars232
    dq 37

Lstr_chars234:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct235:
    dq Lstr_chars234
    dq 37

Lstr_chars236:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct237:
    dq Lstr_chars236
    dq 37

Lstr_chars238:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct239:
    dq Lstr_chars238
    dq 37

Lstr_chars240:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct241:
    dq Lstr_chars240
    dq 37

Lstr_chars242:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct243:
    dq Lstr_chars242
    dq 37

Lstr_chars244:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct245:
    dq Lstr_chars244
    dq 37

Lstr_chars246:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct247:
    dq Lstr_chars246
    dq 37

Lstr_chars248:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct249:
    dq Lstr_chars248
    dq 37

Lstr_chars250:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct251:
    dq Lstr_chars250
    dq 37

Lstr_chars252:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct253:
    dq Lstr_chars252
    dq 37

Lstr_chars254:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct255:
    dq Lstr_chars254
    dq 37

Lstr_chars256:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct257:
    dq Lstr_chars256
    dq 37

Lstr_chars258:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct259:
    dq Lstr_chars258
    dq 37

Lstr_chars260:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct261:
    dq Lstr_chars260
    dq 37

Lstr_chars262:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct263:
    dq Lstr_chars262
    dq 37

Lstr_chars264:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct265:
    dq Lstr_chars264
    dq 37

Lstr_chars266:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct267:
    dq Lstr_chars266
    dq 37

Lstr_chars268:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct269:
    dq Lstr_chars268
    dq 37

Lstr_chars270:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct271:
    dq Lstr_chars270
    dq 37

Lstr_chars272:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct273:
    dq Lstr_chars272
    dq 37

Lstr_chars274:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct275:
    dq Lstr_chars274
    dq 37

Lstr_chars276:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct277:
    dq Lstr_chars276
    dq 37

Lstr_chars278:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct279:
    dq Lstr_chars278
    dq 37

Lstr_chars280:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct281:
    dq Lstr_chars280
    dq 37

Lstr_chars282:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct283:
    dq Lstr_chars282
    dq 37

Lstr_chars284:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct285:
    dq Lstr_chars284
    dq 37

Lstr_chars286:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct287:
    dq Lstr_chars286
    dq 37

Lstr_chars288:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct289:
    dq Lstr_chars288
    dq 37

Lstr_chars290:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct291:
    dq Lstr_chars290
    dq 37

Lstr_chars292:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct293:
    dq Lstr_chars292
    dq 37

Lstr_chars294:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct295:
    dq Lstr_chars294
    dq 37

Lstr_chars296:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct297:
    dq Lstr_chars296
    dq 38

Lstr_chars298:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct299:
    dq Lstr_chars298
    dq 38

Lstr_chars300:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct301:
    dq Lstr_chars300
    dq 37

Lstr_chars302:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct303:
    dq Lstr_chars302
    dq 38

Lstr_chars304:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct305:
    dq Lstr_chars304
    dq 38

Lstr_chars306:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct307:
    dq Lstr_chars306
    dq 37

Lstr_chars308:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct309:
    dq Lstr_chars308
    dq 37

Lstr_chars310:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct311:
    dq Lstr_chars310
    dq 37

Lstr_chars312:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct313:
    dq Lstr_chars312
    dq 37

Lstr_chars314:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct315:
    dq Lstr_chars314
    dq 37

Lstr_chars316:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct317:
    dq Lstr_chars316
    dq 37

Lstr_chars318:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct319:
    dq Lstr_chars318
    dq 37

Lstr_chars320:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct321:
    dq Lstr_chars320
    dq 37

Lstr_chars322:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct323:
    dq Lstr_chars322
    dq 37

Lstr_chars324:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct325:
    dq Lstr_chars324
    dq 37

Lstr_chars326:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct327:
    dq Lstr_chars326
    dq 37

Lstr_chars328:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct329:
    dq Lstr_chars328
    dq 37

Lstr_chars330:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct331:
    dq Lstr_chars330
    dq 37

Lstr_chars332:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct333:
    dq Lstr_chars332
    dq 37

Lstr_chars334:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct335:
    dq Lstr_chars334
    dq 37

Lstr_chars336:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct337:
    dq Lstr_chars336
    dq 37

Lstr_chars338:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct339:
    dq Lstr_chars338
    dq 37

Lstr_chars340:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct341:
    dq Lstr_chars340
    dq 37

Lstr_chars342:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct343:
    dq Lstr_chars342
    dq 37

Lstr_chars344:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct345:
    dq Lstr_chars344
    dq 37

Lstr_chars346:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct347:
    dq Lstr_chars346
    dq 37

Lstr_chars348:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct349:
    dq Lstr_chars348
    dq 37

Lstr_chars350:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct351:
    dq Lstr_chars350
    dq 37

Lstr_chars352:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct353:
    dq Lstr_chars352
    dq 37

Lstr_chars354:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct355:
    dq Lstr_chars354
    dq 37

Lstr_chars356:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct357:
    dq Lstr_chars356
    dq 37

Lstr_chars358:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct359:
    dq Lstr_chars358
    dq 37

Lstr_chars360:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct361:
    dq Lstr_chars360
    dq 37

Lstr_chars362:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct363:
    dq Lstr_chars362
    dq 37

Lstr_chars364:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct365:
    dq Lstr_chars364
    dq 37

Lstr_chars366:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct367:
    dq Lstr_chars366
    dq 37

Lstr_chars368:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct369:
    dq Lstr_chars368
    dq 38

Lstr_chars370:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct371:
    dq Lstr_chars370
    dq 37

Lstr_chars384:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct385:
    dq Lstr_chars384
    dq 38

Lstr_chars386:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct387:
    dq Lstr_chars386
    dq 38

Lstr_chars388:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct389:
    dq Lstr_chars388
    dq 38

Lstr_chars390:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct391:
    dq Lstr_chars390
    dq 38

Lstr_chars392:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct393:
    dq Lstr_chars392
    dq 38

Lstr_chars394:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct395:
    dq Lstr_chars394
    dq 38

Lstr_chars396:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct397:
    dq Lstr_chars396
    dq 38

Lstr_chars398:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct399:
    dq Lstr_chars398
    dq 38

Lstr_chars400:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct401:
    dq Lstr_chars400
    dq 38

Lstr_chars414:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct415:
    dq Lstr_chars414
    dq 38

Lstr_chars416:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct417:
    dq Lstr_chars416
    dq 38

Lstr_chars418:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct419:
    dq Lstr_chars418
    dq 38

Lstr_chars420:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct421:
    dq Lstr_chars420
    dq 38

Lstr_chars422:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct423:
    dq Lstr_chars422
    dq 38

Lstr_chars424:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct425:
    dq Lstr_chars424
    dq 38

Lstr_chars426:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct427:
    dq Lstr_chars426
    dq 38

Lstr_chars428:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct429:
    dq Lstr_chars428
    dq 38

Lstr_chars430:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct431:
    dq Lstr_chars430
    dq 38

Lstr_chars432:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct433:
    dq Lstr_chars432
    dq 38

Lstr_chars434:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct435:
    dq Lstr_chars434
    dq 38

Lstr_chars436:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct437:
    dq Lstr_chars436
    dq 38

Lstr_chars438:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct439:
    dq Lstr_chars438
    dq 38

Lstr_chars440:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct441:
    dq Lstr_chars440
    dq 38

Lstr_chars442:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct443:
    dq Lstr_chars442
    dq 38

Lstr_chars444:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct445:
    dq Lstr_chars444
    dq 38

Lstr_chars446:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct447:
    dq Lstr_chars446
    dq 38

Lstr_chars448:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct449:
    dq Lstr_chars448
    dq 38

Lstr_chars450:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct451:
    dq Lstr_chars450
    dq 38

Lstr_chars452:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct453:
    dq Lstr_chars452
    dq 38

Lstr_chars454:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct455:
    dq Lstr_chars454
    dq 38

Lstr_chars456:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct457:
    dq Lstr_chars456
    dq 38

Lstr_chars458:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct459:
    dq Lstr_chars458
    dq 38

Lstr_chars460:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct461:
    dq Lstr_chars460
    dq 38

Lstr_chars462:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct463:
    dq Lstr_chars462
    dq 38

Lstr_chars464:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct465:
    dq Lstr_chars464
    dq 38

Lstr_chars466:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct467:
    dq Lstr_chars466
    dq 38

Lstr_chars468:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct469:
    dq Lstr_chars468
    dq 38

Lstr_chars470:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct471:
    dq Lstr_chars470
    dq 38

Lstr_chars472:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct473:
    dq Lstr_chars472
    dq 38

Lstr_chars474:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct475:
    dq Lstr_chars474
    dq 38

Lstr_chars476:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct477:
    dq Lstr_chars476
    dq 38

Lstr_chars478:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct479:
    dq Lstr_chars478
    dq 38

Lstr_chars480:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct481:
    dq Lstr_chars480
    dq 38

Lstr_chars482:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct483:
    dq Lstr_chars482
    dq 38

Lstr_chars484:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct485:
    dq Lstr_chars484
    dq 38

Lstr_chars486:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct487:
    dq Lstr_chars486
    dq 38

Lstr_chars488:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct489:
    dq Lstr_chars488
    dq 38

Lstr_chars490:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct491:
    dq Lstr_chars490
    dq 38

Lstr_chars492:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct493:
    dq Lstr_chars492
    dq 38

Lstr_chars494:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct495:
    dq Lstr_chars494
    dq 38

Lstr_chars496:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct497:
    dq Lstr_chars496
    dq 38

Lstr_chars498:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct499:
    dq Lstr_chars498
    dq 38

Lstr_chars500:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct501:
    dq Lstr_chars500
    dq 38

Lstr_chars502:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct503:
    dq Lstr_chars502
    dq 38

Lstr_chars504:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct505:
    dq Lstr_chars504
    dq 38

Lstr_chars506:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct507:
    dq Lstr_chars506
    dq 38

Lstr_chars508:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct509:
    dq Lstr_chars508
    dq 38

Lstr_chars510:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct511:
    dq Lstr_chars510
    dq 38

Lstr_chars512:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct513:
    dq Lstr_chars512
    dq 38

Lstr_chars514:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct515:
    dq Lstr_chars514
    dq 38

Lstr_chars516:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct517:
    dq Lstr_chars516
    dq 38

Lstr_chars518:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct519:
    dq Lstr_chars518
    dq 38

Lstr_chars520:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct521:
    dq Lstr_chars520
    dq 38

Lstr_chars522:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct523:
    dq Lstr_chars522
    dq 38

Lstr_chars524:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct525:
    dq Lstr_chars524
    dq 38

Lstr_chars526:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct527:
    dq Lstr_chars526
    dq 38

Lstr_chars528:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct529:
    dq Lstr_chars528
    dq 38

Lstr_chars530:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct531:
    dq Lstr_chars530
    dq 38

Lstr_chars532:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct533:
    dq Lstr_chars532
    dq 38

Lstr_chars534:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct535:
    dq Lstr_chars534
    dq 38

Lstr_chars536:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct537:
    dq Lstr_chars536
    dq 38

Lstr_chars538:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct539:
    dq Lstr_chars538
    dq 38

Lstr_chars540:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct541:
    dq Lstr_chars540
    dq 38

Lstr_chars542:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct543:
    dq Lstr_chars542
    dq 38

