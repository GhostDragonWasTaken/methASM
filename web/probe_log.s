; Generated by MethASM
; x86-64 Assembly Output

section .text
; Code section

; First pass: processing 6 declarations
; Declaration 0 type: 3 (AST_INLINE_ASM = 16)
; Declaration 1 type: 3 (AST_INLINE_ASM = 16)
; Declaration 2 type: 2 (AST_INLINE_ASM = 16)
; Declaration 3 type: 2 (AST_INLINE_ASM = 16)
; Declaration 4 type: 3 (AST_INLINE_ASM = 16)
; Declaration 5 type: 3 (AST_INLINE_ASM = 16)

; Data section for global variables
section .data
; Global variable: msg (string, 16 bytes)
msg:
    dq Lstr0  ; Pointer to string data
    dq 5  ; String length
Lstr0:
    db "hello", 0

; Global variable: nl (string, 16 bytes)
nl:
    dq Lstr1  ; Pointer to string data
    dq 2  ; String length
Lstr1:
    db 13, 10, 0


section .text
    extern GetStdHandle
    extern WriteFile

global log_line_parts

log_line_parts:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 304    ; Allocate 304 bytes on stack (aligned)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 'chars'
    ; Parameter 'chars' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'len'
    ; Parameter 'len' arrived in register rdx
ir_entry_0:
    mov rax, 11
    neg rax
    mov [rbp - 32], rax
    ; IR call: GetStdHandle (1 args)
    sub rsp, 32
    mov rax, [rbp - 32]
    mov rcx, rax
    call GetStdHandle
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    ; Store to variable: out
    mov qword [rbp - 24], rax  ; To stack [rbp - 24]
    ; Load variable: out
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_if_else_1
    jmp Llog_line_parts_exit
    jmp ir_if_end_2
ir_if_else_1:
ir_if_end_2:
    ; IR call: WriteFile (5 args)
    sub rsp, 48
    mov rax, 0
    mov [rsp + 32], rax
    ; Load variable: out
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov rcx, rax
    ; Load variable: chars
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rdx, rax
    ; Load variable: len
    mov eax, dword [rbp - 16]  ; From stack [rbp - 16]
    mov r8, rax
    mov rax, 0
    mov r9, rax
    call WriteFile
    mov rcx, rax
    add rsp, 48
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 56], rax
    lea rax, [rel nl]
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    mov rax, qword [rax]
    mov [rbp - 80], rax
    lea rax, [rel nl]
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    mov rax, qword [rax]
    mov [rbp - 104], rax
    ; IR call: WriteFile (5 args)
    sub rsp, 48
    mov rax, 0
    mov [rsp + 32], rax
    ; Load variable: out
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov rcx, rax
    mov rax, [rbp - 80]
    mov rdx, rax
    mov rax, [rbp - 104]
    mov r8, rax
    mov rax, 0
    mov r9, rax
    call WriteFile
    mov rcx, rax
    add rsp, 48
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 112], rax
Llog_line_parts_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global main

main:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 176    ; Allocate 176 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_3:
    lea rax, [rel msg]
    mov [rbp - 8], rax
    mov rax, [rbp - 8]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    mov rax, qword [rax]
    mov [rbp - 24], rax
    lea rax, [rel msg]
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    mov rax, qword [rax]
    mov [rbp - 48], rax
    ; IR call: log_line_parts (2 args)
    sub rsp, 32
    mov rax, [rbp - 24]
    mov rcx, rax
    mov rax, [rbp - 48]
    mov rdx, rax
    call log_line_parts
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Void return - no value to handle
    mov [rbp - 56], rax
    mov rax, 0
    jmp Lmain_exit
Lmain_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

; Default program entry point
global mainCRTStartup
mainCRTStartup:
    sub rsp, 40      ; Shadow space + alignment
    ; Initialize garbage collector runtime
    lea rcx, [rsp + 40]
    extern gc_init
    call gc_init
    extern gc_register_root
    lea rcx, [rel msg]
    call gc_register_root
    lea rcx, [rel nl]
    call gc_register_root
    ; Call user main function
    call main
    mov [rsp + 32], rax ; Preserve main return code
    extern gc_shutdown
    call gc_shutdown
    mov rcx, [rsp + 32] ; Use main return as exit code
    extern ExitProcess
    call ExitProcess
