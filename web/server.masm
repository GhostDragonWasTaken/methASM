// MethASM Web Server - Full implementation in MethASM
// Serves HTML on port 5000 using Winsock (Windows) via extern C calls.
// Uses modular imports to test the import system.

import "socket";
import "http";

extern function GetStdHandle(nStdHandle: int32) -> int64 = "GetStdHandle";
extern function WriteFile(hFile: int64, lpBuffer: uint8*, nNumberOfBytesToWrite: uint32, lpNumberOfBytesWritten: uint8*, lpOverlapped: uint8*) -> int32 = "WriteFile";

var nl: string = "\r\n";
var msg_wsa_fail: string = "Startup error: WSAStartup failed";
var msg_socket_fail: string = "Startup error: socket() failed";
var msg_bind_fail: string = "Startup error: bind() failed (port in use?)";
var msg_listen_fail: string = "Startup error: listen() failed";
var msg_started: string = "Server listening on http://localhost:5000";

function log_line_parts(chars: cstring, len: int32) {
  var out: int64 = GetStdHandle(-11);
  if (out < 0) {
    return;
  }

  WriteFile(out, chars, len, 0, 0);
  WriteFile(out, nl.chars, nl.length, 0, 0);
}

function main() -> int32 {
  var wsa: uint8[416];
  var addr: SockAddrIn;
  var listen_sock: int64 = 0;
  var client: int64 = 0;
  var result: int32 = 0;

  // WSAStartup(MAKEWORD(2,2)=514, &wsa)
  result = WSAStartup(514, &wsa[0]);
  if (result != 0) {
    log_line_parts(msg_wsa_fail.chars, msg_wsa_fail.length);
    return 1;
  }

  // listen_sock = socket(AF_INET, SOCK_STREAM, 0)
  listen_sock = socket(2, 1, 0);
  if (listen_sock < 0) {
    log_line_parts(msg_socket_fail.chars, msg_socket_fail.length);
    WSACleanup();
    return 1;
  }

  // SO_REUSEADDR for quick restart (SOL_SOCKET=0xFFFF, SO_REUSEADDR=4)
  var opt: uint8[4];
  opt[0] = 1;
  setsockopt(listen_sock, 0xFFFF, 4, &opt[0], 4);

  // addr.sin_family = AF_INET, addr.sin_port = htons(5000), addr.sin_addr = INADDR_ANY
  addr.sin_family = 2;
  addr.sin_port = htons(5000);
  addr.sin_addr = 0;

  // bind(listen_sock, &addr, 16)
  result = bind(listen_sock, &addr, 16);
  if (result != 0) {
    log_line_parts(msg_bind_fail.chars, msg_bind_fail.length);
    closesocket(listen_sock);
    WSACleanup();
    return 1;
  }

  // listen(listen_sock, 5)
  result = listen(listen_sock, 5);
  if (result != 0) {
    log_line_parts(msg_listen_fail.chars, msg_listen_fail.length);
    closesocket(listen_sock);
    WSACleanup();
    return 1;
  }

  log_line_parts(msg_started.chars, msg_started.length);

  // Main accept loop
  while (1) {
    // client = accept(listen_sock, 0, 0)
    client = accept(listen_sock, 0, 0);
    if (client < 0) {
      continue;
    }

    var buf: uint8[1024];
    var bytes_read: int32 = recv(client, &buf[0], 1024, 0);
    if (bytes_read <= 0) {
      closesocket(client);
      continue;
    }

    var route: int32 = get_route(&buf[0], bytes_read);

    switch (route) {
      case 0:
        send(client, http_header.chars, http_header.length, 0);
        send(client, html_body.chars, html_body.length, 0);
        break;
      case 1:
        send(client, health_header.chars, health_header.length, 0);
        send(client, health_body.chars, health_body.length, 0);
        break;
      case 2:
        send(client, http_header.chars, http_header.length, 0);
        send(client, about_body.chars, about_body.length, 0);
        break;
      default:
        send(client, not_found_header.chars, not_found_header.length, 0);
        send(client, not_found_body.chars, not_found_body.length, 0);
    }

    closesocket(client);
  }

  closesocket(listen_sock);
  WSACleanup();
  return 0;
}
