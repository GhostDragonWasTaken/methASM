// MethASM Demonstration Server
//
// Single-threaded TCP server on port 5000. Accepts connections, reads HTTP
// requests, and responds with comprehensive MethASM feature demonstrations.
//
// Endpoints:
//   GET /           -> Enhanced homepage with feature showcase
//   GET /health     -> plain text "OK" (health check)
//   GET /demo       -> Interactive code demonstrations
//   GET /demo?feature={name} -> Specific feature demonstration
//   GET /benchmarks -> Performance benchmarks and comparisons
//   GET /docs       -> Documentation and tutorials
//   GET /forum      -> Forum index (thread list, new thread form)
//   GET /forum?thread=N -> Thread view (posts, reply form); 404 if invalid N
//   POST /forum     -> Create thread (form: title=...) -> 302 to new thread
//   POST /forum?thread=N -> Add post (form: body=...) -> 302 to thread
//   other           -> 404 Not Found
//
// Storage: threads.txt (one title per line), posts_N.txt (one post per line)
//
// Build: see web/build.bat
// Run: server.exe, then open http://localhost:5000
//
// All strings are global to avoid compiler codegen ordering with literals in bodies.

import "std/io";
import "std/net";
import "std/conv";

extern function gc_init() = "gc_init";

// Use Windows API for console output â€” CRT stdout is uninitialized with -nostartfiles
extern function AllocConsole() -> int32 = "AllocConsole";
extern function GetStdHandle(which: int32) -> int64 = "GetStdHandle";
extern function WriteFile(h: int64, buf: cstring, len: int32, written: cstring, overlapped: cstring) -> int32 = "WriteFile";

import "router";
import "form_parser";

// Enhanced homepage content loaded at compile time
var PAGE_CONTENT: string = import_str "index.html";

// Demo page content
var DEMO_CONTENT: string = import_str "demo.html";
var BENCHMARKS_CONTENT: string = import_str "benchmarks.html";
var DOCS_CONTENT: string = import_str "docs.html";

// Root page response header with modern features
// We intentionally omit Content-Length and close the connection after body.
// This avoids dynamic header assembly and remains valid HTTP/1.1.
var HTTP_PAGE_HEADER: string = "HTTP/1.1 200 OK\r\nContent-Type: text/html; charset=utf-8\r\nCache-Control: no-cache\r\nConnection: close\r\n\r\n";

// Demo page header
var HTTP_DEMO_HEADER: string = "HTTP/1.1 200 OK\r\nContent-Type: text/html; charset=utf-8\r\nCache-Control: no-cache\r\nConnection: close\r\n\r\n";

// Benchmarks page header
var HTTP_BENCHMARKS_HEADER: string = "HTTP/1.1 200 OK\r\nContent-Type: text/html; charset=utf-8\r\nCache-Control: max-age=300\r\nConnection: close\r\n\r\n";

// Docs page header
var HTTP_DOCS_HEADER: string = "HTTP/1.1 200 OK\r\nContent-Type: text/html; charset=utf-8\r\nCache-Control: max-age=600\r\nConnection: close\r\n\r\n";

// Other HTTP responses (fixed content)

var HTTP_404_HEADER: string = "HTTP/1.1 404 Not Found\r\nContent-Length: 9\r\n\r\n";
var HTTP_404_BODY: string = "Not Found";

var HTTP_HEALTH_HEADER: string = "HTTP/1.1 200 OK\r\nContent-Type: text/plain\r\nContent-Length: 2\r\n\r\n";
var HTTP_HEALTH_BODY: string = "OK";

// Forum HTML chunks (Connection: close, no Content-Length)
var FORUM_HEADER: string = "HTTP/1.1 200 OK\r\nContent-Type: text/html; charset=utf-8\r\nConnection: close\r\n\r\n";
var FORUM_CSS: string = import_str "templates/forum.css";
var FORUM_INDEX_START: string = "<!DOCTYPE html><html lang='en'><head><meta charset='UTF-8'><meta name='viewport' content='width=device-width,initial-scale=1'><title>Community Forum</title><link href='https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap' rel='stylesheet'>";
var FORUM_INDEX_BODY: string = "</head><body><div class='container'><h1>Community Forum</h1><a href='/' class='back'>Back to Website</a><h2>Threads</h2><ul>";
var FORUM_INDEX_END: string = "</ul><h2>Start a Discussion</h2>";
var FORUM_FORM: string = "<form method='POST' action='/forum'><input name='title' placeholder='Thread title...' required maxlength='200'><button type='submit'>Create Thread</button></form></div></body></html>";
var FORUM_THREAD_START: string = "<!DOCTYPE html><html lang='en'><head><meta charset='UTF-8'><meta name='viewport' content='width=device-width,initial-scale=1'><title>Discussion Thread</title><link href='https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap' rel='stylesheet'>";
var FORUM_THREAD_HEAD_END: string = "</head><body><div class='container'><h1>";
var FORUM_THREAD_MID: string = "</h1><a href='/forum' class='back'>Back to Forum</a><h2>Replies</h2>";
var FORUM_THREAD_END: string = "<h2>Post a Reply</h2><form method='POST' action='/forum?thread=";
var FORUM_THREAD_END2: string = "'><textarea name='body' placeholder='Write your reply here...' required></textarea><button type='submit'>Post Reply</button></form></div></body></html>";
var FORUM_NO_POSTS: string = "<p class='empty'>No posts yet. Be the first to reply!</p>";
var FORUM_ERR_EMPTY: string = "<p class='err'>Thread title cannot be empty.</p>";
var FORUM_LI_OPEN: string = "<li><a href='/forum?thread=";
var FORUM_LI_MID: string = "'>";
var FORUM_LI_CLOSE: string = "</a></li>";
var FORUM_POST_OPEN: string = "<div class='post'>";
var FORUM_POST_CLOSE: string = "</div>";
var REDIRECT_302: string = "HTTP/1.1 302 Found\r\nLocation: ";
var REDIRECT_END: string = "\r\n\r\n";
var fn_threads: string = "threads.txt";
var fn_posts_prefix: string = "posts_";
var fn_posts_suffix: string = ".txt";
var mode_r: string = "r";
var mode_a: string = "a";
var nl: string = "\n";
var key_title: string = "title";
var key_body: string = "body";
var hdr_content_length: string = "Content-Length:";
var hdr_content_length_lo: string = "content-length:";
var pat_crlf2: string = "\r\n\r\n";
var pat_lf2: string = "\n\n";
var html_amp: string = "&amp;";
var html_lt: string = "&lt;";
var html_gt: string = "&gt;";
var html_quot: string = "&quot;";
var html_apos: string = "&#39;";

// Debug (set to 1 to enable)
var dbg_on: int32 = 0;
var dbg_post: string = "[POST] ";
var dbg_bs: string = " body_start=";
var dbg_bl: string = " body_len=";
var dbg_cl: string = " content_len=";
var dbg_need: string = " need=";
var dbg_n: string = " n=";
var dbg_got: string = " got=";
var dbg_title: string = " title_len=";
var dbg_fopen_ok: string = " fopen_ok";
var dbg_fopen_fail: string = " fopen_fail";
var dbg_newline: string = "\n";
var dbg_fbs_enter: string = "[fbs] enter n=";
var dbg_fbs_exit: string = "[fbs] exit ret=";
var dbg_fbs_ok: string = "[fbs] ok";
var dbg_loop: string = "[fbs] loop i=";

function dbg(label: cstring, val: int64) {
  if (dbg_on == 0) { return; }
  print(label);
  print_int(val);
  putchar(10);
  fflush(get_stdout());
}

function dbg_msg(msg: cstring) {
  if (dbg_on == 0) { return; }
  println(msg);
  fflush(get_stdout());
}

// Build Content-Length decimal string in buf, return digit count
function int_to_dec(buf: cstring, n: int64) -> int32 {
  var digits: int32[20];
  var count: int32 = 0;
  if (n == 0) {
    buf[0] = 48;
    return 1;
  }
  while (n > 0) {
    var d: int64 = n - (n / 10) * 10;
    digits[count] = d;
    count = count + 1;
    n = n / 10;
  }
  var i: int32 = count - 1;
  while (i >= 0) {
    buf[count - 1 - i] = digit_to_char(digits[i]);
    i = i - 1;
  }
  return count;
}

// Error messages (globals so no string literals in function bodies)
var err_net_init: string = "net_init failed";
var err_socket: string = "socket failed";
var err_reuseaddr: string = "setsockopt failed";
var err_sockaddr: string = "sockaddr failed";
var err_bind: string = "bind failed";
var err_listen: string = "listen failed";
var msg_ready: string = "Server: http://localhost:5000";
var crlf: string = "\r\n";

// Write string + newline via WriteFile to stdout (works with -nostartfiles)
function con_writeln(s: string) {
  var h: int64 = GetStdHandle(-11);
  if (h != -1 && h != 0) {
    var written: uint8[4];
    WriteFile(h, s.chars, s.length, &written[0], 0);
    WriteFile(h, crlf.chars, 2, &written[0], 0);
  }
}

// Parse Content-Length header. Returns value or 0 if not found. Case-insensitive. "Content-Length:" = 15 chars.
function parse_content_length(buf: cstring, n: int32) -> int32 {
  var i: int32 = 0;
  while (i + 15 <= n) {
    var match: int32 = 1;
    var k: int32 = 0;
    while (k < 15) {
      var b: int32 = buf[i + k];
      var h: int32 = hdr_content_length.chars[k];
      var lo: int32 = hdr_content_length_lo.chars[k];
      if (b != h && b != lo) { match = 0; break; }
      k = k + 1;
    }
    if (match == 1) {
      i = i + 15;
      while (i < n && (buf[i] == 32 || buf[i] == 9)) {
        i = i + 1;
      }
      var val: int32 = 0;
      while (i < n && buf[i] >= 48 && buf[i] <= 57) {
        val = val * 10 + (buf[i] - 48);
        i = i + 1;
      }
      return val;
    }
    i = i + 1;
  }
  return 0;
}

// Find start of HTTP body (after \r\n\r\n or \n\n). Returns offset or n if not found.
// Uses memcmp to avoid potential codegen issues with manual byte loop.
function find_body_start(buf: cstring, n: int32) -> int32 {
  if (dbg_on != 0) { dbg_msg(cstr(dbg_fbs_ok)); }
  if (dbg_on != 0) { dbg(cstr(dbg_fbs_enter), n); }
  var i: int32 = 0;
  while (i + 4 <= n) {
    if (memcmp(&buf[i], cstr(pat_crlf2), 4) == 0) {
      if (dbg_on != 0) { dbg(cstr(dbg_fbs_exit), i + 4); }
      return i + 4;
    }
    i = i + 1;
  }
  i = 0;
  while (i + 2 <= n) {
    if (memcmp(&buf[i], cstr(pat_lf2), 2) == 0) {
      if (dbg_on != 0) { dbg(cstr(dbg_fbs_exit), i + 2); }
      return i + 2;
    }
    i = i + 1;
  }
  if (dbg_on != 0) { dbg(cstr(dbg_fbs_exit), n); }
  return n;
}



// Write HTML-escaped text to client.
function send_html_escaped(client: int64, src: cstring, len: int32) {
  var i: int32 = 0;
  while (i < len) {
    var ch: int32 = src[i];
    if (ch == 38) {
      send_all(client, html_amp.chars, html_amp.length);
    } else if (ch == 60) {
      send_all(client, html_lt.chars, html_lt.length);
    } else if (ch == 62) {
      send_all(client, html_gt.chars, html_gt.length);
    } else if (ch == 34) {
      send_all(client, html_quot.chars, html_quot.length);
    } else if (ch == 39) {
      send_all(client, html_apos.chars, html_apos.length);
    } else {
      send_all(client, &src[i], 1);
    }
    i = i + 1;
  }
}

// Build "posts_N.txt" in buf, null-terminate. buf must be at least 32 bytes.
function build_posts_filename(buf: cstring, id: int32) {
  memcpy(buf, fn_posts_prefix.chars, fn_posts_prefix.length);
  var dc: int32 = int_to_dec(&buf[fn_posts_prefix.length], id);
  memcpy(&buf[fn_posts_prefix.length + dc], fn_posts_suffix.chars, fn_posts_suffix.length);
  buf[fn_posts_prefix.length + dc + fn_posts_suffix.length] = 0;
}

// Build "/forum?thread=N" in buf (null-terminated). buf must be at least 32 bytes.
function build_forum_thread_url(buf: cstring, thread_id: int32) {
  buf[0] = 47;
  buf[1] = 102;
  buf[2] = 111;
  buf[3] = 114;
  buf[4] = 117;
  buf[5] = 109;
  buf[6] = 63;
  buf[7] = 116;
  buf[8] = 104;
  buf[9] = 114;
  buf[10] = 101;
  buf[11] = 97;
  buf[12] = 100;
  buf[13] = 61;
  var dc: int32 = int_to_dec(&buf[14], thread_id);
  buf[14 + dc] = 0;
}

// Count lines in threads.txt. Returns 0 if file missing or empty.
function count_threads() -> int32 {
  var fp: cstring = fopen(cstr(fn_threads), cstr(mode_r));
  if (fp == 0) { return 0; }
  var count: int32 = 0;
  var line_buf: uint8[64];
  while (fgets(&line_buf[0], 64, fp) != 0) {
    count = count + 1;
  }
  fclose(fp);
  return count;
}

// Send 302 redirect to location. location must be null-terminated.
function send_redirect(client: int64, location: cstring) {
  send_all(client, REDIRECT_302.chars, REDIRECT_302.length);
  var len: int32 = 0;
  while (location[len] != 0) { len = len + 1; }
  send_all(client, location, len);
  send_all(client, REDIRECT_END.chars, REDIRECT_END.length);
}

// Serve forum index: thread list + new thread form. show_err_empty=1 to show empty-title error.
function serve_forum_index(client: int64, show_err_empty: int32) {
  var out: string = FORUM_HEADER + FORUM_INDEX_START + FORUM_CSS + FORUM_INDEX_BODY;
  send_all(client, out.chars, out.length);

  var fp: cstring = fopen(cstr(fn_threads), cstr(mode_r));
  if (fp != 0) {
    var line_buf: uint8[512];
    var line_num: int32 = 1;
    while (fgets(&line_buf[0], 512, fp) != 0) {
      var len: int32 = 0;
      while (line_buf[len] != 0 && line_buf[len] != 10 && line_buf[len] != 13) {
        len = len + 1;
      }
      if (len > 0) {
        var item_buf: uint8[600];
        memcpy(&item_buf[0], FORUM_LI_OPEN.chars, FORUM_LI_OPEN.length);
        var dc: int32 = int_to_dec(&item_buf[FORUM_LI_OPEN.length], line_num);
        memcpy(&item_buf[FORUM_LI_OPEN.length + dc], FORUM_LI_MID.chars, FORUM_LI_MID.length);
        var mid: int32 = FORUM_LI_OPEN.length + dc + FORUM_LI_MID.length;
        var copy_len: int32 = len;
        if (copy_len > 200) { copy_len = 200; }
        send_all(client, &item_buf[0], mid);
        send_html_escaped(client, &line_buf[0], copy_len);
        send_all(client, FORUM_LI_CLOSE.chars, FORUM_LI_CLOSE.length);
      }
      line_num = line_num + 1;
    }
    fclose(fp);
  }

  send_all(client, FORUM_INDEX_END.chars, FORUM_INDEX_END.length);
  if (show_err_empty != 0) {
    send_all(client, FORUM_ERR_EMPTY.chars, FORUM_ERR_EMPTY.length);
  }
  send_all(client, FORUM_FORM.chars, FORUM_FORM.length);
}

// Serve thread view: title, posts, reply form
function serve_forum_thread(client: int64, thread_id: int32) {
  var out: string = FORUM_HEADER + FORUM_THREAD_START + FORUM_CSS + FORUM_THREAD_HEAD_END;
  send_all(client, out.chars, out.length);

  var title_buf: uint8[256];
  title_buf[0] = 85;
  title_buf[1] = 110;
  title_buf[2] = 107;
  title_buf[3] = 110;
  title_buf[4] = 111;
  title_buf[5] = 119;
  title_buf[6] = 110;
  title_buf[7] = 0;

  var fp: cstring = fopen(cstr(fn_threads), cstr(mode_r));
  if (fp != 0) {
    var line_buf: uint8[512];
    var line_num: int32 = 1;
    while (fgets(&line_buf[0], 512, fp) != 0) {
      if (line_num == thread_id) {
        var len: int32 = 0;
        while (line_buf[len] != 0 && line_buf[len] != 10 && line_buf[len] != 13) {
          if (len < 255) {
            title_buf[len] = line_buf[len];
          }
          len = len + 1;
        }
        if (len < 256) {
          title_buf[len] = 0;
        } else {
          title_buf[255] = 0;
        }
        break;
      }
      line_num = line_num + 1;
    }
    fclose(fp);
  }

  var title_len: int32 = 0;
  while (title_buf[title_len] != 0) {
    title_len = title_len + 1;
  }
  send_html_escaped(client, &title_buf[0], title_len);
  send_all(client, FORUM_THREAD_MID.chars, FORUM_THREAD_MID.length);

  var posts_fn: uint8[32];
  build_posts_filename(&posts_fn[0], thread_id);
  var had_posts: int32 = 0;
  fp = fopen(&posts_fn[0], cstr(mode_r));
  if (fp != 0) {
    var line_buf: uint8[2048];
    while (fgets(&line_buf[0], 2048, fp) != 0) {
      var len: int32 = 0;
      while (line_buf[len] != 0 && line_buf[len] != 10 && line_buf[len] != 13) {
        len = len + 1;
      }
      if (len > 0) {
        had_posts = 1;
        send_all(client, FORUM_POST_OPEN.chars, FORUM_POST_OPEN.length);
        send_html_escaped(client, &line_buf[0], len);
        send_all(client, FORUM_POST_CLOSE.chars, FORUM_POST_CLOSE.length);
      }
    }
    fclose(fp);
  }
  if (had_posts == 0) {
    send_all(client, FORUM_NO_POSTS.chars, FORUM_NO_POSTS.length);
  }

  send_all(client, FORUM_THREAD_END.chars, FORUM_THREAD_END.length);
  var id_buf: uint8[16];
  var dc: int32 = int_to_dec(&id_buf[0], thread_id);
  send_all(client, &id_buf[0], dc);
  send_all(client, FORUM_THREAD_END2.chars, FORUM_THREAD_END2.length);
}

// Handle POST /forum (new thread): append title to threads.txt
function handle_post_new_thread(client: int64, buf: cstring, n: int32) {
  var body_start: int32 = find_body_start(buf, n);
  var body_len: int32 = n - body_start;
  if (dbg_on != 0) {
    dbg(cstr(dbg_bs), body_start);
    dbg(cstr(dbg_bl), body_len);
  }
  var title_buf: uint8[256];
  var got: int32 = extract_form_value(buf, body_start, body_len, cstr(key_title), 5, &title_buf[0], 256);
  if (dbg_on != 0) { dbg(cstr(dbg_title), got); }
  if (got > 0) {
    var count: int32 = count_threads();
    var fp: cstring = fopen(cstr(fn_threads), cstr(mode_a));
    if (dbg_on != 0) {
      if (fp != 0) { dbg_msg(cstr(dbg_fopen_ok)); } else { dbg_msg(cstr(dbg_fopen_fail)); }
    }
    if (fp != 0) {
      fputs(&title_buf[0], fp);
      fputs(cstr(nl), fp);
      fclose(fp);
      var new_id: int32 = count + 1;
      var loc_buf: uint8[32];
      build_forum_thread_url(&loc_buf[0], new_id);
      send_redirect(client, &loc_buf[0]);
      return;
    }
  }
  serve_forum_index(client, got == 0);
}

// Handle POST /forum?thread=N (reply): append body to posts_N.txt
function handle_post_reply(client: int64, buf: cstring, n: int32, thread_id: int32) {
  var body_start: int32 = find_body_start(buf, n);
  var body_len: int32 = n - body_start;
  if (dbg_on != 0) {
    dbg(cstr(dbg_bs), body_start);
    dbg(cstr(dbg_bl), body_len);
  }
  var post_buf: uint8[2048];
  var got: int32 = extract_form_value(buf, body_start, body_len, cstr(key_body), 4, &post_buf[0], 2048);
  if (dbg_on != 0) { dbg(cstr(dbg_title), got); }
  if (got > 0) {
    var posts_fn: uint8[32];
    build_posts_filename(&posts_fn[0], thread_id);
    var fp: cstring = fopen(&posts_fn[0], cstr(mode_a));
    if (dbg_on != 0) {
      if (fp != 0) { dbg_msg(cstr(dbg_fopen_ok)); } else { dbg_msg(cstr(dbg_fopen_fail)); }
    }
    if (fp != 0) {
      fputs(&post_buf[0], fp);
      fputs(cstr(nl), fp);
      fclose(fp);
    }
  }
  var loc_buf: uint8[32];
  build_forum_thread_url(&loc_buf[0], thread_id);
  send_redirect(client, &loc_buf[0]);
}

function main() -> int32 {
  gc_init();
  var out_handle: int64 = GetStdHandle(-11);
  if (out_handle == 0 || out_handle == -1) {
    AllocConsole();
  }
  if (net_init() != 0) {
    con_writeln(err_net_init);
    return 1;
  }

  var sock: int64 = socket_tcp();
  if (sock == INVALID_SOCKET()) {
    con_writeln(err_socket);
    net_cleanup();
    return 1;
  }

  if (set_reuseaddr(sock, 1) != 0) {
    con_writeln(err_reuseaddr);
    closesocket(sock);
    net_cleanup();
    return 1;
  }

  var addr: cstring = sockaddr_in_any(5000);
  if (addr == 0) {
    con_writeln(err_sockaddr);
    closesocket(sock);
    net_cleanup();
    return 1;
  }

  if (bind(sock, addr, 16) != 0) {
    con_writeln(err_bind);
    free(addr);
    closesocket(sock);
    net_cleanup();
    return 1;
  }
  free(addr);

  if (listen(sock, 5) != 0) {
    con_writeln(err_listen);
    closesocket(sock);
    net_cleanup();
    return 1;
  }

  con_writeln(msg_ready);

  var client_addr: uint8[16];
  var addrlen_buf: uint8[4];
  addrlen_buf[0] = 16;
  addrlen_buf[1] = 0;
  addrlen_buf[2] = 0;
  addrlen_buf[3] = 0;
  var recv_buf: uint8[4096];

  while (1) {
    addrlen_buf[0] = 16;
    addrlen_buf[1] = 0;
    addrlen_buf[2] = 0;
    addrlen_buf[3] = 0;
    var client: int64 = accept(sock, &client_addr[0], &addrlen_buf[0]);
    if (client == INVALID_SOCKET()) {
      continue;
    }
    
    defer closesocket(client);
    defer shutdown(client, SD_BOTH());

    var n: int32 = recv(client, &recv_buf[0], 4096, 0);
    if (n > 0) {
      if (is_post(&recv_buf[0], n) == 1) {
        var body_start: int32 = find_body_start(&recv_buf[0], n);
        if (dbg_on != 0) { dbg(cstr(dbg_post), n); }
        if (dbg_on != 0) { dbg(cstr(dbg_bs), body_start); }
        var content_len: int32 = parse_content_length(&recv_buf[0], body_start);
        if (dbg_on != 0) { dbg(cstr(dbg_cl), content_len); }
        var need: int32 = body_start + content_len;
        if (dbg_on != 0) { dbg(cstr(dbg_need), need); }
        if (content_len > 0 && need <= 4096 && n < need) {
          while (n < need) {
            var got: int32 = recv(client, &recv_buf[n], need - n, 0);
            if (dbg_on != 0) { dbg(cstr(dbg_got), got); }
            if (got <= 0) { break; }
            n = n + got;
          }
        }
        if (dbg_on != 0) { dbg(cstr(dbg_n), n); }
      }
      if (n > 0) {
      if (is_get(&recv_buf[0], n) == 1) {
        if (is_health(&recv_buf[0], n) == 1) {
          send_all(client, HTTP_HEALTH_HEADER.chars, HTTP_HEALTH_HEADER.length);
          send_all(client, HTTP_HEALTH_BODY.chars, 2);
        } else if (is_root(&recv_buf[0], n) == 1) {
          if (send_all(client, HTTP_PAGE_HEADER.chars, HTTP_PAGE_HEADER.length) == HTTP_PAGE_HEADER.length) {
            send_all(client, PAGE_CONTENT.chars, PAGE_CONTENT.length);
          }
        } else if (is_demo(&recv_buf[0], n) == 1) {
          if (send_all(client, HTTP_DEMO_HEADER.chars, HTTP_DEMO_HEADER.length) == HTTP_DEMO_HEADER.length) {
            send_all(client, DEMO_CONTENT.chars, DEMO_CONTENT.length);
          }
        } else if (is_benchmarks(&recv_buf[0], n) == 1) {
          if (send_all(client, HTTP_BENCHMARKS_HEADER.chars, HTTP_BENCHMARKS_HEADER.length) == HTTP_BENCHMARKS_HEADER.length) {
            send_all(client, BENCHMARKS_CONTENT.chars, BENCHMARKS_CONTENT.length);
          }
        } else if (is_docs(&recv_buf[0], n) == 1) {
          if (send_all(client, HTTP_DOCS_HEADER.chars, HTTP_DOCS_HEADER.length) == HTTP_DOCS_HEADER.length) {
            send_all(client, DOCS_CONTENT.chars, DOCS_CONTENT.length);
          }
        } else if (is_forum(&recv_buf[0], n, 4) == 1) {
          var tid: int32 = get_thread_id(&recv_buf[0], n, 4);
          if (tid > 0) {
            var max_tid: int32 = count_threads();
            if (tid <= max_tid) {
              serve_forum_thread(client, tid);
            } else {
              send_all(client, HTTP_404_HEADER.chars, HTTP_404_HEADER.length);
              send_all(client, HTTP_404_BODY.chars, 9);
            }
          } else {
            serve_forum_index(client, 0);
          }
        } else {
          send_all(client, HTTP_404_HEADER.chars, HTTP_404_HEADER.length);
          send_all(client, HTTP_404_BODY.chars, 9);
        }
      } else if (is_post(&recv_buf[0], n) == 1) {
        if (is_forum(&recv_buf[0], n, 5) == 1) {
          var tid: int32 = get_thread_id(&recv_buf[0], n, 5);
          if (tid > 0) {
            var max_tid: int32 = count_threads();
            if (tid <= max_tid) {
              handle_post_reply(client, &recv_buf[0], n, tid);
            } else {
              send_all(client, HTTP_404_HEADER.chars, HTTP_404_HEADER.length);
              send_all(client, HTTP_404_BODY.chars, 9);
            }
          } else {
            handle_post_new_thread(client, &recv_buf[0], n);
          }
        } else {
          send_all(client, HTTP_404_HEADER.chars, HTTP_404_HEADER.length);
          send_all(client, HTTP_404_BODY.chars, 9);
        }
      } else {
        send_all(client, HTTP_404_HEADER.chars, HTTP_404_HEADER.length);
        send_all(client, HTTP_404_BODY.chars, 9);
      }
      }
    }
  }

  closesocket(sock);
  net_cleanup();
  return 0;
}
