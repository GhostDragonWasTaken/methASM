; Generated by MethASM
; x86-64 Assembly Output

section .text
; Code section

; First pass: processing 9 declarations
; Declaration 0 type: 3 (AST_INLINE_ASM = 16)
; Declaration 1 type: 3 (AST_INLINE_ASM = 16)
; Declaration 2 type: 3 (AST_INLINE_ASM = 16)
; Declaration 3 type: 3 (AST_INLINE_ASM = 16)
; Declaration 4 type: 3 (AST_INLINE_ASM = 16)
; Declaration 5 type: 3 (AST_INLINE_ASM = 16)
; Declaration 6 type: 3 (AST_INLINE_ASM = 16)
; Declaration 7 type: 4 (AST_INLINE_ASM = 16)
; Declaration 8 type: 3 (AST_INLINE_ASM = 16)
    extern WSAStartup
    extern WSACleanup
    extern socket
    extern bind
    extern listen
    extern closesocket
    extern htons
    ; Struct declaration: SockAddrIn
    ; Struct SockAddrIn: size=16, alignment=4

global main

main:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 1152    ; Allocate 1152 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_0:
    mov rax, 0
    ; Store to variable: s
    mov qword [rbp - 440], rax  ; To stack [rbp - 440]
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 456], rax
    ; Load variable: wsa
    lea rax, [rbp - 416]  ; Local array base
    push rax
    mov rax, [rbp - 456]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 464], rax
    ; IR call: WSAStartup (2 args)
    sub rsp, 32
    mov rax, 514
    mov rcx, rax
    mov rax, [rbp - 464]
    mov rdx, rax
    call WSAStartup
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 472], rax
    mov rax, [rbp - 472]
    ; Store to variable: r
    mov dword [rbp - 444], eax  ; To stack [rbp - 444]
    ; Load variable: r
    mov eax, dword [rbp - 444]  ; From stack [rbp - 444]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 480], rax
    mov rax, [rbp - 480]
    test rax, rax
    jz ir_if_else_1
    mov rax, 1
    jmp Lmain_exit
    jmp ir_if_end_2
ir_if_else_1:
ir_if_end_2:
    ; IR call: socket (3 args)
    sub rsp, 32
    mov rax, 2
    mov rcx, rax
    mov rax, 1
    mov rdx, rax
    mov rax, 0
    mov r8, rax
    call socket
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    mov [rbp - 488], rax
    mov rax, [rbp - 488]
    ; Store to variable: s
    mov qword [rbp - 440], rax  ; To stack [rbp - 440]
    ; Load variable: s
    mov rax, qword [rbp - 440]  ; From stack [rbp - 440]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 496], rax
    mov rax, [rbp - 496]
    test rax, rax
    jz ir_if_else_3
    ; IR call: WSACleanup (0 args)
    sub rsp, 32
    call WSACleanup
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 504], rax
    mov rax, 2
    jmp Lmain_exit
    jmp ir_if_end_4
ir_if_else_3:
ir_if_end_4:
    lea rax, [rbp - 432]
    mov [rbp - 512], rax
    mov rax, [rbp - 512]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 520], rax
    mov rax, [rbp - 520]
    push rax
    mov rax, 2
    mov rcx, rax
    pop rax
    mov word [rax], cx
    ; IR call: htons (1 args)
    sub rsp, 32
    mov rax, 5000
    mov rcx, rax
    call htons
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    movzx eax, ax    ; Zero-extend 16-bit return value
    mov [rbp - 536], rax
    lea rax, [rbp - 432]
    mov [rbp - 544], rax
    mov rax, [rbp - 544]
    push rax
    mov rax, 2
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 552], rax
    mov rax, [rbp - 552]
    push rax
    mov rax, [rbp - 536]
    mov rcx, rax
    pop rax
    mov word [rax], cx
    lea rax, [rbp - 432]
    mov [rbp - 568], rax
    mov rax, [rbp - 568]
    push rax
    mov rax, 4
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 576], rax
    mov rax, [rbp - 576]
    push rax
    mov rax, 0
    mov rcx, rax
    pop rax
    mov dword [rax], ecx
    lea rax, [rbp - 432]
    mov [rbp - 592], rax
    ; IR call: bind (3 args)
    sub rsp, 32
    ; Load variable: s
    mov rax, qword [rbp - 440]  ; From stack [rbp - 440]
    mov rcx, rax
    mov rax, [rbp - 592]
    mov rdx, rax
    mov rax, 16
    mov r8, rax
    call bind
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 600], rax
    mov rax, [rbp - 600]
    ; Store to variable: r
    mov dword [rbp - 444], eax  ; To stack [rbp - 444]
    ; Load variable: r
    mov eax, dword [rbp - 444]  ; From stack [rbp - 444]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 608], rax
    mov rax, [rbp - 608]
    test rax, rax
    jz ir_if_else_5
    ; IR call: closesocket (1 args)
    sub rsp, 32
    ; Load variable: s
    mov rax, qword [rbp - 440]  ; From stack [rbp - 440]
    mov rcx, rax
    call closesocket
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 616], rax
    ; IR call: WSACleanup (0 args)
    sub rsp, 32
    call WSACleanup
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 624], rax
    mov rax, 3
    jmp Lmain_exit
    jmp ir_if_end_6
ir_if_else_5:
ir_if_end_6:
    ; IR call: listen (2 args)
    sub rsp, 32
    ; Load variable: s
    mov rax, qword [rbp - 440]  ; From stack [rbp - 440]
    mov rcx, rax
    mov rax, 5
    mov rdx, rax
    call listen
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 632], rax
    mov rax, [rbp - 632]
    ; Store to variable: r
    mov dword [rbp - 444], eax  ; To stack [rbp - 444]
    ; Load variable: r
    mov eax, dword [rbp - 444]  ; From stack [rbp - 444]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 640], rax
    mov rax, [rbp - 640]
    test rax, rax
    jz ir_if_else_7
    ; IR call: closesocket (1 args)
    sub rsp, 32
    ; Load variable: s
    mov rax, qword [rbp - 440]  ; From stack [rbp - 440]
    mov rcx, rax
    call closesocket
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 648], rax
    ; IR call: WSACleanup (0 args)
    sub rsp, 32
    call WSACleanup
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 656], rax
    mov rax, 4
    jmp Lmain_exit
    jmp ir_if_end_8
ir_if_else_7:
ir_if_end_8:
    ; IR call: closesocket (1 args)
    sub rsp, 32
    ; Load variable: s
    mov rax, qword [rbp - 440]  ; From stack [rbp - 440]
    mov rcx, rax
    call closesocket
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 664], rax
    ; IR call: WSACleanup (0 args)
    sub rsp, 32
    call WSACleanup
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 672], rax
    mov rax, 0
    jmp Lmain_exit
Lmain_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

; Default program entry point
global mainCRTStartup
mainCRTStartup:
    sub rsp, 40      ; Shadow space + alignment
    ; Initialize garbage collector runtime
    lea rcx, [rsp + 40]
    extern gc_init
    call gc_init
    ; Call user main function
    call main
    mov [rsp + 32], rax ; Preserve main return code
    extern gc_shutdown
    call gc_shutdown
    mov rcx, [rsp + 32] ; Use main return as exit code
    extern ExitProcess
    call ExitProcess
