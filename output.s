; Generated by MethASM
; x86-64 Assembly Output

section .text
; Code section

; First pass: processing 79 declarations
; Declaration 0 type: 3 (AST_INLINE_ASM = 17)
; Declaration 1 type: 3 (AST_INLINE_ASM = 17)
; Declaration 2 type: 3 (AST_INLINE_ASM = 17)
; Declaration 3 type: 3 (AST_INLINE_ASM = 17)
; Declaration 4 type: 3 (AST_INLINE_ASM = 17)
; Declaration 5 type: 3 (AST_INLINE_ASM = 17)
; Declaration 6 type: 3 (AST_INLINE_ASM = 17)
; Declaration 7 type: 3 (AST_INLINE_ASM = 17)
; Declaration 8 type: 3 (AST_INLINE_ASM = 17)
; Declaration 9 type: 3 (AST_INLINE_ASM = 17)
; Declaration 10 type: 3 (AST_INLINE_ASM = 17)
; Declaration 11 type: 3 (AST_INLINE_ASM = 17)
; Declaration 12 type: 3 (AST_INLINE_ASM = 17)
; Declaration 13 type: 3 (AST_INLINE_ASM = 17)
; Declaration 14 type: 3 (AST_INLINE_ASM = 17)
; Declaration 15 type: 3 (AST_INLINE_ASM = 17)
; Declaration 16 type: 3 (AST_INLINE_ASM = 17)
; Declaration 17 type: 3 (AST_INLINE_ASM = 17)
; Declaration 18 type: 3 (AST_INLINE_ASM = 17)
; Declaration 19 type: 3 (AST_INLINE_ASM = 17)
; Declaration 20 type: 3 (AST_INLINE_ASM = 17)
; Declaration 21 type: 3 (AST_INLINE_ASM = 17)
; Declaration 22 type: 3 (AST_INLINE_ASM = 17)
; Declaration 23 type: 3 (AST_INLINE_ASM = 17)
; Declaration 24 type: 3 (AST_INLINE_ASM = 17)
; Declaration 25 type: 3 (AST_INLINE_ASM = 17)
; Declaration 26 type: 3 (AST_INLINE_ASM = 17)
; Declaration 27 type: 3 (AST_INLINE_ASM = 17)
; Declaration 28 type: 3 (AST_INLINE_ASM = 17)
; Declaration 29 type: 3 (AST_INLINE_ASM = 17)
; Declaration 30 type: 3 (AST_INLINE_ASM = 17)
; Declaration 31 type: 3 (AST_INLINE_ASM = 17)
; Declaration 32 type: 3 (AST_INLINE_ASM = 17)
; Declaration 33 type: 3 (AST_INLINE_ASM = 17)
; Declaration 34 type: 3 (AST_INLINE_ASM = 17)
; Declaration 35 type: 3 (AST_INLINE_ASM = 17)
; Declaration 36 type: 3 (AST_INLINE_ASM = 17)
; Declaration 37 type: 3 (AST_INLINE_ASM = 17)
; Declaration 38 type: 3 (AST_INLINE_ASM = 17)
; Declaration 39 type: 3 (AST_INLINE_ASM = 17)
; Declaration 40 type: 3 (AST_INLINE_ASM = 17)
; Declaration 41 type: 3 (AST_INLINE_ASM = 17)
; Declaration 42 type: 3 (AST_INLINE_ASM = 17)
; Declaration 43 type: 3 (AST_INLINE_ASM = 17)
; Declaration 44 type: 3 (AST_INLINE_ASM = 17)
; Declaration 45 type: 3 (AST_INLINE_ASM = 17)
; Declaration 46 type: 3 (AST_INLINE_ASM = 17)
; Declaration 47 type: 3 (AST_INLINE_ASM = 17)
; Declaration 48 type: 3 (AST_INLINE_ASM = 17)
; Declaration 49 type: 3 (AST_INLINE_ASM = 17)
; Declaration 50 type: 3 (AST_INLINE_ASM = 17)
; Declaration 51 type: 3 (AST_INLINE_ASM = 17)
; Declaration 52 type: 3 (AST_INLINE_ASM = 17)
; Declaration 53 type: 3 (AST_INLINE_ASM = 17)
; Declaration 54 type: 3 (AST_INLINE_ASM = 17)
; Declaration 55 type: 3 (AST_INLINE_ASM = 17)
; Declaration 56 type: 3 (AST_INLINE_ASM = 17)
; Declaration 57 type: 3 (AST_INLINE_ASM = 17)
; Declaration 58 type: 3 (AST_INLINE_ASM = 17)
; Declaration 59 type: 3 (AST_INLINE_ASM = 17)
; Declaration 60 type: 3 (AST_INLINE_ASM = 17)
; Declaration 61 type: 3 (AST_INLINE_ASM = 17)
; Declaration 62 type: 3 (AST_INLINE_ASM = 17)
; Declaration 63 type: 3 (AST_INLINE_ASM = 17)
; Declaration 64 type: 3 (AST_INLINE_ASM = 17)
; Declaration 65 type: 3 (AST_INLINE_ASM = 17)
; Declaration 66 type: 3 (AST_INLINE_ASM = 17)
; Declaration 67 type: 3 (AST_INLINE_ASM = 17)
; Declaration 68 type: 3 (AST_INLINE_ASM = 17)
; Declaration 69 type: 3 (AST_INLINE_ASM = 17)
; Declaration 70 type: 3 (AST_INLINE_ASM = 17)
; Declaration 71 type: 3 (AST_INLINE_ASM = 17)
; Declaration 72 type: 3 (AST_INLINE_ASM = 17)
; Declaration 73 type: 3 (AST_INLINE_ASM = 17)
; Declaration 74 type: 3 (AST_INLINE_ASM = 17)
; Declaration 75 type: 3 (AST_INLINE_ASM = 17)
; Declaration 76 type: 3 (AST_INLINE_ASM = 17)
; Declaration 77 type: 5 (AST_INLINE_ASM = 17)
; Declaration 78 type: 3 (AST_INLINE_ASM = 17)

section .text
    extern puts
    extern putchar
    extern getchar

global cstr

cstr:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 80    ; Allocate 80 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 's'
    ; Parameter 's' arrived in register rcx
ir_entry_0:
    lea rax, [rbp - 8]
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    mov rax, qword [rax]
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    jmp Lcstr_exit
Lcstr_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global print

print:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 240    ; Allocate 240 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'msg'
    ; Parameter 'msg' arrived in register rcx
ir_entry_1:
    mov rax, 0
    ; Store to variable: i
    mov qword [rbp - 16], rax  ; To stack [rbp - 16]
ir_while_2:
    ; Load variable: i
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 24], rax
    ; Load variable: msg
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 24]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    movzx rax, byte [rax]
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_while_end_3
    ; Load variable: i
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 56], rax
    ; Load variable: msg
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 56]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    movzx rax, byte [rax]
    mov [rbp - 72], rax
    ; IR call: putchar (1 args)
    sub rsp, 32
    mov rax, [rbp - 72]
    mov rcx, rax
    call putchar
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 80], rax
    ; Load variable: i
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    ; Store to variable: i
    mov qword [rbp - 16], rax  ; To stack [rbp - 16]
    jmp ir_while_2
ir_while_end_3:
Lprint_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global println

println:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 32    ; Allocate 32 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'msg'
    ; Parameter 'msg' arrived in register rcx
ir_entry_4:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; Load variable: msg
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call puts
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 16], rax
Lprintln_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global newline

newline:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 32    ; Allocate 32 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_5:
    ; IR call: putchar (1 args)
    sub rsp, 32
    mov rax, 10
    mov rcx, rax
    call putchar
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 8], rax
Lnewline_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global print_int

print_int:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 656    ; Allocate 656 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'n'
    ; Parameter 'n' arrived in register rcx
ir_entry_6:
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 104], rax
    mov rax, [rbp - 104]
    test rax, rax
    jz ir_if_else_7
    ; IR call: putchar (1 args)
    sub rsp, 32
    mov rax, 45
    mov rcx, rax
    call putchar
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 112], rax
    mov rax, 0
    push rax
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 120], rax
    mov rax, [rbp - 120]
    ; Store to variable: n
    mov qword [rbp - 8], rax  ; To stack [rbp - 8]
    jmp ir_if_end_8
ir_if_else_7:
ir_if_end_8:
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 128], rax
    mov rax, [rbp - 128]
    test rax, rax
    jz ir_if_else_9
    ; IR call: putchar (1 args)
    sub rsp, 32
    mov rax, 48
    mov rcx, rax
    call putchar
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 136], rax
    jmp Lprint_int_exit
    jmp ir_if_end_10
ir_if_else_9:
ir_if_end_10:
    mov rax, 0
    ; Store to variable: len
    mov dword [rbp - 92], eax  ; To stack [rbp - 92]
ir_while_11:
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setg al
    movzx rax, al
    mov [rbp - 144], rax
    mov rax, [rbp - 144]
    test rax, rax
    jz ir_while_end_12
    mov rax, 48
    push rax
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 152], rax
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 10
    mov r10, rax
    pop rax
    cqo
    idiv r10
    mov [rbp - 160], rax
    mov rax, [rbp - 160]
    push rax
    mov rax, 10
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 168], rax
    mov rax, [rbp - 152]
    push rax
    mov rax, [rbp - 168]
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 176], rax
    ; Load variable: len
    mov eax, dword [rbp - 92]  ; From stack [rbp - 92]
    push rax
    mov rax, 4
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 184], rax
    ; Load variable: buf
    lea rax, [rbp - 88]  ; Local array base
    push rax
    mov rax, [rbp - 184]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 192], rax
    mov rax, [rbp - 192]
    push rax
    mov rax, [rbp - 176]
    mov rcx, rax
    pop rax
    mov dword [rax], ecx
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 10
    mov r10, rax
    pop rax
    cqo
    idiv r10
    mov [rbp - 208], rax
    mov rax, [rbp - 208]
    ; Store to variable: n
    mov qword [rbp - 8], rax  ; To stack [rbp - 8]
    ; Load variable: len
    mov eax, dword [rbp - 92]  ; From stack [rbp - 92]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 216], rax
    mov rax, [rbp - 216]
    ; Store to variable: len
    mov dword [rbp - 92], eax  ; To stack [rbp - 92]
    jmp ir_while_11
ir_while_end_12:
    ; Load variable: len
    mov eax, dword [rbp - 92]  ; From stack [rbp - 92]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 224], rax
    mov rax, [rbp - 224]
    ; Store to variable: i
    mov dword [rbp - 96], eax  ; To stack [rbp - 96]
ir_while_13:
    ; Load variable: i
    mov eax, dword [rbp - 96]  ; From stack [rbp - 96]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 232], rax
    mov rax, [rbp - 232]
    test rax, rax
    jz ir_while_end_14
    ; Load variable: i
    mov eax, dword [rbp - 96]  ; From stack [rbp - 96]
    push rax
    mov rax, 4
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 240], rax
    ; Load variable: buf
    lea rax, [rbp - 88]  ; Local array base
    push rax
    mov rax, [rbp - 240]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 248], rax
    mov rax, [rbp - 248]
    mov eax, dword [rax]
    mov [rbp - 256], rax
    ; IR call: putchar (1 args)
    sub rsp, 32
    mov rax, [rbp - 256]
    mov rcx, rax
    call putchar
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 264], rax
    ; Load variable: i
    mov eax, dword [rbp - 96]  ; From stack [rbp - 96]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 272], rax
    mov rax, [rbp - 272]
    ; Store to variable: i
    mov dword [rbp - 96], eax  ; To stack [rbp - 96]
    jmp ir_while_13
ir_while_end_14:
Lprint_int_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global println_int

println_int:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 64    ; Allocate 64 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'n'
    ; Parameter 'n' arrived in register rcx
ir_entry_15:
    ; IR call: print_int (1 args)
    sub rsp, 32
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call print_int
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Void return - no value to handle
    mov [rbp - 16], rax
    ; IR call: putchar (1 args)
    sub rsp, 32
    mov rax, 10
    mov rcx, rax
    call putchar
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 24], rax
Lprintln_int_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller
    extern fopen
    extern fclose
    extern fread
    extern fwrite
    extern fputs
    extern fgets
    extern fflush
    extern __acrt_iob_func

global get_stdin

get_stdin:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 32    ; Allocate 32 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_16:
    ; IR call: __acrt_iob_func (1 args)
    sub rsp, 32
    mov rax, 0
    mov rcx, rax
    call __acrt_iob_func
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    mov [rbp - 8], rax
    mov rax, [rbp - 8]
    jmp Lget_stdin_exit
Lget_stdin_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global get_stdout

get_stdout:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 32    ; Allocate 32 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_17:
    ; IR call: __acrt_iob_func (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call __acrt_iob_func
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    mov [rbp - 8], rax
    mov rax, [rbp - 8]
    jmp Lget_stdout_exit
Lget_stdout_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global get_stderr

get_stderr:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 32    ; Allocate 32 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_18:
    ; IR call: __acrt_iob_func (1 args)
    sub rsp, 32
    mov rax, 2
    mov rcx, rax
    call __acrt_iob_func
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    mov [rbp - 8], rax
    mov rax, [rbp - 8]
    jmp Lget_stderr_exit
Lget_stderr_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller
    extern abs

global min

min:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 48    ; Allocate 48 bytes on stack (aligned)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 'a'
    ; Parameter 'a' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'b'
    ; Parameter 'b' arrived in register rdx
ir_entry_19:
    ; Load variable: a
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    ; Load variable: b
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_else_20
    ; Load variable: a
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    jmp Lmin_exit
    jmp ir_if_end_21
ir_if_else_20:
ir_if_end_21:
    ; Load variable: b
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    jmp Lmin_exit
Lmin_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global max

max:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 48    ; Allocate 48 bytes on stack (aligned)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 'a'
    ; Parameter 'a' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'b'
    ; Parameter 'b' arrived in register rdx
ir_entry_22:
    ; Load variable: a
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    ; Load variable: b
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov r10, rax
    pop rax
    cmp rax, r10
    setg al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_else_23
    ; Load variable: a
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    jmp Lmax_exit
    jmp ir_if_end_24
ir_if_else_23:
ir_if_end_24:
    ; Load variable: b
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    jmp Lmax_exit
Lmax_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global clamp

clamp:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 80    ; Allocate 80 bytes on stack (aligned)
    ; Registering 3 function parameters
    mov [rbp - 8], rcx  ; Home param 'value'
    ; Parameter 'value' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'lo'
    ; Parameter 'lo' arrived in register rdx
    mov [rbp - 24], r8  ; Home param 'hi'
    ; Parameter 'hi' arrived in register r8
ir_entry_25:
    ; Load variable: value
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    ; Load variable: lo
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_if_else_26
    ; Load variable: lo
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    jmp Lclamp_exit
    jmp ir_if_end_27
ir_if_else_26:
ir_if_end_27:
    ; Load variable: value
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    ; Load variable: hi
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov r10, rax
    pop rax
    cmp rax, r10
    setg al
    movzx rax, al
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_if_else_28
    ; Load variable: hi
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    jmp Lclamp_exit
    jmp ir_if_end_29
ir_if_else_28:
ir_if_end_29:
    ; Load variable: value
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    jmp Lclamp_exit
Lclamp_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller
    extern atoi
    extern atol

global digit_to_char

digit_to_char:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 32    ; Allocate 32 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'd'
    ; Parameter 'd' arrived in register rcx
ir_entry_30:
    ; Load variable: d
    mov eax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 48
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    jmp Ldigit_to_char_exit
Ldigit_to_char_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global char_to_digit

char_to_digit:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 32    ; Allocate 32 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_31:
    ; Load variable: c
    mov eax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 48
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    jmp Lchar_to_digit_exit
Lchar_to_digit_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global is_digit

is_digit:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 64    ; Allocate 64 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_32:
    ; Load variable: c
    mov eax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 48
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_if_else_33
    ; Load variable: c
    mov eax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 57
    mov r10, rax
    pop rax
    cmp rax, r10
    setle al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_else_35
    mov rax, 1
    jmp Lis_digit_exit
    jmp ir_if_end_36
ir_if_else_35:
ir_if_end_36:
    jmp ir_if_end_34
ir_if_else_33:
ir_if_end_34:
    mov rax, 0
    jmp Lis_digit_exit
Lis_digit_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global is_upper

is_upper:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 64    ; Allocate 64 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_37:
    ; Load variable: c
    mov eax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 65
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_if_else_38
    ; Load variable: c
    mov eax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 90
    mov r10, rax
    pop rax
    cmp rax, r10
    setle al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_else_40
    mov rax, 1
    jmp Lis_upper_exit
    jmp ir_if_end_41
ir_if_else_40:
ir_if_end_41:
    jmp ir_if_end_39
ir_if_else_38:
ir_if_end_39:
    mov rax, 0
    jmp Lis_upper_exit
Lis_upper_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global is_lower

is_lower:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 64    ; Allocate 64 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_42:
    ; Load variable: c
    mov eax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 97
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_if_else_43
    ; Load variable: c
    mov eax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 122
    mov r10, rax
    pop rax
    cmp rax, r10
    setle al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_else_45
    mov rax, 1
    jmp Lis_lower_exit
    jmp ir_if_end_46
ir_if_else_45:
ir_if_end_46:
    jmp ir_if_end_44
ir_if_else_43:
ir_if_end_44:
    mov rax, 0
    jmp Lis_lower_exit
Lis_lower_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global is_alpha

is_alpha:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 112    ; Allocate 112 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_47:
    ; IR call: is_upper (1 args)
    sub rsp, 32
    ; Load variable: c
    mov eax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call is_upper
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_else_48
    mov rax, 1
    jmp Lis_alpha_exit
    jmp ir_if_end_49
ir_if_else_48:
ir_if_end_49:
    ; IR call: is_lower (1 args)
    sub rsp, 32
    ; Load variable: c
    mov eax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call is_lower
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_if_else_50
    mov rax, 1
    jmp Lis_alpha_exit
    jmp ir_if_end_51
ir_if_else_50:
ir_if_end_51:
    mov rax, 0
    jmp Lis_alpha_exit
Lis_alpha_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global is_alnum

is_alnum:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 112    ; Allocate 112 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_52:
    ; IR call: is_alpha (1 args)
    sub rsp, 32
    ; Load variable: c
    mov eax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call is_alpha
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_else_53
    mov rax, 1
    jmp Lis_alnum_exit
    jmp ir_if_end_54
ir_if_else_53:
ir_if_end_54:
    ; IR call: is_digit (1 args)
    sub rsp, 32
    ; Load variable: c
    mov eax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call is_digit
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_if_else_55
    mov rax, 1
    jmp Lis_alnum_exit
    jmp ir_if_end_56
ir_if_else_55:
ir_if_end_56:
    mov rax, 0
    jmp Lis_alnum_exit
Lis_alnum_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global is_space

is_space:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 160    ; Allocate 160 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_57:
    ; Load variable: c
    mov eax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 32
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_if_else_58
    mov rax, 1
    jmp Lis_space_exit
    jmp ir_if_end_59
ir_if_else_58:
ir_if_end_59:
    ; Load variable: c
    mov eax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 9
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_else_60
    mov rax, 1
    jmp Lis_space_exit
    jmp ir_if_end_61
ir_if_else_60:
ir_if_end_61:
    ; Load variable: c
    mov eax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 10
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_if_else_62
    mov rax, 1
    jmp Lis_space_exit
    jmp ir_if_end_63
ir_if_else_62:
ir_if_end_63:
    ; Load variable: c
    mov eax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 13
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_if_else_64
    mov rax, 1
    jmp Lis_space_exit
    jmp ir_if_end_65
ir_if_else_64:
ir_if_end_65:
    ; Load variable: c
    mov eax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 12
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_if_else_66
    mov rax, 1
    jmp Lis_space_exit
    jmp ir_if_end_67
ir_if_else_66:
ir_if_end_67:
    ; Load variable: c
    mov eax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 11
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    test rax, rax
    jz ir_if_else_68
    mov rax, 1
    jmp Lis_space_exit
    jmp ir_if_end_69
ir_if_else_68:
ir_if_end_69:
    mov rax, 0
    jmp Lis_space_exit
Lis_space_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global to_lower

to_lower:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 80    ; Allocate 80 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_70:
    ; IR call: is_upper (1 args)
    sub rsp, 32
    ; Load variable: c
    mov eax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call is_upper
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_else_71
    ; Load variable: c
    mov eax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 32
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    jmp Lto_lower_exit
    jmp ir_if_end_72
ir_if_else_71:
ir_if_end_72:
    ; Load variable: c
    mov eax, dword [rbp - 8]  ; From stack [rbp - 8]
    jmp Lto_lower_exit
Lto_lower_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global to_upper

to_upper:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 80    ; Allocate 80 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_73:
    ; IR call: is_lower (1 args)
    sub rsp, 32
    ; Load variable: c
    mov eax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call is_lower
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_else_74
    ; Load variable: c
    mov eax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 32
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    jmp Lto_upper_exit
    jmp ir_if_end_75
ir_if_else_74:
ir_if_end_75:
    ; Load variable: c
    mov eax, dword [rbp - 8]  ; From stack [rbp - 8]
    jmp Lto_upper_exit
Lto_upper_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global strlen

strlen:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 160    ; Allocate 160 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 's'
    ; Parameter 's' arrived in register rcx
ir_entry_76:
    mov rax, 0
    ; Store to variable: i
    mov qword [rbp - 16], rax  ; To stack [rbp - 16]
ir_while_77:
    ; Load variable: i
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 24], rax
    ; Load variable: s
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 24]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    movzx rax, byte [rax]
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_while_end_78
    ; Load variable: i
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    ; Store to variable: i
    mov qword [rbp - 16], rax  ; To stack [rbp - 16]
    jmp ir_while_77
ir_while_end_78:
    ; Load variable: i
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    jmp Lstrlen_exit
Lstrlen_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global streq

streq:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 416    ; Allocate 416 bytes on stack (aligned)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 'a'
    ; Parameter 'a' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'b'
    ; Parameter 'b' arrived in register rdx
ir_entry_79:
    mov rax, 0
    ; Store to variable: i
    mov qword [rbp - 24], rax  ; To stack [rbp - 24]
ir_while_80:
    ; Load variable: i
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 32], rax
    ; Load variable: a
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 32]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    movzx rax, byte [rax]
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    test rax, rax
    jz ir_while_end_81
    ; Load variable: i
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 64], rax
    ; Load variable: a
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 64]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    movzx rax, byte [rax]
    mov [rbp - 80], rax
    ; Load variable: i
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 88], rax
    ; Load variable: b
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, [rbp - 88]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    movzx rax, byte [rax]
    mov [rbp - 104], rax
    mov rax, [rbp - 80]
    push rax
    mov rax, [rbp - 104]
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    test rax, rax
    jz ir_if_else_82
    mov rax, 0
    jmp Lstreq_exit
    jmp ir_if_end_83
ir_if_else_82:
ir_if_end_83:
    ; Load variable: i
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 120], rax
    mov rax, [rbp - 120]
    ; Store to variable: i
    mov qword [rbp - 24], rax  ; To stack [rbp - 24]
    jmp ir_while_80
ir_while_end_81:
    ; Load variable: i
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 128], rax
    ; Load variable: b
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, [rbp - 128]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 136], rax
    mov rax, [rbp - 136]
    movzx rax, byte [rax]
    mov [rbp - 144], rax
    mov rax, [rbp - 144]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 152], rax
    mov rax, [rbp - 152]
    test rax, rax
    jz ir_if_else_84
    mov rax, 0
    jmp Lstreq_exit
    jmp ir_if_end_85
ir_if_else_84:
ir_if_end_85:
    mov rax, 1
    jmp Lstreq_exit
Lstreq_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller
    extern malloc
    extern calloc
    extern realloc
    extern free
    extern memset
    extern memcpy
    extern memmove
    extern memcmp

global alloc_zeroed

alloc_zeroed:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 32    ; Allocate 32 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'n'
    ; Parameter 'n' arrived in register rcx
ir_entry_86:
    ; IR call: calloc (2 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rdx, rax
    call calloc
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    jmp Lalloc_zeroed_exit
Lalloc_zeroed_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global buf_dup

buf_dup:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 112    ; Allocate 112 bytes on stack (aligned)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 'src'
    ; Parameter 'src' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'len'
    ; Parameter 'len' arrived in register rdx
ir_entry_87:
    ; IR call: malloc (1 args)
    sub rsp, 32
    ; Load variable: len
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov rcx, rax
    call malloc
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    ; Store to variable: dst
    mov qword [rbp - 24], rax  ; To stack [rbp - 24]
    ; Load variable: dst
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_if_else_88
    mov rax, 0
    jmp Lbuf_dup_exit
    jmp ir_if_end_89
ir_if_else_88:
ir_if_end_89:
    ; IR call: memcpy (3 args)
    sub rsp, 32
    ; Load variable: dst
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov rcx, rax
    ; Load variable: src
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rdx, rax
    ; Load variable: len
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov r8, rax
    call memcpy
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    mov [rbp - 48], rax
    ; Load variable: dst
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    jmp Lbuf_dup_exit
Lbuf_dup_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller
    extern exit
    extern rand
    extern srand

global AF_INET

AF_INET:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    ; Registering 0 function parameters
ir_entry_90:
    mov rax, 2
    jmp LAF_INET_exit
LAF_INET_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global SOCK_STREAM

SOCK_STREAM:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    ; Registering 0 function parameters
ir_entry_91:
    mov rax, 1
    jmp LSOCK_STREAM_exit
LSOCK_STREAM_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global SOCK_DGRAM

SOCK_DGRAM:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    ; Registering 0 function parameters
ir_entry_92:
    mov rax, 2
    jmp LSOCK_DGRAM_exit
LSOCK_DGRAM_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global IPPROTO_TCP

IPPROTO_TCP:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    ; Registering 0 function parameters
ir_entry_93:
    mov rax, 6
    jmp LIPPROTO_TCP_exit
LIPPROTO_TCP_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global IPPROTO_UDP

IPPROTO_UDP:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    ; Registering 0 function parameters
ir_entry_94:
    mov rax, 17
    jmp LIPPROTO_UDP_exit
LIPPROTO_UDP_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global INVALID_SOCKET

INVALID_SOCKET:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 32    ; Allocate 32 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_95:
    mov rax, 1
    neg rax
    mov [rbp - 8], rax
    mov rax, [rbp - 8]
    jmp LINVALID_SOCKET_exit
LINVALID_SOCKET_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global SOCKET_ERROR

SOCKET_ERROR:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 32    ; Allocate 32 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_96:
    mov rax, 1
    neg rax
    mov [rbp - 8], rax
    mov rax, [rbp - 8]
    jmp LSOCKET_ERROR_exit
LSOCKET_ERROR_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller
    extern WSAStartup
    extern WSACleanup
    extern WSAGetLastError
    extern socket
    extern closesocket
    extern connect
    extern bind
    extern listen
    extern accept
    extern send
    extern recv
    extern htons
    extern htonl
    extern ntohs
    extern ntohl
    extern inet_addr

global net_init

net_init:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 160    ; Allocate 160 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_97:
    ; IR call: malloc (1 args)
    sub rsp, 32
    mov rax, 408
    mov rcx, rax
    call malloc
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    ; Store to variable: wsa_buf
    mov qword [rbp - 8], rax  ; To stack [rbp - 8]
    ; Load variable: wsa_buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_if_else_98
    mov rax, 1
    neg rax
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    jmp Lnet_init_exit
    jmp ir_if_end_99
ir_if_else_98:
ir_if_end_99:
    ; IR call: WSAStartup (2 args)
    sub rsp, 32
    mov rax, 514
    mov rcx, rax
    ; Load variable: wsa_buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rdx, rax
    call WSAStartup
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    ; Store to variable: result
    mov dword [rbp - 12], eax  ; To stack [rbp - 12]
    ; IR call: free (1 args)
    sub rsp, 32
    ; Load variable: wsa_buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call free
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Void return - no value to handle
    mov [rbp - 56], rax
    ; Load variable: result
    mov eax, dword [rbp - 12]  ; From stack [rbp - 12]
    jmp Lnet_init_exit
Lnet_init_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global net_cleanup

net_cleanup:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 32    ; Allocate 32 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_100:
    ; IR call: WSACleanup (0 args)
    sub rsp, 32
    call WSACleanup
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 8], rax
    mov rax, [rbp - 8]
    jmp Lnet_cleanup_exit
Lnet_cleanup_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global sockaddr_in

sockaddr_in:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 848    ; Allocate 848 bytes on stack (aligned)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 'ip'
    ; Parameter 'ip' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'port'
    ; Parameter 'port' arrived in register rdx
ir_entry_101:
    ; IR call: malloc (1 args)
    sub rsp, 32
    mov rax, 16
    mov rcx, rax
    call malloc
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    ; Store to variable: buf
    mov qword [rbp - 24], rax  ; To stack [rbp - 24]
    ; Load variable: buf
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_if_else_102
    mov rax, 0
    jmp Lsockaddr_in_exit
    jmp ir_if_end_103
ir_if_else_102:
ir_if_end_103:
    ; IR call: memset (3 args)
    sub rsp, 32
    ; Load variable: buf
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov rcx, rax
    mov rax, 0
    mov rdx, rax
    mov rax, 16
    mov r8, rax
    call memset
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    mov [rbp - 56], rax
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 64], rax
    ; Load variable: buf
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, [rbp - 64]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    push rax
    mov rax, 2
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    mov rax, 1
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 88], rax
    ; Load variable: buf
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, [rbp - 88]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    push rax
    mov rax, 0
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; IR call: htons (1 args)
    sub rsp, 32
    ; Load variable: port
    mov eax, dword [rbp - 16]  ; From stack [rbp - 16]
    mov rcx, rax
    call htons
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    ; Store to variable: net_port
    mov dword [rbp - 28], eax  ; To stack [rbp - 28]
    mov rax, 2
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 120], rax
    ; Load variable: buf
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, [rbp - 120]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 128], rax
    mov rax, [rbp - 128]
    push rax
    ; Load variable: net_port
    mov eax, dword [rbp - 28]  ; From stack [rbp - 28]
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: net_port
    mov eax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 256
    mov r10, rax
    pop rax
    cqo
    idiv r10
    mov [rbp - 144], rax
    mov rax, 3
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 152], rax
    ; Load variable: buf
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, [rbp - 152]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 160], rax
    mov rax, [rbp - 160]
    push rax
    mov rax, [rbp - 144]
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; IR call: inet_addr (1 args)
    sub rsp, 32
    ; Load variable: ip
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call inet_addr
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 176], rax
    mov rax, [rbp - 176]
    ; Store to variable: addr
    mov dword [rbp - 32], eax  ; To stack [rbp - 32]
    mov rax, 4
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 184], rax
    ; Load variable: buf
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, [rbp - 184]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 192], rax
    mov rax, [rbp - 192]
    push rax
    ; Load variable: addr
    mov eax, dword [rbp - 32]  ; From stack [rbp - 32]
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: addr
    mov eax, dword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, 256
    mov r10, rax
    pop rax
    cqo
    idiv r10
    mov [rbp - 208], rax
    mov rax, 5
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 216], rax
    ; Load variable: buf
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, [rbp - 216]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 224], rax
    mov rax, [rbp - 224]
    push rax
    mov rax, [rbp - 208]
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: addr
    mov eax, dword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, 65536
    mov r10, rax
    pop rax
    cqo
    idiv r10
    mov [rbp - 240], rax
    mov rax, 6
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 248], rax
    ; Load variable: buf
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, [rbp - 248]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 256], rax
    mov rax, [rbp - 256]
    push rax
    mov rax, [rbp - 240]
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: addr
    mov eax, dword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, 16777216
    mov r10, rax
    pop rax
    cqo
    idiv r10
    mov [rbp - 272], rax
    mov rax, 7
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 280], rax
    ; Load variable: buf
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, [rbp - 280]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 288], rax
    mov rax, [rbp - 288]
    push rax
    mov rax, [rbp - 272]
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: buf
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    jmp Lsockaddr_in_exit
Lsockaddr_in_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global main

main:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 208    ; Allocate 208 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_104:
    mov rax, 0
    ; Store to variable: a
    mov qword [rbp - 8], rax  ; To stack [rbp - 8]
    mov rax, 2
    ; Store to variable: b
    mov qword [rbp - 16], rax  ; To stack [rbp - 16]
    mov rax, 3
    ; Store to variable: c
    mov qword [rbp - 24], rax  ; To stack [rbp - 24]
    mov rax, -5
    ; Store to variable: d
    mov qword [rbp - 32], rax  ; To stack [rbp - 32]
    ; Load variable: a
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_if_else_105
    mov rax, 1
    jmp Lmain_exit
    jmp ir_if_end_106
ir_if_else_105:
ir_if_end_106:
    ; Load variable: b
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 2
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_if_else_107
    mov rax, 2
    jmp Lmain_exit
    jmp ir_if_end_108
ir_if_else_107:
ir_if_end_108:
    ; Load variable: c
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 3
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    test rax, rax
    jz ir_if_else_109
    mov rax, 3
    jmp Lmain_exit
    jmp ir_if_end_110
ir_if_else_109:
ir_if_end_110:
    mov rax, 5
    neg rax
    mov [rbp - 64], rax
    ; Load variable: d
    mov rax, qword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, [rbp - 64]
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    test rax, rax
    jz ir_if_else_111
    mov rax, 4
    jmp Lmain_exit
    jmp ir_if_end_112
ir_if_else_111:
ir_if_end_112:
    mov rax, 0
    jmp Lmain_exit
Lmain_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

; Default program entry point
global mainCRTStartup
mainCRTStartup:
    sub rsp, 40      ; Shadow space + alignment
    ; Initialize garbage collector runtime
    lea rcx, [rsp + 40]
    extern gc_init
    call gc_init
    ; Call user main function
    call main
    mov [rsp + 32], rax ; Preserve main return code
    extern gc_shutdown
    call gc_shutdown
    mov rcx, [rsp + 32] ; Use main return as exit code
    extern ExitProcess
    call ExitProcess
