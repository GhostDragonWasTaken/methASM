// MethASM standard library: Networking (Winsock2)
//
// Provides raw socket operations for TCP/UDP networking on Windows.
// Programs using this module must link against ws2_32:
//   gcc -o myapp output.s -lws2_32
//
// Usage pattern:
//   net_init();
//   var sock: int64 = socket(AF_INET, SOCK_STREAM, 0);
//   ... connect / bind / listen / accept / send / recv ...
//   closesocket(sock);
//   net_cleanup();

// ─── Address family / socket type / protocol constants ───────────────────────
// These are returned as functions because MethASM doesn't have
// top-level constant expressions yet.

export function AF_INET() -> int32     { return 2; }
export function SOCK_STREAM() -> int32 { return 1; }
export function SOCK_DGRAM() -> int32  { return 2; }
export function IPPROTO_TCP() -> int32 { return 6; }
export function IPPROTO_UDP() -> int32 { return 17; }
export function INVALID_SOCKET() -> int64 { return -1; }
export function SOCKET_ERROR() -> int32 { return -1; }

// ─── Winsock2 core functions ─────────────────────────────────────────────────
// WSAStartup(wVersionRequired, lpWSAData) -> int32
//   wVersionRequired: typically 0x0202 for Winsock 2.2
//   lpWSAData: pointer to a 408-byte buffer (WSADATA struct)
export extern function WSAStartup(version: int32, wsa_data: cstring) -> int32 = "WSAStartup";
export extern function WSACleanup() -> int32 = "WSACleanup";
export extern function WSAGetLastError() -> int32 = "WSAGetLastError";

// ─── Socket lifecycle ────────────────────────────────────────────────────────
export extern function socket(af: int32, sock_type: int32, protocol: int32) -> int64 = "socket";
export extern function closesocket(s: int64) -> int32 = "closesocket";

// ─── Client operations ──────────────────────────────────────────────────────
export extern function connect(s: int64, addr: cstring, addrlen: int32) -> int32 = "connect";

// ─── Server operations ──────────────────────────────────────────────────────
export extern function bind(s: int64, addr: cstring, addrlen: int32) -> int32 = "bind";
export extern function listen(s: int64, backlog: int32) -> int32 = "listen";
export extern function accept(s: int64, addr: cstring, addrlen: cstring) -> int64 = "accept";

// ─── Data transfer ──────────────────────────────────────────────────────────
export extern function send(s: int64, buf: cstring, len: int32, flags: int32) -> int32 = "send";
export extern function recv(s: int64, buf: cstring, len: int32, flags: int32) -> int32 = "recv";

// ─── Address utilities ──────────────────────────────────────────────────────
export extern function htons(hostshort: int32) -> int32 = "htons";
export extern function htonl(hostlong: int32) -> int32 = "htonl";
export extern function ntohs(netshort: int32) -> int32 = "ntohs";
export extern function ntohl(netlong: int32) -> int32 = "ntohl";
export extern function inet_addr(cp: cstring) -> int32 = "inet_addr";

// ─── Convenience wrappers ───────────────────────────────────────────────────

// Initialize Winsock 2.2.  Returns 0 on success.
export function net_init() -> int32 {
  // WSADATA is 408 bytes on x64 Windows.  We allocate a raw buffer.
  var wsa_buf: cstring = malloc(408);
  if (wsa_buf == 0) {
    return -1;
  }
  // 0x0202 = version 2.2
  var result: int32 = WSAStartup(514, wsa_buf);
  free(wsa_buf);
  return result;
}

// Shut down Winsock.  Returns 0 on success.
export function net_cleanup() -> int32 {
  return WSACleanup();
}

// Build a sockaddr_in structure for IPv4.
// Returns a malloc'd 16-byte buffer the caller must free() after use.
//   ip   – dotted-quad string, e.g. "127.0.0.1"
//   port – port number in host byte order
export function sockaddr_in(ip: cstring, port: int32) -> cstring {
  var buf: cstring = malloc(16);
  if (buf == 0) {
    return 0;
  }
  // Zero it out
  memset(buf, 0, 16);

  // sin_family = AF_INET (2) at offset 0 (2 bytes, little-endian)
  buf[0] = 2;
  buf[1] = 0;

  // sin_port at offset 2 (2 bytes, network byte order)
  var net_port: int32 = htons(port);
  buf[2] = net_port;
  buf[3] = net_port / 256;

  // sin_addr at offset 4 (4 bytes)
  var addr: int32 = inet_addr(ip);
  buf[4] = addr;
  buf[5] = addr / 256;
  buf[6] = addr / 65536;
  buf[7] = addr / 16777216;

  return buf;
}
