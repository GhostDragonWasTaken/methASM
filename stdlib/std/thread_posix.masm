// MethASM standard library: Threading (POSIX – Linux / macOS)
//
// Thin wrappers around pthreads and POSIX synchronisation APIs.
// This module is for Linux and macOS only.  On Windows, use std/thread
// (Win32 threading) instead.
//
// Link flags:
//   Linux:  gcc -o myapp output.s -lpthread
//   macOS:  gcc -o myapp output.s   (pthreads are in libSystem, no -lpthread needed)
//
// Due to the language's current lack of function pointer support, practical
// callback-based thread entry is usually provided via a tiny C bridge:
//
//   // thread_bridge.c
//   #include <pthread.h>
//   extern void my_worker(void *arg);   // MethASM function
//   void *thread_entry(void *arg) { my_worker(arg); return 0; }
//   pthread_t spawn_worker(void *arg) {
//       pthread_t t;
//       pthread_create(&t, 0, thread_entry, arg);
//       return t;
//   }
//
// Then from MethASM:
//   extern function spawn_worker(arg: cstring) -> int64 = "spawn_worker";
//   var t: int64 = spawn_worker(my_data);
//   pthread_join(t, 0);

// ─── pthread_t / pthread_mutex_t ─────────────────────────────────────────────
// On Linux x86-64, pthread_t is an unsigned long (8 bytes).
// On macOS, pthread_t is a pointer (8 bytes).
// We represent both as int64.
//
// pthread_mutex_t is an opaque struct (40 bytes on Linux, 56 bytes on macOS).
// We allocate it on the heap via malloc and pass it as cstring (void*).

// ─── Thread lifecycle ────────────────────────────────────────────────────────
// pthread_create(thread*, attr*, start_routine*, arg*) -> int (0 = success)
// Because MethASM lacks function pointer types, start_routine is passed as
// cstring.  Use a C bridge (see above) to wrap the actual entry function.
export extern function pthread_create(thread: int64*, attr: cstring, start_routine: cstring, arg: cstring) -> int32 = "pthread_create";

// pthread_join(thread, retval*) -> int (0 = success)
// Pass 0 for retval when the return value is not needed.
export extern function pthread_join(thread: int64, retval: cstring) -> int32 = "pthread_join";

// pthread_detach(thread) -> int (0 = success)
export extern function pthread_detach(thread: int64) -> int32 = "pthread_detach";

// pthread_self() -> pthread_t (current thread handle)
export extern function pthread_self() -> int64 = "pthread_self";

// pthread_exit(retval*) – terminate the calling thread
export extern function pthread_exit(retval: cstring) = "pthread_exit";

// ─── Mutex ───────────────────────────────────────────────────────────────────
// pthread_mutex_init(mutex*, attr*) -> int (0 = success)
export extern function pthread_mutex_init(mutex: cstring, attr: cstring) -> int32 = "pthread_mutex_init";

// pthread_mutex_destroy(mutex*) -> int (0 = success)
export extern function pthread_mutex_destroy(mutex: cstring) -> int32 = "pthread_mutex_destroy";

// pthread_mutex_lock(mutex*) -> int (0 = success)
export extern function pthread_mutex_lock(mutex: cstring) -> int32 = "pthread_mutex_lock";

// pthread_mutex_trylock(mutex*) -> int (0 = acquired, EBUSY = not acquired)
export extern function pthread_mutex_trylock(mutex: cstring) -> int32 = "pthread_mutex_trylock";

// pthread_mutex_unlock(mutex*) -> int (0 = success)
export extern function pthread_mutex_unlock(mutex: cstring) -> int32 = "pthread_mutex_unlock";

// ─── Condition variable ──────────────────────────────────────────────────────
// pthread_cond_init(cond*, attr*) -> int
export extern function pthread_cond_init(cond: cstring, attr: cstring) -> int32 = "pthread_cond_init";

// pthread_cond_destroy(cond*) -> int
export extern function pthread_cond_destroy(cond: cstring) -> int32 = "pthread_cond_destroy";

// pthread_cond_wait(cond*, mutex*) -> int
export extern function pthread_cond_wait(cond: cstring, mutex: cstring) -> int32 = "pthread_cond_wait";

// pthread_cond_signal(cond*) -> int  (wake one waiter)
export extern function pthread_cond_signal(cond: cstring) -> int32 = "pthread_cond_signal";

// pthread_cond_broadcast(cond*) -> int  (wake all waiters)
export extern function pthread_cond_broadcast(cond: cstring) -> int32 = "pthread_cond_broadcast";

// ─── Sleep ───────────────────────────────────────────────────────────────────
// usleep(microseconds) – sleep for the given number of microseconds.
// 1 ms = 1000 µs.  Available in libc; no extra link flags needed.
export extern function usleep(usec: uint32) -> int32 = "usleep";

// nanosleep is more precise but requires a timespec struct (two int64 fields).
// Allocate a 16-byte buffer: buf[0..7] = seconds, buf[8..15] = nanoseconds.
export extern function nanosleep(req: cstring, rem: cstring) -> int32 = "nanosleep";

// ─── GC lifecycle helpers ────────────────────────────────────────────────────
// Call thread_gc_attach_posix() near the beginning of a worker entry function
// and thread_gc_detach_posix() just before thread exit.
export extern function gc_thread_attach() -> int32 = "gc_thread_attach";
export extern function gc_thread_detach() -> int32 = "gc_thread_detach";

export function thread_gc_attach_posix() {
  gc_thread_attach();
}

export function thread_gc_detach_posix() {
  gc_thread_detach();
}

// ─── Atomic helpers (via C bridge) ──────────────────────────────────────────
// GCC/Clang __sync built-ins are compiler intrinsics; we expose them through
// a small C helper so MethASM can call them without inline assembly.
//
// Add the following to a C file compiled alongside your program:
//
//   // posix_sync_helpers.c
//   #include <sched.h>
//   int posix_cas_i32(int *ptr, int expected, int desired) {
//       return __sync_val_compare_and_swap(ptr, expected, desired);
//   }
//   void posix_yield(void) { sched_yield(); }
//   int posix_atomic_exchange_i32(int *ptr, int val) {
//       return __sync_lock_test_and_set(ptr, val);
//   }
//   int posix_atomic_add_i32(int *ptr, int val) {
//       return __sync_fetch_and_add(ptr, val);
//   }
//
// Link flags: none (sched_yield is in libc; __sync builtins are inlined).

export extern function posix_cas_i32(ptr: int32*, expected: int32, desired: int32) -> int32 = "posix_cas_i32";
export extern function posix_yield() = "posix_yield";
export extern function posix_atomic_exchange_i32(ptr: int32*, val: int32) -> int32 = "posix_atomic_exchange_i32";
export extern function posix_atomic_add_i32(ptr: int32*, val: int32) -> int32 = "posix_atomic_add_i32";

// ─── Spin-lock helpers ───────────────────────────────────────────────────────
// Lightweight synchronisation for short critical sections.
// lock_var must be a shared int32 initialised to 0.

export function posix_spin_try_lock(lock_var: int32*) -> int32 {
  if (posix_cas_i32(lock_var, 0, 1) == 0) {
    return 1;
  }
  return 0;
}

export function posix_spin_lock(lock_var: int32*) {
  while (posix_spin_try_lock(lock_var) == 0) {
    posix_yield();
  }
}

export function posix_spin_unlock(lock_var: int32*) {
  posix_atomic_exchange_i32(lock_var, 0);
}

// ─── Convenience wrappers ───────────────────────────────────────────────────

// Allocate and initialise a default (non-recursive) mutex.
// Returns a cstring (pointer to the heap-allocated pthread_mutex_t).
// The caller must call mutex_destroy_posix() and free() when done.
//
// pthread_mutex_t size: 40 bytes on Linux x86-64, 56 bytes on macOS.
// We allocate 64 bytes to cover both platforms.
import "std/mem";

export function mutex_create_posix() -> cstring {
  var m: cstring = malloc(64);
  if (m == 0) {
    return 0;
  }
  memset(m, 0, 64);
  pthread_mutex_init(m, 0);
  return m;
}

export function mutex_lock_posix(mutex: cstring) -> int32 {
  return pthread_mutex_lock(mutex);
}

export function mutex_trylock_posix(mutex: cstring) -> int32 {
  return pthread_mutex_trylock(mutex);
}

export function mutex_unlock_posix(mutex: cstring) -> int32 {
  return pthread_mutex_unlock(mutex);
}

export function mutex_destroy_posix(mutex: cstring) -> int32 {
  return pthread_mutex_destroy(mutex);
}

// Sleep for the given number of milliseconds.
export function thread_sleep_ms_posix(milliseconds: uint32) {
  usleep(milliseconds * 1000);
}

// Join a thread, discarding its return value.
export function thread_join_posix(thread: int64) -> int32 {
  return pthread_join(thread, 0);
}

// Detach a thread so its resources are released automatically on exit.
export function thread_detach_posix(thread: int64) -> int32 {
  return pthread_detach(thread);
}
//
// Thin wrappers around pthreads and POSIX synchronisation APIs.
// This module is for Linux and macOS only.  On Windows, use std/thread
// (Win32 threading) instead.
//
// Link flags:
//   Linux:  gcc -o myapp output.s -lpthread
//   macOS:  gcc -o myapp output.s   (pthreads are in libSystem, no -lpthread needed)
//
// Due to the language's current lack of function pointer support, practical
// callback-based thread entry is usually provided via a tiny C bridge:
//
//   // thread_bridge.c
//   #include <pthread.h>
//   extern void my_worker(void *arg);   // MethASM function
//   void *thread_entry(void *arg) { my_worker(arg); return 0; }
//   pthread_t spawn_worker(void *arg) {
//       pthread_t t;
//       pthread_create(&t, 0, thread_entry, arg);
//       return t;
//   }
//
// Then from MethASM:
//   extern function spawn_worker(arg: cstring) -> int64 = "spawn_worker";
//   var t: int64 = spawn_worker(my_data);
//   pthread_join(t, 0);

// ─── pthread_t / pthread_mutex_t ─────────────────────────────────────────────
// On Linux x86-64, pthread_t is an unsigned long (8 bytes).
// On macOS, pthread_t is a pointer (8 bytes).
// We represent both as int64.
//
// pthread_mutex_t is an opaque struct (40 bytes on Linux, 56 bytes on macOS).
// We allocate it on the heap via malloc and pass it as cstring (void*).

// ─── Thread lifecycle ────────────────────────────────────────────────────────
// pthread_create(thread*, attr*, start_routine*, arg*) -> int (0 = success)
// Because MethASM lacks function pointer types, start_routine is passed as
// cstring.  Use a C bridge (see above) to wrap the actual entry function.
export extern function pthread_create(thread: int64*, attr: cstring, start_routine: cstring, arg: cstring) -> int32 = "pthread_create";

// pthread_join(thread, retval*) -> int (0 = success)
// Pass 0 for retval when the return value is not needed.
export extern function pthread_join(thread: int64, retval: cstring) -> int32 = "pthread_join";

// pthread_detach(thread) -> int (0 = success)
export extern function pthread_detach(thread: int64) -> int32 = "pthread_detach";

// pthread_self() -> pthread_t (current thread handle)
export extern function pthread_self() -> int64 = "pthread_self";

// pthread_exit(retval*) – terminate the calling thread
export extern function pthread_exit(retval: cstring) = "pthread_exit";

// ─── Mutex ───────────────────────────────────────────────────────────────────
// pthread_mutex_init(mutex*, attr*) -> int (0 = success)
export extern function pthread_mutex_init(mutex: cstring, attr: cstring) -> int32 = "pthread_mutex_init";

// pthread_mutex_destroy(mutex*) -> int (0 = success)
export extern function pthread_mutex_destroy(mutex: cstring) -> int32 = "pthread_mutex_destroy";

// pthread_mutex_lock(mutex*) -> int (0 = success)
export extern function pthread_mutex_lock(mutex: cstring) -> int32 = "pthread_mutex_lock";

// pthread_mutex_trylock(mutex*) -> int (0 = acquired, EBUSY = not acquired)
export extern function pthread_mutex_trylock(mutex: cstring) -> int32 = "pthread_mutex_trylock";

// pthread_mutex_unlock(mutex*) -> int (0 = success)
export extern function pthread_mutex_unlock(mutex: cstring) -> int32 = "pthread_mutex_unlock";

// ─── Condition variable ──────────────────────────────────────────────────────
// pthread_cond_init(cond*, attr*) -> int
export extern function pthread_cond_init(cond: cstring, attr: cstring) -> int32 = "pthread_cond_init";

// pthread_cond_destroy(cond*) -> int
export extern function pthread_cond_destroy(cond: cstring) -> int32 = "pthread_cond_destroy";

// pthread_cond_wait(cond*, mutex*) -> int
export extern function pthread_cond_wait(cond: cstring, mutex: cstring) -> int32 = "pthread_cond_wait";

// pthread_cond_signal(cond*) -> int  (wake one waiter)
export extern function pthread_cond_signal(cond: cstring) -> int32 = "pthread_cond_signal";

// pthread_cond_broadcast(cond*) -> int  (wake all waiters)
export extern function pthread_cond_broadcast(cond: cstring) -> int32 = "pthread_cond_broadcast";

// ─── Sleep ───────────────────────────────────────────────────────────────────
// usleep(microseconds) – sleep for the given number of microseconds.
// 1 ms = 1000 µs.  Available in libc; no extra link flags needed.
export extern function usleep(usec: uint32) -> int32 = "usleep";

// nanosleep is more precise but requires a timespec struct (two int64 fields).
// Allocate a 16-byte buffer: buf[0..7] = seconds, buf[8..15] = nanoseconds.
export extern function nanosleep(req: cstring, rem: cstring) -> int32 = "nanosleep";

// ─── GC lifecycle helpers ────────────────────────────────────────────────────
// Call thread_gc_attach_posix() near the beginning of a worker entry function
// and thread_gc_detach_posix() just before thread exit.
export extern function gc_thread_attach() -> int32 = "gc_thread_attach";
export extern function gc_thread_detach() -> int32 = "gc_thread_detach";

export function thread_gc_attach_posix() {
  gc_thread_attach();
}

export function thread_gc_detach_posix() {
  gc_thread_detach();
}

// ─── Atomic helpers (via C bridge) ──────────────────────────────────────────
// GCC/Clang __sync built-ins are compiler intrinsics; we expose them through
// a small C helper so MethASM can call them without inline assembly.
//
// Add the following to a C file compiled alongside your program:
//
//   // posix_sync_helpers.c
//   #include <sched.h>
//   int posix_cas_i32(int *ptr, int expected, int desired) {
//       return __sync_val_compare_and_swap(ptr, expected, desired);
//   }
//   void posix_yield(void) { sched_yield(); }
//   int posix_atomic_exchange_i32(int *ptr, int val) {
//       return __sync_lock_test_and_set(ptr, val);
//   }
//   int posix_atomic_add_i32(int *ptr, int val) {
//       return __sync_fetch_and_add(ptr, val);
//   }
//
// Link flags: none (sched_yield is in libc; __sync builtins are inlined).

export extern function posix_cas_i32(ptr: int32*, expected: int32, desired: int32) -> int32 = "posix_cas_i32";
export extern function posix_yield() = "posix_yield";
export extern function posix_atomic_exchange_i32(ptr: int32*, val: int32) -> int32 = "posix_atomic_exchange_i32";
export extern function posix_atomic_add_i32(ptr: int32*, val: int32) -> int32 = "posix_atomic_add_i32";

// ─── Spin-lock helpers ───────────────────────────────────────────────────────
// Lightweight synchronisation for short critical sections.
// lock_var must be a shared int32 initialised to 0.

export function posix_spin_try_lock(lock_var: int32*) -> int32 {
  if (posix_cas_i32(lock_var, 0, 1) == 0) {
    return 1;
  }
  return 0;
}

export function posix_spin_lock(lock_var: int32*) {
  while (posix_spin_try_lock(lock_var) == 0) {
    posix_yield();
  }
}

export function posix_spin_unlock(lock_var: int32*) {
  posix_atomic_exchange_i32(lock_var, 0);
}

// ─── Convenience wrappers ───────────────────────────────────────────────────

// Allocate and initialise a default (non-recursive) mutex.
// Returns a cstring (pointer to the heap-allocated pthread_mutex_t).
// The caller must call mutex_destroy_posix() and free() when done.
//
// pthread_mutex_t size: 40 bytes on Linux x86-64, 56 bytes on macOS.
// We allocate 64 bytes to cover both platforms.
import "std/mem";

export function mutex_create_posix() -> cstring {
  var m: cstring = malloc(64);
  if (m == 0) {
    return 0;
  }
  memset(m, 0, 64);
  pthread_mutex_init(m, 0);
  return m;
}

export function mutex_lock_posix(mutex: cstring) -> int32 {
  return pthread_mutex_lock(mutex);
}

export function mutex_trylock_posix(mutex: cstring) -> int32 {
  return pthread_mutex_trylock(mutex);
}

export function mutex_unlock_posix(mutex: cstring) -> int32 {
  return pthread_mutex_unlock(mutex);
}

export function mutex_destroy_posix(mutex: cstring) -> int32 {
  return pthread_mutex_destroy(mutex);
}

// Sleep for the given number of milliseconds.
export function thread_sleep_ms_posix(milliseconds: uint32) {
  usleep(milliseconds * 1000);
}

// Join a thread, discarding its return value.
export function thread_join_posix(thread: int64) -> int32 {
  return pthread_join(thread, 0);
}

// Detach a thread so its resources are released automatically on exit.
export function thread_detach_posix(thread: int64) -> int32 {
  return pthread_detach(thread);
}

