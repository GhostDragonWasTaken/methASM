; Generated by MethASM
; x86-64 Assembly Output

bits 64

section .text
; Code section

; First pass: processing 91 declarations
; Declaration 0 type: 4 (AST_INLINE_ASM = 21)
; Declaration 1 type: 4 (AST_INLINE_ASM = 21)
; Declaration 2 type: 4 (AST_INLINE_ASM = 21)
; Declaration 3 type: 4 (AST_INLINE_ASM = 21)
; Declaration 4 type: 4 (AST_INLINE_ASM = 21)
; Declaration 5 type: 4 (AST_INLINE_ASM = 21)
; Declaration 6 type: 4 (AST_INLINE_ASM = 21)
; Declaration 7 type: 4 (AST_INLINE_ASM = 21)
; Declaration 8 type: 4 (AST_INLINE_ASM = 21)
; Declaration 9 type: 4 (AST_INLINE_ASM = 21)
; Declaration 10 type: 4 (AST_INLINE_ASM = 21)
; Declaration 11 type: 4 (AST_INLINE_ASM = 21)
; Declaration 12 type: 4 (AST_INLINE_ASM = 21)
; Declaration 13 type: 4 (AST_INLINE_ASM = 21)
; Declaration 14 type: 4 (AST_INLINE_ASM = 21)
; Declaration 15 type: 4 (AST_INLINE_ASM = 21)
; Declaration 16 type: 4 (AST_INLINE_ASM = 21)
; Declaration 17 type: 4 (AST_INLINE_ASM = 21)
; Declaration 18 type: 4 (AST_INLINE_ASM = 21)
; Declaration 19 type: 4 (AST_INLINE_ASM = 21)
; Declaration 20 type: 4 (AST_INLINE_ASM = 21)
; Declaration 21 type: 4 (AST_INLINE_ASM = 21)
; Declaration 22 type: 4 (AST_INLINE_ASM = 21)
; Declaration 23 type: 4 (AST_INLINE_ASM = 21)
; Declaration 24 type: 4 (AST_INLINE_ASM = 21)
; Declaration 25 type: 4 (AST_INLINE_ASM = 21)
; Declaration 26 type: 4 (AST_INLINE_ASM = 21)
; Declaration 27 type: 4 (AST_INLINE_ASM = 21)
; Declaration 28 type: 4 (AST_INLINE_ASM = 21)
; Declaration 29 type: 4 (AST_INLINE_ASM = 21)
; Declaration 30 type: 4 (AST_INLINE_ASM = 21)
; Declaration 31 type: 4 (AST_INLINE_ASM = 21)
; Declaration 32 type: 4 (AST_INLINE_ASM = 21)
; Declaration 33 type: 4 (AST_INLINE_ASM = 21)
; Declaration 34 type: 4 (AST_INLINE_ASM = 21)
; Declaration 35 type: 4 (AST_INLINE_ASM = 21)
; Declaration 36 type: 4 (AST_INLINE_ASM = 21)
; Declaration 37 type: 4 (AST_INLINE_ASM = 21)
; Declaration 38 type: 4 (AST_INLINE_ASM = 21)
; Declaration 39 type: 4 (AST_INLINE_ASM = 21)
; Declaration 40 type: 4 (AST_INLINE_ASM = 21)
; Declaration 41 type: 4 (AST_INLINE_ASM = 21)
; Declaration 42 type: 4 (AST_INLINE_ASM = 21)
; Declaration 43 type: 4 (AST_INLINE_ASM = 21)
; Declaration 44 type: 4 (AST_INLINE_ASM = 21)
; Declaration 45 type: 4 (AST_INLINE_ASM = 21)
; Declaration 46 type: 4 (AST_INLINE_ASM = 21)
; Declaration 47 type: 4 (AST_INLINE_ASM = 21)
; Declaration 48 type: 4 (AST_INLINE_ASM = 21)
; Declaration 49 type: 4 (AST_INLINE_ASM = 21)
; Declaration 50 type: 4 (AST_INLINE_ASM = 21)
; Declaration 51 type: 4 (AST_INLINE_ASM = 21)
; Declaration 52 type: 4 (AST_INLINE_ASM = 21)
; Declaration 53 type: 3 (AST_INLINE_ASM = 21)
; Declaration 54 type: 3 (AST_INLINE_ASM = 21)
; Declaration 55 type: 3 (AST_INLINE_ASM = 21)
; Declaration 56 type: 3 (AST_INLINE_ASM = 21)
; Declaration 57 type: 3 (AST_INLINE_ASM = 21)
; Declaration 58 type: 3 (AST_INLINE_ASM = 21)
; Declaration 59 type: 3 (AST_INLINE_ASM = 21)
; Declaration 60 type: 3 (AST_INLINE_ASM = 21)
; Declaration 61 type: 3 (AST_INLINE_ASM = 21)
; Declaration 62 type: 3 (AST_INLINE_ASM = 21)
; Declaration 63 type: 4 (AST_INLINE_ASM = 21)
; Declaration 64 type: 4 (AST_INLINE_ASM = 21)
; Declaration 65 type: 4 (AST_INLINE_ASM = 21)
; Declaration 66 type: 4 (AST_INLINE_ASM = 21)
; Declaration 67 type: 4 (AST_INLINE_ASM = 21)
; Declaration 68 type: 4 (AST_INLINE_ASM = 21)
; Declaration 69 type: 4 (AST_INLINE_ASM = 21)
; Declaration 70 type: 4 (AST_INLINE_ASM = 21)
; Declaration 71 type: 4 (AST_INLINE_ASM = 21)
; Declaration 72 type: 4 (AST_INLINE_ASM = 21)
; Declaration 73 type: 4 (AST_INLINE_ASM = 21)
; Declaration 74 type: 4 (AST_INLINE_ASM = 21)
; Declaration 75 type: 4 (AST_INLINE_ASM = 21)
; Declaration 76 type: 4 (AST_INLINE_ASM = 21)
; Declaration 77 type: 4 (AST_INLINE_ASM = 21)
; Declaration 78 type: 4 (AST_INLINE_ASM = 21)
; Declaration 79 type: 4 (AST_INLINE_ASM = 21)
; Declaration 80 type: 4 (AST_INLINE_ASM = 21)
; Declaration 81 type: 4 (AST_INLINE_ASM = 21)
; Declaration 82 type: 4 (AST_INLINE_ASM = 21)
; Declaration 83 type: 4 (AST_INLINE_ASM = 21)
; Declaration 84 type: 4 (AST_INLINE_ASM = 21)
; Declaration 85 type: 4 (AST_INLINE_ASM = 21)
; Declaration 86 type: 4 (AST_INLINE_ASM = 21)
; Declaration 87 type: 4 (AST_INLINE_ASM = 21)
; Declaration 88 type: 4 (AST_INLINE_ASM = 21)
; Declaration 89 type: 4 (AST_INLINE_ASM = 21)
; Declaration 90 type: 4 (AST_INLINE_ASM = 21)

section .text
    extern puts
    extern putchar
    extern getchar

global cstr

cstr:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 80    ; Allocate 80 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 's'
    ; Parameter 's' arrived in register rcx
ir_entry_0:
    ; Load variable: s
    mov rax, qword [rbp - 8]  ; String param ptr
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    mov rax, qword [rax]
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_1
    jmp ir_errdefer_end_2
ir_errdefer_ok_1:
ir_errdefer_end_2:
    mov rax, [rbp - 24]
    jmp Lcstr_exit
Lcstr_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global print

print:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 272    ; Allocate 272 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'msg'
    ; Parameter 'msg' arrived in register rcx
ir_entry_3:
    mov rax, 0
    ; Store to variable: i
    mov qword [rbp - 16], rax  ; To stack [rbp - 16]
ir_while_4:
    ; Load variable: msg
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_6
    jmp ir_nonnull_7
ir_trap_null_6:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct6]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    extern exit
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_7:
    ; Load variable: i
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 24], rax
    ; Load variable: msg
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 24]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    movzx rax, byte [rax]
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_while_end_5
    ; Load variable: msg
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_8
    jmp ir_nonnull_9
ir_trap_null_8:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct8]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_9:
    ; Load variable: i
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 56], rax
    ; Load variable: msg
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 56]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    movzx rax, byte [rax]
    mov [rbp - 72], rax
    ; IR call: putchar (1 args)
    sub rsp, 32
    mov rax, [rbp - 72]
    mov rcx, rax
    call putchar
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 80], rax
    ; Load variable: i
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    ; Store to variable: i
    mov qword [rbp - 16], rax  ; To stack [rbp - 16]
    jmp ir_while_4
ir_while_end_5:
    mov rax, 0
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    test rax, rax
    jz ir_errdefer_ok_10
    jmp ir_errdefer_end_11
ir_errdefer_ok_10:
ir_errdefer_end_11:
    jmp Lprint_exit
Lprint_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global println

println:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 64    ; Allocate 64 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'msg'
    ; Parameter 'msg' arrived in register rcx
ir_entry_12:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; Load variable: msg
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 16], rax
    mov rax, 0
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_errdefer_ok_13
    jmp ir_errdefer_end_14
ir_errdefer_ok_13:
ir_errdefer_end_14:
    jmp Lprintln_exit
Lprintln_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global newline

newline:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 48    ; Allocate 48 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_15:
    ; IR call: putchar (1 args)
    sub rsp, 32
    mov rax, 10
    mov rcx, rax
    call putchar
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 8], rax
    mov rax, 0
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_errdefer_ok_16
    jmp ir_errdefer_end_17
ir_errdefer_ok_16:
ir_errdefer_end_17:
    jmp Lnewline_exit
Lnewline_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global print_int

print_int:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 752    ; Allocate 752 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'n'
    ; Parameter 'n' arrived in register rcx
ir_entry_18:
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 104], rax
    mov rax, [rbp - 104]
    test rax, rax
    jz ir_if_next_20
    ; IR call: putchar (1 args)
    sub rsp, 32
    mov rax, 45
    mov rcx, rax
    call putchar
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 112], rax
    mov rax, 0
    push rax
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 120], rax
    mov rax, [rbp - 120]
    ; Store to variable: n
    mov qword [rbp - 8], rax  ; To stack [rbp - 8]
    jmp ir_if_end_19
ir_if_next_20:
ir_if_end_19:
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 128], rax
    mov rax, [rbp - 128]
    test rax, rax
    jz ir_if_next_22
    ; IR call: putchar (1 args)
    sub rsp, 32
    mov rax, 48
    mov rcx, rax
    call putchar
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 136], rax
    mov rax, 0
    mov [rbp - 144], rax
    mov rax, [rbp - 144]
    test rax, rax
    jz ir_errdefer_ok_23
    jmp ir_errdefer_end_24
ir_errdefer_ok_23:
ir_errdefer_end_24:
    jmp Lprint_int_exit
    jmp ir_if_end_21
ir_if_next_22:
ir_if_end_21:
    mov rax, 0
    ; Store to variable: len
    mov dword [rbp - 92], eax  ; To stack [rbp - 92]
ir_while_25:
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setg al
    movzx rax, al
    mov [rbp - 152], rax
    mov rax, [rbp - 152]
    test rax, rax
    jz ir_while_end_26
    mov rax, 48
    push rax
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 160], rax
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 10
    mov r10, rax
    pop rax
    cqo
    idiv r10
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    push rax
    mov rax, 10
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 176], rax
    mov rax, [rbp - 160]
    push rax
    mov rax, [rbp - 176]
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 184], rax
    ; Load variable: len
    movsxd rax, dword [rbp - 92]  ; From stack [rbp - 92]
    push rax
    mov rax, 20
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 192], rax
    mov rax, [rbp - 192]
    test rax, rax
    jz ir_trap_bounds_27
    jmp ir_in_bounds_28
ir_trap_bounds_27:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct10]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_28:
    ; Load variable: len
    movsxd rax, dword [rbp - 92]  ; From stack [rbp - 92]
    push rax
    mov rax, 4
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 200], rax
    ; Load variable: buf
    lea rax, [rbp - 88]  ; Local array base
    push rax
    mov rax, [rbp - 200]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 208], rax
    mov rax, [rbp - 208]
    push rax
    mov rax, [rbp - 184]
    mov rcx, rax
    pop rax
    mov dword [rax], ecx
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 10
    mov r10, rax
    pop rax
    cqo
    idiv r10
    mov [rbp - 224], rax
    mov rax, [rbp - 224]
    ; Store to variable: n
    mov qword [rbp - 8], rax  ; To stack [rbp - 8]
    ; Load variable: len
    movsxd rax, dword [rbp - 92]  ; From stack [rbp - 92]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 232], rax
    mov rax, [rbp - 232]
    ; Store to variable: len
    mov dword [rbp - 92], eax  ; To stack [rbp - 92]
    jmp ir_while_25
ir_while_end_26:
    ; Load variable: len
    movsxd rax, dword [rbp - 92]  ; From stack [rbp - 92]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 240], rax
    mov rax, [rbp - 240]
    ; Store to variable: i
    mov dword [rbp - 96], eax  ; To stack [rbp - 96]
ir_while_29:
    ; Load variable: i
    movsxd rax, dword [rbp - 96]  ; From stack [rbp - 96]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 248], rax
    mov rax, [rbp - 248]
    test rax, rax
    jz ir_while_end_30
    ; Load variable: i
    movsxd rax, dword [rbp - 96]  ; From stack [rbp - 96]
    push rax
    mov rax, 20
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 256], rax
    mov rax, [rbp - 256]
    test rax, rax
    jz ir_trap_bounds_31
    jmp ir_in_bounds_32
ir_trap_bounds_31:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct12]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_32:
    ; Load variable: i
    movsxd rax, dword [rbp - 96]  ; From stack [rbp - 96]
    push rax
    mov rax, 4
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 264], rax
    ; Load variable: buf
    lea rax, [rbp - 88]  ; Local array base
    push rax
    mov rax, [rbp - 264]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 272], rax
    mov rax, [rbp - 272]
    mov eax, dword [rax]
    mov [rbp - 280], rax
    ; IR call: putchar (1 args)
    sub rsp, 32
    mov rax, [rbp - 280]
    mov rcx, rax
    call putchar
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 288], rax
    ; Load variable: i
    movsxd rax, dword [rbp - 96]  ; From stack [rbp - 96]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 296], rax
    mov rax, [rbp - 296]
    ; Store to variable: i
    mov dword [rbp - 96], eax  ; To stack [rbp - 96]
    jmp ir_while_29
ir_while_end_30:
    mov rax, 0
    mov [rbp - 304], rax
    mov rax, [rbp - 304]
    test rax, rax
    jz ir_errdefer_ok_33
    jmp ir_errdefer_end_34
ir_errdefer_ok_33:
ir_errdefer_end_34:
    jmp Lprint_int_exit
Lprint_int_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global println_int

println_int:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 80    ; Allocate 80 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'n'
    ; Parameter 'n' arrived in register rcx
ir_entry_35:
    ; IR call: print_int (1 args)
    sub rsp, 32
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call print_int
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 16], rax
    ; IR call: putchar (1 args)
    sub rsp, 32
    mov rax, 10
    mov rcx, rax
    call putchar
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 24], rax
    mov rax, 0
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_36
    jmp ir_errdefer_end_37
ir_errdefer_ok_36:
ir_errdefer_end_37:
    jmp Lprintln_int_exit
Lprintln_int_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller
    extern fopen
    extern fclose
    extern fread
    extern fwrite
    extern fputs
    extern fgets
    extern fflush
    extern __acrt_iob_func

global get_stdin

get_stdin:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 48    ; Allocate 48 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_38:
    ; IR call: __acrt_iob_func (1 args)
    sub rsp, 32
    mov rax, 0
    mov rcx, rax
    call __acrt_iob_func
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 8], rax
    mov rax, [rbp - 8]
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_errdefer_ok_39
    jmp ir_errdefer_end_40
ir_errdefer_ok_39:
ir_errdefer_end_40:
    mov rax, [rbp - 8]
    jmp Lget_stdin_exit
Lget_stdin_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global get_stdout

get_stdout:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 48    ; Allocate 48 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_41:
    ; IR call: __acrt_iob_func (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call __acrt_iob_func
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 8], rax
    mov rax, [rbp - 8]
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_errdefer_ok_42
    jmp ir_errdefer_end_43
ir_errdefer_ok_42:
ir_errdefer_end_43:
    mov rax, [rbp - 8]
    jmp Lget_stdout_exit
Lget_stdout_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global get_stderr

get_stderr:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 48    ; Allocate 48 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_44:
    ; IR call: __acrt_iob_func (1 args)
    sub rsp, 32
    mov rax, 2
    mov rcx, rax
    call __acrt_iob_func
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 8], rax
    mov rax, [rbp - 8]
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_errdefer_ok_45
    jmp ir_errdefer_end_46
ir_errdefer_ok_45:
ir_errdefer_end_46:
    mov rax, [rbp - 8]
    jmp Lget_stderr_exit
Lget_stderr_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global print_err

print_err:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 80    ; Allocate 80 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'msg'
    ; Parameter 'msg' arrived in register rcx
ir_entry_47:
    ; IR call: get_stderr (0 args)
    sub rsp, 32
    call get_stderr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 16], rax
    ; IR call: fputs (2 args)
    sub rsp, 32
    ; Load variable: msg
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    mov rax, [rbp - 16]
    mov rdx, rax
    call fputs
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 24], rax
    mov rax, 0
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_48
    jmp ir_errdefer_end_49
ir_errdefer_ok_48:
ir_errdefer_end_49:
    jmp Lprint_err_exit
Lprint_err_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global println_err

println_err:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 160    ; Allocate 160 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'msg'
    ; Parameter 'msg' arrived in register rcx
ir_entry_50:
    ; IR call: get_stderr (0 args)
    sub rsp, 32
    call get_stderr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 16], rax
    ; IR call: fputs (2 args)
    sub rsp, 32
    ; Load variable: msg
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    mov rax, [rbp - 16]
    mov rdx, rax
    call fputs
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 24], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (1 bytes)
    lea rax, [rel Lstr_struct14]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 32], rax
    ; IR call: get_stderr (0 args)
    sub rsp, 32
    call get_stderr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 40], rax
    ; IR call: fputs (2 args)
    sub rsp, 32
    mov rax, [rbp - 32]
    mov rcx, rax
    mov rax, [rbp - 40]
    mov rdx, rax
    call fputs
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 48], rax
    mov rax, 0
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    test rax, rax
    jz ir_errdefer_ok_51
    jmp ir_errdefer_end_52
ir_errdefer_ok_51:
ir_errdefer_end_52:
    jmp Lprintln_err_exit
Lprintln_err_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller
    extern atoi
    extern atol

global digit_to_char

digit_to_char:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 64    ; Allocate 64 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'd'
    ; Parameter 'd' arrived in register rcx
ir_entry_53:
    ; Load variable: d
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 48
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_errdefer_ok_54
    jmp ir_errdefer_end_55
ir_errdefer_ok_54:
ir_errdefer_end_55:
    mov rax, [rbp - 16]
    jmp Ldigit_to_char_exit
Ldigit_to_char_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global char_to_digit

char_to_digit:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 64    ; Allocate 64 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_56:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 48
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_errdefer_ok_57
    jmp ir_errdefer_end_58
ir_errdefer_ok_57:
ir_errdefer_end_58:
    mov rax, [rbp - 16]
    jmp Lchar_to_digit_exit
Lchar_to_digit_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global is_digit

is_digit:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 112    ; Allocate 112 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_59:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 48
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_if_next_61
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 57
    mov r10, rax
    pop rax
    cmp rax, r10
    setle al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_next_63
    mov rax, 1
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_64
    jmp ir_errdefer_end_65
ir_errdefer_ok_64:
ir_errdefer_end_65:
    mov rax, 1
    jmp Lis_digit_exit
    jmp ir_if_end_62
ir_if_next_63:
ir_if_end_62:
    jmp ir_if_end_60
ir_if_next_61:
ir_if_end_60:
    mov rax, 0
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_errdefer_ok_66
    jmp ir_errdefer_end_67
ir_errdefer_ok_66:
ir_errdefer_end_67:
    mov rax, 0
    jmp Lis_digit_exit
Lis_digit_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global is_upper

is_upper:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 112    ; Allocate 112 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_68:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 65
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_if_next_70
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 90
    mov r10, rax
    pop rax
    cmp rax, r10
    setle al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_next_72
    mov rax, 1
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_73
    jmp ir_errdefer_end_74
ir_errdefer_ok_73:
ir_errdefer_end_74:
    mov rax, 1
    jmp Lis_upper_exit
    jmp ir_if_end_71
ir_if_next_72:
ir_if_end_71:
    jmp ir_if_end_69
ir_if_next_70:
ir_if_end_69:
    mov rax, 0
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_errdefer_ok_75
    jmp ir_errdefer_end_76
ir_errdefer_ok_75:
ir_errdefer_end_76:
    mov rax, 0
    jmp Lis_upper_exit
Lis_upper_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global is_lower

is_lower:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 112    ; Allocate 112 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_77:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 97
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_if_next_79
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 122
    mov r10, rax
    pop rax
    cmp rax, r10
    setle al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_next_81
    mov rax, 1
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_82
    jmp ir_errdefer_end_83
ir_errdefer_ok_82:
ir_errdefer_end_83:
    mov rax, 1
    jmp Lis_lower_exit
    jmp ir_if_end_80
ir_if_next_81:
ir_if_end_80:
    jmp ir_if_end_78
ir_if_next_79:
ir_if_end_78:
    mov rax, 0
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_errdefer_ok_84
    jmp ir_errdefer_end_85
ir_errdefer_ok_84:
ir_errdefer_end_85:
    mov rax, 0
    jmp Lis_lower_exit
Lis_lower_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global is_alpha

is_alpha:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 176    ; Allocate 176 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_86:
    ; IR call: is_upper (1 args)
    sub rsp, 32
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call is_upper
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_next_88
    mov rax, 1
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_89
    jmp ir_errdefer_end_90
ir_errdefer_ok_89:
ir_errdefer_end_90:
    mov rax, 1
    jmp Lis_alpha_exit
    jmp ir_if_end_87
ir_if_next_88:
ir_if_end_87:
    ; IR call: is_lower (1 args)
    sub rsp, 32
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call is_lower
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_if_next_92
    mov rax, 1
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    test rax, rax
    jz ir_errdefer_ok_93
    jmp ir_errdefer_end_94
ir_errdefer_ok_93:
ir_errdefer_end_94:
    mov rax, 1
    jmp Lis_alpha_exit
    jmp ir_if_end_91
ir_if_next_92:
ir_if_end_91:
    mov rax, 0
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    test rax, rax
    jz ir_errdefer_ok_95
    jmp ir_errdefer_end_96
ir_errdefer_ok_95:
ir_errdefer_end_96:
    mov rax, 0
    jmp Lis_alpha_exit
Lis_alpha_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global is_alnum

is_alnum:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 176    ; Allocate 176 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_97:
    ; IR call: is_alpha (1 args)
    sub rsp, 32
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call is_alpha
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_next_99
    mov rax, 1
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_100
    jmp ir_errdefer_end_101
ir_errdefer_ok_100:
ir_errdefer_end_101:
    mov rax, 1
    jmp Lis_alnum_exit
    jmp ir_if_end_98
ir_if_next_99:
ir_if_end_98:
    ; IR call: is_digit (1 args)
    sub rsp, 32
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call is_digit
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_if_next_103
    mov rax, 1
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    test rax, rax
    jz ir_errdefer_ok_104
    jmp ir_errdefer_end_105
ir_errdefer_ok_104:
ir_errdefer_end_105:
    mov rax, 1
    jmp Lis_alnum_exit
    jmp ir_if_end_102
ir_if_next_103:
ir_if_end_102:
    mov rax, 0
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    test rax, rax
    jz ir_errdefer_ok_106
    jmp ir_errdefer_end_107
ir_errdefer_ok_106:
ir_errdefer_end_107:
    mov rax, 0
    jmp Lis_alnum_exit
Lis_alnum_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global is_space

is_space:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 320    ; Allocate 320 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_108:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 32
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_if_next_110
    mov rax, 1
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_errdefer_ok_111
    jmp ir_errdefer_end_112
ir_errdefer_ok_111:
ir_errdefer_end_112:
    mov rax, 1
    jmp Lis_space_exit
    jmp ir_if_end_109
ir_if_next_110:
ir_if_end_109:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 9
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_if_next_114
    mov rax, 1
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_errdefer_ok_115
    jmp ir_errdefer_end_116
ir_errdefer_ok_115:
ir_errdefer_end_116:
    mov rax, 1
    jmp Lis_space_exit
    jmp ir_if_end_113
ir_if_next_114:
ir_if_end_113:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 10
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_if_next_118
    mov rax, 1
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    test rax, rax
    jz ir_errdefer_ok_119
    jmp ir_errdefer_end_120
ir_errdefer_ok_119:
ir_errdefer_end_120:
    mov rax, 1
    jmp Lis_space_exit
    jmp ir_if_end_117
ir_if_next_118:
ir_if_end_117:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 13
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    test rax, rax
    jz ir_if_next_122
    mov rax, 1
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    test rax, rax
    jz ir_errdefer_ok_123
    jmp ir_errdefer_end_124
ir_errdefer_ok_123:
ir_errdefer_end_124:
    mov rax, 1
    jmp Lis_space_exit
    jmp ir_if_end_121
ir_if_next_122:
ir_if_end_121:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 12
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 80], rax
    mov rax, [rbp - 80]
    test rax, rax
    jz ir_if_next_126
    mov rax, 1
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    test rax, rax
    jz ir_errdefer_ok_127
    jmp ir_errdefer_end_128
ir_errdefer_ok_127:
ir_errdefer_end_128:
    mov rax, 1
    jmp Lis_space_exit
    jmp ir_if_end_125
ir_if_next_126:
ir_if_end_125:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 11
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    test rax, rax
    jz ir_if_next_130
    mov rax, 1
    mov [rbp - 104], rax
    mov rax, [rbp - 104]
    test rax, rax
    jz ir_errdefer_ok_131
    jmp ir_errdefer_end_132
ir_errdefer_ok_131:
ir_errdefer_end_132:
    mov rax, 1
    jmp Lis_space_exit
    jmp ir_if_end_129
ir_if_next_130:
ir_if_end_129:
    mov rax, 0
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    test rax, rax
    jz ir_errdefer_ok_133
    jmp ir_errdefer_end_134
ir_errdefer_ok_133:
ir_errdefer_end_134:
    mov rax, 0
    jmp Lis_space_exit
Lis_space_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global to_lower

to_lower:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 128    ; Allocate 128 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_135:
    ; IR call: is_upper (1 args)
    sub rsp, 32
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call is_upper
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_next_137
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 32
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_errdefer_ok_138
    jmp ir_errdefer_end_139
ir_errdefer_ok_138:
ir_errdefer_end_139:
    mov rax, [rbp - 32]
    jmp Lto_lower_exit
    jmp ir_if_end_136
ir_if_next_137:
ir_if_end_136:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_errdefer_ok_140
    jmp ir_errdefer_end_141
ir_errdefer_ok_140:
ir_errdefer_end_141:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    jmp Lto_lower_exit
Lto_lower_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global to_upper

to_upper:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 128    ; Allocate 128 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_142:
    ; IR call: is_lower (1 args)
    sub rsp, 32
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call is_lower
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_next_144
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 32
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_errdefer_ok_145
    jmp ir_errdefer_end_146
ir_errdefer_ok_145:
ir_errdefer_end_146:
    mov rax, [rbp - 32]
    jmp Lto_upper_exit
    jmp ir_if_end_143
ir_if_next_144:
ir_if_end_143:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_errdefer_ok_147
    jmp ir_errdefer_end_148
ir_errdefer_ok_147:
ir_errdefer_end_148:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    jmp Lto_upper_exit
Lto_upper_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global strlen

strlen:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 176    ; Allocate 176 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 's'
    ; Parameter 's' arrived in register rcx
ir_entry_149:
    mov rax, 0
    ; Store to variable: i
    mov qword [rbp - 16], rax  ; To stack [rbp - 16]
ir_while_150:
    ; Load variable: s
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_152
    jmp ir_nonnull_153
ir_trap_null_152:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct16]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_153:
    ; Load variable: i
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 24], rax
    ; Load variable: s
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 24]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    movzx rax, byte [rax]
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_while_end_151
    ; Load variable: i
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    ; Store to variable: i
    mov qword [rbp - 16], rax  ; To stack [rbp - 16]
    jmp ir_while_150
ir_while_end_151:
    ; Load variable: i
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    test rax, rax
    jz ir_errdefer_ok_154
    jmp ir_errdefer_end_155
ir_errdefer_ok_154:
ir_errdefer_end_155:
    ; Load variable: i
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    jmp Lstrlen_exit
Lstrlen_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global streq

streq:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 480    ; Allocate 480 bytes on stack (aligned)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 'a'
    ; Parameter 'a' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'b'
    ; Parameter 'b' arrived in register rdx
ir_entry_156:
    mov rax, 0
    ; Store to variable: i
    mov qword [rbp - 24], rax  ; To stack [rbp - 24]
ir_while_157:
    ; Load variable: a
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_159
    jmp ir_nonnull_160
ir_trap_null_159:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct18]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_160:
    ; Load variable: i
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 32], rax
    ; Load variable: a
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 32]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    movzx rax, byte [rax]
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    test rax, rax
    jz ir_while_end_158
    ; Load variable: a
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_163
    jmp ir_nonnull_164
ir_trap_null_163:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct20]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_164:
    ; Load variable: i
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 64], rax
    ; Load variable: a
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 64]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    movzx rax, byte [rax]
    mov [rbp - 80], rax
    ; Load variable: b
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    test rax, rax
    jz ir_trap_null_165
    jmp ir_nonnull_166
ir_trap_null_165:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct22]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_166:
    ; Load variable: i
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 88], rax
    ; Load variable: b
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, [rbp - 88]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    movzx rax, byte [rax]
    mov [rbp - 104], rax
    mov rax, [rbp - 80]
    push rax
    mov rax, [rbp - 104]
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    test rax, rax
    jz ir_if_next_162
    mov rax, 0
    mov [rbp - 120], rax
    mov rax, [rbp - 120]
    test rax, rax
    jz ir_errdefer_ok_167
    jmp ir_errdefer_end_168
ir_errdefer_ok_167:
ir_errdefer_end_168:
    mov rax, 0
    jmp Lstreq_exit
    jmp ir_if_end_161
ir_if_next_162:
ir_if_end_161:
    ; Load variable: i
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 128], rax
    mov rax, [rbp - 128]
    ; Store to variable: i
    mov qword [rbp - 24], rax  ; To stack [rbp - 24]
    jmp ir_while_157
ir_while_end_158:
    ; Load variable: b
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    test rax, rax
    jz ir_trap_null_171
    jmp ir_nonnull_172
ir_trap_null_171:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct24]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_172:
    ; Load variable: i
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 136], rax
    ; Load variable: b
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, [rbp - 136]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 144], rax
    mov rax, [rbp - 144]
    movzx rax, byte [rax]
    mov [rbp - 152], rax
    mov rax, [rbp - 152]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 160], rax
    mov rax, [rbp - 160]
    test rax, rax
    jz ir_if_next_170
    mov rax, 0
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    test rax, rax
    jz ir_errdefer_ok_173
    jmp ir_errdefer_end_174
ir_errdefer_ok_173:
ir_errdefer_end_174:
    mov rax, 0
    jmp Lstreq_exit
    jmp ir_if_end_169
ir_if_next_170:
ir_if_end_169:
    mov rax, 1
    mov [rbp - 176], rax
    mov rax, [rbp - 176]
    test rax, rax
    jz ir_errdefer_ok_175
    jmp ir_errdefer_end_176
ir_errdefer_ok_175:
ir_errdefer_end_176:
    mov rax, 1
    jmp Lstreq_exit
Lstreq_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global strncmp

strncmp:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 960    ; Allocate 960 bytes on stack (aligned)
    ; Registering 4 function parameters
    mov [rbp - 8], rcx  ; Home param 'buf'
    ; Parameter 'buf' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'offset'
    ; Parameter 'offset' arrived in register rdx
    mov [rbp - 24], r8  ; Home param 'needle'
    ; Parameter 'needle' arrived in register r8
    mov [rbp - 32], r9  ; Home param 'buf_len'
    ; Parameter 'buf_len' arrived in register r9
ir_entry_177:
    ; Load variable: offset
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_if_next_179
    mov rax, 1
    neg rax
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    test rax, rax
    jz ir_errdefer_ok_180
    jmp ir_errdefer_end_181
ir_errdefer_ok_180:
ir_errdefer_end_181:
    mov rax, [rbp - 56]
    jmp Lstrncmp_exit
    jmp ir_if_end_178
ir_if_next_179:
ir_if_end_178:
    ; Load variable: buf_len
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    test rax, rax
    jz ir_if_next_183
    mov rax, 1
    neg rax
    mov [rbp - 80], rax
    mov rax, [rbp - 80]
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    test rax, rax
    jz ir_errdefer_ok_184
    jmp ir_errdefer_end_185
ir_errdefer_ok_184:
ir_errdefer_end_185:
    mov rax, [rbp - 80]
    jmp Lstrncmp_exit
    jmp ir_if_end_182
ir_if_next_183:
ir_if_end_182:
    ; Load variable: offset
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    ; Load variable: buf_len
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    mov r10, rax
    pop rax
    cmp rax, r10
    setg al
    movzx rax, al
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    test rax, rax
    jz ir_if_next_187
    mov rax, 1
    neg rax
    mov [rbp - 104], rax
    mov rax, [rbp - 104]
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    test rax, rax
    jz ir_errdefer_ok_188
    jmp ir_errdefer_end_189
ir_errdefer_ok_188:
ir_errdefer_end_189:
    mov rax, [rbp - 104]
    jmp Lstrncmp_exit
    jmp ir_if_end_186
ir_if_next_187:
ir_if_end_186:
    mov rax, 0
    ; Store to variable: i
    mov dword [rbp - 36], eax  ; To stack [rbp - 36]
ir_while_190:
    ; Load variable: needle
    mov rax, qword [rbp - 24]  ; String param ptr
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 120], rax
    mov rax, [rbp - 120]
    mov rax, qword [rax]
    mov [rbp - 128], rax
    ; Load variable: i
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    push rax
    mov rax, [rbp - 128]
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 136], rax
    mov rax, [rbp - 136]
    test rax, rax
    jz ir_while_end_191
    ; Load variable: offset
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    ; Load variable: i
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 144], rax
    mov rax, [rbp - 144]
    push rax
    ; Load variable: buf_len
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 152], rax
    mov rax, [rbp - 152]
    test rax, rax
    jz ir_if_next_193
    mov rax, 1
    neg rax
    mov [rbp - 160], rax
    mov rax, [rbp - 160]
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    test rax, rax
    jz ir_errdefer_ok_194
    jmp ir_errdefer_end_195
ir_errdefer_ok_194:
ir_errdefer_end_195:
    mov rax, [rbp - 160]
    jmp Lstrncmp_exit
    jmp ir_if_end_192
ir_if_next_193:
ir_if_end_192:
    ; Load variable: offset
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    ; Load variable: i
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 176], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_198
    jmp ir_nonnull_199
ir_trap_null_198:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct26]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_199:
    mov rax, [rbp - 176]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 184], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 184]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 192], rax
    mov rax, [rbp - 192]
    movzx rax, byte [rax]
    mov [rbp - 200], rax
    ; Load variable: needle
    mov rax, qword [rbp - 24]  ; String param ptr
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 208], rax
    mov rax, [rbp - 208]
    mov rax, qword [rax]
    mov [rbp - 216], rax
    mov rax, [rbp - 216]
    test rax, rax
    jz ir_trap_null_200
    jmp ir_nonnull_201
ir_trap_null_200:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct28]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_201:
    ; Load variable: i
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 224], rax
    mov rax, [rbp - 216]
    push rax
    mov rax, [rbp - 224]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 232], rax
    mov rax, [rbp - 232]
    movzx rax, byte [rax]
    mov [rbp - 240], rax
    mov rax, [rbp - 200]
    push rax
    mov rax, [rbp - 240]
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 248], rax
    mov rax, [rbp - 248]
    test rax, rax
    jz ir_if_next_197
    ; Load variable: offset
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    ; Load variable: i
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 256], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_202
    jmp ir_nonnull_203
ir_trap_null_202:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct30]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_203:
    mov rax, [rbp - 256]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 264], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 264]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 272], rax
    mov rax, [rbp - 272]
    movzx rax, byte [rax]
    mov [rbp - 280], rax
    ; Load variable: needle
    mov rax, qword [rbp - 24]  ; String param ptr
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 288], rax
    mov rax, [rbp - 288]
    mov rax, qword [rax]
    mov [rbp - 296], rax
    mov rax, [rbp - 296]
    test rax, rax
    jz ir_trap_null_204
    jmp ir_nonnull_205
ir_trap_null_204:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct32]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_205:
    ; Load variable: i
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 304], rax
    mov rax, [rbp - 296]
    push rax
    mov rax, [rbp - 304]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 312], rax
    mov rax, [rbp - 312]
    movzx rax, byte [rax]
    mov [rbp - 320], rax
    mov rax, [rbp - 280]
    push rax
    mov rax, [rbp - 320]
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 328], rax
    mov rax, [rbp - 328]
    mov [rbp - 336], rax
    mov rax, [rbp - 336]
    test rax, rax
    jz ir_errdefer_ok_206
    jmp ir_errdefer_end_207
ir_errdefer_ok_206:
ir_errdefer_end_207:
    mov rax, [rbp - 328]
    jmp Lstrncmp_exit
    jmp ir_if_end_196
ir_if_next_197:
ir_if_end_196:
    ; Load variable: i
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 344], rax
    mov rax, [rbp - 344]
    ; Store to variable: i
    mov dword [rbp - 36], eax  ; To stack [rbp - 36]
    jmp ir_while_190
ir_while_end_191:
    mov rax, 0
    mov [rbp - 352], rax
    mov rax, [rbp - 352]
    test rax, rax
    jz ir_errdefer_ok_208
    jmp ir_errdefer_end_209
ir_errdefer_ok_208:
ir_errdefer_end_209:
    mov rax, 0
    jmp Lstrncmp_exit
Lstrncmp_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller
    extern system
    extern masm_dir_exists
    extern masm_dir_create
    extern masm_file_exists
    extern masm_getcwd

global dir_exists

dir_exists:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 64    ; Allocate 64 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'path'
    ; Parameter 'path' arrived in register rcx
ir_entry_210:
    ; IR call: masm_dir_exists (1 args)
    sub rsp, 32
    ; Load variable: path
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call masm_dir_exists
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_errdefer_ok_211
    jmp ir_errdefer_end_212
ir_errdefer_ok_211:
ir_errdefer_end_212:
    mov rax, [rbp - 16]
    jmp Ldir_exists_exit
Ldir_exists_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global dir_create

dir_create:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 64    ; Allocate 64 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'path'
    ; Parameter 'path' arrived in register rcx
ir_entry_213:
    ; IR call: masm_dir_create (1 args)
    sub rsp, 32
    ; Load variable: path
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call masm_dir_create
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_errdefer_ok_214
    jmp ir_errdefer_end_215
ir_errdefer_ok_214:
ir_errdefer_end_215:
    mov rax, [rbp - 16]
    jmp Ldir_create_exit
Ldir_create_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global file_exists

file_exists:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 64    ; Allocate 64 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'path'
    ; Parameter 'path' arrived in register rcx
ir_entry_216:
    ; IR call: masm_file_exists (1 args)
    sub rsp, 32
    ; Load variable: path
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call masm_file_exists
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_errdefer_ok_217
    jmp ir_errdefer_end_218
ir_errdefer_ok_217:
ir_errdefer_end_218:
    mov rax, [rbp - 16]
    jmp Lfile_exists_exit
Lfile_exists_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global getcwd

getcwd:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 64    ; Allocate 64 bytes on stack (aligned)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 'buf'
    ; Parameter 'buf' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'size'
    ; Parameter 'size' arrived in register rdx
ir_entry_219:
    ; IR call: masm_getcwd (2 args)
    sub rsp, 32
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    ; Load variable: size
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    mov rdx, rax
    call masm_getcwd
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_220
    jmp ir_errdefer_end_221
ir_errdefer_ok_220:
ir_errdefer_end_221:
    mov rax, [rbp - 24]
    jmp Lgetcwd_exit
Lgetcwd_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global append_str

append_str:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 1136    ; Allocate 1136 bytes on stack (aligned)
    ; Registering 4 function parameters
    mov [rbp - 8], rcx  ; Home param 'buf'
    ; Parameter 'buf' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'pos'
    ; Parameter 'pos' arrived in register rdx
    mov [rbp - 24], r8  ; Home param 'max_len'
    ; Parameter 'max_len' arrived in register r8
    mov [rbp - 32], r9  ; Home param 's'
    ; Parameter 's' arrived in register r9
ir_entry_222:
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_sc_rhs_225
    jmp ir_sc_true_226
ir_sc_rhs_225:
    ; Load variable: pos
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    test rax, rax
    jz ir_sc_false_227
ir_sc_true_226:
    mov rax, 1
    mov [rbp - 64], rax
    jmp ir_sc_end_228
ir_sc_false_227:
    mov rax, 0
    mov [rbp - 64], rax
ir_sc_end_228:
    mov rax, [rbp - 64]
    test rax, rax
    jz ir_sc_rhs_229
    jmp ir_sc_true_230
ir_sc_rhs_229:
    ; Load variable: s
    mov rax, qword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 80], rax
    mov rax, [rbp - 80]
    test rax, rax
    jz ir_sc_false_231
ir_sc_true_230:
    mov rax, 1
    mov [rbp - 88], rax
    jmp ir_sc_end_232
ir_sc_false_231:
    mov rax, 0
    mov [rbp - 88], rax
ir_sc_end_232:
    mov rax, [rbp - 88]
    test rax, rax
    jz ir_sc_rhs_233
    jmp ir_sc_true_234
ir_sc_rhs_233:
    ; Load variable: max_len
    movsxd rax, dword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    setle al
    movzx rax, al
    mov [rbp - 104], rax
    mov rax, [rbp - 104]
    test rax, rax
    jz ir_sc_false_235
ir_sc_true_234:
    mov rax, 1
    mov [rbp - 112], rax
    jmp ir_sc_end_236
ir_sc_false_235:
    mov rax, 0
    mov [rbp - 112], rax
ir_sc_end_236:
    mov rax, [rbp - 112]
    test rax, rax
    jz ir_if_next_224
    mov rax, 1
    neg rax
    mov [rbp - 128], rax
    mov rax, [rbp - 128]
    mov [rbp - 136], rax
    mov rax, [rbp - 136]
    test rax, rax
    jz ir_errdefer_ok_237
    jmp ir_errdefer_end_238
ir_errdefer_ok_237:
ir_errdefer_end_238:
    mov rax, [rbp - 128]
    jmp Lappend_str_exit
    jmp ir_if_end_223
ir_if_next_224:
ir_if_end_223:
    mov rax, 0
    ; Store to variable: i
    mov dword [rbp - 36], eax  ; To stack [rbp - 36]
ir_while_239:
    ; Load variable: s
    mov rax, qword [rbp - 32]  ; From stack [rbp - 32]
    test rax, rax
    jz ir_trap_null_241
    jmp ir_nonnull_242
ir_trap_null_241:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct34]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_242:
    ; Load variable: i
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 144], rax
    ; Load variable: s
    mov rax, qword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, [rbp - 144]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 152], rax
    mov rax, [rbp - 152]
    movzx rax, byte [rax]
    mov [rbp - 160], rax
    mov rax, [rbp - 160]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    test rax, rax
    jz ir_sc_false_245
ir_sc_rhs_243:
    ; Load variable: pos
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    test rax, rax
    jz ir_trap_null_247
    jmp ir_nonnull_248
ir_trap_null_247:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct36]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_248:
    mov rax, 0
    push rax
    mov rax, 4
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 176], rax
    ; Load variable: pos
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, [rbp - 176]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 184], rax
    mov rax, [rbp - 184]
    mov eax, dword [rax]
    mov [rbp - 192], rax
    ; Load variable: max_len
    movsxd rax, dword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 200], rax
    mov rax, [rbp - 192]
    push rax
    mov rax, [rbp - 200]
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 208], rax
    mov rax, [rbp - 208]
    test rax, rax
    jz ir_sc_false_245
ir_sc_true_244:
    mov rax, 1
    mov [rbp - 216], rax
    jmp ir_sc_end_246
ir_sc_false_245:
    mov rax, 0
    mov [rbp - 216], rax
ir_sc_end_246:
    mov rax, [rbp - 216]
    test rax, rax
    jz ir_while_end_240
    ; Load variable: s
    mov rax, qword [rbp - 32]  ; From stack [rbp - 32]
    test rax, rax
    jz ir_trap_null_249
    jmp ir_nonnull_250
ir_trap_null_249:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct38]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_250:
    ; Load variable: i
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 232], rax
    ; Load variable: s
    mov rax, qword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, [rbp - 232]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 240], rax
    mov rax, [rbp - 240]
    movzx rax, byte [rax]
    mov [rbp - 248], rax
    ; Load variable: pos
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    test rax, rax
    jz ir_trap_null_251
    jmp ir_nonnull_252
ir_trap_null_251:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct40]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_252:
    mov rax, 0
    push rax
    mov rax, 4
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 256], rax
    ; Load variable: pos
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, [rbp - 256]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 264], rax
    mov rax, [rbp - 264]
    mov eax, dword [rax]
    mov [rbp - 272], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_253
    jmp ir_nonnull_254
ir_trap_null_253:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct42]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_254:
    mov rax, [rbp - 272]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 280], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 280]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 288], rax
    mov rax, [rbp - 288]
    push rax
    mov rax, [rbp - 248]
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: pos
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    test rax, rax
    jz ir_trap_null_255
    jmp ir_nonnull_256
ir_trap_null_255:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct44]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_256:
    mov rax, 0
    push rax
    mov rax, 4
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 304], rax
    ; Load variable: pos
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, [rbp - 304]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 312], rax
    mov rax, [rbp - 312]
    mov eax, dword [rax]
    mov [rbp - 320], rax
    mov rax, [rbp - 320]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 328], rax
    ; Load variable: pos
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    test rax, rax
    jz ir_trap_null_257
    jmp ir_nonnull_258
ir_trap_null_257:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct46]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_258:
    mov rax, 0
    push rax
    mov rax, 4
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 336], rax
    ; Load variable: pos
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, [rbp - 336]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 344], rax
    mov rax, [rbp - 344]
    push rax
    mov rax, [rbp - 328]
    mov rcx, rax
    pop rax
    mov dword [rax], ecx
    ; Load variable: i
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 360], rax
    mov rax, [rbp - 360]
    ; Store to variable: i
    mov dword [rbp - 36], eax  ; To stack [rbp - 36]
    jmp ir_while_239
ir_while_end_240:
    ; Load variable: s
    mov rax, qword [rbp - 32]  ; From stack [rbp - 32]
    test rax, rax
    jz ir_trap_null_261
    jmp ir_nonnull_262
ir_trap_null_261:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct48]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_262:
    ; Load variable: i
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 368], rax
    ; Load variable: s
    mov rax, qword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, [rbp - 368]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 376], rax
    mov rax, [rbp - 376]
    movzx rax, byte [rax]
    mov [rbp - 384], rax
    mov rax, [rbp - 384]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 392], rax
    mov rax, [rbp - 392]
    test rax, rax
    jz ir_if_next_260
    mov rax, 1
    neg rax
    mov [rbp - 400], rax
    mov rax, [rbp - 400]
    mov [rbp - 408], rax
    mov rax, [rbp - 408]
    test rax, rax
    jz ir_errdefer_ok_263
    jmp ir_errdefer_end_264
ir_errdefer_ok_263:
ir_errdefer_end_264:
    mov rax, [rbp - 400]
    jmp Lappend_str_exit
    jmp ir_if_end_259
ir_if_next_260:
ir_if_end_259:
    mov rax, 0
    mov [rbp - 416], rax
    mov rax, [rbp - 416]
    test rax, rax
    jz ir_errdefer_ok_265
    jmp ir_errdefer_end_266
ir_errdefer_ok_265:
ir_errdefer_end_266:
    mov rax, 0
    jmp Lappend_str_exit
Lappend_str_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global starts_with

starts_with:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 480    ; Allocate 480 bytes on stack (aligned)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 's'
    ; Parameter 's' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'prefix'
    ; Parameter 'prefix' arrived in register rdx
ir_entry_267:
    ; Load variable: s
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_sc_rhs_270
    jmp ir_sc_true_271
ir_sc_rhs_270:
    ; Load variable: prefix
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_sc_false_272
ir_sc_true_271:
    mov rax, 1
    mov [rbp - 48], rax
    jmp ir_sc_end_273
ir_sc_false_272:
    mov rax, 0
    mov [rbp - 48], rax
ir_sc_end_273:
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_if_next_269
    mov rax, 0
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    test rax, rax
    jz ir_errdefer_ok_274
    jmp ir_errdefer_end_275
ir_errdefer_ok_274:
ir_errdefer_end_275:
    mov rax, 0
    jmp Lstarts_with_exit
    jmp ir_if_end_268
ir_if_next_269:
ir_if_end_268:
    mov rax, 0
    ; Store to variable: i
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
ir_while_276:
    ; Load variable: prefix
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    test rax, rax
    jz ir_trap_null_278
    jmp ir_nonnull_279
ir_trap_null_278:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct50]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_279:
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 72], rax
    ; Load variable: prefix
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, [rbp - 72]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 80], rax
    mov rax, [rbp - 80]
    movzx rax, byte [rax]
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    test rax, rax
    jz ir_while_end_277
    ; Load variable: s
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_282
    jmp ir_nonnull_283
ir_trap_null_282:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct52]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_283:
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 104], rax
    ; Load variable: s
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 104]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    movzx rax, byte [rax]
    mov [rbp - 120], rax
    ; Load variable: prefix
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    test rax, rax
    jz ir_trap_null_284
    jmp ir_nonnull_285
ir_trap_null_284:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct54]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_285:
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 128], rax
    ; Load variable: prefix
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, [rbp - 128]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 136], rax
    mov rax, [rbp - 136]
    movzx rax, byte [rax]
    mov [rbp - 144], rax
    mov rax, [rbp - 120]
    push rax
    mov rax, [rbp - 144]
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 152], rax
    mov rax, [rbp - 152]
    test rax, rax
    jz ir_if_next_281
    mov rax, 0
    mov [rbp - 160], rax
    mov rax, [rbp - 160]
    test rax, rax
    jz ir_errdefer_ok_286
    jmp ir_errdefer_end_287
ir_errdefer_ok_286:
ir_errdefer_end_287:
    mov rax, 0
    jmp Lstarts_with_exit
    jmp ir_if_end_280
ir_if_next_281:
ir_if_end_280:
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    ; Store to variable: i
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
    jmp ir_while_276
ir_while_end_277:
    mov rax, 1
    mov [rbp - 176], rax
    mov rax, [rbp - 176]
    test rax, rax
    jz ir_errdefer_ok_288
    jmp ir_errdefer_end_289
ir_errdefer_ok_288:
ir_errdefer_end_289:
    mov rax, 1
    jmp Lstarts_with_exit
Lstarts_with_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global build_path3

build_path3:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 496    ; Allocate 496 bytes on stack (aligned)
    ; Registering 5 function parameters
    mov [rbp - 8], rcx  ; Home param 'a'
    ; Parameter 'a' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'b'
    ; Parameter 'b' arrived in register rdx
    mov [rbp - 24], r8  ; Home param 'c'
    ; Parameter 'c' arrived in register r8
    mov [rbp - 32], r9  ; Home param 'out'
    ; Parameter 'out' arrived in register r9
    mov rax, [rbp + 48]  ; Load stack param 'out_max'
    mov [rbp - 40], rax  ; Home param 'out_max'
    ; Parameter 'out_max' arrived on stack [rbp + 48]
ir_entry_290:
    mov rax, 0
    ; Store to variable: pos
    mov dword [rbp - 44], eax  ; To stack [rbp - 44]
    lea rax, [rbp - 44]
    mov [rbp - 56], rax
    ; IR call: append_str (4 args)
    sub rsp, 32
    ; Load variable: out
    mov rax, qword [rbp - 32]  ; From stack [rbp - 32]
    mov rcx, rax
    mov rax, [rbp - 56]
    mov rdx, rax
    ; Load variable: out_max
    movsxd rax, dword [rbp - 40]  ; From stack [rbp - 40]
    mov r8, rax
    ; Load variable: a
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov r9, rax
    call append_str
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    test rax, rax
    jz ir_if_next_292
    mov rax, 1
    neg rax
    mov [rbp - 80], rax
    mov rax, [rbp - 80]
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    test rax, rax
    jz ir_errdefer_ok_293
    jmp ir_errdefer_end_294
ir_errdefer_ok_293:
ir_errdefer_end_294:
    mov rax, [rbp - 80]
    jmp Lbuild_path3_exit
    jmp ir_if_end_291
ir_if_next_292:
ir_if_end_291:
    lea rax, [rbp - 44]
    mov [rbp - 96], rax
    ; IR call: append_str (4 args)
    sub rsp, 32
    ; Load variable: out
    mov rax, qword [rbp - 32]  ; From stack [rbp - 32]
    mov rcx, rax
    mov rax, [rbp - 96]
    mov rdx, rax
    ; Load variable: out_max
    movsxd rax, dword [rbp - 40]  ; From stack [rbp - 40]
    mov r8, rax
    ; Load variable: b
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov r9, rax
    call append_str
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 104], rax
    mov rax, [rbp - 104]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    test rax, rax
    jz ir_if_next_296
    mov rax, 1
    neg rax
    mov [rbp - 120], rax
    mov rax, [rbp - 120]
    mov [rbp - 128], rax
    mov rax, [rbp - 128]
    test rax, rax
    jz ir_errdefer_ok_297
    jmp ir_errdefer_end_298
ir_errdefer_ok_297:
ir_errdefer_end_298:
    mov rax, [rbp - 120]
    jmp Lbuild_path3_exit
    jmp ir_if_end_295
ir_if_next_296:
ir_if_end_295:
    lea rax, [rbp - 44]
    mov [rbp - 136], rax
    ; IR call: append_str (4 args)
    sub rsp, 32
    ; Load variable: out
    mov rax, qword [rbp - 32]  ; From stack [rbp - 32]
    mov rcx, rax
    mov rax, [rbp - 136]
    mov rdx, rax
    ; Load variable: out_max
    movsxd rax, dword [rbp - 40]  ; From stack [rbp - 40]
    mov r8, rax
    ; Load variable: c
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov r9, rax
    call append_str
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 144], rax
    mov rax, [rbp - 144]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 152], rax
    mov rax, [rbp - 152]
    test rax, rax
    jz ir_if_next_300
    mov rax, 1
    neg rax
    mov [rbp - 160], rax
    mov rax, [rbp - 160]
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    test rax, rax
    jz ir_errdefer_ok_301
    jmp ir_errdefer_end_302
ir_errdefer_ok_301:
ir_errdefer_end_302:
    mov rax, [rbp - 160]
    jmp Lbuild_path3_exit
    jmp ir_if_end_299
ir_if_next_300:
ir_if_end_299:
    ; Load variable: out
    mov rax, qword [rbp - 32]  ; From stack [rbp - 32]
    test rax, rax
    jz ir_trap_null_303
    jmp ir_nonnull_304
ir_trap_null_303:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct56]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_304:
    ; Load variable: pos
    movsxd rax, dword [rbp - 44]  ; From stack [rbp - 44]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 176], rax
    ; Load variable: out
    mov rax, qword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, [rbp - 176]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 184], rax
    mov rax, [rbp - 184]
    push rax
    mov rax, 0
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    mov rax, 0
    mov [rbp - 200], rax
    mov rax, [rbp - 200]
    test rax, rax
    jz ir_errdefer_ok_305
    jmp ir_errdefer_end_306
ir_errdefer_ok_305:
ir_errdefer_end_306:
    mov rax, 0
    jmp Lbuild_path3_exit
Lbuild_path3_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global install_local_package

install_local_package:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 3040    ; Allocate 3040 bytes on stack (aligned)
    ; Registering 3 function parameters
    mov [rbp - 8], rcx  ; Home param 'name'
    ; Parameter 'name' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'local_path'
    ; Parameter 'local_path' arrived in register rdx
    mov [rbp - 24], r8  ; Home param 'cache_dir'
    ; Parameter 'cache_dir' arrived in register r8
ir_entry_307:
    ; Load variable: name
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 1064], rax
    mov rax, [rbp - 1064]
    test rax, rax
    jz ir_sc_rhs_310
    jmp ir_sc_true_311
ir_sc_rhs_310:
    ; Load variable: local_path
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 1072], rax
    mov rax, [rbp - 1072]
    test rax, rax
    jz ir_sc_false_312
ir_sc_true_311:
    mov rax, 1
    mov [rbp - 1080], rax
    jmp ir_sc_end_313
ir_sc_false_312:
    mov rax, 0
    mov [rbp - 1080], rax
ir_sc_end_313:
    mov rax, [rbp - 1080]
    test rax, rax
    jz ir_sc_rhs_314
    jmp ir_sc_true_315
ir_sc_rhs_314:
    ; Load variable: cache_dir
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 1096], rax
    mov rax, [rbp - 1096]
    test rax, rax
    jz ir_sc_false_316
ir_sc_true_315:
    mov rax, 1
    mov [rbp - 1104], rax
    jmp ir_sc_end_317
ir_sc_false_316:
    mov rax, 0
    mov [rbp - 1104], rax
ir_sc_end_317:
    mov rax, [rbp - 1104]
    test rax, rax
    jz ir_if_next_309
    mov rax, 1
    neg rax
    mov [rbp - 1120], rax
    mov rax, [rbp - 1120]
    mov [rbp - 1128], rax
    mov rax, [rbp - 1128]
    test rax, rax
    jz ir_errdefer_ok_318
    jmp ir_errdefer_end_319
ir_errdefer_ok_318:
ir_errdefer_end_319:
    mov rax, [rbp - 1120]
    jmp Linstall_local_package_exit
    jmp ir_if_end_308
ir_if_next_309:
ir_if_end_308:
    ; IR call: dir_exists (1 args)
    sub rsp, 32
    ; Load variable: local_path
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov rcx, rax
    call dir_exists
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1136], rax
    mov rax, [rbp - 1136]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 1144], rax
    mov rax, [rbp - 1144]
    test rax, rax
    jz ir_if_next_321
    mov rax, 1
    neg rax
    mov [rbp - 1152], rax
    mov rax, [rbp - 1152]
    mov [rbp - 1160], rax
    mov rax, [rbp - 1160]
    test rax, rax
    jz ir_errdefer_ok_322
    jmp ir_errdefer_end_323
ir_errdefer_ok_322:
ir_errdefer_end_323:
    mov rax, [rbp - 1152]
    jmp Linstall_local_package_exit
    jmp ir_if_end_320
ir_if_next_321:
ir_if_end_320:
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (5 bytes)
    lea rax, [rel Lstr_struct58]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1168], rax
    ; IR call: dir_create (1 args)
    sub rsp, 32
    mov rax, [rbp - 1168]
    mov rcx, rax
    call dir_create
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1176], rax
    ; IR call: dir_create (1 args)
    sub rsp, 32
    ; Load variable: cache_dir
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov rcx, rax
    call dir_create
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1184], rax
    mov rax, 0
    ; Store to variable: pos
    mov dword [rbp - 1052], eax  ; To stack [rbp - 1052]
    mov rax, 0
    push rax
    mov rax, 1024
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1192], rax
    mov rax, [rbp - 1192]
    test rax, rax
    jz ir_trap_bounds_326
    jmp ir_in_bounds_327
ir_trap_bounds_326:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct60]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_327:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1200], rax
    ; Load variable: cmd_buf
    lea rax, [rbp - 1048]  ; Local array base
    push rax
    mov rax, [rbp - 1200]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1208], rax
    lea rax, [rbp - 1052]
    mov [rbp - 1216], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (16 bytes)
    lea rax, [rel Lstr_struct62]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1224], rax
    ; IR call: append_str (4 args)
    sub rsp, 32
    mov rax, [rbp - 1208]
    mov rcx, rax
    mov rax, [rbp - 1216]
    mov rdx, rax
    mov rax, 1024
    mov r8, rax
    mov rax, [rbp - 1224]
    mov r9, rax
    call append_str
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1232], rax
    mov rax, [rbp - 1232]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 1240], rax
    mov rax, [rbp - 1240]
    test rax, rax
    jz ir_if_next_325
    mov rax, 2
    neg rax
    mov [rbp - 1248], rax
    mov rax, [rbp - 1248]
    mov [rbp - 1256], rax
    mov rax, [rbp - 1256]
    test rax, rax
    jz ir_errdefer_ok_328
    jmp ir_errdefer_end_329
ir_errdefer_ok_328:
ir_errdefer_end_329:
    mov rax, [rbp - 1248]
    jmp Linstall_local_package_exit
    jmp ir_if_end_324
ir_if_next_325:
ir_if_end_324:
    mov rax, 0
    push rax
    mov rax, 1024
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1264], rax
    mov rax, [rbp - 1264]
    test rax, rax
    jz ir_trap_bounds_332
    jmp ir_in_bounds_333
ir_trap_bounds_332:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct64]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_333:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1272], rax
    ; Load variable: cmd_buf
    lea rax, [rbp - 1048]  ; Local array base
    push rax
    mov rax, [rbp - 1272]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1280], rax
    lea rax, [rbp - 1052]
    mov [rbp - 1288], rax
    ; IR call: append_str (4 args)
    sub rsp, 32
    mov rax, [rbp - 1280]
    mov rcx, rax
    mov rax, [rbp - 1288]
    mov rdx, rax
    mov rax, 1024
    mov r8, rax
    ; Load variable: local_path
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov r9, rax
    call append_str
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1296], rax
    mov rax, [rbp - 1296]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 1304], rax
    mov rax, [rbp - 1304]
    test rax, rax
    jz ir_if_next_331
    mov rax, 2
    neg rax
    mov [rbp - 1312], rax
    mov rax, [rbp - 1312]
    mov [rbp - 1320], rax
    mov rax, [rbp - 1320]
    test rax, rax
    jz ir_errdefer_ok_334
    jmp ir_errdefer_end_335
ir_errdefer_ok_334:
ir_errdefer_end_335:
    mov rax, [rbp - 1312]
    jmp Linstall_local_package_exit
    jmp ir_if_end_330
ir_if_next_331:
ir_if_end_330:
    mov rax, 0
    push rax
    mov rax, 1024
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1328], rax
    mov rax, [rbp - 1328]
    test rax, rax
    jz ir_trap_bounds_338
    jmp ir_in_bounds_339
ir_trap_bounds_338:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct66]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_339:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1336], rax
    ; Load variable: cmd_buf
    lea rax, [rbp - 1048]  ; Local array base
    push rax
    mov rax, [rbp - 1336]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1344], rax
    lea rax, [rbp - 1052]
    mov [rbp - 1352], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (3 bytes)
    lea rax, [rel Lstr_struct68]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1360], rax
    ; IR call: append_str (4 args)
    sub rsp, 32
    mov rax, [rbp - 1344]
    mov rcx, rax
    mov rax, [rbp - 1352]
    mov rdx, rax
    mov rax, 1024
    mov r8, rax
    mov rax, [rbp - 1360]
    mov r9, rax
    call append_str
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1368], rax
    mov rax, [rbp - 1368]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 1376], rax
    mov rax, [rbp - 1376]
    test rax, rax
    jz ir_if_next_337
    mov rax, 2
    neg rax
    mov [rbp - 1384], rax
    mov rax, [rbp - 1384]
    mov [rbp - 1392], rax
    mov rax, [rbp - 1392]
    test rax, rax
    jz ir_errdefer_ok_340
    jmp ir_errdefer_end_341
ir_errdefer_ok_340:
ir_errdefer_end_341:
    mov rax, [rbp - 1384]
    jmp Linstall_local_package_exit
    jmp ir_if_end_336
ir_if_next_337:
ir_if_end_336:
    mov rax, 0
    push rax
    mov rax, 1024
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1400], rax
    mov rax, [rbp - 1400]
    test rax, rax
    jz ir_trap_bounds_344
    jmp ir_in_bounds_345
ir_trap_bounds_344:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct70]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_345:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1408], rax
    ; Load variable: cmd_buf
    lea rax, [rbp - 1048]  ; Local array base
    push rax
    mov rax, [rbp - 1408]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1416], rax
    lea rax, [rbp - 1052]
    mov [rbp - 1424], rax
    ; IR call: append_str (4 args)
    sub rsp, 32
    mov rax, [rbp - 1416]
    mov rcx, rax
    mov rax, [rbp - 1424]
    mov rdx, rax
    mov rax, 1024
    mov r8, rax
    ; Load variable: cache_dir
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov r9, rax
    call append_str
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1432], rax
    mov rax, [rbp - 1432]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 1440], rax
    mov rax, [rbp - 1440]
    test rax, rax
    jz ir_if_next_343
    mov rax, 2
    neg rax
    mov [rbp - 1448], rax
    mov rax, [rbp - 1448]
    mov [rbp - 1456], rax
    mov rax, [rbp - 1456]
    test rax, rax
    jz ir_errdefer_ok_346
    jmp ir_errdefer_end_347
ir_errdefer_ok_346:
ir_errdefer_end_347:
    mov rax, [rbp - 1448]
    jmp Linstall_local_package_exit
    jmp ir_if_end_342
ir_if_next_343:
ir_if_end_342:
    mov rax, 0
    push rax
    mov rax, 1024
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1464], rax
    mov rax, [rbp - 1464]
    test rax, rax
    jz ir_trap_bounds_350
    jmp ir_in_bounds_351
ir_trap_bounds_350:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct72]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_351:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1472], rax
    ; Load variable: cmd_buf
    lea rax, [rbp - 1048]  ; Local array base
    push rax
    mov rax, [rbp - 1472]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1480], rax
    lea rax, [rbp - 1052]
    mov [rbp - 1488], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (1 bytes)
    lea rax, [rel Lstr_struct74]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1496], rax
    ; IR call: append_str (4 args)
    sub rsp, 32
    mov rax, [rbp - 1480]
    mov rcx, rax
    mov rax, [rbp - 1488]
    mov rdx, rax
    mov rax, 1024
    mov r8, rax
    mov rax, [rbp - 1496]
    mov r9, rax
    call append_str
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1504], rax
    mov rax, [rbp - 1504]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 1512], rax
    mov rax, [rbp - 1512]
    test rax, rax
    jz ir_if_next_349
    mov rax, 2
    neg rax
    mov [rbp - 1520], rax
    mov rax, [rbp - 1520]
    mov [rbp - 1528], rax
    mov rax, [rbp - 1528]
    test rax, rax
    jz ir_errdefer_ok_352
    jmp ir_errdefer_end_353
ir_errdefer_ok_352:
ir_errdefer_end_353:
    mov rax, [rbp - 1520]
    jmp Linstall_local_package_exit
    jmp ir_if_end_348
ir_if_next_349:
ir_if_end_348:
    mov rax, 0
    push rax
    mov rax, 1024
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1536], rax
    mov rax, [rbp - 1536]
    test rax, rax
    jz ir_trap_bounds_356
    jmp ir_in_bounds_357
ir_trap_bounds_356:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct76]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_357:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1544], rax
    ; Load variable: cmd_buf
    lea rax, [rbp - 1048]  ; Local array base
    push rax
    mov rax, [rbp - 1544]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1552], rax
    lea rax, [rbp - 1052]
    mov [rbp - 1560], rax
    ; IR call: append_str (4 args)
    sub rsp, 32
    mov rax, [rbp - 1552]
    mov rcx, rax
    mov rax, [rbp - 1560]
    mov rdx, rax
    mov rax, 1024
    mov r8, rax
    ; Load variable: name
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov r9, rax
    call append_str
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1568], rax
    mov rax, [rbp - 1568]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 1576], rax
    mov rax, [rbp - 1576]
    test rax, rax
    jz ir_if_next_355
    mov rax, 2
    neg rax
    mov [rbp - 1584], rax
    mov rax, [rbp - 1584]
    mov [rbp - 1592], rax
    mov rax, [rbp - 1592]
    test rax, rax
    jz ir_errdefer_ok_358
    jmp ir_errdefer_end_359
ir_errdefer_ok_358:
ir_errdefer_end_359:
    mov rax, [rbp - 1584]
    jmp Linstall_local_package_exit
    jmp ir_if_end_354
ir_if_next_355:
ir_if_end_354:
    mov rax, 0
    push rax
    mov rax, 1024
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1600], rax
    mov rax, [rbp - 1600]
    test rax, rax
    jz ir_trap_bounds_362
    jmp ir_in_bounds_363
ir_trap_bounds_362:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct78]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_363:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1608], rax
    ; Load variable: cmd_buf
    lea rax, [rbp - 1048]  ; Local array base
    push rax
    mov rax, [rbp - 1608]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1616], rax
    lea rax, [rbp - 1052]
    mov [rbp - 1624], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (1 bytes)
    lea rax, [rel Lstr_struct80]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1632], rax
    ; IR call: append_str (4 args)
    sub rsp, 32
    mov rax, [rbp - 1616]
    mov rcx, rax
    mov rax, [rbp - 1624]
    mov rdx, rax
    mov rax, 1024
    mov r8, rax
    mov rax, [rbp - 1632]
    mov r9, rax
    call append_str
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1640], rax
    mov rax, [rbp - 1640]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 1648], rax
    mov rax, [rbp - 1648]
    test rax, rax
    jz ir_if_next_361
    mov rax, 2
    neg rax
    mov [rbp - 1656], rax
    mov rax, [rbp - 1656]
    mov [rbp - 1664], rax
    mov rax, [rbp - 1664]
    test rax, rax
    jz ir_errdefer_ok_364
    jmp ir_errdefer_end_365
ir_errdefer_ok_364:
ir_errdefer_end_365:
    mov rax, [rbp - 1656]
    jmp Linstall_local_package_exit
    jmp ir_if_end_360
ir_if_next_361:
ir_if_end_360:
    ; Load variable: pos
    movsxd rax, dword [rbp - 1052]  ; From stack [rbp - 1052]
    push rax
    mov rax, 1024
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1672], rax
    mov rax, [rbp - 1672]
    test rax, rax
    jz ir_trap_bounds_366
    jmp ir_in_bounds_367
ir_trap_bounds_366:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct82]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_367:
    ; Load variable: pos
    movsxd rax, dword [rbp - 1052]  ; From stack [rbp - 1052]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1680], rax
    ; Load variable: cmd_buf
    lea rax, [rbp - 1048]  ; Local array base
    push rax
    mov rax, [rbp - 1680]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1688], rax
    mov rax, [rbp - 1688]
    push rax
    mov rax, 0
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    mov rax, 0
    push rax
    mov rax, 1024
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1704], rax
    mov rax, [rbp - 1704]
    test rax, rax
    jz ir_trap_bounds_368
    jmp ir_in_bounds_369
ir_trap_bounds_368:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct84]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_369:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1712], rax
    ; Load variable: cmd_buf
    lea rax, [rbp - 1048]  ; Local array base
    push rax
    mov rax, [rbp - 1712]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1720], rax
    ; IR call: system (1 args)
    sub rsp, 32
    mov rax, [rbp - 1720]
    mov rcx, rax
    call system
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1728], rax
    mov rax, [rbp - 1728]
    mov [rbp - 1736], rax
    mov rax, [rbp - 1736]
    test rax, rax
    jz ir_errdefer_ok_370
    jmp ir_errdefer_end_371
ir_errdefer_ok_370:
ir_errdefer_end_371:
    mov rax, [rbp - 1728]
    jmp Linstall_local_package_exit
Linstall_local_package_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global fetch_remote_package

fetch_remote_package:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    mov rax, 7008
    extern ___chkstk_ms
    sub rsp, 32
    call ___chkstk_ms
    add rsp, 32
    sub rsp, rax    ; Allocate 7008 bytes on stack (probed)
    ; Registering 4 function parameters
    mov [rbp - 8], rcx  ; Home param 'name'
    ; Parameter 'name' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'url'
    ; Parameter 'url' arrived in register rdx
    mov [rbp - 24], r8  ; Home param 'out_local_dir'
    ; Parameter 'out_local_dir' arrived in register r8
    mov [rbp - 32], r9  ; Home param 'out_max'
    ; Parameter 'out_max' arrived in register r9
ir_entry_372:
    ; Load variable: name
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 2744], rax
    mov rax, [rbp - 2744]
    test rax, rax
    jz ir_sc_rhs_375
    jmp ir_sc_true_376
ir_sc_rhs_375:
    ; Load variable: url
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 2752], rax
    mov rax, [rbp - 2752]
    test rax, rax
    jz ir_sc_false_377
ir_sc_true_376:
    mov rax, 1
    mov [rbp - 2760], rax
    jmp ir_sc_end_378
ir_sc_false_377:
    mov rax, 0
    mov [rbp - 2760], rax
ir_sc_end_378:
    mov rax, [rbp - 2760]
    test rax, rax
    jz ir_sc_rhs_379
    jmp ir_sc_true_380
ir_sc_rhs_379:
    ; Load variable: out_local_dir
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 2776], rax
    mov rax, [rbp - 2776]
    test rax, rax
    jz ir_sc_false_381
ir_sc_true_380:
    mov rax, 1
    mov [rbp - 2784], rax
    jmp ir_sc_end_382
ir_sc_false_381:
    mov rax, 0
    mov [rbp - 2784], rax
ir_sc_end_382:
    mov rax, [rbp - 2784]
    test rax, rax
    jz ir_sc_rhs_383
    jmp ir_sc_true_384
ir_sc_rhs_383:
    ; Load variable: out_max
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    setle al
    movzx rax, al
    mov [rbp - 2800], rax
    mov rax, [rbp - 2800]
    test rax, rax
    jz ir_sc_false_385
ir_sc_true_384:
    mov rax, 1
    mov [rbp - 2808], rax
    jmp ir_sc_end_386
ir_sc_false_385:
    mov rax, 0
    mov [rbp - 2808], rax
ir_sc_end_386:
    mov rax, [rbp - 2808]
    test rax, rax
    jz ir_if_next_374
    mov rax, 1
    neg rax
    mov [rbp - 2824], rax
    mov rax, [rbp - 2824]
    mov [rbp - 2832], rax
    mov rax, [rbp - 2832]
    test rax, rax
    jz ir_errdefer_ok_387
    jmp ir_errdefer_end_388
ir_errdefer_ok_387:
ir_errdefer_end_388:
    mov rax, [rbp - 2824]
    jmp Lfetch_remote_package_exit
    jmp ir_if_end_373
ir_if_next_374:
ir_if_end_373:
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (7 bytes)
    lea rax, [rel Lstr_struct86]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 2840], rax
    ; IR call: starts_with (2 args)
    sub rsp, 32
    ; Load variable: url
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov rcx, rax
    mov rax, [rbp - 2840]
    mov rdx, rax
    call starts_with
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 2848], rax
    mov rax, [rbp - 2848]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 2856], rax
    mov rax, [rbp - 2856]
    test rax, rax
    jz ir_sc_false_393
ir_sc_rhs_391:
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (8 bytes)
    lea rax, [rel Lstr_struct88]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 2864], rax
    ; IR call: starts_with (2 args)
    sub rsp, 32
    ; Load variable: url
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov rcx, rax
    mov rax, [rbp - 2864]
    mov rdx, rax
    call starts_with
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 2872], rax
    mov rax, [rbp - 2872]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 2880], rax
    mov rax, [rbp - 2880]
    test rax, rax
    jz ir_sc_false_393
ir_sc_true_392:
    mov rax, 1
    mov [rbp - 2888], rax
    jmp ir_sc_end_394
ir_sc_false_393:
    mov rax, 0
    mov [rbp - 2888], rax
ir_sc_end_394:
    mov rax, [rbp - 2888]
    test rax, rax
    jz ir_if_next_390
    mov rax, 1
    neg rax
    mov [rbp - 2904], rax
    mov rax, [rbp - 2904]
    mov [rbp - 2912], rax
    mov rax, [rbp - 2912]
    test rax, rax
    jz ir_errdefer_ok_395
    jmp ir_errdefer_end_396
ir_errdefer_ok_395:
ir_errdefer_end_396:
    mov rax, [rbp - 2904]
    jmp Lfetch_remote_package_exit
    jmp ir_if_end_389
ir_if_next_390:
ir_if_end_389:
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (5 bytes)
    lea rax, [rel Lstr_struct90]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 2920], rax
    ; IR call: dir_create (1 args)
    sub rsp, 32
    mov rax, [rbp - 2920]
    mov rcx, rax
    call dir_create
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 2928], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (12 bytes)
    lea rax, [rel Lstr_struct92]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 2936], rax
    ; IR call: dir_create (1 args)
    sub rsp, 32
    mov rax, [rbp - 2936]
    mov rcx, rax
    call dir_create
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 2944], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (13 bytes)
    lea rax, [rel Lstr_struct94]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 2952], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (0 bytes)
    lea rax, [rel Lstr_struct96]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 2960], rax
    mov rax, 0
    push rax
    mov rax, 320
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 2968], rax
    mov rax, [rbp - 2968]
    test rax, rax
    jz ir_trap_bounds_399
    jmp ir_in_bounds_400
ir_trap_bounds_399:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct98]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_400:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 2976], rax
    ; Load variable: remote_dir
    lea rax, [rbp - 352]  ; Local array base
    push rax
    mov rax, [rbp - 2976]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2984], rax
    ; IR call: build_path3 (5 args)
    sub rsp, 48
    mov rax, 320
    mov [rsp + 32], rax
    mov rax, [rbp - 2952]
    mov rcx, rax
    ; Load variable: name
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rdx, rax
    mov rax, [rbp - 2960]
    mov r8, rax
    mov rax, [rbp - 2984]
    mov r9, rax
    call build_path3
    add rsp, 48
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 2992], rax
    mov rax, [rbp - 2992]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 3000], rax
    mov rax, [rbp - 3000]
    test rax, rax
    jz ir_if_next_398
    mov rax, 2
    neg rax
    mov [rbp - 3008], rax
    mov rax, [rbp - 3008]
    mov [rbp - 3016], rax
    mov rax, [rbp - 3016]
    test rax, rax
    jz ir_errdefer_ok_401
    jmp ir_errdefer_end_402
ir_errdefer_ok_401:
ir_errdefer_end_402:
    mov rax, [rbp - 3008]
    jmp Lfetch_remote_package_exit
    jmp ir_if_end_397
ir_if_next_398:
ir_if_end_397:
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (13 bytes)
    lea rax, [rel Lstr_struct100]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 3024], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (4 bytes)
    lea rax, [rel Lstr_struct102]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 3032], rax
    mov rax, 0
    push rax
    mov rax, 320
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 3040], rax
    mov rax, [rbp - 3040]
    test rax, rax
    jz ir_trap_bounds_405
    jmp ir_in_bounds_406
ir_trap_bounds_405:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct104]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_406:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 3048], rax
    ; Load variable: zip_path
    lea rax, [rbp - 672]  ; Local array base
    push rax
    mov rax, [rbp - 3048]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 3056], rax
    ; IR call: build_path3 (5 args)
    sub rsp, 48
    mov rax, 320
    mov [rsp + 32], rax
    mov rax, [rbp - 3024]
    mov rcx, rax
    ; Load variable: name
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rdx, rax
    mov rax, [rbp - 3032]
    mov r8, rax
    mov rax, [rbp - 3056]
    mov r9, rax
    call build_path3
    add rsp, 48
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 3064], rax
    mov rax, [rbp - 3064]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 3072], rax
    mov rax, [rbp - 3072]
    test rax, rax
    jz ir_if_next_404
    mov rax, 2
    neg rax
    mov [rbp - 3080], rax
    mov rax, [rbp - 3080]
    mov [rbp - 3088], rax
    mov rax, [rbp - 3088]
    test rax, rax
    jz ir_errdefer_ok_407
    jmp ir_errdefer_end_408
ir_errdefer_ok_407:
ir_errdefer_end_408:
    mov rax, [rbp - 3080]
    jmp Lfetch_remote_package_exit
    jmp ir_if_end_403
ir_if_next_404:
ir_if_end_403:
    mov rax, 0
    ; Store to variable: pos
    mov dword [rbp - 2724], eax  ; To stack [rbp - 2724]
    mov rax, 0
    push rax
    mov rax, 2048
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 3096], rax
    mov rax, [rbp - 3096]
    test rax, rax
    jz ir_trap_bounds_411
    jmp ir_in_bounds_412
ir_trap_bounds_411:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct106]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_412:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 3104], rax
    ; Load variable: cmd_buf
    lea rax, [rbp - 2720]  ; Local array base
    push rax
    mov rax, [rbp - 3104]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 3112], rax
    lea rax, [rbp - 2724]
    mov [rbp - 3120], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (97 bytes)
    lea rax, [rel Lstr_struct108]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 3128], rax
    ; IR call: append_str (4 args)
    sub rsp, 32
    mov rax, [rbp - 3112]
    mov rcx, rax
    mov rax, [rbp - 3120]
    mov rdx, rax
    mov rax, 2048
    mov r8, rax
    mov rax, [rbp - 3128]
    mov r9, rax
    call append_str
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 3136], rax
    mov rax, [rbp - 3136]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 3144], rax
    mov rax, [rbp - 3144]
    test rax, rax
    jz ir_if_next_410
    mov rax, 2
    neg rax
    mov [rbp - 3152], rax
    mov rax, [rbp - 3152]
    mov [rbp - 3160], rax
    mov rax, [rbp - 3160]
    test rax, rax
    jz ir_errdefer_ok_413
    jmp ir_errdefer_end_414
ir_errdefer_ok_413:
ir_errdefer_end_414:
    mov rax, [rbp - 3152]
    jmp Lfetch_remote_package_exit
    jmp ir_if_end_409
ir_if_next_410:
ir_if_end_409:
    mov rax, 0
    push rax
    mov rax, 2048
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 3168], rax
    mov rax, [rbp - 3168]
    test rax, rax
    jz ir_trap_bounds_417
    jmp ir_in_bounds_418
ir_trap_bounds_417:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct110]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_418:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 3176], rax
    ; Load variable: cmd_buf
    lea rax, [rbp - 2720]  ; Local array base
    push rax
    mov rax, [rbp - 3176]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 3184], rax
    lea rax, [rbp - 2724]
    mov [rbp - 3192], rax
    ; IR call: append_str (4 args)
    sub rsp, 32
    mov rax, [rbp - 3184]
    mov rcx, rax
    mov rax, [rbp - 3192]
    mov rdx, rax
    mov rax, 2048
    mov r8, rax
    ; Load variable: url
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov r9, rax
    call append_str
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 3200], rax
    mov rax, [rbp - 3200]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 3208], rax
    mov rax, [rbp - 3208]
    test rax, rax
    jz ir_if_next_416
    mov rax, 2
    neg rax
    mov [rbp - 3216], rax
    mov rax, [rbp - 3216]
    mov [rbp - 3224], rax
    mov rax, [rbp - 3224]
    test rax, rax
    jz ir_errdefer_ok_419
    jmp ir_errdefer_end_420
ir_errdefer_ok_419:
ir_errdefer_end_420:
    mov rax, [rbp - 3216]
    jmp Lfetch_remote_package_exit
    jmp ir_if_end_415
ir_if_next_416:
ir_if_end_415:
    mov rax, 0
    push rax
    mov rax, 2048
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 3232], rax
    mov rax, [rbp - 3232]
    test rax, rax
    jz ir_trap_bounds_423
    jmp ir_in_bounds_424
ir_trap_bounds_423:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct112]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_424:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 3240], rax
    ; Load variable: cmd_buf
    lea rax, [rbp - 2720]  ; Local array base
    push rax
    mov rax, [rbp - 3240]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 3248], rax
    lea rax, [rbp - 2724]
    mov [rbp - 3256], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (12 bytes)
    lea rax, [rel Lstr_struct114]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 3264], rax
    ; IR call: append_str (4 args)
    sub rsp, 32
    mov rax, [rbp - 3248]
    mov rcx, rax
    mov rax, [rbp - 3256]
    mov rdx, rax
    mov rax, 2048
    mov r8, rax
    mov rax, [rbp - 3264]
    mov r9, rax
    call append_str
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 3272], rax
    mov rax, [rbp - 3272]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 3280], rax
    mov rax, [rbp - 3280]
    test rax, rax
    jz ir_if_next_422
    mov rax, 2
    neg rax
    mov [rbp - 3288], rax
    mov rax, [rbp - 3288]
    mov [rbp - 3296], rax
    mov rax, [rbp - 3296]
    test rax, rax
    jz ir_errdefer_ok_425
    jmp ir_errdefer_end_426
ir_errdefer_ok_425:
ir_errdefer_end_426:
    mov rax, [rbp - 3288]
    jmp Lfetch_remote_package_exit
    jmp ir_if_end_421
ir_if_next_422:
ir_if_end_421:
    mov rax, 0
    push rax
    mov rax, 2048
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 3304], rax
    mov rax, [rbp - 3304]
    test rax, rax
    jz ir_trap_bounds_429
    jmp ir_in_bounds_430
ir_trap_bounds_429:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct116]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_430:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 3312], rax
    ; Load variable: cmd_buf
    lea rax, [rbp - 2720]  ; Local array base
    push rax
    mov rax, [rbp - 3312]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 3320], rax
    lea rax, [rbp - 2724]
    mov [rbp - 3328], rax
    mov rax, 0
    push rax
    mov rax, 320
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 3336], rax
    mov rax, [rbp - 3336]
    test rax, rax
    jz ir_trap_bounds_431
    jmp ir_in_bounds_432
ir_trap_bounds_431:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct118]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_432:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 3344], rax
    ; Load variable: zip_path
    lea rax, [rbp - 672]  ; Local array base
    push rax
    mov rax, [rbp - 3344]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 3352], rax
    ; IR call: append_str (4 args)
    sub rsp, 32
    mov rax, [rbp - 3320]
    mov rcx, rax
    mov rax, [rbp - 3328]
    mov rdx, rax
    mov rax, 2048
    mov r8, rax
    mov rax, [rbp - 3352]
    mov r9, rax
    call append_str
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 3360], rax
    mov rax, [rbp - 3360]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 3368], rax
    mov rax, [rbp - 3368]
    test rax, rax
    jz ir_if_next_428
    mov rax, 2
    neg rax
    mov [rbp - 3376], rax
    mov rax, [rbp - 3376]
    mov [rbp - 3384], rax
    mov rax, [rbp - 3384]
    test rax, rax
    jz ir_errdefer_ok_433
    jmp ir_errdefer_end_434
ir_errdefer_ok_433:
ir_errdefer_end_434:
    mov rax, [rbp - 3376]
    jmp Lfetch_remote_package_exit
    jmp ir_if_end_427
ir_if_next_428:
ir_if_end_427:
    mov rax, 0
    push rax
    mov rax, 2048
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 3392], rax
    mov rax, [rbp - 3392]
    test rax, rax
    jz ir_trap_bounds_437
    jmp ir_in_bounds_438
ir_trap_bounds_437:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct120]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_438:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 3400], rax
    ; Load variable: cmd_buf
    lea rax, [rbp - 2720]  ; Local array base
    push rax
    mov rax, [rbp - 3400]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 3408], rax
    lea rax, [rbp - 2724]
    mov [rbp - 3416], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (2 bytes)
    lea rax, [rel Lstr_struct122]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 3424], rax
    ; IR call: append_str (4 args)
    sub rsp, 32
    mov rax, [rbp - 3408]
    mov rcx, rax
    mov rax, [rbp - 3416]
    mov rdx, rax
    mov rax, 2048
    mov r8, rax
    mov rax, [rbp - 3424]
    mov r9, rax
    call append_str
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 3432], rax
    mov rax, [rbp - 3432]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 3440], rax
    mov rax, [rbp - 3440]
    test rax, rax
    jz ir_if_next_436
    mov rax, 2
    neg rax
    mov [rbp - 3448], rax
    mov rax, [rbp - 3448]
    mov [rbp - 3456], rax
    mov rax, [rbp - 3456]
    test rax, rax
    jz ir_errdefer_ok_439
    jmp ir_errdefer_end_440
ir_errdefer_ok_439:
ir_errdefer_end_440:
    mov rax, [rbp - 3448]
    jmp Lfetch_remote_package_exit
    jmp ir_if_end_435
ir_if_next_436:
ir_if_end_435:
    ; Load variable: pos
    movsxd rax, dword [rbp - 2724]  ; From stack [rbp - 2724]
    push rax
    mov rax, 2048
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 3464], rax
    mov rax, [rbp - 3464]
    test rax, rax
    jz ir_trap_bounds_441
    jmp ir_in_bounds_442
ir_trap_bounds_441:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct124]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_442:
    ; Load variable: pos
    movsxd rax, dword [rbp - 2724]  ; From stack [rbp - 2724]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 3472], rax
    ; Load variable: cmd_buf
    lea rax, [rbp - 2720]  ; Local array base
    push rax
    mov rax, [rbp - 3472]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 3480], rax
    mov rax, [rbp - 3480]
    push rax
    mov rax, 0
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    mov rax, 0
    push rax
    mov rax, 2048
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 3496], rax
    mov rax, [rbp - 3496]
    test rax, rax
    jz ir_trap_bounds_443
    jmp ir_in_bounds_444
ir_trap_bounds_443:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct126]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_444:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 3504], rax
    ; Load variable: cmd_buf
    lea rax, [rbp - 2720]  ; Local array base
    push rax
    mov rax, [rbp - 3504]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 3512], rax
    ; IR call: system (1 args)
    sub rsp, 32
    mov rax, [rbp - 3512]
    mov rcx, rax
    call system
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 3520], rax
    mov rax, [rbp - 3520]
    ; Store to variable: result
    mov dword [rbp - 2728], eax  ; To stack [rbp - 2728]
    ; Load variable: result
    movsxd rax, dword [rbp - 2728]  ; From stack [rbp - 2728]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 3528], rax
    mov rax, [rbp - 3528]
    test rax, rax
    jz ir_if_next_446
    mov rax, 3
    neg rax
    mov [rbp - 3536], rax
    mov rax, [rbp - 3536]
    mov [rbp - 3544], rax
    mov rax, [rbp - 3544]
    test rax, rax
    jz ir_errdefer_ok_447
    jmp ir_errdefer_end_448
ir_errdefer_ok_447:
ir_errdefer_end_448:
    mov rax, [rbp - 3536]
    jmp Lfetch_remote_package_exit
    jmp ir_if_end_445
ir_if_next_446:
ir_if_end_445:
    mov rax, 0
    ; Store to variable: pos
    mov dword [rbp - 2724], eax  ; To stack [rbp - 2724]
    mov rax, 0
    push rax
    mov rax, 2048
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 3552], rax
    mov rax, [rbp - 3552]
    test rax, rax
    jz ir_trap_bounds_451
    jmp ir_in_bounds_452
ir_trap_bounds_451:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct128]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_452:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 3560], rax
    ; Load variable: cmd_buf
    lea rax, [rbp - 2720]  ; Local array base
    push rax
    mov rax, [rbp - 3560]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 3568], rax
    lea rax, [rbp - 2724]
    mov [rbp - 3576], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (60 bytes)
    lea rax, [rel Lstr_struct130]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 3584], rax
    ; IR call: append_str (4 args)
    sub rsp, 32
    mov rax, [rbp - 3568]
    mov rcx, rax
    mov rax, [rbp - 3576]
    mov rdx, rax
    mov rax, 2048
    mov r8, rax
    mov rax, [rbp - 3584]
    mov r9, rax
    call append_str
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 3592], rax
    mov rax, [rbp - 3592]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 3600], rax
    mov rax, [rbp - 3600]
    test rax, rax
    jz ir_if_next_450
    mov rax, 2
    neg rax
    mov [rbp - 3608], rax
    mov rax, [rbp - 3608]
    mov [rbp - 3616], rax
    mov rax, [rbp - 3616]
    test rax, rax
    jz ir_errdefer_ok_453
    jmp ir_errdefer_end_454
ir_errdefer_ok_453:
ir_errdefer_end_454:
    mov rax, [rbp - 3608]
    jmp Lfetch_remote_package_exit
    jmp ir_if_end_449
ir_if_next_450:
ir_if_end_449:
    mov rax, 0
    push rax
    mov rax, 2048
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 3624], rax
    mov rax, [rbp - 3624]
    test rax, rax
    jz ir_trap_bounds_457
    jmp ir_in_bounds_458
ir_trap_bounds_457:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct132]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_458:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 3632], rax
    ; Load variable: cmd_buf
    lea rax, [rbp - 2720]  ; Local array base
    push rax
    mov rax, [rbp - 3632]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 3640], rax
    lea rax, [rbp - 2724]
    mov [rbp - 3648], rax
    mov rax, 0
    push rax
    mov rax, 320
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 3656], rax
    mov rax, [rbp - 3656]
    test rax, rax
    jz ir_trap_bounds_459
    jmp ir_in_bounds_460
ir_trap_bounds_459:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct134]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_460:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 3664], rax
    ; Load variable: remote_dir
    lea rax, [rbp - 352]  ; Local array base
    push rax
    mov rax, [rbp - 3664]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 3672], rax
    ; IR call: append_str (4 args)
    sub rsp, 32
    mov rax, [rbp - 3640]
    mov rcx, rax
    mov rax, [rbp - 3648]
    mov rdx, rax
    mov rax, 2048
    mov r8, rax
    mov rax, [rbp - 3672]
    mov r9, rax
    call append_str
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 3680], rax
    mov rax, [rbp - 3680]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 3688], rax
    mov rax, [rbp - 3688]
    test rax, rax
    jz ir_if_next_456
    mov rax, 2
    neg rax
    mov [rbp - 3696], rax
    mov rax, [rbp - 3696]
    mov [rbp - 3704], rax
    mov rax, [rbp - 3704]
    test rax, rax
    jz ir_errdefer_ok_461
    jmp ir_errdefer_end_462
ir_errdefer_ok_461:
ir_errdefer_end_462:
    mov rax, [rbp - 3696]
    jmp Lfetch_remote_package_exit
    jmp ir_if_end_455
ir_if_next_456:
ir_if_end_455:
    mov rax, 0
    push rax
    mov rax, 2048
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 3712], rax
    mov rax, [rbp - 3712]
    test rax, rax
    jz ir_trap_bounds_465
    jmp ir_in_bounds_466
ir_trap_bounds_465:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct136]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_466:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 3720], rax
    ; Load variable: cmd_buf
    lea rax, [rbp - 2720]  ; Local array base
    push rax
    mov rax, [rbp - 3720]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 3728], rax
    lea rax, [rbp - 2724]
    mov [rbp - 3736], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (130 bytes)
    lea rax, [rel Lstr_struct138]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 3744], rax
    ; IR call: append_str (4 args)
    sub rsp, 32
    mov rax, [rbp - 3728]
    mov rcx, rax
    mov rax, [rbp - 3736]
    mov rdx, rax
    mov rax, 2048
    mov r8, rax
    mov rax, [rbp - 3744]
    mov r9, rax
    call append_str
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 3752], rax
    mov rax, [rbp - 3752]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 3760], rax
    mov rax, [rbp - 3760]
    test rax, rax
    jz ir_if_next_464
    mov rax, 2
    neg rax
    mov [rbp - 3768], rax
    mov rax, [rbp - 3768]
    mov [rbp - 3776], rax
    mov rax, [rbp - 3776]
    test rax, rax
    jz ir_errdefer_ok_467
    jmp ir_errdefer_end_468
ir_errdefer_ok_467:
ir_errdefer_end_468:
    mov rax, [rbp - 3768]
    jmp Lfetch_remote_package_exit
    jmp ir_if_end_463
ir_if_next_464:
ir_if_end_463:
    mov rax, 0
    push rax
    mov rax, 2048
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 3784], rax
    mov rax, [rbp - 3784]
    test rax, rax
    jz ir_trap_bounds_471
    jmp ir_in_bounds_472
ir_trap_bounds_471:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct140]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_472:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 3792], rax
    ; Load variable: cmd_buf
    lea rax, [rbp - 2720]  ; Local array base
    push rax
    mov rax, [rbp - 3792]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 3800], rax
    lea rax, [rbp - 2724]
    mov [rbp - 3808], rax
    mov rax, 0
    push rax
    mov rax, 320
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 3816], rax
    mov rax, [rbp - 3816]
    test rax, rax
    jz ir_trap_bounds_473
    jmp ir_in_bounds_474
ir_trap_bounds_473:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct142]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_474:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 3824], rax
    ; Load variable: zip_path
    lea rax, [rbp - 672]  ; Local array base
    push rax
    mov rax, [rbp - 3824]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 3832], rax
    ; IR call: append_str (4 args)
    sub rsp, 32
    mov rax, [rbp - 3800]
    mov rcx, rax
    mov rax, [rbp - 3808]
    mov rdx, rax
    mov rax, 2048
    mov r8, rax
    mov rax, [rbp - 3832]
    mov r9, rax
    call append_str
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 3840], rax
    mov rax, [rbp - 3840]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 3848], rax
    mov rax, [rbp - 3848]
    test rax, rax
    jz ir_if_next_470
    mov rax, 2
    neg rax
    mov [rbp - 3856], rax
    mov rax, [rbp - 3856]
    mov [rbp - 3864], rax
    mov rax, [rbp - 3864]
    test rax, rax
    jz ir_errdefer_ok_475
    jmp ir_errdefer_end_476
ir_errdefer_ok_475:
ir_errdefer_end_476:
    mov rax, [rbp - 3856]
    jmp Lfetch_remote_package_exit
    jmp ir_if_end_469
ir_if_next_470:
ir_if_end_469:
    mov rax, 0
    push rax
    mov rax, 2048
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 3872], rax
    mov rax, [rbp - 3872]
    test rax, rax
    jz ir_trap_bounds_479
    jmp ir_in_bounds_480
ir_trap_bounds_479:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct144]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_480:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 3880], rax
    ; Load variable: cmd_buf
    lea rax, [rbp - 2720]  ; Local array base
    push rax
    mov rax, [rbp - 3880]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 3888], rax
    lea rax, [rbp - 2724]
    mov [rbp - 3896], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (29 bytes)
    lea rax, [rel Lstr_struct146]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 3904], rax
    ; IR call: append_str (4 args)
    sub rsp, 32
    mov rax, [rbp - 3888]
    mov rcx, rax
    mov rax, [rbp - 3896]
    mov rdx, rax
    mov rax, 2048
    mov r8, rax
    mov rax, [rbp - 3904]
    mov r9, rax
    call append_str
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 3912], rax
    mov rax, [rbp - 3912]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 3920], rax
    mov rax, [rbp - 3920]
    test rax, rax
    jz ir_if_next_478
    mov rax, 2
    neg rax
    mov [rbp - 3928], rax
    mov rax, [rbp - 3928]
    mov [rbp - 3936], rax
    mov rax, [rbp - 3936]
    test rax, rax
    jz ir_errdefer_ok_481
    jmp ir_errdefer_end_482
ir_errdefer_ok_481:
ir_errdefer_end_482:
    mov rax, [rbp - 3928]
    jmp Lfetch_remote_package_exit
    jmp ir_if_end_477
ir_if_next_478:
ir_if_end_477:
    ; Load variable: pos
    movsxd rax, dword [rbp - 2724]  ; From stack [rbp - 2724]
    push rax
    mov rax, 2048
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 3944], rax
    mov rax, [rbp - 3944]
    test rax, rax
    jz ir_trap_bounds_483
    jmp ir_in_bounds_484
ir_trap_bounds_483:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct148]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_484:
    ; Load variable: pos
    movsxd rax, dword [rbp - 2724]  ; From stack [rbp - 2724]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 3952], rax
    ; Load variable: cmd_buf
    lea rax, [rbp - 2720]  ; Local array base
    push rax
    mov rax, [rbp - 3952]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 3960], rax
    mov rax, [rbp - 3960]
    push rax
    mov rax, 0
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    mov rax, 0
    push rax
    mov rax, 2048
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 3976], rax
    mov rax, [rbp - 3976]
    test rax, rax
    jz ir_trap_bounds_485
    jmp ir_in_bounds_486
ir_trap_bounds_485:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct150]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_486:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 3984], rax
    ; Load variable: cmd_buf
    lea rax, [rbp - 2720]  ; Local array base
    push rax
    mov rax, [rbp - 3984]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 3992], rax
    ; IR call: system (1 args)
    sub rsp, 32
    mov rax, [rbp - 3992]
    mov rcx, rax
    call system
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 4000], rax
    mov rax, [rbp - 4000]
    ; Store to variable: result
    mov dword [rbp - 2728], eax  ; To stack [rbp - 2728]
    ; Load variable: result
    movsxd rax, dword [rbp - 2728]  ; From stack [rbp - 2728]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 4008], rax
    mov rax, [rbp - 4008]
    test rax, rax
    jz ir_if_next_488
    mov rax, 4
    neg rax
    mov [rbp - 4016], rax
    mov rax, [rbp - 4016]
    mov [rbp - 4024], rax
    mov rax, [rbp - 4024]
    test rax, rax
    jz ir_errdefer_ok_489
    jmp ir_errdefer_end_490
ir_errdefer_ok_489:
ir_errdefer_end_490:
    mov rax, [rbp - 4016]
    jmp Lfetch_remote_package_exit
    jmp ir_if_end_487
ir_if_next_488:
ir_if_end_487:
    mov rax, 0
    ; Store to variable: i
    mov dword [rbp - 2732], eax  ; To stack [rbp - 2732]
ir_while_491:
    ; Load variable: out_max
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 4032], rax
    ; Load variable: i
    movsxd rax, dword [rbp - 2732]  ; From stack [rbp - 2732]
    push rax
    mov rax, [rbp - 4032]
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 4040], rax
    mov rax, [rbp - 4040]
    test rax, rax
    jz ir_sc_false_495
ir_sc_rhs_493:
    ; Load variable: i
    movsxd rax, dword [rbp - 2732]  ; From stack [rbp - 2732]
    push rax
    mov rax, 320
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 4048], rax
    mov rax, [rbp - 4048]
    test rax, rax
    jz ir_trap_bounds_497
    jmp ir_in_bounds_498
ir_trap_bounds_497:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct152]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_498:
    ; Load variable: i
    movsxd rax, dword [rbp - 2732]  ; From stack [rbp - 2732]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 4056], rax
    ; Load variable: remote_dir
    lea rax, [rbp - 352]  ; Local array base
    push rax
    mov rax, [rbp - 4056]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 4064], rax
    mov rax, [rbp - 4064]
    movzx rax, byte [rax]
    mov [rbp - 4072], rax
    mov rax, [rbp - 4072]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 4080], rax
    mov rax, [rbp - 4080]
    test rax, rax
    jz ir_sc_false_495
ir_sc_true_494:
    mov rax, 1
    mov [rbp - 4088], rax
    jmp ir_sc_end_496
ir_sc_false_495:
    mov rax, 0
    mov [rbp - 4088], rax
ir_sc_end_496:
    mov rax, [rbp - 4088]
    test rax, rax
    jz ir_while_end_492
    ; Load variable: i
    movsxd rax, dword [rbp - 2732]  ; From stack [rbp - 2732]
    push rax
    mov rax, 320
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 4104], rax
    mov rax, [rbp - 4104]
    test rax, rax
    jz ir_trap_bounds_499
    jmp ir_in_bounds_500
ir_trap_bounds_499:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct154]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_500:
    ; Load variable: i
    movsxd rax, dword [rbp - 2732]  ; From stack [rbp - 2732]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 4112], rax
    ; Load variable: remote_dir
    lea rax, [rbp - 352]  ; Local array base
    push rax
    mov rax, [rbp - 4112]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 4120], rax
    mov rax, [rbp - 4120]
    movzx rax, byte [rax]
    mov [rbp - 4128], rax
    ; Load variable: out_local_dir
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    test rax, rax
    jz ir_trap_null_501
    jmp ir_nonnull_502
ir_trap_null_501:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct156]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_502:
    ; Load variable: i
    movsxd rax, dword [rbp - 2732]  ; From stack [rbp - 2732]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 4136], rax
    ; Load variable: out_local_dir
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, [rbp - 4136]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 4144], rax
    mov rax, [rbp - 4144]
    push rax
    mov rax, [rbp - 4128]
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: i
    movsxd rax, dword [rbp - 2732]  ; From stack [rbp - 2732]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 4160], rax
    mov rax, [rbp - 4160]
    ; Store to variable: i
    mov dword [rbp - 2732], eax  ; To stack [rbp - 2732]
    jmp ir_while_491
ir_while_end_492:
    ; Load variable: out_local_dir
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    test rax, rax
    jz ir_trap_null_503
    jmp ir_nonnull_504
ir_trap_null_503:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct158]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_504:
    ; Load variable: i
    movsxd rax, dword [rbp - 2732]  ; From stack [rbp - 2732]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 4168], rax
    ; Load variable: out_local_dir
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, [rbp - 4168]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 4176], rax
    mov rax, [rbp - 4176]
    push rax
    mov rax, 0
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    mov rax, 0
    mov [rbp - 4192], rax
    mov rax, [rbp - 4192]
    test rax, rax
    jz ir_errdefer_ok_505
    jmp ir_errdefer_end_506
ir_errdefer_ok_505:
ir_errdefer_end_506:
    mov rax, 0
    jmp Lfetch_remote_package_exit
Lfetch_remote_package_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller
    extern rename
    extern remove

global copy_str

copy_str:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 480    ; Allocate 480 bytes on stack (aligned)
    ; Registering 3 function parameters
    mov [rbp - 8], rcx  ; Home param 'dst'
    ; Parameter 'dst' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'src'
    ; Parameter 'src' arrived in register rdx
    mov [rbp - 24], r8  ; Home param 'max_len'
    ; Parameter 'max_len' arrived in register r8
ir_entry_507:
    mov rax, 0
    ; Store to variable: i
    mov dword [rbp - 28], eax  ; To stack [rbp - 28]
ir_while_508:
    ; Load variable: max_len
    movsxd rax, dword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 40], rax
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, [rbp - 40]
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_sc_false_512
ir_sc_rhs_510:
    ; Load variable: src
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    test rax, rax
    jz ir_trap_null_514
    jmp ir_nonnull_515
ir_trap_null_514:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct160]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_515:
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 56], rax
    ; Load variable: src
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, [rbp - 56]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    movzx rax, byte [rax]
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 80], rax
    mov rax, [rbp - 80]
    test rax, rax
    jz ir_sc_false_512
ir_sc_true_511:
    mov rax, 1
    mov [rbp - 88], rax
    jmp ir_sc_end_513
ir_sc_false_512:
    mov rax, 0
    mov [rbp - 88], rax
ir_sc_end_513:
    mov rax, [rbp - 88]
    test rax, rax
    jz ir_while_end_509
    ; Load variable: src
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    test rax, rax
    jz ir_trap_null_516
    jmp ir_nonnull_517
ir_trap_null_516:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct162]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_517:
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 104], rax
    ; Load variable: src
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, [rbp - 104]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    movzx rax, byte [rax]
    mov [rbp - 120], rax
    ; Load variable: dst
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_518
    jmp ir_nonnull_519
ir_trap_null_518:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct164]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_519:
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 128], rax
    ; Load variable: dst
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 128]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 136], rax
    mov rax, [rbp - 136]
    push rax
    mov rax, [rbp - 120]
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 152], rax
    mov rax, [rbp - 152]
    ; Store to variable: i
    mov dword [rbp - 28], eax  ; To stack [rbp - 28]
    jmp ir_while_508
ir_while_end_509:
    ; Load variable: dst
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_520
    jmp ir_nonnull_521
ir_trap_null_520:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct166]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_521:
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 160], rax
    ; Load variable: dst
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 160]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    push rax
    mov rax, 0
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    mov rax, 0
    mov [rbp - 184], rax
    mov rax, [rbp - 184]
    test rax, rax
    jz ir_errdefer_ok_522
    jmp ir_errdefer_end_523
ir_errdefer_ok_522:
ir_errdefer_end_523:
    jmp Lcopy_str_exit
Lcopy_str_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global str_len_i32

str_len_i32:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 96    ; Allocate 96 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 's'
    ; Parameter 's' arrived in register rcx
ir_entry_524:
    ; IR call: strlen (1 args)
    sub rsp, 32
    ; Load variable: s
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call strlen
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    ; Store to variable: n
    mov qword [rbp - 16], rax  ; To stack [rbp - 16]
    ; Load variable: n
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    ; Store to variable: n32
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
    ; Load variable: n32
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_errdefer_ok_525
    jmp ir_errdefer_end_526
ir_errdefer_ok_525:
ir_errdefer_end_526:
    ; Load variable: n32
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    jmp Lstr_len_i32_exit
Lstr_len_i32_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global is_path_absolute

is_path_absolute:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 752    ; Allocate 752 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'path'
    ; Parameter 'path' arrived in register rcx
ir_entry_527:
    ; Load variable: path
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_sc_rhs_530
    jmp ir_sc_true_531
ir_sc_rhs_530:
    ; Load variable: path
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_534
    jmp ir_nonnull_535
ir_trap_null_534:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct168]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_535:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 24], rax
    ; Load variable: path
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 24]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    movzx rax, byte [rax]
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_sc_false_532
ir_sc_true_531:
    mov rax, 1
    mov [rbp - 56], rax
    jmp ir_sc_end_533
ir_sc_false_532:
    mov rax, 0
    mov [rbp - 56], rax
ir_sc_end_533:
    mov rax, [rbp - 56]
    test rax, rax
    jz ir_if_next_529
    mov rax, 0
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    test rax, rax
    jz ir_errdefer_ok_536
    jmp ir_errdefer_end_537
ir_errdefer_ok_536:
ir_errdefer_end_537:
    mov rax, 0
    jmp Lis_path_absolute_exit
    jmp ir_if_end_528
ir_if_next_529:
ir_if_end_528:
    ; Load variable: path
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_540
    jmp ir_nonnull_541
ir_trap_null_540:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct170]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_541:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 80], rax
    ; Load variable: path
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 80]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    movzx rax, byte [rax]
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    push rax
    mov rax, 47
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 104], rax
    mov rax, [rbp - 104]
    test rax, rax
    jz ir_sc_rhs_542
    jmp ir_sc_true_543
ir_sc_rhs_542:
    ; Load variable: path
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_546
    jmp ir_nonnull_547
ir_trap_null_546:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct172]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_547:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 112], rax
    ; Load variable: path
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 112]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 120], rax
    mov rax, [rbp - 120]
    movzx rax, byte [rax]
    mov [rbp - 128], rax
    mov rax, [rbp - 128]
    push rax
    mov rax, 92
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 136], rax
    mov rax, [rbp - 136]
    test rax, rax
    jz ir_sc_false_544
ir_sc_true_543:
    mov rax, 1
    mov [rbp - 144], rax
    jmp ir_sc_end_545
ir_sc_false_544:
    mov rax, 0
    mov [rbp - 144], rax
ir_sc_end_545:
    mov rax, [rbp - 144]
    test rax, rax
    jz ir_if_next_539
    mov rax, 1
    mov [rbp - 160], rax
    mov rax, [rbp - 160]
    test rax, rax
    jz ir_errdefer_ok_548
    jmp ir_errdefer_end_549
ir_errdefer_ok_548:
ir_errdefer_end_549:
    mov rax, 1
    jmp Lis_path_absolute_exit
    jmp ir_if_end_538
ir_if_next_539:
ir_if_end_538:
    ; Load variable: path
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_552
    jmp ir_nonnull_553
ir_trap_null_552:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct174]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_553:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 168], rax
    ; Load variable: path
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 168]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 176], rax
    mov rax, [rbp - 176]
    movzx rax, byte [rax]
    mov [rbp - 184], rax
    ; IR call: is_alpha (1 args)
    sub rsp, 32
    mov rax, [rbp - 184]
    mov rcx, rax
    call is_alpha
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 192], rax
    mov rax, [rbp - 192]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 200], rax
    mov rax, [rbp - 200]
    test rax, rax
    jz ir_sc_false_556
ir_sc_rhs_554:
    ; Load variable: path
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_558
    jmp ir_nonnull_559
ir_trap_null_558:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct176]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_559:
    mov rax, 1
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 208], rax
    ; Load variable: path
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 208]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 216], rax
    mov rax, [rbp - 216]
    movzx rax, byte [rax]
    mov [rbp - 224], rax
    mov rax, [rbp - 224]
    push rax
    mov rax, 58
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 232], rax
    mov rax, [rbp - 232]
    test rax, rax
    jz ir_sc_false_556
ir_sc_true_555:
    mov rax, 1
    mov [rbp - 240], rax
    jmp ir_sc_end_557
ir_sc_false_556:
    mov rax, 0
    mov [rbp - 240], rax
ir_sc_end_557:
    mov rax, [rbp - 240]
    test rax, rax
    jz ir_if_next_551
    mov rax, 1
    mov [rbp - 256], rax
    mov rax, [rbp - 256]
    test rax, rax
    jz ir_errdefer_ok_560
    jmp ir_errdefer_end_561
ir_errdefer_ok_560:
ir_errdefer_end_561:
    mov rax, 1
    jmp Lis_path_absolute_exit
    jmp ir_if_end_550
ir_if_next_551:
ir_if_end_550:
    mov rax, 0
    mov [rbp - 264], rax
    mov rax, [rbp - 264]
    test rax, rax
    jz ir_errdefer_ok_562
    jmp ir_errdefer_end_563
ir_errdefer_ok_562:
ir_errdefer_end_563:
    mov rax, 0
    jmp Lis_path_absolute_exit
Lis_path_absolute_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global path_join

path_join:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 1872    ; Allocate 1872 bytes on stack (aligned)
    ; Registering 4 function parameters
    mov [rbp - 8], rcx  ; Home param 'base'
    ; Parameter 'base' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'child'
    ; Parameter 'child' arrived in register rdx
    mov [rbp - 24], r8  ; Home param 'out'
    ; Parameter 'out' arrived in register r8
    mov [rbp - 32], r9  ; Home param 'out_max'
    ; Parameter 'out_max' arrived in register r9
ir_entry_564:
    ; Load variable: base
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    test rax, rax
    jz ir_sc_rhs_567
    jmp ir_sc_true_568
ir_sc_rhs_567:
    ; Load variable: child
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    test rax, rax
    jz ir_sc_false_569
ir_sc_true_568:
    mov rax, 1
    mov [rbp - 72], rax
    jmp ir_sc_end_570
ir_sc_false_569:
    mov rax, 0
    mov [rbp - 72], rax
ir_sc_end_570:
    mov rax, [rbp - 72]
    test rax, rax
    jz ir_sc_rhs_571
    jmp ir_sc_true_572
ir_sc_rhs_571:
    ; Load variable: out
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    test rax, rax
    jz ir_sc_false_573
ir_sc_true_572:
    mov rax, 1
    mov [rbp - 96], rax
    jmp ir_sc_end_574
ir_sc_false_573:
    mov rax, 0
    mov [rbp - 96], rax
ir_sc_end_574:
    mov rax, [rbp - 96]
    test rax, rax
    jz ir_sc_rhs_575
    jmp ir_sc_true_576
ir_sc_rhs_575:
    ; Load variable: out_max
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    setle al
    movzx rax, al
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    test rax, rax
    jz ir_sc_false_577
ir_sc_true_576:
    mov rax, 1
    mov [rbp - 120], rax
    jmp ir_sc_end_578
ir_sc_false_577:
    mov rax, 0
    mov [rbp - 120], rax
ir_sc_end_578:
    mov rax, [rbp - 120]
    test rax, rax
    jz ir_if_next_566
    mov rax, 1
    neg rax
    mov [rbp - 136], rax
    mov rax, [rbp - 136]
    mov [rbp - 144], rax
    mov rax, [rbp - 144]
    test rax, rax
    jz ir_errdefer_ok_579
    jmp ir_errdefer_end_580
ir_errdefer_ok_579:
ir_errdefer_end_580:
    mov rax, [rbp - 136]
    jmp Lpath_join_exit
    jmp ir_if_end_565
ir_if_next_566:
ir_if_end_565:
    mov rax, 0
    ; Store to variable: pos
    mov dword [rbp - 36], eax  ; To stack [rbp - 36]
    mov rax, 0
    ; Store to variable: i
    mov dword [rbp - 40], eax  ; To stack [rbp - 40]
ir_while_581:
    ; Load variable: base
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_583
    jmp ir_nonnull_584
ir_trap_null_583:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct178]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_584:
    ; Load variable: i
    movsxd rax, dword [rbp - 40]  ; From stack [rbp - 40]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 152], rax
    ; Load variable: base
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 152]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 160], rax
    mov rax, [rbp - 160]
    movzx rax, byte [rax]
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 176], rax
    mov rax, [rbp - 176]
    test rax, rax
    jz ir_sc_false_587
ir_sc_rhs_585:
    ; Load variable: out_max
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 184], rax
    ; Load variable: pos
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    push rax
    mov rax, [rbp - 184]
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 192], rax
    mov rax, [rbp - 192]
    test rax, rax
    jz ir_sc_false_587
ir_sc_true_586:
    mov rax, 1
    mov [rbp - 200], rax
    jmp ir_sc_end_588
ir_sc_false_587:
    mov rax, 0
    mov [rbp - 200], rax
ir_sc_end_588:
    mov rax, [rbp - 200]
    test rax, rax
    jz ir_while_end_582
    ; Load variable: base
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_589
    jmp ir_nonnull_590
ir_trap_null_589:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct180]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_590:
    ; Load variable: i
    movsxd rax, dword [rbp - 40]  ; From stack [rbp - 40]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 216], rax
    ; Load variable: base
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 216]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 224], rax
    mov rax, [rbp - 224]
    movzx rax, byte [rax]
    mov [rbp - 232], rax
    ; Load variable: out
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    test rax, rax
    jz ir_trap_null_591
    jmp ir_nonnull_592
ir_trap_null_591:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct182]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_592:
    ; Load variable: pos
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 240], rax
    ; Load variable: out
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, [rbp - 240]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 248], rax
    mov rax, [rbp - 248]
    push rax
    mov rax, [rbp - 232]
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: pos
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 264], rax
    mov rax, [rbp - 264]
    ; Store to variable: pos
    mov dword [rbp - 36], eax  ; To stack [rbp - 36]
    ; Load variable: i
    movsxd rax, dword [rbp - 40]  ; From stack [rbp - 40]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 272], rax
    mov rax, [rbp - 272]
    ; Store to variable: i
    mov dword [rbp - 40], eax  ; To stack [rbp - 40]
    jmp ir_while_581
ir_while_end_582:
    ; Load variable: pos
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setle al
    movzx rax, al
    mov [rbp - 280], rax
    mov rax, [rbp - 280]
    test rax, rax
    jz ir_sc_rhs_595
    jmp ir_sc_true_596
ir_sc_rhs_595:
    ; Load variable: out_max
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 288], rax
    ; Load variable: pos
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    push rax
    mov rax, [rbp - 288]
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 296], rax
    mov rax, [rbp - 296]
    test rax, rax
    jz ir_sc_false_597
ir_sc_true_596:
    mov rax, 1
    mov [rbp - 304], rax
    jmp ir_sc_end_598
ir_sc_false_597:
    mov rax, 0
    mov [rbp - 304], rax
ir_sc_end_598:
    mov rax, [rbp - 304]
    test rax, rax
    jz ir_if_next_594
    ; Load variable: out
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    test rax, rax
    jz ir_trap_null_599
    jmp ir_nonnull_600
ir_trap_null_599:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct184]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_600:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 320], rax
    ; Load variable: out
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, [rbp - 320]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 328], rax
    mov rax, [rbp - 328]
    push rax
    mov rax, 0
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    mov rax, 1
    neg rax
    mov [rbp - 344], rax
    mov rax, [rbp - 344]
    mov [rbp - 352], rax
    mov rax, [rbp - 352]
    test rax, rax
    jz ir_errdefer_ok_601
    jmp ir_errdefer_end_602
ir_errdefer_ok_601:
ir_errdefer_end_602:
    mov rax, [rbp - 344]
    jmp Lpath_join_exit
    jmp ir_if_end_593
ir_if_next_594:
ir_if_end_593:
    ; Load variable: pos
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 360], rax
    ; Load variable: out
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    test rax, rax
    jz ir_trap_null_603
    jmp ir_nonnull_604
ir_trap_null_603:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct186]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_604:
    mov rax, [rbp - 360]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 368], rax
    ; Load variable: out
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, [rbp - 368]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 376], rax
    mov rax, [rbp - 376]
    movzx rax, byte [rax]
    mov [rbp - 384], rax
    mov rax, [rbp - 384]
    ; Store to variable: last
    mov dword [rbp - 44], eax  ; To stack [rbp - 44]
    ; Load variable: last
    movsxd rax, dword [rbp - 44]  ; From stack [rbp - 44]
    push rax
    mov rax, 47
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 392], rax
    mov rax, [rbp - 392]
    test rax, rax
    jz ir_sc_false_609
ir_sc_rhs_607:
    ; Load variable: last
    movsxd rax, dword [rbp - 44]  ; From stack [rbp - 44]
    push rax
    mov rax, 92
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 400], rax
    mov rax, [rbp - 400]
    test rax, rax
    jz ir_sc_false_609
ir_sc_true_608:
    mov rax, 1
    mov [rbp - 408], rax
    jmp ir_sc_end_610
ir_sc_false_609:
    mov rax, 0
    mov [rbp - 408], rax
ir_sc_end_610:
    mov rax, [rbp - 408]
    test rax, rax
    jz ir_if_next_606
    ; Load variable: out
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    test rax, rax
    jz ir_trap_null_611
    jmp ir_nonnull_612
ir_trap_null_611:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct188]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_612:
    ; Load variable: pos
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 424], rax
    ; Load variable: out
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, [rbp - 424]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 432], rax
    mov rax, [rbp - 432]
    push rax
    mov rax, 92
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: pos
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 448], rax
    mov rax, [rbp - 448]
    ; Store to variable: pos
    mov dword [rbp - 36], eax  ; To stack [rbp - 36]
    ; Load variable: out_max
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 456], rax
    ; Load variable: pos
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    push rax
    mov rax, [rbp - 456]
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 464], rax
    mov rax, [rbp - 464]
    test rax, rax
    jz ir_if_next_614
    ; Load variable: out
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    test rax, rax
    jz ir_trap_null_615
    jmp ir_nonnull_616
ir_trap_null_615:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct190]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_616:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 472], rax
    ; Load variable: out
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, [rbp - 472]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 480], rax
    mov rax, [rbp - 480]
    push rax
    mov rax, 0
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    mov rax, 1
    neg rax
    mov [rbp - 496], rax
    mov rax, [rbp - 496]
    mov [rbp - 504], rax
    mov rax, [rbp - 504]
    test rax, rax
    jz ir_errdefer_ok_617
    jmp ir_errdefer_end_618
ir_errdefer_ok_617:
ir_errdefer_end_618:
    mov rax, [rbp - 496]
    jmp Lpath_join_exit
    jmp ir_if_end_613
ir_if_next_614:
ir_if_end_613:
    jmp ir_if_end_605
ir_if_next_606:
ir_if_end_605:
    mov rax, 0
    ; Store to variable: i
    mov dword [rbp - 40], eax  ; To stack [rbp - 40]
ir_while_619:
    ; Load variable: child
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    test rax, rax
    jz ir_trap_null_621
    jmp ir_nonnull_622
ir_trap_null_621:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct192]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_622:
    ; Load variable: i
    movsxd rax, dword [rbp - 40]  ; From stack [rbp - 40]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 512], rax
    ; Load variable: child
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, [rbp - 512]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 520], rax
    mov rax, [rbp - 520]
    movzx rax, byte [rax]
    mov [rbp - 528], rax
    mov rax, [rbp - 528]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 536], rax
    mov rax, [rbp - 536]
    test rax, rax
    jz ir_sc_false_625
ir_sc_rhs_623:
    ; Load variable: out_max
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 544], rax
    ; Load variable: pos
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    push rax
    mov rax, [rbp - 544]
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 552], rax
    mov rax, [rbp - 552]
    test rax, rax
    jz ir_sc_false_625
ir_sc_true_624:
    mov rax, 1
    mov [rbp - 560], rax
    jmp ir_sc_end_626
ir_sc_false_625:
    mov rax, 0
    mov [rbp - 560], rax
ir_sc_end_626:
    mov rax, [rbp - 560]
    test rax, rax
    jz ir_while_end_620
    ; Load variable: child
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    test rax, rax
    jz ir_trap_null_627
    jmp ir_nonnull_628
ir_trap_null_627:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct194]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_628:
    ; Load variable: i
    movsxd rax, dword [rbp - 40]  ; From stack [rbp - 40]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 576], rax
    ; Load variable: child
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, [rbp - 576]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 584], rax
    mov rax, [rbp - 584]
    movzx rax, byte [rax]
    mov [rbp - 592], rax
    ; Load variable: out
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    test rax, rax
    jz ir_trap_null_629
    jmp ir_nonnull_630
ir_trap_null_629:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct196]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_630:
    ; Load variable: pos
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 600], rax
    ; Load variable: out
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, [rbp - 600]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 608], rax
    mov rax, [rbp - 608]
    push rax
    mov rax, [rbp - 592]
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: pos
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 624], rax
    mov rax, [rbp - 624]
    ; Store to variable: pos
    mov dword [rbp - 36], eax  ; To stack [rbp - 36]
    ; Load variable: i
    movsxd rax, dword [rbp - 40]  ; From stack [rbp - 40]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 632], rax
    mov rax, [rbp - 632]
    ; Store to variable: i
    mov dword [rbp - 40], eax  ; To stack [rbp - 40]
    jmp ir_while_619
ir_while_end_620:
    ; Load variable: out
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    test rax, rax
    jz ir_trap_null_631
    jmp ir_nonnull_632
ir_trap_null_631:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct198]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_632:
    ; Load variable: pos
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 640], rax
    ; Load variable: out
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, [rbp - 640]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 648], rax
    mov rax, [rbp - 648]
    push rax
    mov rax, 0
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    mov rax, 0
    mov [rbp - 664], rax
    mov rax, [rbp - 664]
    test rax, rax
    jz ir_errdefer_ok_633
    jmp ir_errdefer_end_634
ir_errdefer_ok_633:
ir_errdefer_end_634:
    mov rax, 0
    jmp Lpath_join_exit
Lpath_join_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global path_dirname

path_dirname:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 1424    ; Allocate 1424 bytes on stack (aligned)
    ; Registering 3 function parameters
    mov [rbp - 8], rcx  ; Home param 'path'
    ; Parameter 'path' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'out'
    ; Parameter 'out' arrived in register rdx
    mov [rbp - 24], r8  ; Home param 'out_max'
    ; Parameter 'out_max' arrived in register r8
ir_entry_635:
    ; Load variable: path
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_sc_rhs_638
    jmp ir_sc_true_639
ir_sc_rhs_638:
    ; Load variable: out
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    test rax, rax
    jz ir_sc_false_640
ir_sc_true_639:
    mov rax, 1
    mov [rbp - 64], rax
    jmp ir_sc_end_641
ir_sc_false_640:
    mov rax, 0
    mov [rbp - 64], rax
ir_sc_end_641:
    mov rax, [rbp - 64]
    test rax, rax
    jz ir_sc_rhs_642
    jmp ir_sc_true_643
ir_sc_rhs_642:
    ; Load variable: out_max
    movsxd rax, dword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    setle al
    movzx rax, al
    mov [rbp - 80], rax
    mov rax, [rbp - 80]
    test rax, rax
    jz ir_sc_false_644
ir_sc_true_643:
    mov rax, 1
    mov [rbp - 88], rax
    jmp ir_sc_end_645
ir_sc_false_644:
    mov rax, 0
    mov [rbp - 88], rax
ir_sc_end_645:
    mov rax, [rbp - 88]
    test rax, rax
    jz ir_if_next_637
    mov rax, 1
    neg rax
    mov [rbp - 104], rax
    mov rax, [rbp - 104]
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    test rax, rax
    jz ir_errdefer_ok_646
    jmp ir_errdefer_end_647
ir_errdefer_ok_646:
ir_errdefer_end_647:
    mov rax, [rbp - 104]
    jmp Lpath_dirname_exit
    jmp ir_if_end_636
ir_if_next_637:
ir_if_end_636:
    ; IR call: str_len_i32 (1 args)
    sub rsp, 32
    ; Load variable: path
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call str_len_i32
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 120], rax
    mov rax, [rbp - 120]
    ; Store to variable: len
    mov dword [rbp - 28], eax  ; To stack [rbp - 28]
    ; Load variable: len
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setle al
    movzx rax, al
    mov [rbp - 128], rax
    mov rax, [rbp - 128]
    test rax, rax
    jz ir_if_next_649
    ; Load variable: out
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    test rax, rax
    jz ir_trap_null_650
    jmp ir_nonnull_651
ir_trap_null_650:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct200]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_651:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 136], rax
    ; Load variable: out
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, [rbp - 136]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 144], rax
    mov rax, [rbp - 144]
    push rax
    mov rax, 46
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: out
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    test rax, rax
    jz ir_trap_null_652
    jmp ir_nonnull_653
ir_trap_null_652:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct202]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_653:
    mov rax, 1
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 160], rax
    ; Load variable: out
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, [rbp - 160]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    push rax
    mov rax, 0
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    mov rax, 0
    mov [rbp - 184], rax
    mov rax, [rbp - 184]
    test rax, rax
    jz ir_errdefer_ok_654
    jmp ir_errdefer_end_655
ir_errdefer_ok_654:
ir_errdefer_end_655:
    mov rax, 0
    jmp Lpath_dirname_exit
    jmp ir_if_end_648
ir_if_next_649:
ir_if_end_648:
    ; Load variable: len
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 192], rax
    mov rax, [rbp - 192]
    ; Store to variable: i
    mov dword [rbp - 32], eax  ; To stack [rbp - 32]
ir_while_656:
    ; Load variable: i
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 200], rax
    mov rax, [rbp - 200]
    test rax, rax
    jz ir_while_end_657
    ; Load variable: path
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_660
    jmp ir_nonnull_661
ir_trap_null_660:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct204]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_661:
    ; Load variable: i
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 208], rax
    ; Load variable: path
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 208]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 216], rax
    mov rax, [rbp - 216]
    movzx rax, byte [rax]
    mov [rbp - 224], rax
    mov rax, [rbp - 224]
    push rax
    mov rax, 47
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 232], rax
    mov rax, [rbp - 232]
    test rax, rax
    jz ir_sc_rhs_662
    jmp ir_sc_true_663
ir_sc_rhs_662:
    ; Load variable: path
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_666
    jmp ir_nonnull_667
ir_trap_null_666:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct206]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_667:
    ; Load variable: i
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 240], rax
    ; Load variable: path
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 240]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 248], rax
    mov rax, [rbp - 248]
    movzx rax, byte [rax]
    mov [rbp - 256], rax
    mov rax, [rbp - 256]
    push rax
    mov rax, 92
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 264], rax
    mov rax, [rbp - 264]
    test rax, rax
    jz ir_sc_false_664
ir_sc_true_663:
    mov rax, 1
    mov [rbp - 272], rax
    jmp ir_sc_end_665
ir_sc_false_664:
    mov rax, 0
    mov [rbp - 272], rax
ir_sc_end_665:
    mov rax, [rbp - 272]
    test rax, rax
    jz ir_if_next_659
    jmp ir_while_end_657
    jmp ir_if_end_658
ir_if_next_659:
ir_if_end_658:
    ; Load variable: i
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 288], rax
    mov rax, [rbp - 288]
    ; Store to variable: i
    mov dword [rbp - 32], eax  ; To stack [rbp - 32]
    jmp ir_while_656
ir_while_end_657:
    ; Load variable: i
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setle al
    movzx rax, al
    mov [rbp - 296], rax
    mov rax, [rbp - 296]
    test rax, rax
    jz ir_if_next_669
    ; Load variable: out
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    test rax, rax
    jz ir_trap_null_670
    jmp ir_nonnull_671
ir_trap_null_670:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct208]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_671:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 304], rax
    ; Load variable: out
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, [rbp - 304]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 312], rax
    mov rax, [rbp - 312]
    push rax
    mov rax, 46
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: out
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    test rax, rax
    jz ir_trap_null_672
    jmp ir_nonnull_673
ir_trap_null_672:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct210]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_673:
    mov rax, 1
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 328], rax
    ; Load variable: out
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, [rbp - 328]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 336], rax
    mov rax, [rbp - 336]
    push rax
    mov rax, 0
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    mov rax, 0
    mov [rbp - 352], rax
    mov rax, [rbp - 352]
    test rax, rax
    jz ir_errdefer_ok_674
    jmp ir_errdefer_end_675
ir_errdefer_ok_674:
ir_errdefer_end_675:
    mov rax, 0
    jmp Lpath_dirname_exit
    jmp ir_if_end_668
ir_if_next_669:
ir_if_end_668:
    ; Load variable: i
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    ; Load variable: out_max
    movsxd rax, dword [rbp - 24]  ; From stack [rbp - 24]
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 360], rax
    mov rax, [rbp - 360]
    test rax, rax
    jz ir_if_next_677
    mov rax, 1
    neg rax
    mov [rbp - 368], rax
    mov rax, [rbp - 368]
    mov [rbp - 376], rax
    mov rax, [rbp - 376]
    test rax, rax
    jz ir_errdefer_ok_678
    jmp ir_errdefer_end_679
ir_errdefer_ok_678:
ir_errdefer_end_679:
    mov rax, [rbp - 368]
    jmp Lpath_dirname_exit
    jmp ir_if_end_676
ir_if_next_677:
ir_if_end_676:
    mov rax, 0
    ; Store to variable: j
    mov dword [rbp - 36], eax  ; To stack [rbp - 36]
ir_while_680:
    ; Load variable: j
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    push rax
    ; Load variable: i
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 384], rax
    mov rax, [rbp - 384]
    test rax, rax
    jz ir_sc_false_684
ir_sc_rhs_682:
    ; Load variable: out_max
    movsxd rax, dword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 392], rax
    ; Load variable: j
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    push rax
    mov rax, [rbp - 392]
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 400], rax
    mov rax, [rbp - 400]
    test rax, rax
    jz ir_sc_false_684
ir_sc_true_683:
    mov rax, 1
    mov [rbp - 408], rax
    jmp ir_sc_end_685
ir_sc_false_684:
    mov rax, 0
    mov [rbp - 408], rax
ir_sc_end_685:
    mov rax, [rbp - 408]
    test rax, rax
    jz ir_while_end_681
    ; Load variable: path
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_686
    jmp ir_nonnull_687
ir_trap_null_686:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct212]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_687:
    ; Load variable: j
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 424], rax
    ; Load variable: path
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 424]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 432], rax
    mov rax, [rbp - 432]
    movzx rax, byte [rax]
    mov [rbp - 440], rax
    ; Load variable: out
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    test rax, rax
    jz ir_trap_null_688
    jmp ir_nonnull_689
ir_trap_null_688:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct214]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_689:
    ; Load variable: j
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 448], rax
    ; Load variable: out
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, [rbp - 448]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 456], rax
    mov rax, [rbp - 456]
    push rax
    mov rax, [rbp - 440]
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: j
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 472], rax
    mov rax, [rbp - 472]
    ; Store to variable: j
    mov dword [rbp - 36], eax  ; To stack [rbp - 36]
    jmp ir_while_680
ir_while_end_681:
    ; Load variable: out
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    test rax, rax
    jz ir_trap_null_690
    jmp ir_nonnull_691
ir_trap_null_690:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct216]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_691:
    ; Load variable: j
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 480], rax
    ; Load variable: out
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, [rbp - 480]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 488], rax
    mov rax, [rbp - 488]
    push rax
    mov rax, 0
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    mov rax, 0
    mov [rbp - 504], rax
    mov rax, [rbp - 504]
    test rax, rax
    jz ir_errdefer_ok_692
    jmp ir_errdefer_end_693
ir_errdefer_ok_692:
ir_errdefer_end_693:
    mov rax, 0
    jmp Lpath_dirname_exit
Lpath_dirname_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global is_dep_name_char

is_dep_name_char:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 224    ; Allocate 224 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_694:
    ; IR call: is_alnum (1 args)
    sub rsp, 32
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call is_alnum
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_next_696
    mov rax, 1
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_697
    jmp ir_errdefer_end_698
ir_errdefer_ok_697:
ir_errdefer_end_698:
    mov rax, 1
    jmp Lis_dep_name_char_exit
    jmp ir_if_end_695
ir_if_next_696:
ir_if_end_695:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 95
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_sc_rhs_701
    jmp ir_sc_true_702
ir_sc_rhs_701:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 45
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_sc_false_703
ir_sc_true_702:
    mov rax, 1
    mov [rbp - 56], rax
    jmp ir_sc_end_704
ir_sc_false_703:
    mov rax, 0
    mov [rbp - 56], rax
ir_sc_end_704:
    mov rax, [rbp - 56]
    test rax, rax
    jz ir_if_next_700
    mov rax, 1
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    test rax, rax
    jz ir_errdefer_ok_705
    jmp ir_errdefer_end_706
ir_errdefer_ok_705:
ir_errdefer_end_706:
    mov rax, 1
    jmp Lis_dep_name_char_exit
    jmp ir_if_end_699
ir_if_next_700:
ir_if_end_699:
    mov rax, 0
    mov [rbp - 80], rax
    mov rax, [rbp - 80]
    test rax, rax
    jz ir_errdefer_ok_707
    jmp ir_errdefer_end_708
ir_errdefer_ok_707:
ir_errdefer_end_708:
    mov rax, 0
    jmp Lis_dep_name_char_exit
Lis_dep_name_char_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global is_valid_dep_name

is_valid_dep_name:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 496    ; Allocate 496 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'name'
    ; Parameter 'name' arrived in register rcx
ir_entry_709:
    ; Load variable: name
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_sc_rhs_712
    jmp ir_sc_true_713
ir_sc_rhs_712:
    ; Load variable: name
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_716
    jmp ir_nonnull_717
ir_trap_null_716:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct218]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_717:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 32], rax
    ; Load variable: name
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 32]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    movzx rax, byte [rax]
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    test rax, rax
    jz ir_sc_false_714
ir_sc_true_713:
    mov rax, 1
    mov [rbp - 64], rax
    jmp ir_sc_end_715
ir_sc_false_714:
    mov rax, 0
    mov [rbp - 64], rax
ir_sc_end_715:
    mov rax, [rbp - 64]
    test rax, rax
    jz ir_if_next_711
    mov rax, 0
    mov [rbp - 80], rax
    mov rax, [rbp - 80]
    test rax, rax
    jz ir_errdefer_ok_718
    jmp ir_errdefer_end_719
ir_errdefer_ok_718:
ir_errdefer_end_719:
    mov rax, 0
    jmp Lis_valid_dep_name_exit
    jmp ir_if_end_710
ir_if_next_711:
ir_if_end_710:
    mov rax, 0
    ; Store to variable: i
    mov dword [rbp - 12], eax  ; To stack [rbp - 12]
ir_while_720:
    ; Load variable: name
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_722
    jmp ir_nonnull_723
ir_trap_null_722:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct220]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_723:
    ; Load variable: i
    movsxd rax, dword [rbp - 12]  ; From stack [rbp - 12]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 88], rax
    ; Load variable: name
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 88]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    movzx rax, byte [rax]
    mov [rbp - 104], rax
    mov rax, [rbp - 104]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    test rax, rax
    jz ir_while_end_721
    ; Load variable: name
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_726
    jmp ir_nonnull_727
ir_trap_null_726:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct222]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_727:
    ; Load variable: i
    movsxd rax, dword [rbp - 12]  ; From stack [rbp - 12]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 120], rax
    ; Load variable: name
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 120]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 128], rax
    mov rax, [rbp - 128]
    movzx rax, byte [rax]
    mov [rbp - 136], rax
    ; IR call: is_dep_name_char (1 args)
    sub rsp, 32
    mov rax, [rbp - 136]
    mov rcx, rax
    call is_dep_name_char
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 144], rax
    mov rax, [rbp - 144]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 152], rax
    mov rax, [rbp - 152]
    test rax, rax
    jz ir_if_next_725
    mov rax, 0
    mov [rbp - 160], rax
    mov rax, [rbp - 160]
    test rax, rax
    jz ir_errdefer_ok_728
    jmp ir_errdefer_end_729
ir_errdefer_ok_728:
ir_errdefer_end_729:
    mov rax, 0
    jmp Lis_valid_dep_name_exit
    jmp ir_if_end_724
ir_if_next_725:
ir_if_end_724:
    ; Load variable: i
    movsxd rax, dword [rbp - 12]  ; From stack [rbp - 12]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    ; Store to variable: i
    mov dword [rbp - 12], eax  ; To stack [rbp - 12]
    jmp ir_while_720
ir_while_end_721:
    mov rax, 1
    mov [rbp - 176], rax
    mov rax, [rbp - 176]
    test rax, rax
    jz ir_errdefer_ok_730
    jmp ir_errdefer_end_731
ir_errdefer_ok_730:
ir_errdefer_end_731:
    mov rax, 1
    jmp Lis_valid_dep_name_exit
Lis_valid_dep_name_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global parse_key_value_line

parse_key_value_line:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    mov rax, 4608
    extern ___chkstk_ms
    sub rsp, 32
    call ___chkstk_ms
    add rsp, 32
    sub rsp, rax    ; Allocate 4608 bytes on stack (probed)
    ; Registering 6 function parameters
    mov [rbp - 8], rcx  ; Home param 'line'
    ; Parameter 'line' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'line_len'
    ; Parameter 'line_len' arrived in register rdx
    mov [rbp - 24], r8  ; Home param 'out_key'
    ; Parameter 'out_key' arrived in register r8
    mov [rbp - 32], r9  ; Home param 'out_key_max'
    ; Parameter 'out_key_max' arrived in register r9
    mov rax, [rbp + 48]  ; Load stack param 'out_value'
    mov [rbp - 40], rax  ; Home param 'out_value'
    ; Parameter 'out_value' arrived on stack [rbp + 48]
    mov rax, [rbp + 56]  ; Load stack param 'out_value_max'
    mov [rbp - 48], rax  ; Home param 'out_value_max'
    ; Parameter 'out_value_max' arrived on stack [rbp + 56]
ir_entry_732:
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    test rax, rax
    jz ir_sc_rhs_735
    jmp ir_sc_true_736
ir_sc_rhs_735:
    ; Load variable: out_key
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    test rax, rax
    jz ir_sc_false_737
ir_sc_true_736:
    mov rax, 1
    mov [rbp - 104], rax
    jmp ir_sc_end_738
ir_sc_false_737:
    mov rax, 0
    mov [rbp - 104], rax
ir_sc_end_738:
    mov rax, [rbp - 104]
    test rax, rax
    jz ir_sc_rhs_739
    jmp ir_sc_true_740
ir_sc_rhs_739:
    ; Load variable: out_value
    mov rax, qword [rbp - 40]  ; From stack [rbp - 40]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 120], rax
    mov rax, [rbp - 120]
    test rax, rax
    jz ir_sc_false_741
ir_sc_true_740:
    mov rax, 1
    mov [rbp - 128], rax
    jmp ir_sc_end_742
ir_sc_false_741:
    mov rax, 0
    mov [rbp - 128], rax
ir_sc_end_742:
    mov rax, [rbp - 128]
    test rax, rax
    jz ir_sc_rhs_743
    jmp ir_sc_true_744
ir_sc_rhs_743:
    ; Load variable: out_key_max
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    setle al
    movzx rax, al
    mov [rbp - 144], rax
    mov rax, [rbp - 144]
    test rax, rax
    jz ir_sc_false_745
ir_sc_true_744:
    mov rax, 1
    mov [rbp - 152], rax
    jmp ir_sc_end_746
ir_sc_false_745:
    mov rax, 0
    mov [rbp - 152], rax
ir_sc_end_746:
    mov rax, [rbp - 152]
    test rax, rax
    jz ir_sc_rhs_747
    jmp ir_sc_true_748
ir_sc_rhs_747:
    ; Load variable: out_value_max
    movsxd rax, dword [rbp - 48]  ; From stack [rbp - 48]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    setle al
    movzx rax, al
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    test rax, rax
    jz ir_sc_false_749
ir_sc_true_748:
    mov rax, 1
    mov [rbp - 176], rax
    jmp ir_sc_end_750
ir_sc_false_749:
    mov rax, 0
    mov [rbp - 176], rax
ir_sc_end_750:
    mov rax, [rbp - 176]
    test rax, rax
    jz ir_if_next_734
    mov rax, 1
    neg rax
    mov [rbp - 192], rax
    mov rax, [rbp - 192]
    mov [rbp - 200], rax
    mov rax, [rbp - 200]
    test rax, rax
    jz ir_errdefer_ok_751
    jmp ir_errdefer_end_752
ir_errdefer_ok_751:
ir_errdefer_end_752:
    mov rax, [rbp - 192]
    jmp Lparse_key_value_line_exit
    jmp ir_if_end_733
ir_if_next_734:
ir_if_end_733:
    mov rax, 0
    ; Store to variable: i
    mov dword [rbp - 52], eax  ; To stack [rbp - 52]
ir_while_753:
    ; Load variable: i
    movsxd rax, dword [rbp - 52]  ; From stack [rbp - 52]
    push rax
    ; Load variable: line_len
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 208], rax
    mov rax, [rbp - 208]
    test rax, rax
    jz ir_sc_false_757
ir_sc_rhs_755:
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_759
    jmp ir_nonnull_760
ir_trap_null_759:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct224]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_760:
    ; Load variable: i
    movsxd rax, dword [rbp - 52]  ; From stack [rbp - 52]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 216], rax
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 216]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 224], rax
    mov rax, [rbp - 224]
    movzx rax, byte [rax]
    mov [rbp - 232], rax
    mov rax, [rbp - 232]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 240], rax
    mov rax, [rbp - 240]
    test rax, rax
    jz ir_sc_false_757
ir_sc_true_756:
    mov rax, 1
    mov [rbp - 248], rax
    jmp ir_sc_end_758
ir_sc_false_757:
    mov rax, 0
    mov [rbp - 248], rax
ir_sc_end_758:
    mov rax, [rbp - 248]
    test rax, rax
    jz ir_while_end_754
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_763
    jmp ir_nonnull_764
ir_trap_null_763:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct226]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_764:
    ; Load variable: i
    movsxd rax, dword [rbp - 52]  ; From stack [rbp - 52]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 264], rax
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 264]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 272], rax
    mov rax, [rbp - 272]
    movzx rax, byte [rax]
    mov [rbp - 280], rax
    ; IR call: is_space (1 args)
    sub rsp, 32
    mov rax, [rbp - 280]
    mov rcx, rax
    call is_space
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 288], rax
    mov rax, [rbp - 288]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 296], rax
    mov rax, [rbp - 296]
    test rax, rax
    jz ir_if_next_762
    ; Load variable: i
    movsxd rax, dword [rbp - 52]  ; From stack [rbp - 52]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 304], rax
    mov rax, [rbp - 304]
    ; Store to variable: i
    mov dword [rbp - 52], eax  ; To stack [rbp - 52]
    jmp ir_if_end_761
ir_if_next_762:
    jmp ir_while_end_754
ir_if_end_761:
    jmp ir_while_753
ir_while_end_754:
    ; Load variable: i
    movsxd rax, dword [rbp - 52]  ; From stack [rbp - 52]
    push rax
    ; Load variable: line_len
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 312], rax
    mov rax, [rbp - 312]
    test rax, rax
    jz ir_sc_rhs_767
    jmp ir_sc_true_768
ir_sc_rhs_767:
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_771
    jmp ir_nonnull_772
ir_trap_null_771:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct228]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_772:
    ; Load variable: i
    movsxd rax, dword [rbp - 52]  ; From stack [rbp - 52]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 320], rax
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 320]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 328], rax
    mov rax, [rbp - 328]
    movzx rax, byte [rax]
    mov [rbp - 336], rax
    mov rax, [rbp - 336]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 344], rax
    mov rax, [rbp - 344]
    test rax, rax
    jz ir_sc_false_769
ir_sc_true_768:
    mov rax, 1
    mov [rbp - 352], rax
    jmp ir_sc_end_770
ir_sc_false_769:
    mov rax, 0
    mov [rbp - 352], rax
ir_sc_end_770:
    mov rax, [rbp - 352]
    test rax, rax
    jz ir_sc_rhs_773
    jmp ir_sc_true_774
ir_sc_rhs_773:
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_777
    jmp ir_nonnull_778
ir_trap_null_777:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct230]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_778:
    ; Load variable: i
    movsxd rax, dword [rbp - 52]  ; From stack [rbp - 52]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 368], rax
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 368]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 376], rax
    mov rax, [rbp - 376]
    movzx rax, byte [rax]
    mov [rbp - 384], rax
    mov rax, [rbp - 384]
    push rax
    mov rax, 10
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 392], rax
    mov rax, [rbp - 392]
    test rax, rax
    jz ir_sc_false_775
ir_sc_true_774:
    mov rax, 1
    mov [rbp - 400], rax
    jmp ir_sc_end_776
ir_sc_false_775:
    mov rax, 0
    mov [rbp - 400], rax
ir_sc_end_776:
    mov rax, [rbp - 400]
    test rax, rax
    jz ir_sc_rhs_779
    jmp ir_sc_true_780
ir_sc_rhs_779:
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_783
    jmp ir_nonnull_784
ir_trap_null_783:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct232]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_784:
    ; Load variable: i
    movsxd rax, dword [rbp - 52]  ; From stack [rbp - 52]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 416], rax
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 416]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 424], rax
    mov rax, [rbp - 424]
    movzx rax, byte [rax]
    mov [rbp - 432], rax
    mov rax, [rbp - 432]
    push rax
    mov rax, 13
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 440], rax
    mov rax, [rbp - 440]
    test rax, rax
    jz ir_sc_false_781
ir_sc_true_780:
    mov rax, 1
    mov [rbp - 448], rax
    jmp ir_sc_end_782
ir_sc_false_781:
    mov rax, 0
    mov [rbp - 448], rax
ir_sc_end_782:
    mov rax, [rbp - 448]
    test rax, rax
    jz ir_if_next_766
    mov rax, 0
    mov [rbp - 464], rax
    mov rax, [rbp - 464]
    test rax, rax
    jz ir_errdefer_ok_785
    jmp ir_errdefer_end_786
ir_errdefer_ok_785:
ir_errdefer_end_786:
    mov rax, 0
    jmp Lparse_key_value_line_exit
    jmp ir_if_end_765
ir_if_next_766:
ir_if_end_765:
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_789
    jmp ir_nonnull_790
ir_trap_null_789:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct234]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_790:
    ; Load variable: i
    movsxd rax, dword [rbp - 52]  ; From stack [rbp - 52]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 472], rax
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 472]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 480], rax
    mov rax, [rbp - 480]
    movzx rax, byte [rax]
    mov [rbp - 488], rax
    mov rax, [rbp - 488]
    push rax
    mov rax, 35
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 496], rax
    mov rax, [rbp - 496]
    test rax, rax
    jz ir_if_next_788
    mov rax, 0
    mov [rbp - 504], rax
    mov rax, [rbp - 504]
    test rax, rax
    jz ir_errdefer_ok_791
    jmp ir_errdefer_end_792
ir_errdefer_ok_791:
ir_errdefer_end_792:
    mov rax, 0
    jmp Lparse_key_value_line_exit
    jmp ir_if_end_787
ir_if_next_788:
ir_if_end_787:
    ; Load variable: i
    movsxd rax, dword [rbp - 52]  ; From stack [rbp - 52]
    ; Store to variable: key_start
    mov dword [rbp - 56], eax  ; To stack [rbp - 56]
ir_while_793:
    ; Load variable: i
    movsxd rax, dword [rbp - 52]  ; From stack [rbp - 52]
    push rax
    ; Load variable: line_len
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 512], rax
    mov rax, [rbp - 512]
    test rax, rax
    jz ir_sc_false_797
ir_sc_rhs_795:
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_799
    jmp ir_nonnull_800
ir_trap_null_799:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct236]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_800:
    ; Load variable: i
    movsxd rax, dword [rbp - 52]  ; From stack [rbp - 52]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 520], rax
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 520]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 528], rax
    mov rax, [rbp - 528]
    movzx rax, byte [rax]
    mov [rbp - 536], rax
    mov rax, [rbp - 536]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 544], rax
    mov rax, [rbp - 544]
    test rax, rax
    jz ir_sc_false_797
ir_sc_true_796:
    mov rax, 1
    mov [rbp - 552], rax
    jmp ir_sc_end_798
ir_sc_false_797:
    mov rax, 0
    mov [rbp - 552], rax
ir_sc_end_798:
    mov rax, [rbp - 552]
    test rax, rax
    jz ir_sc_false_803
ir_sc_rhs_801:
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_805
    jmp ir_nonnull_806
ir_trap_null_805:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct238]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_806:
    ; Load variable: i
    movsxd rax, dword [rbp - 52]  ; From stack [rbp - 52]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 568], rax
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 568]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 576], rax
    mov rax, [rbp - 576]
    movzx rax, byte [rax]
    mov [rbp - 584], rax
    mov rax, [rbp - 584]
    push rax
    mov rax, 61
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 592], rax
    mov rax, [rbp - 592]
    test rax, rax
    jz ir_sc_false_803
ir_sc_true_802:
    mov rax, 1
    mov [rbp - 600], rax
    jmp ir_sc_end_804
ir_sc_false_803:
    mov rax, 0
    mov [rbp - 600], rax
ir_sc_end_804:
    mov rax, [rbp - 600]
    test rax, rax
    jz ir_sc_false_809
ir_sc_rhs_807:
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_811
    jmp ir_nonnull_812
ir_trap_null_811:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct240]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_812:
    ; Load variable: i
    movsxd rax, dword [rbp - 52]  ; From stack [rbp - 52]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 616], rax
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 616]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 624], rax
    mov rax, [rbp - 624]
    movzx rax, byte [rax]
    mov [rbp - 632], rax
    mov rax, [rbp - 632]
    push rax
    mov rax, 10
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 640], rax
    mov rax, [rbp - 640]
    test rax, rax
    jz ir_sc_false_809
ir_sc_true_808:
    mov rax, 1
    mov [rbp - 648], rax
    jmp ir_sc_end_810
ir_sc_false_809:
    mov rax, 0
    mov [rbp - 648], rax
ir_sc_end_810:
    mov rax, [rbp - 648]
    test rax, rax
    jz ir_sc_false_815
ir_sc_rhs_813:
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_817
    jmp ir_nonnull_818
ir_trap_null_817:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct242]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_818:
    ; Load variable: i
    movsxd rax, dword [rbp - 52]  ; From stack [rbp - 52]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 664], rax
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 664]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 672], rax
    mov rax, [rbp - 672]
    movzx rax, byte [rax]
    mov [rbp - 680], rax
    mov rax, [rbp - 680]
    push rax
    mov rax, 13
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 688], rax
    mov rax, [rbp - 688]
    test rax, rax
    jz ir_sc_false_815
ir_sc_true_814:
    mov rax, 1
    mov [rbp - 696], rax
    jmp ir_sc_end_816
ir_sc_false_815:
    mov rax, 0
    mov [rbp - 696], rax
ir_sc_end_816:
    mov rax, [rbp - 696]
    test rax, rax
    jz ir_while_end_794
    ; Load variable: i
    movsxd rax, dword [rbp - 52]  ; From stack [rbp - 52]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 712], rax
    mov rax, [rbp - 712]
    ; Store to variable: i
    mov dword [rbp - 52], eax  ; To stack [rbp - 52]
    jmp ir_while_793
ir_while_end_794:
    ; Load variable: i
    movsxd rax, dword [rbp - 52]  ; From stack [rbp - 52]
    push rax
    ; Load variable: line_len
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 720], rax
    mov rax, [rbp - 720]
    test rax, rax
    jz ir_sc_rhs_821
    jmp ir_sc_true_822
ir_sc_rhs_821:
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_825
    jmp ir_nonnull_826
ir_trap_null_825:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct244]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_826:
    ; Load variable: i
    movsxd rax, dword [rbp - 52]  ; From stack [rbp - 52]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 728], rax
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 728]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 736], rax
    mov rax, [rbp - 736]
    movzx rax, byte [rax]
    mov [rbp - 744], rax
    mov rax, [rbp - 744]
    push rax
    mov rax, 61
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 752], rax
    mov rax, [rbp - 752]
    test rax, rax
    jz ir_sc_false_823
ir_sc_true_822:
    mov rax, 1
    mov [rbp - 760], rax
    jmp ir_sc_end_824
ir_sc_false_823:
    mov rax, 0
    mov [rbp - 760], rax
ir_sc_end_824:
    mov rax, [rbp - 760]
    test rax, rax
    jz ir_if_next_820
    mov rax, 0
    mov [rbp - 776], rax
    mov rax, [rbp - 776]
    test rax, rax
    jz ir_errdefer_ok_827
    jmp ir_errdefer_end_828
ir_errdefer_ok_827:
ir_errdefer_end_828:
    mov rax, 0
    jmp Lparse_key_value_line_exit
    jmp ir_if_end_819
ir_if_next_820:
ir_if_end_819:
    ; Load variable: i
    movsxd rax, dword [rbp - 52]  ; From stack [rbp - 52]
    ; Store to variable: key_end
    mov dword [rbp - 60], eax  ; To stack [rbp - 60]
ir_while_829:
    ; Load variable: key_end
    movsxd rax, dword [rbp - 60]  ; From stack [rbp - 60]
    push rax
    ; Load variable: key_start
    movsxd rax, dword [rbp - 56]  ; From stack [rbp - 56]
    mov r10, rax
    pop rax
    cmp rax, r10
    setg al
    movzx rax, al
    mov [rbp - 784], rax
    mov rax, [rbp - 784]
    test rax, rax
    jz ir_sc_false_833
ir_sc_rhs_831:
    ; Load variable: key_end
    movsxd rax, dword [rbp - 60]  ; From stack [rbp - 60]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 792], rax
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_835
    jmp ir_nonnull_836
ir_trap_null_835:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct246]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_836:
    mov rax, [rbp - 792]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 800], rax
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 800]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 808], rax
    mov rax, [rbp - 808]
    movzx rax, byte [rax]
    mov [rbp - 816], rax
    ; IR call: is_space (1 args)
    sub rsp, 32
    mov rax, [rbp - 816]
    mov rcx, rax
    call is_space
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 824], rax
    mov rax, [rbp - 824]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 832], rax
    mov rax, [rbp - 832]
    test rax, rax
    jz ir_sc_false_833
ir_sc_true_832:
    mov rax, 1
    mov [rbp - 840], rax
    jmp ir_sc_end_834
ir_sc_false_833:
    mov rax, 0
    mov [rbp - 840], rax
ir_sc_end_834:
    mov rax, [rbp - 840]
    test rax, rax
    jz ir_while_end_830
    ; Load variable: key_end
    movsxd rax, dword [rbp - 60]  ; From stack [rbp - 60]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 856], rax
    mov rax, [rbp - 856]
    ; Store to variable: key_end
    mov dword [rbp - 60], eax  ; To stack [rbp - 60]
    jmp ir_while_829
ir_while_end_830:
    ; Load variable: i
    movsxd rax, dword [rbp - 52]  ; From stack [rbp - 52]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 864], rax
    mov rax, [rbp - 864]
    ; Store to variable: i
    mov dword [rbp - 52], eax  ; To stack [rbp - 52]
ir_while_837:
    ; Load variable: i
    movsxd rax, dword [rbp - 52]  ; From stack [rbp - 52]
    push rax
    ; Load variable: line_len
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 872], rax
    mov rax, [rbp - 872]
    test rax, rax
    jz ir_sc_false_841
ir_sc_rhs_839:
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_843
    jmp ir_nonnull_844
ir_trap_null_843:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct248]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_844:
    ; Load variable: i
    movsxd rax, dword [rbp - 52]  ; From stack [rbp - 52]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 880], rax
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 880]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 888], rax
    mov rax, [rbp - 888]
    movzx rax, byte [rax]
    mov [rbp - 896], rax
    mov rax, [rbp - 896]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 904], rax
    mov rax, [rbp - 904]
    test rax, rax
    jz ir_sc_false_841
ir_sc_true_840:
    mov rax, 1
    mov [rbp - 912], rax
    jmp ir_sc_end_842
ir_sc_false_841:
    mov rax, 0
    mov [rbp - 912], rax
ir_sc_end_842:
    mov rax, [rbp - 912]
    test rax, rax
    jz ir_sc_false_847
ir_sc_rhs_845:
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_849
    jmp ir_nonnull_850
ir_trap_null_849:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct250]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_850:
    ; Load variable: i
    movsxd rax, dword [rbp - 52]  ; From stack [rbp - 52]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 928], rax
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 928]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 936], rax
    mov rax, [rbp - 936]
    movzx rax, byte [rax]
    mov [rbp - 944], rax
    mov rax, [rbp - 944]
    push rax
    mov rax, 10
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 952], rax
    mov rax, [rbp - 952]
    test rax, rax
    jz ir_sc_false_847
ir_sc_true_846:
    mov rax, 1
    mov [rbp - 960], rax
    jmp ir_sc_end_848
ir_sc_false_847:
    mov rax, 0
    mov [rbp - 960], rax
ir_sc_end_848:
    mov rax, [rbp - 960]
    test rax, rax
    jz ir_sc_false_853
ir_sc_rhs_851:
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_855
    jmp ir_nonnull_856
ir_trap_null_855:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct252]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_856:
    ; Load variable: i
    movsxd rax, dword [rbp - 52]  ; From stack [rbp - 52]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 976], rax
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 976]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 984], rax
    mov rax, [rbp - 984]
    movzx rax, byte [rax]
    mov [rbp - 992], rax
    mov rax, [rbp - 992]
    push rax
    mov rax, 13
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 1000], rax
    mov rax, [rbp - 1000]
    test rax, rax
    jz ir_sc_false_853
ir_sc_true_852:
    mov rax, 1
    mov [rbp - 1008], rax
    jmp ir_sc_end_854
ir_sc_false_853:
    mov rax, 0
    mov [rbp - 1008], rax
ir_sc_end_854:
    mov rax, [rbp - 1008]
    test rax, rax
    jz ir_sc_false_859
ir_sc_rhs_857:
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_861
    jmp ir_nonnull_862
ir_trap_null_861:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct254]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_862:
    ; Load variable: i
    movsxd rax, dword [rbp - 52]  ; From stack [rbp - 52]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1024], rax
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 1024]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1032], rax
    mov rax, [rbp - 1032]
    movzx rax, byte [rax]
    mov [rbp - 1040], rax
    ; IR call: is_space (1 args)
    sub rsp, 32
    mov rax, [rbp - 1040]
    mov rcx, rax
    call is_space
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1048], rax
    mov rax, [rbp - 1048]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 1056], rax
    mov rax, [rbp - 1056]
    test rax, rax
    jz ir_sc_false_859
ir_sc_true_858:
    mov rax, 1
    mov [rbp - 1064], rax
    jmp ir_sc_end_860
ir_sc_false_859:
    mov rax, 0
    mov [rbp - 1064], rax
ir_sc_end_860:
    mov rax, [rbp - 1064]
    test rax, rax
    jz ir_while_end_838
    ; Load variable: i
    movsxd rax, dword [rbp - 52]  ; From stack [rbp - 52]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1080], rax
    mov rax, [rbp - 1080]
    ; Store to variable: i
    mov dword [rbp - 52], eax  ; To stack [rbp - 52]
    jmp ir_while_837
ir_while_end_838:
    ; Load variable: i
    movsxd rax, dword [rbp - 52]  ; From stack [rbp - 52]
    ; Store to variable: value_start
    mov dword [rbp - 64], eax  ; To stack [rbp - 64]
ir_while_863:
    ; Load variable: i
    movsxd rax, dword [rbp - 52]  ; From stack [rbp - 52]
    push rax
    ; Load variable: line_len
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1088], rax
    mov rax, [rbp - 1088]
    test rax, rax
    jz ir_sc_false_867
ir_sc_rhs_865:
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_869
    jmp ir_nonnull_870
ir_trap_null_869:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct256]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_870:
    ; Load variable: i
    movsxd rax, dword [rbp - 52]  ; From stack [rbp - 52]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1096], rax
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 1096]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1104], rax
    mov rax, [rbp - 1104]
    movzx rax, byte [rax]
    mov [rbp - 1112], rax
    mov rax, [rbp - 1112]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 1120], rax
    mov rax, [rbp - 1120]
    test rax, rax
    jz ir_sc_false_867
ir_sc_true_866:
    mov rax, 1
    mov [rbp - 1128], rax
    jmp ir_sc_end_868
ir_sc_false_867:
    mov rax, 0
    mov [rbp - 1128], rax
ir_sc_end_868:
    mov rax, [rbp - 1128]
    test rax, rax
    jz ir_sc_false_873
ir_sc_rhs_871:
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_875
    jmp ir_nonnull_876
ir_trap_null_875:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct258]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_876:
    ; Load variable: i
    movsxd rax, dword [rbp - 52]  ; From stack [rbp - 52]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1144], rax
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 1144]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1152], rax
    mov rax, [rbp - 1152]
    movzx rax, byte [rax]
    mov [rbp - 1160], rax
    mov rax, [rbp - 1160]
    push rax
    mov rax, 10
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 1168], rax
    mov rax, [rbp - 1168]
    test rax, rax
    jz ir_sc_false_873
ir_sc_true_872:
    mov rax, 1
    mov [rbp - 1176], rax
    jmp ir_sc_end_874
ir_sc_false_873:
    mov rax, 0
    mov [rbp - 1176], rax
ir_sc_end_874:
    mov rax, [rbp - 1176]
    test rax, rax
    jz ir_sc_false_879
ir_sc_rhs_877:
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_881
    jmp ir_nonnull_882
ir_trap_null_881:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct260]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_882:
    ; Load variable: i
    movsxd rax, dword [rbp - 52]  ; From stack [rbp - 52]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1192], rax
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 1192]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1200], rax
    mov rax, [rbp - 1200]
    movzx rax, byte [rax]
    mov [rbp - 1208], rax
    mov rax, [rbp - 1208]
    push rax
    mov rax, 13
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 1216], rax
    mov rax, [rbp - 1216]
    test rax, rax
    jz ir_sc_false_879
ir_sc_true_878:
    mov rax, 1
    mov [rbp - 1224], rax
    jmp ir_sc_end_880
ir_sc_false_879:
    mov rax, 0
    mov [rbp - 1224], rax
ir_sc_end_880:
    mov rax, [rbp - 1224]
    test rax, rax
    jz ir_while_end_864
    ; Load variable: i
    movsxd rax, dword [rbp - 52]  ; From stack [rbp - 52]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1240], rax
    mov rax, [rbp - 1240]
    ; Store to variable: i
    mov dword [rbp - 52], eax  ; To stack [rbp - 52]
    jmp ir_while_863
ir_while_end_864:
    ; Load variable: i
    movsxd rax, dword [rbp - 52]  ; From stack [rbp - 52]
    ; Store to variable: value_end
    mov dword [rbp - 68], eax  ; To stack [rbp - 68]
ir_while_883:
    ; Load variable: value_end
    movsxd rax, dword [rbp - 68]  ; From stack [rbp - 68]
    push rax
    ; Load variable: value_start
    movsxd rax, dword [rbp - 64]  ; From stack [rbp - 64]
    mov r10, rax
    pop rax
    cmp rax, r10
    setg al
    movzx rax, al
    mov [rbp - 1248], rax
    mov rax, [rbp - 1248]
    test rax, rax
    jz ir_sc_false_887
ir_sc_rhs_885:
    ; Load variable: value_end
    movsxd rax, dword [rbp - 68]  ; From stack [rbp - 68]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 1256], rax
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_889
    jmp ir_nonnull_890
ir_trap_null_889:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct262]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_890:
    mov rax, [rbp - 1256]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1264], rax
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 1264]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1272], rax
    mov rax, [rbp - 1272]
    movzx rax, byte [rax]
    mov [rbp - 1280], rax
    ; IR call: is_space (1 args)
    sub rsp, 32
    mov rax, [rbp - 1280]
    mov rcx, rax
    call is_space
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1288], rax
    mov rax, [rbp - 1288]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 1296], rax
    mov rax, [rbp - 1296]
    test rax, rax
    jz ir_sc_false_887
ir_sc_true_886:
    mov rax, 1
    mov [rbp - 1304], rax
    jmp ir_sc_end_888
ir_sc_false_887:
    mov rax, 0
    mov [rbp - 1304], rax
ir_sc_end_888:
    mov rax, [rbp - 1304]
    test rax, rax
    jz ir_while_end_884
    ; Load variable: value_end
    movsxd rax, dword [rbp - 68]  ; From stack [rbp - 68]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 1320], rax
    mov rax, [rbp - 1320]
    ; Store to variable: value_end
    mov dword [rbp - 68], eax  ; To stack [rbp - 68]
    jmp ir_while_883
ir_while_end_884:
    ; Load variable: key_end
    movsxd rax, dword [rbp - 60]  ; From stack [rbp - 60]
    push rax
    ; Load variable: key_start
    movsxd rax, dword [rbp - 56]  ; From stack [rbp - 56]
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 1328], rax
    mov rax, [rbp - 1328]
    ; Store to variable: key_len
    mov dword [rbp - 72], eax  ; To stack [rbp - 72]
    ; Load variable: value_end
    movsxd rax, dword [rbp - 68]  ; From stack [rbp - 68]
    push rax
    ; Load variable: value_start
    movsxd rax, dword [rbp - 64]  ; From stack [rbp - 64]
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 1336], rax
    mov rax, [rbp - 1336]
    ; Store to variable: value_len
    mov dword [rbp - 76], eax  ; To stack [rbp - 76]
    ; Load variable: key_len
    movsxd rax, dword [rbp - 72]  ; From stack [rbp - 72]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setle al
    movzx rax, al
    mov [rbp - 1344], rax
    mov rax, [rbp - 1344]
    test rax, rax
    jz ir_sc_rhs_893
    jmp ir_sc_true_894
ir_sc_rhs_893:
    ; Load variable: key_len
    movsxd rax, dword [rbp - 72]  ; From stack [rbp - 72]
    push rax
    ; Load variable: out_key_max
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 1352], rax
    mov rax, [rbp - 1352]
    test rax, rax
    jz ir_sc_false_895
ir_sc_true_894:
    mov rax, 1
    mov [rbp - 1360], rax
    jmp ir_sc_end_896
ir_sc_false_895:
    mov rax, 0
    mov [rbp - 1360], rax
ir_sc_end_896:
    mov rax, [rbp - 1360]
    test rax, rax
    jz ir_if_next_892
    mov rax, 1
    neg rax
    mov [rbp - 1376], rax
    mov rax, [rbp - 1376]
    mov [rbp - 1384], rax
    mov rax, [rbp - 1384]
    test rax, rax
    jz ir_errdefer_ok_897
    jmp ir_errdefer_end_898
ir_errdefer_ok_897:
ir_errdefer_end_898:
    mov rax, [rbp - 1376]
    jmp Lparse_key_value_line_exit
    jmp ir_if_end_891
ir_if_next_892:
ir_if_end_891:
    ; Load variable: value_len
    movsxd rax, dword [rbp - 76]  ; From stack [rbp - 76]
    push rax
    ; Load variable: out_value_max
    movsxd rax, dword [rbp - 48]  ; From stack [rbp - 48]
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 1392], rax
    mov rax, [rbp - 1392]
    test rax, rax
    jz ir_if_next_900
    mov rax, 1
    neg rax
    mov [rbp - 1400], rax
    mov rax, [rbp - 1400]
    mov [rbp - 1408], rax
    mov rax, [rbp - 1408]
    test rax, rax
    jz ir_errdefer_ok_901
    jmp ir_errdefer_end_902
ir_errdefer_ok_901:
ir_errdefer_end_902:
    mov rax, [rbp - 1400]
    jmp Lparse_key_value_line_exit
    jmp ir_if_end_899
ir_if_next_900:
ir_if_end_899:
    mov rax, 0
    ; Store to variable: j
    mov dword [rbp - 80], eax  ; To stack [rbp - 80]
ir_while_903:
    ; Load variable: j
    movsxd rax, dword [rbp - 80]  ; From stack [rbp - 80]
    push rax
    ; Load variable: key_len
    movsxd rax, dword [rbp - 72]  ; From stack [rbp - 72]
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1416], rax
    mov rax, [rbp - 1416]
    test rax, rax
    jz ir_while_end_904
    ; Load variable: key_start
    movsxd rax, dword [rbp - 56]  ; From stack [rbp - 56]
    push rax
    ; Load variable: j
    movsxd rax, dword [rbp - 80]  ; From stack [rbp - 80]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1424], rax
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_905
    jmp ir_nonnull_906
ir_trap_null_905:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct264]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_906:
    mov rax, [rbp - 1424]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1432], rax
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 1432]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1440], rax
    mov rax, [rbp - 1440]
    movzx rax, byte [rax]
    mov [rbp - 1448], rax
    ; Load variable: out_key
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    test rax, rax
    jz ir_trap_null_907
    jmp ir_nonnull_908
ir_trap_null_907:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct266]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_908:
    ; Load variable: j
    movsxd rax, dword [rbp - 80]  ; From stack [rbp - 80]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1456], rax
    ; Load variable: out_key
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, [rbp - 1456]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1464], rax
    mov rax, [rbp - 1464]
    push rax
    mov rax, [rbp - 1448]
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: j
    movsxd rax, dword [rbp - 80]  ; From stack [rbp - 80]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1480], rax
    mov rax, [rbp - 1480]
    ; Store to variable: j
    mov dword [rbp - 80], eax  ; To stack [rbp - 80]
    jmp ir_while_903
ir_while_end_904:
    ; Load variable: out_key
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    test rax, rax
    jz ir_trap_null_909
    jmp ir_nonnull_910
ir_trap_null_909:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct268]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_910:
    ; Load variable: j
    movsxd rax, dword [rbp - 80]  ; From stack [rbp - 80]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1488], rax
    ; Load variable: out_key
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, [rbp - 1488]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1496], rax
    mov rax, [rbp - 1496]
    push rax
    mov rax, 0
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    mov rax, 0
    ; Store to variable: j
    mov dword [rbp - 80], eax  ; To stack [rbp - 80]
ir_while_911:
    ; Load variable: j
    movsxd rax, dword [rbp - 80]  ; From stack [rbp - 80]
    push rax
    ; Load variable: value_len
    movsxd rax, dword [rbp - 76]  ; From stack [rbp - 76]
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1512], rax
    mov rax, [rbp - 1512]
    test rax, rax
    jz ir_while_end_912
    ; Load variable: value_start
    movsxd rax, dword [rbp - 64]  ; From stack [rbp - 64]
    push rax
    ; Load variable: j
    movsxd rax, dword [rbp - 80]  ; From stack [rbp - 80]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1520], rax
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_913
    jmp ir_nonnull_914
ir_trap_null_913:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct270]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_914:
    mov rax, [rbp - 1520]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1528], rax
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 1528]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1536], rax
    mov rax, [rbp - 1536]
    movzx rax, byte [rax]
    mov [rbp - 1544], rax
    ; Load variable: out_value
    mov rax, qword [rbp - 40]  ; From stack [rbp - 40]
    test rax, rax
    jz ir_trap_null_915
    jmp ir_nonnull_916
ir_trap_null_915:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct272]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_916:
    ; Load variable: j
    movsxd rax, dword [rbp - 80]  ; From stack [rbp - 80]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1552], rax
    ; Load variable: out_value
    mov rax, qword [rbp - 40]  ; From stack [rbp - 40]
    push rax
    mov rax, [rbp - 1552]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1560], rax
    mov rax, [rbp - 1560]
    push rax
    mov rax, [rbp - 1544]
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: j
    movsxd rax, dword [rbp - 80]  ; From stack [rbp - 80]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1576], rax
    mov rax, [rbp - 1576]
    ; Store to variable: j
    mov dword [rbp - 80], eax  ; To stack [rbp - 80]
    jmp ir_while_911
ir_while_end_912:
    ; Load variable: out_value
    mov rax, qword [rbp - 40]  ; From stack [rbp - 40]
    test rax, rax
    jz ir_trap_null_917
    jmp ir_nonnull_918
ir_trap_null_917:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct274]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_918:
    ; Load variable: j
    movsxd rax, dword [rbp - 80]  ; From stack [rbp - 80]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1584], rax
    ; Load variable: out_value
    mov rax, qword [rbp - 40]  ; From stack [rbp - 40]
    push rax
    mov rax, [rbp - 1584]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1592], rax
    mov rax, [rbp - 1592]
    push rax
    mov rax, 0
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    mov rax, 1
    mov [rbp - 1608], rax
    mov rax, [rbp - 1608]
    test rax, rax
    jz ir_errdefer_ok_919
    jmp ir_errdefer_end_920
ir_errdefer_ok_919:
ir_errdefer_end_920:
    mov rax, 1
    jmp Lparse_key_value_line_exit
Lparse_key_value_line_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global parse_dep_line

parse_dep_line:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 80    ; Allocate 80 bytes on stack (aligned)
    ; Registering 4 function parameters
    mov [rbp - 8], rcx  ; Home param 'line'
    ; Parameter 'line' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'line_len'
    ; Parameter 'line_len' arrived in register rdx
    mov [rbp - 24], r8  ; Home param 'out_name'
    ; Parameter 'out_name' arrived in register r8
    mov [rbp - 32], r9  ; Home param 'out_value'
    ; Parameter 'out_value' arrived in register r9
ir_entry_921:
    ; IR call: parse_key_value_line (6 args)
    sub rsp, 48
    ; Load variable: out_value
    mov rax, qword [rbp - 32]  ; From stack [rbp - 32]
    mov [rsp + 32], rax
    mov rax, 256
    mov [rsp + 40], rax
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    ; Load variable: line_len
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    mov rdx, rax
    ; Load variable: out_name
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov r8, rax
    mov rax, 128
    mov r9, rax
    call parse_key_value_line
    add rsp, 48
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_errdefer_ok_922
    jmp ir_errdefer_end_923
ir_errdefer_ok_922:
ir_errdefer_end_923:
    mov rax, [rbp - 40]
    jmp Lparse_dep_line_exit
Lparse_dep_line_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global print_usage

print_usage:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 80    ; Allocate 80 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_924:
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: USAGE
    lea rax, [rel USAGE]  ; Address of global string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 8], rax
    ; IR call: println (1 args)
    sub rsp, 32
    mov rax, [rbp - 8]
    mov rcx, rax
    call println
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 16], rax
    mov rax, 0
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_errdefer_ok_925
    jmp ir_errdefer_end_926
ir_errdefer_ok_925:
ir_errdefer_end_926:
    jmp Lprint_usage_exit
Lprint_usage_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global reset_resolved

reset_resolved:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 32    ; Allocate 32 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_927:
    mov rax, 0
    ; Store to variable: RESOLVED_COUNT
    mov dword [rel RESOLVED_COUNT], eax  ; To global memory
    mov rax, 0
    mov [rbp - 8], rax
    mov rax, [rbp - 8]
    test rax, rax
    jz ir_errdefer_ok_928
    jmp ir_errdefer_end_929
ir_errdefer_ok_928:
ir_errdefer_end_929:
    jmp Lreset_resolved_exit
Lreset_resolved_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global slot_copy

slot_copy:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 688    ; Allocate 688 bytes on stack (aligned)
    ; Registering 5 function parameters
    mov [rbp - 8], rcx  ; Home param 'storage'
    ; Parameter 'storage' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'slot_size'
    ; Parameter 'slot_size' arrived in register rdx
    mov [rbp - 24], r8  ; Home param 'index'
    ; Parameter 'index' arrived in register r8
    mov [rbp - 32], r9  ; Home param 'src'
    ; Parameter 'src' arrived in register r9
    mov rax, [rbp + 48]  ; Load stack param 'src_max'
    mov [rbp - 40], rax  ; Home param 'src_max'
    ; Parameter 'src_max' arrived on stack [rbp + 48]
ir_entry_930:
    ; Load variable: index
    movsxd rax, dword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    ; Load variable: slot_size
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    ; Store to variable: base
    mov dword [rbp - 44], eax  ; To stack [rbp - 44]
    mov rax, 0
    ; Store to variable: i
    mov dword [rbp - 48], eax  ; To stack [rbp - 48]
ir_while_931:
    ; Load variable: slot_size
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 64], rax
    ; Load variable: i
    movsxd rax, dword [rbp - 48]  ; From stack [rbp - 48]
    push rax
    mov rax, [rbp - 64]
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    test rax, rax
    jz ir_sc_false_935
ir_sc_rhs_933:
    ; Load variable: src_max
    movsxd rax, dword [rbp - 40]  ; From stack [rbp - 40]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 80], rax
    ; Load variable: i
    movsxd rax, dword [rbp - 48]  ; From stack [rbp - 48]
    push rax
    mov rax, [rbp - 80]
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    test rax, rax
    jz ir_sc_false_935
ir_sc_true_934:
    mov rax, 1
    mov [rbp - 96], rax
    jmp ir_sc_end_936
ir_sc_false_935:
    mov rax, 0
    mov [rbp - 96], rax
ir_sc_end_936:
    mov rax, [rbp - 96]
    test rax, rax
    jz ir_sc_false_939
ir_sc_rhs_937:
    ; Load variable: src
    mov rax, qword [rbp - 32]  ; From stack [rbp - 32]
    test rax, rax
    jz ir_trap_null_941
    jmp ir_nonnull_942
ir_trap_null_941:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct276]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_942:
    ; Load variable: i
    movsxd rax, dword [rbp - 48]  ; From stack [rbp - 48]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 112], rax
    ; Load variable: src
    mov rax, qword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, [rbp - 112]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 120], rax
    mov rax, [rbp - 120]
    movzx rax, byte [rax]
    mov [rbp - 128], rax
    mov rax, [rbp - 128]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 136], rax
    mov rax, [rbp - 136]
    test rax, rax
    jz ir_sc_false_939
ir_sc_true_938:
    mov rax, 1
    mov [rbp - 144], rax
    jmp ir_sc_end_940
ir_sc_false_939:
    mov rax, 0
    mov [rbp - 144], rax
ir_sc_end_940:
    mov rax, [rbp - 144]
    test rax, rax
    jz ir_while_end_932
    ; Load variable: src
    mov rax, qword [rbp - 32]  ; From stack [rbp - 32]
    test rax, rax
    jz ir_trap_null_943
    jmp ir_nonnull_944
ir_trap_null_943:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct278]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_944:
    ; Load variable: i
    movsxd rax, dword [rbp - 48]  ; From stack [rbp - 48]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 160], rax
    ; Load variable: src
    mov rax, qword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, [rbp - 160]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    movzx rax, byte [rax]
    mov [rbp - 176], rax
    ; Load variable: base
    movsxd rax, dword [rbp - 44]  ; From stack [rbp - 44]
    push rax
    ; Load variable: i
    movsxd rax, dword [rbp - 48]  ; From stack [rbp - 48]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 184], rax
    ; Load variable: storage
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_945
    jmp ir_nonnull_946
ir_trap_null_945:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct280]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_946:
    mov rax, [rbp - 184]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 192], rax
    ; Load variable: storage
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 192]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 200], rax
    mov rax, [rbp - 200]
    push rax
    mov rax, [rbp - 176]
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: i
    movsxd rax, dword [rbp - 48]  ; From stack [rbp - 48]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 216], rax
    mov rax, [rbp - 216]
    ; Store to variable: i
    mov dword [rbp - 48], eax  ; To stack [rbp - 48]
    jmp ir_while_931
ir_while_end_932:
    ; Load variable: base
    movsxd rax, dword [rbp - 44]  ; From stack [rbp - 44]
    push rax
    ; Load variable: i
    movsxd rax, dword [rbp - 48]  ; From stack [rbp - 48]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 224], rax
    ; Load variable: storage
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_947
    jmp ir_nonnull_948
ir_trap_null_947:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct282]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_948:
    mov rax, [rbp - 224]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 232], rax
    ; Load variable: storage
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 232]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 240], rax
    mov rax, [rbp - 240]
    push rax
    mov rax, 0
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    mov rax, 0
    mov [rbp - 256], rax
    mov rax, [rbp - 256]
    test rax, rax
    jz ir_errdefer_ok_949
    jmp ir_errdefer_end_950
ir_errdefer_ok_949:
ir_errdefer_end_950:
    jmp Lslot_copy_exit
Lslot_copy_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global slot_streq

slot_streq:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 576    ; Allocate 576 bytes on stack (aligned)
    ; Registering 4 function parameters
    mov [rbp - 8], rcx  ; Home param 'storage'
    ; Parameter 'storage' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'slot_size'
    ; Parameter 'slot_size' arrived in register rdx
    mov [rbp - 24], r8  ; Home param 'index'
    ; Parameter 'index' arrived in register r8
    mov [rbp - 32], r9  ; Home param 'value'
    ; Parameter 'value' arrived in register r9
ir_entry_951:
    ; Load variable: index
    movsxd rax, dword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    ; Load variable: slot_size
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    ; Store to variable: base
    mov dword [rbp - 36], eax  ; To stack [rbp - 36]
    mov rax, 0
    ; Store to variable: i
    mov dword [rbp - 40], eax  ; To stack [rbp - 40]
ir_while_952:
    ; Load variable: base
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    push rax
    ; Load variable: i
    movsxd rax, dword [rbp - 40]  ; From stack [rbp - 40]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 56], rax
    ; Load variable: storage
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_954
    jmp ir_nonnull_955
ir_trap_null_954:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct284]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_955:
    mov rax, [rbp - 56]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 64], rax
    ; Load variable: storage
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 64]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    movzx rax, byte [rax]
    mov [rbp - 80], rax
    mov rax, [rbp - 80]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    test rax, rax
    jz ir_while_end_953
    ; Load variable: base
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    push rax
    ; Load variable: i
    movsxd rax, dword [rbp - 40]  ; From stack [rbp - 40]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 96], rax
    ; Load variable: storage
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_958
    jmp ir_nonnull_959
ir_trap_null_958:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct286]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_959:
    mov rax, [rbp - 96]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 104], rax
    ; Load variable: storage
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 104]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    movzx rax, byte [rax]
    mov [rbp - 120], rax
    ; Load variable: value
    mov rax, qword [rbp - 32]  ; From stack [rbp - 32]
    test rax, rax
    jz ir_trap_null_960
    jmp ir_nonnull_961
ir_trap_null_960:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct288]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_961:
    ; Load variable: i
    movsxd rax, dword [rbp - 40]  ; From stack [rbp - 40]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 128], rax
    ; Load variable: value
    mov rax, qword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, [rbp - 128]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 136], rax
    mov rax, [rbp - 136]
    movzx rax, byte [rax]
    mov [rbp - 144], rax
    mov rax, [rbp - 120]
    push rax
    mov rax, [rbp - 144]
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 152], rax
    mov rax, [rbp - 152]
    test rax, rax
    jz ir_if_next_957
    mov rax, 0
    mov [rbp - 160], rax
    mov rax, [rbp - 160]
    test rax, rax
    jz ir_errdefer_ok_962
    jmp ir_errdefer_end_963
ir_errdefer_ok_962:
ir_errdefer_end_963:
    mov rax, 0
    jmp Lslot_streq_exit
    jmp ir_if_end_956
ir_if_next_957:
ir_if_end_956:
    ; Load variable: i
    movsxd rax, dword [rbp - 40]  ; From stack [rbp - 40]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    ; Store to variable: i
    mov dword [rbp - 40], eax  ; To stack [rbp - 40]
    jmp ir_while_952
ir_while_end_953:
    ; Load variable: value
    mov rax, qword [rbp - 32]  ; From stack [rbp - 32]
    test rax, rax
    jz ir_trap_null_966
    jmp ir_nonnull_967
ir_trap_null_966:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct290]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_967:
    ; Load variable: i
    movsxd rax, dword [rbp - 40]  ; From stack [rbp - 40]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 176], rax
    ; Load variable: value
    mov rax, qword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, [rbp - 176]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 184], rax
    mov rax, [rbp - 184]
    movzx rax, byte [rax]
    mov [rbp - 192], rax
    mov rax, [rbp - 192]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 200], rax
    mov rax, [rbp - 200]
    test rax, rax
    jz ir_if_next_965
    mov rax, 0
    mov [rbp - 208], rax
    mov rax, [rbp - 208]
    test rax, rax
    jz ir_errdefer_ok_968
    jmp ir_errdefer_end_969
ir_errdefer_ok_968:
ir_errdefer_end_969:
    mov rax, 0
    jmp Lslot_streq_exit
    jmp ir_if_end_964
ir_if_next_965:
ir_if_end_964:
    mov rax, 1
    mov [rbp - 216], rax
    mov rax, [rbp - 216]
    test rax, rax
    jz ir_errdefer_ok_970
    jmp ir_errdefer_end_971
ir_errdefer_ok_970:
ir_errdefer_end_971:
    mov rax, 1
    jmp Lslot_streq_exit
Lslot_streq_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global slot_to_buf

slot_to_buf:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 592    ; Allocate 592 bytes on stack (aligned)
    ; Registering 5 function parameters
    mov [rbp - 8], rcx  ; Home param 'storage'
    ; Parameter 'storage' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'slot_size'
    ; Parameter 'slot_size' arrived in register rdx
    mov [rbp - 24], r8  ; Home param 'index'
    ; Parameter 'index' arrived in register r8
    mov [rbp - 32], r9  ; Home param 'out'
    ; Parameter 'out' arrived in register r9
    mov rax, [rbp + 48]  ; Load stack param 'out_max'
    mov [rbp - 40], rax  ; Home param 'out_max'
    ; Parameter 'out_max' arrived on stack [rbp + 48]
ir_entry_972:
    ; Load variable: index
    movsxd rax, dword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    ; Load variable: slot_size
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    ; Store to variable: base
    mov dword [rbp - 44], eax  ; To stack [rbp - 44]
    mov rax, 0
    ; Store to variable: i
    mov dword [rbp - 48], eax  ; To stack [rbp - 48]
ir_while_973:
    ; Load variable: out_max
    movsxd rax, dword [rbp - 40]  ; From stack [rbp - 40]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 64], rax
    ; Load variable: i
    movsxd rax, dword [rbp - 48]  ; From stack [rbp - 48]
    push rax
    mov rax, [rbp - 64]
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    test rax, rax
    jz ir_sc_false_977
ir_sc_rhs_975:
    ; Load variable: base
    movsxd rax, dword [rbp - 44]  ; From stack [rbp - 44]
    push rax
    ; Load variable: i
    movsxd rax, dword [rbp - 48]  ; From stack [rbp - 48]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 80], rax
    ; Load variable: storage
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_979
    jmp ir_nonnull_980
ir_trap_null_979:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct292]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_980:
    mov rax, [rbp - 80]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 88], rax
    ; Load variable: storage
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 88]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    movzx rax, byte [rax]
    mov [rbp - 104], rax
    mov rax, [rbp - 104]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    test rax, rax
    jz ir_sc_false_977
ir_sc_true_976:
    mov rax, 1
    mov [rbp - 120], rax
    jmp ir_sc_end_978
ir_sc_false_977:
    mov rax, 0
    mov [rbp - 120], rax
ir_sc_end_978:
    mov rax, [rbp - 120]
    test rax, rax
    jz ir_while_end_974
    ; Load variable: base
    movsxd rax, dword [rbp - 44]  ; From stack [rbp - 44]
    push rax
    ; Load variable: i
    movsxd rax, dword [rbp - 48]  ; From stack [rbp - 48]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 136], rax
    ; Load variable: storage
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_981
    jmp ir_nonnull_982
ir_trap_null_981:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct294]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_982:
    mov rax, [rbp - 136]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 144], rax
    ; Load variable: storage
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 144]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 152], rax
    mov rax, [rbp - 152]
    movzx rax, byte [rax]
    mov [rbp - 160], rax
    ; Load variable: out
    mov rax, qword [rbp - 32]  ; From stack [rbp - 32]
    test rax, rax
    jz ir_trap_null_983
    jmp ir_nonnull_984
ir_trap_null_983:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct296]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_984:
    ; Load variable: i
    movsxd rax, dword [rbp - 48]  ; From stack [rbp - 48]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 168], rax
    ; Load variable: out
    mov rax, qword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, [rbp - 168]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 176], rax
    mov rax, [rbp - 176]
    push rax
    mov rax, [rbp - 160]
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: i
    movsxd rax, dword [rbp - 48]  ; From stack [rbp - 48]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 192], rax
    mov rax, [rbp - 192]
    ; Store to variable: i
    mov dword [rbp - 48], eax  ; To stack [rbp - 48]
    jmp ir_while_973
ir_while_end_974:
    ; Load variable: out
    mov rax, qword [rbp - 32]  ; From stack [rbp - 32]
    test rax, rax
    jz ir_trap_null_985
    jmp ir_nonnull_986
ir_trap_null_985:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct298]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_986:
    ; Load variable: i
    movsxd rax, dword [rbp - 48]  ; From stack [rbp - 48]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 200], rax
    ; Load variable: out
    mov rax, qword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, [rbp - 200]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 208], rax
    mov rax, [rbp - 208]
    push rax
    mov rax, 0
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    mov rax, 0
    mov [rbp - 224], rax
    mov rax, [rbp - 224]
    test rax, rax
    jz ir_errdefer_ok_987
    jmp ir_errdefer_end_988
ir_errdefer_ok_987:
ir_errdefer_end_988:
    jmp Lslot_to_buf_exit
Lslot_to_buf_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global find_resolved_by_name

find_resolved_by_name:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 272    ; Allocate 272 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'name'
    ; Parameter 'name' arrived in register rcx
ir_entry_989:
    mov rax, 0
    ; Store to variable: i
    mov dword [rbp - 12], eax  ; To stack [rbp - 12]
ir_while_990:
    ; Load variable: i
    movsxd rax, dword [rbp - 12]  ; From stack [rbp - 12]
    push rax
    ; Load variable: RESOLVED_COUNT
    movsxd rax, dword [rel RESOLVED_COUNT]  ; From global memory
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_while_end_991
    mov rax, 0
    push rax
    mov rax, 32768
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_trap_bounds_994
    jmp ir_in_bounds_995
ir_trap_bounds_994:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct300]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_995:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 40], rax
    ; Load variable: RESOLVED_NAME
    lea rax, [rel RESOLVED_NAME]  ; Array base address
    push rax
    mov rax, [rbp - 40]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 48], rax
    ; IR call: slot_streq (4 args)
    sub rsp, 32
    mov rax, [rbp - 48]
    mov rcx, rax
    mov rax, 128
    mov rdx, rax
    ; Load variable: i
    movsxd rax, dword [rbp - 12]  ; From stack [rbp - 12]
    mov r8, rax
    ; Load variable: name
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov r9, rax
    call slot_streq
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    test rax, rax
    jz ir_if_next_993
    ; Load variable: i
    movsxd rax, dword [rbp - 12]  ; From stack [rbp - 12]
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    test rax, rax
    jz ir_errdefer_ok_996
    jmp ir_errdefer_end_997
ir_errdefer_ok_996:
ir_errdefer_end_997:
    ; Load variable: i
    movsxd rax, dword [rbp - 12]  ; From stack [rbp - 12]
    jmp Lfind_resolved_by_name_exit
    jmp ir_if_end_992
ir_if_next_993:
ir_if_end_992:
    ; Load variable: i
    movsxd rax, dword [rbp - 12]  ; From stack [rbp - 12]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 80], rax
    mov rax, [rbp - 80]
    ; Store to variable: i
    mov dword [rbp - 12], eax  ; To stack [rbp - 12]
    jmp ir_while_990
ir_while_end_991:
    mov rax, 1
    neg rax
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    test rax, rax
    jz ir_errdefer_ok_998
    jmp ir_errdefer_end_999
ir_errdefer_ok_998:
ir_errdefer_end_999:
    mov rax, [rbp - 88]
    jmp Lfind_resolved_by_name_exit
Lfind_resolved_by_name_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global add_resolved

add_resolved:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 1936    ; Allocate 1936 bytes on stack (aligned)
    ; Registering 3 function parameters
    mov [rbp - 8], rcx  ; Home param 'name'
    ; Parameter 'name' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'version'
    ; Parameter 'version' arrived in register rdx
    mov [rbp - 24], r8  ; Home param 'path'
    ; Parameter 'path' arrived in register r8
ir_entry_1000:
    ; IR call: find_resolved_by_name (1 args)
    sub rsp, 32
    ; Load variable: name
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call find_resolved_by_name
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 360], rax
    mov rax, [rbp - 360]
    ; Store to variable: idx
    mov dword [rbp - 28], eax  ; To stack [rbp - 28]
    ; Load variable: idx
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 368], rax
    mov rax, [rbp - 368]
    test rax, rax
    jz ir_if_next_1002
    mov rax, 0
    push rax
    mov rax, 16384
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 376], rax
    mov rax, [rbp - 376]
    test rax, rax
    jz ir_trap_bounds_1005
    jmp ir_in_bounds_1006
ir_trap_bounds_1005:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct302]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1006:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 384], rax
    ; Load variable: RESOLVED_VERSION
    lea rax, [rel RESOLVED_VERSION]  ; Array base address
    push rax
    mov rax, [rbp - 384]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 392], rax
    ; IR call: slot_streq (4 args)
    sub rsp, 32
    mov rax, [rbp - 392]
    mov rcx, rax
    mov rax, 64
    mov rdx, rax
    ; Load variable: idx
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    mov r8, rax
    ; Load variable: version
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov r9, rax
    call slot_streq
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 400], rax
    mov rax, [rbp - 400]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 408], rax
    mov rax, [rbp - 408]
    test rax, rax
    jz ir_sc_false_1009
ir_sc_rhs_1007:
    mov rax, 0
    push rax
    mov rax, 65536
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 416], rax
    mov rax, [rbp - 416]
    test rax, rax
    jz ir_trap_bounds_1011
    jmp ir_in_bounds_1012
ir_trap_bounds_1011:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct304]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1012:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 424], rax
    ; Load variable: RESOLVED_PATH
    lea rax, [rel RESOLVED_PATH]  ; Array base address
    push rax
    mov rax, [rbp - 424]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 432], rax
    ; IR call: slot_streq (4 args)
    sub rsp, 32
    mov rax, [rbp - 432]
    mov rcx, rax
    mov rax, 256
    mov rdx, rax
    ; Load variable: idx
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    mov r8, rax
    ; Load variable: path
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov r9, rax
    call slot_streq
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 440], rax
    mov rax, [rbp - 440]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 448], rax
    mov rax, [rbp - 448]
    test rax, rax
    jz ir_sc_false_1009
ir_sc_true_1008:
    mov rax, 1
    mov [rbp - 456], rax
    jmp ir_sc_end_1010
ir_sc_false_1009:
    mov rax, 0
    mov [rbp - 456], rax
ir_sc_end_1010:
    mov rax, [rbp - 456]
    test rax, rax
    jz ir_if_next_1004
    mov rax, 0
    mov [rbp - 472], rax
    mov rax, [rbp - 472]
    test rax, rax
    jz ir_errdefer_ok_1013
    jmp ir_errdefer_end_1014
ir_errdefer_ok_1013:
ir_errdefer_end_1014:
    mov rax, 0
    jmp Ladd_resolved_exit
    jmp ir_if_end_1003
ir_if_next_1004:
ir_if_end_1003:
    mov rax, 0
    push rax
    mov rax, 16384
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 480], rax
    mov rax, [rbp - 480]
    test rax, rax
    jz ir_trap_bounds_1015
    jmp ir_in_bounds_1016
ir_trap_bounds_1015:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct306]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1016:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 488], rax
    ; Load variable: RESOLVED_VERSION
    lea rax, [rel RESOLVED_VERSION]  ; Array base address
    push rax
    mov rax, [rbp - 488]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 496], rax
    mov rax, 0
    push rax
    mov rax, 64
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 504], rax
    mov rax, [rbp - 504]
    test rax, rax
    jz ir_trap_bounds_1017
    jmp ir_in_bounds_1018
ir_trap_bounds_1017:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct308]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1018:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 512], rax
    ; Load variable: old_version
    lea rax, [rbp - 96]  ; Local array base
    push rax
    mov rax, [rbp - 512]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 520], rax
    ; IR call: slot_to_buf (5 args)
    sub rsp, 48
    mov rax, 64
    mov [rsp + 32], rax
    mov rax, [rbp - 496]
    mov rcx, rax
    mov rax, 64
    mov rdx, rax
    ; Load variable: idx
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    mov r8, rax
    mov rax, [rbp - 520]
    mov r9, rax
    call slot_to_buf
    add rsp, 48
    ; Void return - no value to handle
    mov [rbp - 528], rax
    mov rax, 0
    push rax
    mov rax, 65536
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 536], rax
    mov rax, [rbp - 536]
    test rax, rax
    jz ir_trap_bounds_1019
    jmp ir_in_bounds_1020
ir_trap_bounds_1019:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct310]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1020:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 544], rax
    ; Load variable: RESOLVED_PATH
    lea rax, [rel RESOLVED_PATH]  ; Array base address
    push rax
    mov rax, [rbp - 544]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 552], rax
    mov rax, 0
    push rax
    mov rax, 256
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 560], rax
    mov rax, [rbp - 560]
    test rax, rax
    jz ir_trap_bounds_1021
    jmp ir_in_bounds_1022
ir_trap_bounds_1021:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct312]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1022:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 568], rax
    ; Load variable: old_path
    lea rax, [rbp - 352]  ; Local array base
    push rax
    mov rax, [rbp - 568]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 576], rax
    ; IR call: slot_to_buf (5 args)
    sub rsp, 48
    mov rax, 256
    mov [rsp + 32], rax
    mov rax, [rbp - 552]
    mov rcx, rax
    mov rax, 256
    mov rdx, rax
    ; Load variable: idx
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    mov r8, rax
    mov rax, [rbp - 576]
    mov r9, rax
    call slot_to_buf
    add rsp, 48
    ; Void return - no value to handle
    mov [rbp - 584], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (40 bytes)
    lea rax, [rel Lstr_struct314]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 592], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    mov rax, [rbp - 592]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 600], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    ; Load variable: name
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 608], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (20 bytes)
    lea rax, [rel Lstr_struct316]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 616], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    mov rax, [rbp - 616]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 624], rax
    mov rax, 0
    push rax
    mov rax, 64
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 632], rax
    mov rax, [rbp - 632]
    test rax, rax
    jz ir_trap_bounds_1023
    jmp ir_in_bounds_1024
ir_trap_bounds_1023:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct318]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1024:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 640], rax
    ; Load variable: old_version
    lea rax, [rbp - 96]  ; Local array base
    push rax
    mov rax, [rbp - 640]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 648], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    mov rax, [rbp - 648]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 656], rax
    mov rax, 0
    push rax
    mov rax, 256
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 664], rax
    mov rax, [rbp - 664]
    test rax, rax
    jz ir_trap_bounds_1025
    jmp ir_in_bounds_1026
ir_trap_bounds_1025:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct320]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1026:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 672], rax
    ; Load variable: old_path
    lea rax, [rbp - 352]  ; Local array base
    push rax
    mov rax, [rbp - 672]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 680], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    mov rax, [rbp - 680]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 688], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (15 bytes)
    lea rax, [rel Lstr_struct322]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 696], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    mov rax, [rbp - 696]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 704], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    ; Load variable: version
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 712], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    ; Load variable: path
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 720], rax
    mov rax, 1
    neg rax
    mov [rbp - 728], rax
    mov rax, [rbp - 728]
    mov [rbp - 736], rax
    mov rax, [rbp - 736]
    test rax, rax
    jz ir_errdefer_ok_1027
    jmp ir_errdefer_end_1028
ir_errdefer_ok_1027:
ir_errdefer_end_1028:
    mov rax, [rbp - 728]
    jmp Ladd_resolved_exit
    jmp ir_if_end_1001
ir_if_next_1002:
ir_if_end_1001:
    ; Load variable: RESOLVED_COUNT
    movsxd rax, dword [rel RESOLVED_COUNT]  ; From global memory
    push rax
    ; Load variable: MAX_PACKAGES
    movsxd rax, dword [rel MAX_PACKAGES]  ; From global memory
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 744], rax
    mov rax, [rbp - 744]
    test rax, rax
    jz ir_if_next_1030
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (34 bytes)
    lea rax, [rel Lstr_struct324]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 752], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    mov rax, [rbp - 752]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 760], rax
    mov rax, 1
    neg rax
    mov [rbp - 768], rax
    mov rax, [rbp - 768]
    mov [rbp - 776], rax
    mov rax, [rbp - 776]
    test rax, rax
    jz ir_errdefer_ok_1031
    jmp ir_errdefer_end_1032
ir_errdefer_ok_1031:
ir_errdefer_end_1032:
    mov rax, [rbp - 768]
    jmp Ladd_resolved_exit
    jmp ir_if_end_1029
ir_if_next_1030:
ir_if_end_1029:
    mov rax, 0
    push rax
    mov rax, 32768
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 784], rax
    mov rax, [rbp - 784]
    test rax, rax
    jz ir_trap_bounds_1033
    jmp ir_in_bounds_1034
ir_trap_bounds_1033:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct326]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1034:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 792], rax
    ; Load variable: RESOLVED_NAME
    lea rax, [rel RESOLVED_NAME]  ; Array base address
    push rax
    mov rax, [rbp - 792]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 800], rax
    ; IR call: slot_copy (5 args)
    sub rsp, 48
    mov rax, 128
    mov [rsp + 32], rax
    mov rax, [rbp - 800]
    mov rcx, rax
    mov rax, 128
    mov rdx, rax
    ; Load variable: RESOLVED_COUNT
    movsxd rax, dword [rel RESOLVED_COUNT]  ; From global memory
    mov r8, rax
    ; Load variable: name
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov r9, rax
    call slot_copy
    add rsp, 48
    ; Void return - no value to handle
    mov [rbp - 808], rax
    mov rax, 0
    push rax
    mov rax, 16384
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 816], rax
    mov rax, [rbp - 816]
    test rax, rax
    jz ir_trap_bounds_1035
    jmp ir_in_bounds_1036
ir_trap_bounds_1035:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct328]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1036:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 824], rax
    ; Load variable: RESOLVED_VERSION
    lea rax, [rel RESOLVED_VERSION]  ; Array base address
    push rax
    mov rax, [rbp - 824]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 832], rax
    ; IR call: slot_copy (5 args)
    sub rsp, 48
    mov rax, 64
    mov [rsp + 32], rax
    mov rax, [rbp - 832]
    mov rcx, rax
    mov rax, 64
    mov rdx, rax
    ; Load variable: RESOLVED_COUNT
    movsxd rax, dword [rel RESOLVED_COUNT]  ; From global memory
    mov r8, rax
    ; Load variable: version
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov r9, rax
    call slot_copy
    add rsp, 48
    ; Void return - no value to handle
    mov [rbp - 840], rax
    mov rax, 0
    push rax
    mov rax, 65536
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 848], rax
    mov rax, [rbp - 848]
    test rax, rax
    jz ir_trap_bounds_1037
    jmp ir_in_bounds_1038
ir_trap_bounds_1037:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct330]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1038:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 856], rax
    ; Load variable: RESOLVED_PATH
    lea rax, [rel RESOLVED_PATH]  ; Array base address
    push rax
    mov rax, [rbp - 856]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 864], rax
    ; IR call: slot_copy (5 args)
    sub rsp, 48
    mov rax, 256
    mov [rsp + 32], rax
    mov rax, [rbp - 864]
    mov rcx, rax
    mov rax, 256
    mov rdx, rax
    ; Load variable: RESOLVED_COUNT
    movsxd rax, dword [rel RESOLVED_COUNT]  ; From global memory
    mov r8, rax
    ; Load variable: path
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov r9, rax
    call slot_copy
    add rsp, 48
    ; Void return - no value to handle
    mov [rbp - 872], rax
    ; Load variable: RESOLVED_COUNT
    movsxd rax, dword [rel RESOLVED_COUNT]  ; From global memory
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 880], rax
    mov rax, [rbp - 880]
    ; Store to variable: RESOLVED_COUNT
    mov dword [rel RESOLVED_COUNT], eax  ; To global memory
    mov rax, 1
    mov [rbp - 888], rax
    mov rax, [rbp - 888]
    test rax, rax
    jz ir_errdefer_ok_1039
    jmp ir_errdefer_end_1040
ir_errdefer_ok_1039:
ir_errdefer_end_1040:
    mov rax, 1
    jmp Ladd_resolved_exit
Ladd_resolved_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global load_package_identity

load_package_identity:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    mov rax, 4128
    extern ___chkstk_ms
    sub rsp, 32
    call ___chkstk_ms
    add rsp, 32
    sub rsp, rax    ; Allocate 4128 bytes on stack (probed)
    ; Registering 4 function parameters
    mov [rbp - 8], rcx  ; Home param 'pkg_path'
    ; Parameter 'pkg_path' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'fallback_name'
    ; Parameter 'fallback_name' arrived in register rdx
    mov [rbp - 24], r8  ; Home param 'out_name'
    ; Parameter 'out_name' arrived in register r8
    mov [rbp - 32], r9  ; Home param 'out_version'
    ; Parameter 'out_version' arrived in register r9
ir_entry_1041:
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: PKG_FILE
    lea rax, [rel PKG_FILE]  ; Address of global string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1216], rax
    mov rax, 0
    push rax
    mov rax, 320
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1224], rax
    mov rax, [rbp - 1224]
    test rax, rax
    jz ir_trap_bounds_1044
    jmp ir_in_bounds_1045
ir_trap_bounds_1044:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct332]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1045:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1232], rax
    ; Load variable: manifest_path
    lea rax, [rbp - 352]  ; Local array base
    push rax
    mov rax, [rbp - 1232]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1240], rax
    ; IR call: path_join (4 args)
    sub rsp, 32
    ; Load variable: pkg_path
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    mov rax, [rbp - 1216]
    mov rdx, rax
    mov rax, [rbp - 1240]
    mov r8, rax
    mov rax, 320
    mov r9, rax
    call path_join
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1248], rax
    mov rax, [rbp - 1248]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 1256], rax
    mov rax, [rbp - 1256]
    test rax, rax
    jz ir_if_next_1043
    mov rax, 1
    neg rax
    mov [rbp - 1264], rax
    mov rax, [rbp - 1264]
    mov [rbp - 1272], rax
    mov rax, [rbp - 1272]
    test rax, rax
    jz ir_errdefer_ok_1046
    jmp ir_errdefer_end_1047
ir_errdefer_ok_1046:
ir_errdefer_end_1047:
    mov rax, [rbp - 1264]
    jmp Lload_package_identity_exit
    jmp ir_if_end_1042
ir_if_next_1043:
ir_if_end_1042:
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (11 bytes)
    lea rax, [rel Lstr_struct334]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1280], rax
    ; IR call: copy_str (3 args)
    sub rsp, 32
    ; Load variable: out_version
    mov rax, qword [rbp - 32]  ; From stack [rbp - 32]
    mov rcx, rax
    mov rax, [rbp - 1280]
    mov rdx, rax
    mov rax, 64
    mov r8, rax
    call copy_str
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 1288], rax
    ; Load variable: out_name
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    test rax, rax
    jz ir_trap_null_1048
    jmp ir_nonnull_1049
ir_trap_null_1048:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct336]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1049:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1296], rax
    ; Load variable: out_name
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, [rbp - 1296]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1304], rax
    mov rax, [rbp - 1304]
    push rax
    mov rax, 0
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    mov rax, 0
    push rax
    mov rax, 320
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1320], rax
    mov rax, [rbp - 1320]
    test rax, rax
    jz ir_trap_bounds_1052
    jmp ir_in_bounds_1053
ir_trap_bounds_1052:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct338]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1053:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1328], rax
    ; Load variable: manifest_path
    lea rax, [rbp - 352]  ; Local array base
    push rax
    mov rax, [rbp - 1328]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1336], rax
    ; IR call: file_exists (1 args)
    sub rsp, 32
    mov rax, [rbp - 1336]
    mov rcx, rax
    call file_exists
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1344], rax
    mov rax, [rbp - 1344]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 1352], rax
    mov rax, [rbp - 1352]
    test rax, rax
    jz ir_if_next_1051
    ; Load variable: fallback_name
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 1360], rax
    mov rax, [rbp - 1360]
    test rax, rax
    jz ir_sc_false_1058
ir_sc_rhs_1056:
    ; Load variable: fallback_name
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    test rax, rax
    jz ir_trap_null_1060
    jmp ir_nonnull_1061
ir_trap_null_1060:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct340]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1061:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1368], rax
    ; Load variable: fallback_name
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, [rbp - 1368]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1376], rax
    mov rax, [rbp - 1376]
    movzx rax, byte [rax]
    mov [rbp - 1384], rax
    mov rax, [rbp - 1384]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 1392], rax
    mov rax, [rbp - 1392]
    test rax, rax
    jz ir_sc_false_1058
ir_sc_true_1057:
    mov rax, 1
    mov [rbp - 1400], rax
    jmp ir_sc_end_1059
ir_sc_false_1058:
    mov rax, 0
    mov [rbp - 1400], rax
ir_sc_end_1059:
    mov rax, [rbp - 1400]
    test rax, rax
    jz ir_if_next_1055
    ; IR call: copy_str (3 args)
    sub rsp, 32
    ; Load variable: out_name
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov rcx, rax
    ; Load variable: fallback_name
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov rdx, rax
    mov rax, 128
    mov r8, rax
    call copy_str
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 1416], rax
    mov rax, 0
    mov [rbp - 1424], rax
    mov rax, [rbp - 1424]
    test rax, rax
    jz ir_errdefer_ok_1062
    jmp ir_errdefer_end_1063
ir_errdefer_ok_1062:
ir_errdefer_end_1063:
    mov rax, 0
    jmp Lload_package_identity_exit
    jmp ir_if_end_1054
ir_if_next_1055:
ir_if_end_1054:
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (62 bytes)
    lea rax, [rel Lstr_struct342]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1432], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    mov rax, [rbp - 1432]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 1440], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    ; Load variable: pkg_path
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 1448], rax
    mov rax, 1
    neg rax
    mov [rbp - 1456], rax
    mov rax, [rbp - 1456]
    mov [rbp - 1464], rax
    mov rax, [rbp - 1464]
    test rax, rax
    jz ir_errdefer_ok_1064
    jmp ir_errdefer_end_1065
ir_errdefer_ok_1064:
ir_errdefer_end_1065:
    mov rax, [rbp - 1456]
    jmp Lload_package_identity_exit
    jmp ir_if_end_1050
ir_if_next_1051:
ir_if_end_1050:
    mov rax, 0
    push rax
    mov rax, 320
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1472], rax
    mov rax, [rbp - 1472]
    test rax, rax
    jz ir_trap_bounds_1066
    jmp ir_in_bounds_1067
ir_trap_bounds_1066:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct344]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1067:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1480], rax
    ; Load variable: manifest_path
    lea rax, [rbp - 352]  ; Local array base
    push rax
    mov rax, [rbp - 1480]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1488], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (1 bytes)
    lea rax, [rel Lstr_struct346]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1496], rax
    ; IR call: fopen (2 args)
    sub rsp, 32
    mov rax, [rbp - 1488]
    mov rcx, rax
    mov rax, [rbp - 1496]
    mov rdx, rax
    call fopen
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1504], rax
    mov rax, [rbp - 1504]
    ; Store to variable: fp
    mov qword [rbp - 360], rax  ; To stack [rbp - 360]
    ; Load variable: fp
    mov rax, qword [rbp - 360]  ; From stack [rbp - 360]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 1512], rax
    mov rax, [rbp - 1512]
    test rax, rax
    jz ir_if_next_1069
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (39 bytes)
    lea rax, [rel Lstr_struct348]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1520], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    mov rax, [rbp - 1520]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 1528], rax
    mov rax, 0
    push rax
    mov rax, 320
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1536], rax
    mov rax, [rbp - 1536]
    test rax, rax
    jz ir_trap_bounds_1070
    jmp ir_in_bounds_1071
ir_trap_bounds_1070:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct350]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1071:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1544], rax
    ; Load variable: manifest_path
    lea rax, [rbp - 352]  ; Local array base
    push rax
    mov rax, [rbp - 1544]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1552], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    mov rax, [rbp - 1552]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 1560], rax
    mov rax, 1
    neg rax
    mov [rbp - 1568], rax
    mov rax, [rbp - 1568]
    mov [rbp - 1576], rax
    mov rax, [rbp - 1576]
    test rax, rax
    jz ir_errdefer_ok_1072
    jmp ir_errdefer_end_1073
ir_errdefer_ok_1072:
ir_errdefer_end_1073:
    mov rax, [rbp - 1568]
    jmp Lload_package_identity_exit
    jmp ir_if_end_1068
ir_if_next_1069:
ir_if_end_1068:
ir_while_1074:
    mov rax, 0
    push rax
    mov rax, 512
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1584], rax
    mov rax, [rbp - 1584]
    test rax, rax
    jz ir_trap_bounds_1076
    jmp ir_in_bounds_1077
ir_trap_bounds_1076:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct352]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1077:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1592], rax
    ; Load variable: line_buf
    lea rax, [rbp - 872]  ; Local array base
    push rax
    mov rax, [rbp - 1592]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1600], rax
    ; IR call: fgets (3 args)
    sub rsp, 32
    mov rax, [rbp - 1600]
    mov rcx, rax
    mov rax, 512
    mov rdx, rax
    ; Load variable: fp
    mov rax, qword [rbp - 360]  ; From stack [rbp - 360]
    mov r8, rax
    call fgets
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1608], rax
    mov rax, [rbp - 1608]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 1616], rax
    mov rax, [rbp - 1616]
    test rax, rax
    jz ir_while_end_1075
    mov rax, 0
    push rax
    mov rax, 512
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1624], rax
    mov rax, [rbp - 1624]
    test rax, rax
    jz ir_trap_bounds_1078
    jmp ir_in_bounds_1079
ir_trap_bounds_1078:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct354]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1079:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1632], rax
    ; Load variable: line_buf
    lea rax, [rbp - 872]  ; Local array base
    push rax
    mov rax, [rbp - 1632]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1640], rax
    ; IR call: strlen (1 args)
    sub rsp, 32
    mov rax, [rbp - 1640]
    mov rcx, rax
    call strlen
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1648], rax
    mov rax, [rbp - 1648]
    ; Store to variable: len
    mov qword [rbp - 1200], rax  ; To stack [rbp - 1200]
    ; Load variable: len
    mov rax, qword [rbp - 1200]  ; From stack [rbp - 1200]
    push rax
    mov rax, 511
    mov r10, rax
    pop rax
    cmp rax, r10
    setg al
    movzx rax, al
    mov [rbp - 1656], rax
    mov rax, [rbp - 1656]
    test rax, rax
    jz ir_if_next_1081
    mov rax, 511
    ; Store to variable: len
    mov qword [rbp - 1200], rax  ; To stack [rbp - 1200]
    jmp ir_if_end_1080
ir_if_next_1081:
ir_if_end_1080:
    mov rax, 0
    push rax
    mov rax, 512
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1664], rax
    mov rax, [rbp - 1664]
    test rax, rax
    jz ir_trap_bounds_1082
    jmp ir_in_bounds_1083
ir_trap_bounds_1082:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct356]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1083:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1672], rax
    ; Load variable: line_buf
    lea rax, [rbp - 872]  ; Local array base
    push rax
    mov rax, [rbp - 1672]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1680], rax
    mov rax, 0
    push rax
    mov rax, 64
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1688], rax
    mov rax, [rbp - 1688]
    test rax, rax
    jz ir_trap_bounds_1084
    jmp ir_in_bounds_1085
ir_trap_bounds_1084:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct358]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1085:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1696], rax
    ; Load variable: key_buf
    lea rax, [rbp - 936]  ; Local array base
    push rax
    mov rax, [rbp - 1696]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1704], rax
    mov rax, 0
    push rax
    mov rax, 256
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1712], rax
    mov rax, [rbp - 1712]
    test rax, rax
    jz ir_trap_bounds_1086
    jmp ir_in_bounds_1087
ir_trap_bounds_1086:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct360]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1087:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1720], rax
    ; Load variable: value_buf
    lea rax, [rbp - 1192]  ; Local array base
    push rax
    mov rax, [rbp - 1720]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1728], rax
    ; IR call: parse_key_value_line (6 args)
    sub rsp, 48
    mov rax, [rbp - 1728]
    mov [rsp + 32], rax
    mov rax, 256
    mov [rsp + 40], rax
    mov rax, [rbp - 1680]
    mov rcx, rax
    ; Load variable: len
    mov rax, qword [rbp - 1200]  ; From stack [rbp - 1200]
    mov rdx, rax
    mov rax, [rbp - 1704]
    mov r8, rax
    mov rax, 64
    mov r9, rax
    call parse_key_value_line
    add rsp, 48
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1736], rax
    mov rax, [rbp - 1736]
    ; Store to variable: parsed
    mov dword [rbp - 1204], eax  ; To stack [rbp - 1204]
    ; Load variable: parsed
    movsxd rax, dword [rbp - 1204]  ; From stack [rbp - 1204]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 1744], rax
    mov rax, [rbp - 1744]
    test rax, rax
    jz ir_if_next_1089
    mov rax, 0
    push rax
    mov rax, 64
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1752], rax
    mov rax, [rbp - 1752]
    test rax, rax
    jz ir_trap_bounds_1092
    jmp ir_in_bounds_1093
ir_trap_bounds_1092:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct362]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1093:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1760], rax
    ; Load variable: key_buf
    lea rax, [rbp - 936]  ; Local array base
    push rax
    mov rax, [rbp - 1760]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1768], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (4 bytes)
    lea rax, [rel Lstr_struct364]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1776], rax
    ; IR call: streq (2 args)
    sub rsp, 32
    mov rax, [rbp - 1768]
    mov rcx, rax
    mov rax, [rbp - 1776]
    mov rdx, rax
    call streq
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1784], rax
    mov rax, [rbp - 1784]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 1792], rax
    mov rax, [rbp - 1792]
    test rax, rax
    jz ir_if_next_1091
    mov rax, 0
    push rax
    mov rax, 256
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1800], rax
    mov rax, [rbp - 1800]
    test rax, rax
    jz ir_trap_bounds_1094
    jmp ir_in_bounds_1095
ir_trap_bounds_1094:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct366]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1095:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1808], rax
    ; Load variable: value_buf
    lea rax, [rbp - 1192]  ; Local array base
    push rax
    mov rax, [rbp - 1808]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1816], rax
    ; IR call: copy_str (3 args)
    sub rsp, 32
    ; Load variable: out_name
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov rcx, rax
    mov rax, [rbp - 1816]
    mov rdx, rax
    mov rax, 128
    mov r8, rax
    call copy_str
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 1824], rax
    jmp ir_if_end_1090
ir_if_next_1091:
    mov rax, 0
    push rax
    mov rax, 64
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1832], rax
    mov rax, [rbp - 1832]
    test rax, rax
    jz ir_trap_bounds_1097
    jmp ir_in_bounds_1098
ir_trap_bounds_1097:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct368]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1098:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1840], rax
    ; Load variable: key_buf
    lea rax, [rbp - 936]  ; Local array base
    push rax
    mov rax, [rbp - 1840]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1848], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (7 bytes)
    lea rax, [rel Lstr_struct370]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1856], rax
    ; IR call: streq (2 args)
    sub rsp, 32
    mov rax, [rbp - 1848]
    mov rcx, rax
    mov rax, [rbp - 1856]
    mov rdx, rax
    call streq
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1864], rax
    mov rax, [rbp - 1864]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 1872], rax
    mov rax, [rbp - 1872]
    test rax, rax
    jz ir_if_next_1096
    mov rax, 0
    push rax
    mov rax, 256
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1880], rax
    mov rax, [rbp - 1880]
    test rax, rax
    jz ir_trap_bounds_1099
    jmp ir_in_bounds_1100
ir_trap_bounds_1099:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct372]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1100:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1888], rax
    ; Load variable: value_buf
    lea rax, [rbp - 1192]  ; Local array base
    push rax
    mov rax, [rbp - 1888]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1896], rax
    ; IR call: copy_str (3 args)
    sub rsp, 32
    ; Load variable: out_version
    mov rax, qword [rbp - 32]  ; From stack [rbp - 32]
    mov rcx, rax
    mov rax, [rbp - 1896]
    mov rdx, rax
    mov rax, 64
    mov r8, rax
    call copy_str
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 1904], rax
    jmp ir_if_end_1090
ir_if_next_1096:
ir_if_end_1090:
    jmp ir_if_end_1088
ir_if_next_1089:
ir_if_end_1088:
    jmp ir_while_1074
ir_while_end_1075:
    ; IR call: fclose (1 args)
    sub rsp, 32
    ; Load variable: fp
    mov rax, qword [rbp - 360]  ; From stack [rbp - 360]
    mov rcx, rax
    call fclose
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1912], rax
    ; Load variable: out_name
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    test rax, rax
    jz ir_trap_null_1103
    jmp ir_nonnull_1104
ir_trap_null_1103:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct374]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1104:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1920], rax
    ; Load variable: out_name
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, [rbp - 1920]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1928], rax
    mov rax, [rbp - 1928]
    movzx rax, byte [rax]
    mov [rbp - 1936], rax
    mov rax, [rbp - 1936]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 1944], rax
    mov rax, [rbp - 1944]
    test rax, rax
    jz ir_sc_false_1107
ir_sc_rhs_1105:
    ; Load variable: fallback_name
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 1952], rax
    mov rax, [rbp - 1952]
    test rax, rax
    jz ir_sc_false_1107
ir_sc_true_1106:
    mov rax, 1
    mov [rbp - 1960], rax
    jmp ir_sc_end_1108
ir_sc_false_1107:
    mov rax, 0
    mov [rbp - 1960], rax
ir_sc_end_1108:
    mov rax, [rbp - 1960]
    test rax, rax
    jz ir_sc_false_1111
ir_sc_rhs_1109:
    ; Load variable: fallback_name
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    test rax, rax
    jz ir_trap_null_1113
    jmp ir_nonnull_1114
ir_trap_null_1113:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct376]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1114:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1976], rax
    ; Load variable: fallback_name
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, [rbp - 1976]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1984], rax
    mov rax, [rbp - 1984]
    movzx rax, byte [rax]
    mov [rbp - 1992], rax
    mov rax, [rbp - 1992]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 2000], rax
    mov rax, [rbp - 2000]
    test rax, rax
    jz ir_sc_false_1111
ir_sc_true_1110:
    mov rax, 1
    mov [rbp - 2008], rax
    jmp ir_sc_end_1112
ir_sc_false_1111:
    mov rax, 0
    mov [rbp - 2008], rax
ir_sc_end_1112:
    mov rax, [rbp - 2008]
    test rax, rax
    jz ir_if_next_1102
    ; IR call: copy_str (3 args)
    sub rsp, 32
    ; Load variable: out_name
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov rcx, rax
    ; Load variable: fallback_name
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov rdx, rax
    mov rax, 128
    mov r8, rax
    call copy_str
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 2024], rax
    jmp ir_if_end_1101
ir_if_next_1102:
ir_if_end_1101:
    ; Load variable: out_name
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    test rax, rax
    jz ir_trap_null_1117
    jmp ir_nonnull_1118
ir_trap_null_1117:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct378]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1118:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 2032], rax
    ; Load variable: out_name
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, [rbp - 2032]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2040], rax
    mov rax, [rbp - 2040]
    movzx rax, byte [rax]
    mov [rbp - 2048], rax
    mov rax, [rbp - 2048]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 2056], rax
    mov rax, [rbp - 2056]
    test rax, rax
    jz ir_if_next_1116
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct380]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 2064], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    mov rax, [rbp - 2064]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 2072], rax
    mov rax, 0
    push rax
    mov rax, 320
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 2080], rax
    mov rax, [rbp - 2080]
    test rax, rax
    jz ir_trap_bounds_1119
    jmp ir_in_bounds_1120
ir_trap_bounds_1119:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct382]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1120:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 2088], rax
    ; Load variable: manifest_path
    lea rax, [rbp - 352]  ; Local array base
    push rax
    mov rax, [rbp - 2088]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2096], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    mov rax, [rbp - 2096]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 2104], rax
    mov rax, 1
    neg rax
    mov [rbp - 2112], rax
    mov rax, [rbp - 2112]
    mov [rbp - 2120], rax
    mov rax, [rbp - 2120]
    test rax, rax
    jz ir_errdefer_ok_1121
    jmp ir_errdefer_end_1122
ir_errdefer_ok_1121:
ir_errdefer_end_1122:
    mov rax, [rbp - 2112]
    jmp Lload_package_identity_exit
    jmp ir_if_end_1115
ir_if_next_1116:
ir_if_end_1115:
    ; IR call: is_valid_dep_name (1 args)
    sub rsp, 32
    ; Load variable: out_name
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov rcx, rax
    call is_valid_dep_name
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 2128], rax
    mov rax, [rbp - 2128]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 2136], rax
    mov rax, [rbp - 2136]
    test rax, rax
    jz ir_if_next_1124
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (40 bytes)
    lea rax, [rel Lstr_struct384]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 2144], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    mov rax, [rbp - 2144]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 2152], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    ; Load variable: out_name
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 2160], rax
    mov rax, 1
    neg rax
    mov [rbp - 2168], rax
    mov rax, [rbp - 2168]
    mov [rbp - 2176], rax
    mov rax, [rbp - 2176]
    test rax, rax
    jz ir_errdefer_ok_1125
    jmp ir_errdefer_end_1126
ir_errdefer_ok_1125:
ir_errdefer_end_1126:
    mov rax, [rbp - 2168]
    jmp Lload_package_identity_exit
    jmp ir_if_end_1123
ir_if_next_1124:
ir_if_end_1123:
    mov rax, 0
    mov [rbp - 2184], rax
    mov rax, [rbp - 2184]
    test rax, rax
    jz ir_errdefer_ok_1127
    jmp ir_errdefer_end_1128
ir_errdefer_ok_1127:
ir_errdefer_end_1128:
    mov rax, 0
    jmp Lload_package_identity_exit
Lload_package_identity_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global resolve_package

resolve_package:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    mov rax, 5136
    extern ___chkstk_ms
    sub rsp, 32
    call ___chkstk_ms
    add rsp, 32
    sub rsp, rax    ; Allocate 5136 bytes on stack (probed)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 'pkg_path'
    ; Parameter 'pkg_path' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'fallback_name'
    ; Parameter 'fallback_name' arrived in register rdx
ir_entry_1129:
    ; IR call: dir_exists (1 args)
    sub rsp, 32
    ; Load variable: pkg_path
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call dir_exists
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1720], rax
    mov rax, [rbp - 1720]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 1728], rax
    mov rax, [rbp - 1728]
    test rax, rax
    jz ir_if_next_1131
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (30 bytes)
    lea rax, [rel Lstr_struct386]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1736], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    mov rax, [rbp - 1736]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 1744], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    ; Load variable: pkg_path
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 1752], rax
    mov rax, 1
    neg rax
    mov [rbp - 1760], rax
    mov rax, [rbp - 1760]
    mov [rbp - 1768], rax
    mov rax, [rbp - 1768]
    test rax, rax
    jz ir_errdefer_ok_1132
    jmp ir_errdefer_end_1133
ir_errdefer_ok_1132:
ir_errdefer_end_1133:
    mov rax, [rbp - 1760]
    jmp Lresolve_package_exit
    jmp ir_if_end_1130
ir_if_next_1131:
ir_if_end_1130:
    mov rax, 0
    push rax
    mov rax, 128
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1776], rax
    mov rax, [rbp - 1776]
    test rax, rax
    jz ir_trap_bounds_1136
    jmp ir_in_bounds_1137
ir_trap_bounds_1136:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct388]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1137:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1784], rax
    ; Load variable: pkg_name
    lea rax, [rbp - 144]  ; Local array base
    push rax
    mov rax, [rbp - 1784]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1792], rax
    mov rax, 0
    push rax
    mov rax, 64
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1800], rax
    mov rax, [rbp - 1800]
    test rax, rax
    jz ir_trap_bounds_1138
    jmp ir_in_bounds_1139
ir_trap_bounds_1138:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct390]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1139:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1808], rax
    ; Load variable: pkg_version
    lea rax, [rbp - 208]  ; Local array base
    push rax
    mov rax, [rbp - 1808]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1816], rax
    ; IR call: load_package_identity (4 args)
    sub rsp, 32
    ; Load variable: pkg_path
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    ; Load variable: fallback_name
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov rdx, rax
    mov rax, [rbp - 1792]
    mov r8, rax
    mov rax, [rbp - 1816]
    mov r9, rax
    call load_package_identity
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1824], rax
    mov rax, [rbp - 1824]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 1832], rax
    mov rax, [rbp - 1832]
    test rax, rax
    jz ir_if_next_1135
    mov rax, 1
    neg rax
    mov [rbp - 1840], rax
    mov rax, [rbp - 1840]
    mov [rbp - 1848], rax
    mov rax, [rbp - 1848]
    test rax, rax
    jz ir_errdefer_ok_1140
    jmp ir_errdefer_end_1141
ir_errdefer_ok_1140:
ir_errdefer_end_1141:
    mov rax, [rbp - 1840]
    jmp Lresolve_package_exit
    jmp ir_if_end_1134
ir_if_next_1135:
ir_if_end_1134:
    mov rax, 0
    push rax
    mov rax, 128
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1856], rax
    mov rax, [rbp - 1856]
    test rax, rax
    jz ir_trap_bounds_1142
    jmp ir_in_bounds_1143
ir_trap_bounds_1142:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct392]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1143:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1864], rax
    ; Load variable: pkg_name
    lea rax, [rbp - 144]  ; Local array base
    push rax
    mov rax, [rbp - 1864]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1872], rax
    mov rax, 0
    push rax
    mov rax, 64
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1880], rax
    mov rax, [rbp - 1880]
    test rax, rax
    jz ir_trap_bounds_1144
    jmp ir_in_bounds_1145
ir_trap_bounds_1144:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct394]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1145:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1888], rax
    ; Load variable: pkg_version
    lea rax, [rbp - 208]  ; Local array base
    push rax
    mov rax, [rbp - 1888]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1896], rax
    ; IR call: add_resolved (3 args)
    sub rsp, 32
    mov rax, [rbp - 1872]
    mov rcx, rax
    mov rax, [rbp - 1896]
    mov rdx, rax
    ; Load variable: pkg_path
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov r8, rax
    call add_resolved
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1904], rax
    mov rax, [rbp - 1904]
    ; Store to variable: add_status
    mov dword [rbp - 212], eax  ; To stack [rbp - 212]
    ; Load variable: add_status
    movsxd rax, dword [rbp - 212]  ; From stack [rbp - 212]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1912], rax
    mov rax, [rbp - 1912]
    test rax, rax
    jz ir_if_next_1147
    mov rax, 1
    neg rax
    mov [rbp - 1920], rax
    mov rax, [rbp - 1920]
    mov [rbp - 1928], rax
    mov rax, [rbp - 1928]
    test rax, rax
    jz ir_errdefer_ok_1148
    jmp ir_errdefer_end_1149
ir_errdefer_ok_1148:
ir_errdefer_end_1149:
    mov rax, [rbp - 1920]
    jmp Lresolve_package_exit
    jmp ir_if_end_1146
ir_if_next_1147:
ir_if_end_1146:
    ; Load variable: add_status
    movsxd rax, dword [rbp - 212]  ; From stack [rbp - 212]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 1936], rax
    mov rax, [rbp - 1936]
    test rax, rax
    jz ir_if_next_1151
    mov rax, 0
    mov [rbp - 1944], rax
    mov rax, [rbp - 1944]
    test rax, rax
    jz ir_errdefer_ok_1152
    jmp ir_errdefer_end_1153
ir_errdefer_ok_1152:
ir_errdefer_end_1153:
    mov rax, 0
    jmp Lresolve_package_exit
    jmp ir_if_end_1150
ir_if_next_1151:
ir_if_end_1150:
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: PKG_FILE
    lea rax, [rel PKG_FILE]  ; Address of global string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1952], rax
    mov rax, 0
    push rax
    mov rax, 320
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1960], rax
    mov rax, [rbp - 1960]
    test rax, rax
    jz ir_trap_bounds_1156
    jmp ir_in_bounds_1157
ir_trap_bounds_1156:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct396]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1157:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1968], rax
    ; Load variable: manifest_path
    lea rax, [rbp - 536]  ; Local array base
    push rax
    mov rax, [rbp - 1968]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1976], rax
    ; IR call: path_join (4 args)
    sub rsp, 32
    ; Load variable: pkg_path
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    mov rax, [rbp - 1952]
    mov rdx, rax
    mov rax, [rbp - 1976]
    mov r8, rax
    mov rax, 320
    mov r9, rax
    call path_join
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1984], rax
    mov rax, [rbp - 1984]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 1992], rax
    mov rax, [rbp - 1992]
    test rax, rax
    jz ir_if_next_1155
    mov rax, 1
    neg rax
    mov [rbp - 2000], rax
    mov rax, [rbp - 2000]
    mov [rbp - 2008], rax
    mov rax, [rbp - 2008]
    test rax, rax
    jz ir_errdefer_ok_1158
    jmp ir_errdefer_end_1159
ir_errdefer_ok_1158:
ir_errdefer_end_1159:
    mov rax, [rbp - 2000]
    jmp Lresolve_package_exit
    jmp ir_if_end_1154
ir_if_next_1155:
ir_if_end_1154:
    mov rax, 0
    push rax
    mov rax, 320
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 2016], rax
    mov rax, [rbp - 2016]
    test rax, rax
    jz ir_trap_bounds_1162
    jmp ir_in_bounds_1163
ir_trap_bounds_1162:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct398]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1163:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 2024], rax
    ; Load variable: manifest_path
    lea rax, [rbp - 536]  ; Local array base
    push rax
    mov rax, [rbp - 2024]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2032], rax
    ; IR call: file_exists (1 args)
    sub rsp, 32
    mov rax, [rbp - 2032]
    mov rcx, rax
    call file_exists
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 2040], rax
    mov rax, [rbp - 2040]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 2048], rax
    mov rax, [rbp - 2048]
    test rax, rax
    jz ir_if_next_1161
    mov rax, 0
    mov [rbp - 2056], rax
    mov rax, [rbp - 2056]
    test rax, rax
    jz ir_errdefer_ok_1164
    jmp ir_errdefer_end_1165
ir_errdefer_ok_1164:
ir_errdefer_end_1165:
    mov rax, 0
    jmp Lresolve_package_exit
    jmp ir_if_end_1160
ir_if_next_1161:
ir_if_end_1160:
    mov rax, 0
    push rax
    mov rax, 320
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 2064], rax
    mov rax, [rbp - 2064]
    test rax, rax
    jz ir_trap_bounds_1166
    jmp ir_in_bounds_1167
ir_trap_bounds_1166:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct400]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1167:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 2072], rax
    ; Load variable: manifest_path
    lea rax, [rbp - 536]  ; Local array base
    push rax
    mov rax, [rbp - 2072]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2080], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (1 bytes)
    lea rax, [rel Lstr_struct402]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 2088], rax
    ; IR call: fopen (2 args)
    sub rsp, 32
    mov rax, [rbp - 2080]
    mov rcx, rax
    mov rax, [rbp - 2088]
    mov rdx, rax
    call fopen
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 2096], rax
    mov rax, [rbp - 2096]
    ; Store to variable: fp
    mov qword [rbp - 544], rax  ; To stack [rbp - 544]
    ; Load variable: fp
    mov rax, qword [rbp - 544]  ; From stack [rbp - 544]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 2104], rax
    mov rax, [rbp - 2104]
    test rax, rax
    jz ir_if_next_1169
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (39 bytes)
    lea rax, [rel Lstr_struct404]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 2112], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    mov rax, [rbp - 2112]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 2120], rax
    mov rax, 0
    push rax
    mov rax, 320
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 2128], rax
    mov rax, [rbp - 2128]
    test rax, rax
    jz ir_trap_bounds_1170
    jmp ir_in_bounds_1171
ir_trap_bounds_1170:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct406]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1171:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 2136], rax
    ; Load variable: manifest_path
    lea rax, [rbp - 536]  ; Local array base
    push rax
    mov rax, [rbp - 2136]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2144], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    mov rax, [rbp - 2144]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 2152], rax
    mov rax, 1
    neg rax
    mov [rbp - 2160], rax
    mov rax, [rbp - 2160]
    mov [rbp - 2168], rax
    mov rax, [rbp - 2168]
    test rax, rax
    jz ir_errdefer_ok_1172
    jmp ir_errdefer_end_1173
ir_errdefer_ok_1172:
ir_errdefer_end_1173:
    mov rax, [rbp - 2160]
    jmp Lresolve_package_exit
    jmp ir_if_end_1168
ir_if_next_1169:
ir_if_end_1168:
ir_while_1174:
    mov rax, 0
    push rax
    mov rax, 512
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 2176], rax
    mov rax, [rbp - 2176]
    test rax, rax
    jz ir_trap_bounds_1176
    jmp ir_in_bounds_1177
ir_trap_bounds_1176:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct408]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1177:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 2184], rax
    ; Load variable: line_buf
    lea rax, [rbp - 1056]  ; Local array base
    push rax
    mov rax, [rbp - 2184]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2192], rax
    ; IR call: fgets (3 args)
    sub rsp, 32
    mov rax, [rbp - 2192]
    mov rcx, rax
    mov rax, 512
    mov rdx, rax
    ; Load variable: fp
    mov rax, qword [rbp - 544]  ; From stack [rbp - 544]
    mov r8, rax
    call fgets
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 2200], rax
    mov rax, [rbp - 2200]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 2208], rax
    mov rax, [rbp - 2208]
    test rax, rax
    jz ir_while_end_1175
    mov rax, 0
    push rax
    mov rax, 512
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 2216], rax
    mov rax, [rbp - 2216]
    test rax, rax
    jz ir_trap_bounds_1178
    jmp ir_in_bounds_1179
ir_trap_bounds_1178:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct410]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1179:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 2224], rax
    ; Load variable: line_buf
    lea rax, [rbp - 1056]  ; Local array base
    push rax
    mov rax, [rbp - 2224]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2232], rax
    ; IR call: strlen (1 args)
    sub rsp, 32
    mov rax, [rbp - 2232]
    mov rcx, rax
    call strlen
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 2240], rax
    mov rax, [rbp - 2240]
    ; Store to variable: len
    mov qword [rbp - 1384], rax  ; To stack [rbp - 1384]
    ; Load variable: len
    mov rax, qword [rbp - 1384]  ; From stack [rbp - 1384]
    push rax
    mov rax, 511
    mov r10, rax
    pop rax
    cmp rax, r10
    setg al
    movzx rax, al
    mov [rbp - 2248], rax
    mov rax, [rbp - 2248]
    test rax, rax
    jz ir_if_next_1181
    mov rax, 511
    ; Store to variable: len
    mov qword [rbp - 1384], rax  ; To stack [rbp - 1384]
    jmp ir_if_end_1180
ir_if_next_1181:
ir_if_end_1180:
    mov rax, 0
    push rax
    mov rax, 512
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 2256], rax
    mov rax, [rbp - 2256]
    test rax, rax
    jz ir_trap_bounds_1182
    jmp ir_in_bounds_1183
ir_trap_bounds_1182:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct412]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1183:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 2264], rax
    ; Load variable: line_buf
    lea rax, [rbp - 1056]  ; Local array base
    push rax
    mov rax, [rbp - 2264]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2272], rax
    mov rax, 0
    push rax
    mov rax, 64
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 2280], rax
    mov rax, [rbp - 2280]
    test rax, rax
    jz ir_trap_bounds_1184
    jmp ir_in_bounds_1185
ir_trap_bounds_1184:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct414]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1185:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 2288], rax
    ; Load variable: key_buf
    lea rax, [rbp - 1120]  ; Local array base
    push rax
    mov rax, [rbp - 2288]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2296], rax
    mov rax, 0
    push rax
    mov rax, 256
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 2304], rax
    mov rax, [rbp - 2304]
    test rax, rax
    jz ir_trap_bounds_1186
    jmp ir_in_bounds_1187
ir_trap_bounds_1186:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct416]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1187:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 2312], rax
    ; Load variable: value_buf
    lea rax, [rbp - 1376]  ; Local array base
    push rax
    mov rax, [rbp - 2312]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2320], rax
    ; IR call: parse_key_value_line (6 args)
    sub rsp, 48
    mov rax, [rbp - 2320]
    mov [rsp + 32], rax
    mov rax, 256
    mov [rsp + 40], rax
    mov rax, [rbp - 2272]
    mov rcx, rax
    ; Load variable: len
    mov rax, qword [rbp - 1384]  ; From stack [rbp - 1384]
    mov rdx, rax
    mov rax, [rbp - 2296]
    mov r8, rax
    mov rax, 64
    mov r9, rax
    call parse_key_value_line
    add rsp, 48
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 2328], rax
    mov rax, [rbp - 2328]
    ; Store to variable: parsed
    mov dword [rbp - 1388], eax  ; To stack [rbp - 1388]
    ; Load variable: parsed
    movsxd rax, dword [rbp - 1388]  ; From stack [rbp - 1388]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 2336], rax
    mov rax, [rbp - 2336]
    test rax, rax
    jz ir_sc_false_1192
ir_sc_rhs_1190:
    mov rax, 0
    push rax
    mov rax, 64
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 2344], rax
    mov rax, [rbp - 2344]
    test rax, rax
    jz ir_trap_bounds_1194
    jmp ir_in_bounds_1195
ir_trap_bounds_1194:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct418]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1195:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 2352], rax
    ; Load variable: key_buf
    lea rax, [rbp - 1120]  ; Local array base
    push rax
    mov rax, [rbp - 2352]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2360], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (3 bytes)
    lea rax, [rel Lstr_struct420]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 2368], rax
    ; IR call: streq (2 args)
    sub rsp, 32
    mov rax, [rbp - 2360]
    mov rcx, rax
    mov rax, [rbp - 2368]
    mov rdx, rax
    call streq
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 2376], rax
    mov rax, [rbp - 2376]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 2384], rax
    mov rax, [rbp - 2384]
    test rax, rax
    jz ir_sc_false_1192
ir_sc_true_1191:
    mov rax, 1
    mov [rbp - 2392], rax
    jmp ir_sc_end_1193
ir_sc_false_1192:
    mov rax, 0
    mov [rbp - 2392], rax
ir_sc_end_1193:
    mov rax, [rbp - 2392]
    test rax, rax
    jz ir_if_next_1189
    mov rax, 0
    push rax
    mov rax, 256
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 2408], rax
    mov rax, [rbp - 2408]
    test rax, rax
    jz ir_trap_bounds_1198
    jmp ir_in_bounds_1199
ir_trap_bounds_1198:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct422]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1199:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 2416], rax
    ; Load variable: value_buf
    lea rax, [rbp - 1376]  ; Local array base
    push rax
    mov rax, [rbp - 2416]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2424], rax
    ; IR call: is_path_absolute (1 args)
    sub rsp, 32
    mov rax, [rbp - 2424]
    mov rcx, rax
    call is_path_absolute
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 2432], rax
    mov rax, [rbp - 2432]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 2440], rax
    mov rax, [rbp - 2440]
    test rax, rax
    jz ir_if_next_1197
    mov rax, 0
    push rax
    mov rax, 320
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 2448], rax
    mov rax, [rbp - 2448]
    test rax, rax
    jz ir_trap_bounds_1200
    jmp ir_in_bounds_1201
ir_trap_bounds_1200:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct424]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1201:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 2456], rax
    ; Load variable: dep_path
    lea rax, [rbp - 1712]  ; Local array base
    push rax
    mov rax, [rbp - 2456]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2464], rax
    mov rax, 0
    push rax
    mov rax, 256
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 2472], rax
    mov rax, [rbp - 2472]
    test rax, rax
    jz ir_trap_bounds_1202
    jmp ir_in_bounds_1203
ir_trap_bounds_1202:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct426]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1203:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 2480], rax
    ; Load variable: value_buf
    lea rax, [rbp - 1376]  ; Local array base
    push rax
    mov rax, [rbp - 2480]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2488], rax
    ; IR call: copy_str (3 args)
    sub rsp, 32
    mov rax, [rbp - 2464]
    mov rcx, rax
    mov rax, [rbp - 2488]
    mov rdx, rax
    mov rax, 320
    mov r8, rax
    call copy_str
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 2496], rax
    jmp ir_if_end_1196
ir_if_next_1197:
    mov rax, 0
    push rax
    mov rax, 256
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 2504], rax
    mov rax, [rbp - 2504]
    test rax, rax
    jz ir_trap_bounds_1206
    jmp ir_in_bounds_1207
ir_trap_bounds_1206:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct428]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1207:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 2512], rax
    ; Load variable: value_buf
    lea rax, [rbp - 1376]  ; Local array base
    push rax
    mov rax, [rbp - 2512]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2520], rax
    mov rax, 0
    push rax
    mov rax, 320
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 2528], rax
    mov rax, [rbp - 2528]
    test rax, rax
    jz ir_trap_bounds_1208
    jmp ir_in_bounds_1209
ir_trap_bounds_1208:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct430]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1209:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 2536], rax
    ; Load variable: dep_path
    lea rax, [rbp - 1712]  ; Local array base
    push rax
    mov rax, [rbp - 2536]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2544], rax
    ; IR call: path_join (4 args)
    sub rsp, 32
    ; Load variable: pkg_path
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    mov rax, [rbp - 2520]
    mov rdx, rax
    mov rax, [rbp - 2544]
    mov r8, rax
    mov rax, 320
    mov r9, rax
    call path_join
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 2552], rax
    mov rax, [rbp - 2552]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 2560], rax
    mov rax, [rbp - 2560]
    test rax, rax
    jz ir_if_next_1205
    ; IR call: fclose (1 args)
    sub rsp, 32
    ; Load variable: fp
    mov rax, qword [rbp - 544]  ; From stack [rbp - 544]
    mov rcx, rax
    call fclose
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 2568], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (44 bytes)
    lea rax, [rel Lstr_struct432]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 2576], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    mov rax, [rbp - 2576]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 2584], rax
    mov rax, 0
    push rax
    mov rax, 320
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 2592], rax
    mov rax, [rbp - 2592]
    test rax, rax
    jz ir_trap_bounds_1210
    jmp ir_in_bounds_1211
ir_trap_bounds_1210:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct434]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1211:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 2600], rax
    ; Load variable: manifest_path
    lea rax, [rbp - 536]  ; Local array base
    push rax
    mov rax, [rbp - 2600]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2608], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    mov rax, [rbp - 2608]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 2616], rax
    mov rax, 1
    neg rax
    mov [rbp - 2624], rax
    mov rax, [rbp - 2624]
    mov [rbp - 2632], rax
    mov rax, [rbp - 2632]
    test rax, rax
    jz ir_errdefer_ok_1212
    jmp ir_errdefer_end_1213
ir_errdefer_ok_1212:
ir_errdefer_end_1213:
    mov rax, [rbp - 2624]
    jmp Lresolve_package_exit
    jmp ir_if_end_1204
ir_if_next_1205:
ir_if_end_1204:
ir_if_end_1196:
    mov rax, 0
    push rax
    mov rax, 320
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 2640], rax
    mov rax, [rbp - 2640]
    test rax, rax
    jz ir_trap_bounds_1216
    jmp ir_in_bounds_1217
ir_trap_bounds_1216:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct436]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1217:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 2648], rax
    ; Load variable: dep_path
    lea rax, [rbp - 1712]  ; Local array base
    push rax
    mov rax, [rbp - 2648]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2656], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (0 bytes)
    lea rax, [rel Lstr_struct438]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 2664], rax
    ; IR call: resolve_package (2 args)
    sub rsp, 32
    mov rax, [rbp - 2656]
    mov rcx, rax
    mov rax, [rbp - 2664]
    mov rdx, rax
    call resolve_package
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 2672], rax
    mov rax, [rbp - 2672]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 2680], rax
    mov rax, [rbp - 2680]
    test rax, rax
    jz ir_if_next_1215
    ; IR call: fclose (1 args)
    sub rsp, 32
    ; Load variable: fp
    mov rax, qword [rbp - 544]  ; From stack [rbp - 544]
    mov rcx, rax
    call fclose
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 2688], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (58 bytes)
    lea rax, [rel Lstr_struct440]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 2696], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    mov rax, [rbp - 2696]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 2704], rax
    mov rax, 0
    push rax
    mov rax, 128
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 2712], rax
    mov rax, [rbp - 2712]
    test rax, rax
    jz ir_trap_bounds_1218
    jmp ir_in_bounds_1219
ir_trap_bounds_1218:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct442]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1219:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 2720], rax
    ; Load variable: pkg_name
    lea rax, [rbp - 144]  ; Local array base
    push rax
    mov rax, [rbp - 2720]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2728], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    mov rax, [rbp - 2728]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 2736], rax
    mov rax, 1
    neg rax
    mov [rbp - 2744], rax
    mov rax, [rbp - 2744]
    mov [rbp - 2752], rax
    mov rax, [rbp - 2752]
    test rax, rax
    jz ir_errdefer_ok_1220
    jmp ir_errdefer_end_1221
ir_errdefer_ok_1220:
ir_errdefer_end_1221:
    mov rax, [rbp - 2744]
    jmp Lresolve_package_exit
    jmp ir_if_end_1214
ir_if_next_1215:
ir_if_end_1214:
    jmp ir_if_end_1188
ir_if_next_1189:
    ; Load variable: parsed
    movsxd rax, dword [rbp - 1388]  ; From stack [rbp - 1388]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 2760], rax
    mov rax, [rbp - 2760]
    test rax, rax
    jz ir_if_next_1222
    ; IR call: fclose (1 args)
    sub rsp, 32
    ; Load variable: fp
    mov rax, qword [rbp - 544]  ; From stack [rbp - 544]
    mov rcx, rax
    call fclose
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 2768], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (40 bytes)
    lea rax, [rel Lstr_struct444]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 2776], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    mov rax, [rbp - 2776]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 2784], rax
    mov rax, 0
    push rax
    mov rax, 320
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 2792], rax
    mov rax, [rbp - 2792]
    test rax, rax
    jz ir_trap_bounds_1223
    jmp ir_in_bounds_1224
ir_trap_bounds_1223:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct446]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1224:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 2800], rax
    ; Load variable: manifest_path
    lea rax, [rbp - 536]  ; Local array base
    push rax
    mov rax, [rbp - 2800]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2808], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    mov rax, [rbp - 2808]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 2816], rax
    mov rax, 1
    neg rax
    mov [rbp - 2824], rax
    mov rax, [rbp - 2824]
    mov [rbp - 2832], rax
    mov rax, [rbp - 2832]
    test rax, rax
    jz ir_errdefer_ok_1225
    jmp ir_errdefer_end_1226
ir_errdefer_ok_1225:
ir_errdefer_end_1226:
    mov rax, [rbp - 2824]
    jmp Lresolve_package_exit
    jmp ir_if_end_1188
ir_if_next_1222:
ir_if_end_1188:
    jmp ir_while_1174
ir_while_end_1175:
    ; IR call: fclose (1 args)
    sub rsp, 32
    ; Load variable: fp
    mov rax, qword [rbp - 544]  ; From stack [rbp - 544]
    mov rcx, rax
    call fclose
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 2840], rax
    mov rax, 0
    mov [rbp - 2848], rax
    mov rax, [rbp - 2848]
    test rax, rax
    jz ir_errdefer_ok_1227
    jmp ir_errdefer_end_1228
ir_errdefer_ok_1227:
ir_errdefer_end_1228:
    mov rax, 0
    jmp Lresolve_package_exit
Lresolve_package_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global dep_name_exists

dep_name_exists:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 1904    ; Allocate 1904 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'name'
    ; Parameter 'name' arrived in register rcx
ir_entry_1229:
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: DEPS_FILE
    lea rax, [rel DEPS_FILE]  ; Address of global string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 928], rax
    ; IR call: file_exists (1 args)
    sub rsp, 32
    mov rax, [rbp - 928]
    mov rcx, rax
    call file_exists
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 936], rax
    mov rax, [rbp - 936]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 944], rax
    mov rax, [rbp - 944]
    test rax, rax
    jz ir_if_next_1231
    mov rax, 0
    mov [rbp - 952], rax
    mov rax, [rbp - 952]
    test rax, rax
    jz ir_errdefer_ok_1232
    jmp ir_errdefer_end_1233
ir_errdefer_ok_1232:
ir_errdefer_end_1233:
    mov rax, 0
    jmp Ldep_name_exists_exit
    jmp ir_if_end_1230
ir_if_next_1231:
ir_if_end_1230:
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: DEPS_FILE
    lea rax, [rel DEPS_FILE]  ; Address of global string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 960], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (1 bytes)
    lea rax, [rel Lstr_struct448]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 968], rax
    ; IR call: fopen (2 args)
    sub rsp, 32
    mov rax, [rbp - 960]
    mov rcx, rax
    mov rax, [rbp - 968]
    mov rdx, rax
    call fopen
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 976], rax
    mov rax, [rbp - 976]
    ; Store to variable: fp
    mov qword [rbp - 16], rax  ; To stack [rbp - 16]
    ; Load variable: fp
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 984], rax
    mov rax, [rbp - 984]
    test rax, rax
    jz ir_if_next_1235
    mov rax, 0
    mov [rbp - 992], rax
    mov rax, [rbp - 992]
    test rax, rax
    jz ir_errdefer_ok_1236
    jmp ir_errdefer_end_1237
ir_errdefer_ok_1236:
ir_errdefer_end_1237:
    mov rax, 0
    jmp Ldep_name_exists_exit
    jmp ir_if_end_1234
ir_if_next_1235:
ir_if_end_1234:
ir_while_1238:
    mov rax, 0
    push rax
    mov rax, 512
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1000], rax
    mov rax, [rbp - 1000]
    test rax, rax
    jz ir_trap_bounds_1240
    jmp ir_in_bounds_1241
ir_trap_bounds_1240:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct450]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1241:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1008], rax
    ; Load variable: line_buf
    lea rax, [rbp - 528]  ; Local array base
    push rax
    mov rax, [rbp - 1008]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1016], rax
    ; IR call: fgets (3 args)
    sub rsp, 32
    mov rax, [rbp - 1016]
    mov rcx, rax
    mov rax, 512
    mov rdx, rax
    ; Load variable: fp
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov r8, rax
    call fgets
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1024], rax
    mov rax, [rbp - 1024]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 1032], rax
    mov rax, [rbp - 1032]
    test rax, rax
    jz ir_while_end_1239
    mov rax, 0
    push rax
    mov rax, 512
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1040], rax
    mov rax, [rbp - 1040]
    test rax, rax
    jz ir_trap_bounds_1242
    jmp ir_in_bounds_1243
ir_trap_bounds_1242:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct452]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1243:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1048], rax
    ; Load variable: line_buf
    lea rax, [rbp - 528]  ; Local array base
    push rax
    mov rax, [rbp - 1048]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1056], rax
    ; IR call: strlen (1 args)
    sub rsp, 32
    mov rax, [rbp - 1056]
    mov rcx, rax
    call strlen
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1064], rax
    mov rax, [rbp - 1064]
    ; Store to variable: len
    mov qword [rbp - 920], rax  ; To stack [rbp - 920]
    ; Load variable: len
    mov rax, qword [rbp - 920]  ; From stack [rbp - 920]
    push rax
    mov rax, 511
    mov r10, rax
    pop rax
    cmp rax, r10
    setg al
    movzx rax, al
    mov [rbp - 1072], rax
    mov rax, [rbp - 1072]
    test rax, rax
    jz ir_if_next_1245
    mov rax, 511
    ; Store to variable: len
    mov qword [rbp - 920], rax  ; To stack [rbp - 920]
    jmp ir_if_end_1244
ir_if_next_1245:
ir_if_end_1244:
    mov rax, 0
    push rax
    mov rax, 512
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1080], rax
    mov rax, [rbp - 1080]
    test rax, rax
    jz ir_trap_bounds_1248
    jmp ir_in_bounds_1249
ir_trap_bounds_1248:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct454]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1249:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1088], rax
    ; Load variable: line_buf
    lea rax, [rbp - 528]  ; Local array base
    push rax
    mov rax, [rbp - 1088]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1096], rax
    mov rax, 0
    push rax
    mov rax, 128
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1104], rax
    mov rax, [rbp - 1104]
    test rax, rax
    jz ir_trap_bounds_1250
    jmp ir_in_bounds_1251
ir_trap_bounds_1250:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct456]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1251:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1112], rax
    ; Load variable: name_buf
    lea rax, [rbp - 656]  ; Local array base
    push rax
    mov rax, [rbp - 1112]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1120], rax
    mov rax, 0
    push rax
    mov rax, 256
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1128], rax
    mov rax, [rbp - 1128]
    test rax, rax
    jz ir_trap_bounds_1252
    jmp ir_in_bounds_1253
ir_trap_bounds_1252:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct458]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1253:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1136], rax
    ; Load variable: value_buf
    lea rax, [rbp - 912]  ; Local array base
    push rax
    mov rax, [rbp - 1136]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1144], rax
    ; IR call: parse_dep_line (4 args)
    sub rsp, 32
    mov rax, [rbp - 1096]
    mov rcx, rax
    ; Load variable: len
    mov rax, qword [rbp - 920]  ; From stack [rbp - 920]
    mov rdx, rax
    mov rax, [rbp - 1120]
    mov r8, rax
    mov rax, [rbp - 1144]
    mov r9, rax
    call parse_dep_line
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1152], rax
    mov rax, [rbp - 1152]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 1160], rax
    mov rax, [rbp - 1160]
    test rax, rax
    jz ir_if_next_1247
    mov rax, 0
    push rax
    mov rax, 128
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1168], rax
    mov rax, [rbp - 1168]
    test rax, rax
    jz ir_trap_bounds_1256
    jmp ir_in_bounds_1257
ir_trap_bounds_1256:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct460]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1257:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1176], rax
    ; Load variable: name_buf
    lea rax, [rbp - 656]  ; Local array base
    push rax
    mov rax, [rbp - 1176]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1184], rax
    ; IR call: streq (2 args)
    sub rsp, 32
    mov rax, [rbp - 1184]
    mov rcx, rax
    ; Load variable: name
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rdx, rax
    call streq
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1192], rax
    mov rax, [rbp - 1192]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 1200], rax
    mov rax, [rbp - 1200]
    test rax, rax
    jz ir_if_next_1255
    ; IR call: fclose (1 args)
    sub rsp, 32
    ; Load variable: fp
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov rcx, rax
    call fclose
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1208], rax
    mov rax, 1
    mov [rbp - 1216], rax
    mov rax, [rbp - 1216]
    test rax, rax
    jz ir_errdefer_ok_1258
    jmp ir_errdefer_end_1259
ir_errdefer_ok_1258:
ir_errdefer_end_1259:
    mov rax, 1
    jmp Ldep_name_exists_exit
    jmp ir_if_end_1254
ir_if_next_1255:
ir_if_end_1254:
    jmp ir_if_end_1246
ir_if_next_1247:
ir_if_end_1246:
    jmp ir_while_1238
ir_while_end_1239:
    ; IR call: fclose (1 args)
    sub rsp, 32
    ; Load variable: fp
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov rcx, rax
    call fclose
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1224], rax
    mov rax, 0
    mov [rbp - 1232], rax
    mov rax, [rbp - 1232]
    test rax, rax
    jz ir_errdefer_ok_1260
    jmp ir_errdefer_end_1261
ir_errdefer_ok_1260:
ir_errdefer_end_1261:
    mov rax, 0
    jmp Ldep_name_exists_exit
Ldep_name_exists_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global resolve_all_dependencies

resolve_all_dependencies:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 2240    ; Allocate 2240 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_1262:
    ; IR call: reset_resolved (0 args)
    sub rsp, 32
    call reset_resolved
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 928], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: DEPS_FILE
    lea rax, [rel DEPS_FILE]  ; Address of global string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 936], rax
    ; IR call: file_exists (1 args)
    sub rsp, 32
    mov rax, [rbp - 936]
    mov rcx, rax
    call file_exists
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 944], rax
    mov rax, [rbp - 944]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 952], rax
    mov rax, [rbp - 952]
    test rax, rax
    jz ir_if_next_1264
    mov rax, 0
    mov [rbp - 960], rax
    mov rax, [rbp - 960]
    test rax, rax
    jz ir_errdefer_ok_1265
    jmp ir_errdefer_end_1266
ir_errdefer_ok_1265:
ir_errdefer_end_1266:
    mov rax, 0
    jmp Lresolve_all_dependencies_exit
    jmp ir_if_end_1263
ir_if_next_1264:
ir_if_end_1263:
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: DEPS_FILE
    lea rax, [rel DEPS_FILE]  ; Address of global string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 968], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (1 bytes)
    lea rax, [rel Lstr_struct462]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 976], rax
    ; IR call: fopen (2 args)
    sub rsp, 32
    mov rax, [rbp - 968]
    mov rcx, rax
    mov rax, [rbp - 976]
    mov rdx, rax
    call fopen
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 984], rax
    mov rax, [rbp - 984]
    ; Store to variable: fp
    mov qword [rbp - 8], rax  ; To stack [rbp - 8]
    ; Load variable: fp
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 992], rax
    mov rax, [rbp - 992]
    test rax, rax
    jz ir_if_next_1268
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (31 bytes)
    lea rax, [rel Lstr_struct464]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1000], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    mov rax, [rbp - 1000]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 1008], rax
    mov rax, 1
    neg rax
    mov [rbp - 1016], rax
    mov rax, [rbp - 1016]
    mov [rbp - 1024], rax
    mov rax, [rbp - 1024]
    test rax, rax
    jz ir_errdefer_ok_1269
    jmp ir_errdefer_end_1270
ir_errdefer_ok_1269:
ir_errdefer_end_1270:
    mov rax, [rbp - 1016]
    jmp Lresolve_all_dependencies_exit
    jmp ir_if_end_1267
ir_if_next_1268:
ir_if_end_1267:
ir_while_1271:
    mov rax, 0
    push rax
    mov rax, 512
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1032], rax
    mov rax, [rbp - 1032]
    test rax, rax
    jz ir_trap_bounds_1273
    jmp ir_in_bounds_1274
ir_trap_bounds_1273:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct466]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1274:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1040], rax
    ; Load variable: line_buf
    lea rax, [rbp - 520]  ; Local array base
    push rax
    mov rax, [rbp - 1040]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1048], rax
    ; IR call: fgets (3 args)
    sub rsp, 32
    mov rax, [rbp - 1048]
    mov rcx, rax
    mov rax, 512
    mov rdx, rax
    ; Load variable: fp
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov r8, rax
    call fgets
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1056], rax
    mov rax, [rbp - 1056]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 1064], rax
    mov rax, [rbp - 1064]
    test rax, rax
    jz ir_while_end_1272
    mov rax, 0
    push rax
    mov rax, 512
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1072], rax
    mov rax, [rbp - 1072]
    test rax, rax
    jz ir_trap_bounds_1275
    jmp ir_in_bounds_1276
ir_trap_bounds_1275:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct468]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1276:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1080], rax
    ; Load variable: line_buf
    lea rax, [rbp - 520]  ; Local array base
    push rax
    mov rax, [rbp - 1080]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1088], rax
    ; IR call: strlen (1 args)
    sub rsp, 32
    mov rax, [rbp - 1088]
    mov rcx, rax
    call strlen
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1096], rax
    mov rax, [rbp - 1096]
    ; Store to variable: len
    mov qword [rbp - 912], rax  ; To stack [rbp - 912]
    ; Load variable: len
    mov rax, qword [rbp - 912]  ; From stack [rbp - 912]
    push rax
    mov rax, 511
    mov r10, rax
    pop rax
    cmp rax, r10
    setg al
    movzx rax, al
    mov [rbp - 1104], rax
    mov rax, [rbp - 1104]
    test rax, rax
    jz ir_if_next_1278
    mov rax, 511
    ; Store to variable: len
    mov qword [rbp - 912], rax  ; To stack [rbp - 912]
    jmp ir_if_end_1277
ir_if_next_1278:
ir_if_end_1277:
    mov rax, 0
    push rax
    mov rax, 512
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1112], rax
    mov rax, [rbp - 1112]
    test rax, rax
    jz ir_trap_bounds_1279
    jmp ir_in_bounds_1280
ir_trap_bounds_1279:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct470]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1280:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1120], rax
    ; Load variable: line_buf
    lea rax, [rbp - 520]  ; Local array base
    push rax
    mov rax, [rbp - 1120]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1128], rax
    mov rax, 0
    push rax
    mov rax, 128
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1136], rax
    mov rax, [rbp - 1136]
    test rax, rax
    jz ir_trap_bounds_1281
    jmp ir_in_bounds_1282
ir_trap_bounds_1281:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct472]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1282:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1144], rax
    ; Load variable: name_buf
    lea rax, [rbp - 648]  ; Local array base
    push rax
    mov rax, [rbp - 1144]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1152], rax
    mov rax, 0
    push rax
    mov rax, 256
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1160], rax
    mov rax, [rbp - 1160]
    test rax, rax
    jz ir_trap_bounds_1283
    jmp ir_in_bounds_1284
ir_trap_bounds_1283:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct474]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1284:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1168], rax
    ; Load variable: value_buf
    lea rax, [rbp - 904]  ; Local array base
    push rax
    mov rax, [rbp - 1168]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1176], rax
    ; IR call: parse_dep_line (4 args)
    sub rsp, 32
    mov rax, [rbp - 1128]
    mov rcx, rax
    ; Load variable: len
    mov rax, qword [rbp - 912]  ; From stack [rbp - 912]
    mov rdx, rax
    mov rax, [rbp - 1152]
    mov r8, rax
    mov rax, [rbp - 1176]
    mov r9, rax
    call parse_dep_line
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1184], rax
    mov rax, [rbp - 1184]
    ; Store to variable: parsed
    mov dword [rbp - 916], eax  ; To stack [rbp - 916]
    ; Load variable: parsed
    movsxd rax, dword [rbp - 916]  ; From stack [rbp - 916]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 1192], rax
    mov rax, [rbp - 1192]
    test rax, rax
    jz ir_if_next_1286
    jmp ir_while_1271
    jmp ir_if_end_1285
ir_if_next_1286:
ir_if_end_1285:
    ; Load variable: parsed
    movsxd rax, dword [rbp - 916]  ; From stack [rbp - 916]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1200], rax
    mov rax, [rbp - 1200]
    test rax, rax
    jz ir_if_next_1288
    ; IR call: fclose (1 args)
    sub rsp, 32
    ; Load variable: fp
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call fclose
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1208], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (32 bytes)
    lea rax, [rel Lstr_struct476]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1216], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    mov rax, [rbp - 1216]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 1224], rax
    mov rax, 1
    neg rax
    mov [rbp - 1232], rax
    mov rax, [rbp - 1232]
    mov [rbp - 1240], rax
    mov rax, [rbp - 1240]
    test rax, rax
    jz ir_errdefer_ok_1289
    jmp ir_errdefer_end_1290
ir_errdefer_ok_1289:
ir_errdefer_end_1290:
    mov rax, [rbp - 1232]
    jmp Lresolve_all_dependencies_exit
    jmp ir_if_end_1287
ir_if_next_1288:
ir_if_end_1287:
    mov rax, 0
    push rax
    mov rax, 256
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1248], rax
    mov rax, [rbp - 1248]
    test rax, rax
    jz ir_trap_bounds_1293
    jmp ir_in_bounds_1294
ir_trap_bounds_1293:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct478]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1294:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1256], rax
    ; Load variable: value_buf
    lea rax, [rbp - 904]  ; Local array base
    push rax
    mov rax, [rbp - 1256]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1264], rax
    mov rax, 0
    push rax
    mov rax, 128
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1272], rax
    mov rax, [rbp - 1272]
    test rax, rax
    jz ir_trap_bounds_1295
    jmp ir_in_bounds_1296
ir_trap_bounds_1295:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct480]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1296:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1280], rax
    ; Load variable: name_buf
    lea rax, [rbp - 648]  ; Local array base
    push rax
    mov rax, [rbp - 1280]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1288], rax
    ; IR call: resolve_package (2 args)
    sub rsp, 32
    mov rax, [rbp - 1264]
    mov rcx, rax
    mov rax, [rbp - 1288]
    mov rdx, rax
    call resolve_package
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1296], rax
    mov rax, [rbp - 1296]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 1304], rax
    mov rax, [rbp - 1304]
    test rax, rax
    jz ir_if_next_1292
    ; IR call: fclose (1 args)
    sub rsp, 32
    ; Load variable: fp
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call fclose
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1312], rax
    mov rax, 1
    neg rax
    mov [rbp - 1320], rax
    mov rax, [rbp - 1320]
    mov [rbp - 1328], rax
    mov rax, [rbp - 1328]
    test rax, rax
    jz ir_errdefer_ok_1297
    jmp ir_errdefer_end_1298
ir_errdefer_ok_1297:
ir_errdefer_end_1298:
    mov rax, [rbp - 1320]
    jmp Lresolve_all_dependencies_exit
    jmp ir_if_end_1291
ir_if_next_1292:
ir_if_end_1291:
    jmp ir_while_1271
ir_while_end_1272:
    ; IR call: fclose (1 args)
    sub rsp, 32
    ; Load variable: fp
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call fclose
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1336], rax
    mov rax, 0
    mov [rbp - 1344], rax
    mov rax, [rbp - 1344]
    test rax, rax
    jz ir_errdefer_ok_1299
    jmp ir_errdefer_end_1300
ir_errdefer_ok_1299:
ir_errdefer_end_1300:
    mov rax, 0
    jmp Lresolve_all_dependencies_exit
Lresolve_all_dependencies_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global write_lock_file

write_lock_file:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 1808    ; Allocate 1808 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_1301:
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: LOCK_FILE
    lea rax, [rel LOCK_FILE]  ; Address of global string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 472], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (1 bytes)
    lea rax, [rel Lstr_struct482]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 480], rax
    ; IR call: fopen (2 args)
    sub rsp, 32
    mov rax, [rbp - 472]
    mov rcx, rax
    mov rax, [rbp - 480]
    mov rdx, rax
    call fopen
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 488], rax
    mov rax, [rbp - 488]
    ; Store to variable: fp
    mov qword [rbp - 8], rax  ; To stack [rbp - 8]
    ; Load variable: fp
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 496], rax
    mov rax, [rbp - 496]
    test rax, rax
    jz ir_if_next_1303
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (32 bytes)
    lea rax, [rel Lstr_struct484]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 504], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    mov rax, [rbp - 504]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 512], rax
    mov rax, 1
    neg rax
    mov [rbp - 520], rax
    mov rax, [rbp - 520]
    mov [rbp - 528], rax
    mov rax, [rbp - 528]
    test rax, rax
    jz ir_errdefer_ok_1304
    jmp ir_errdefer_end_1305
ir_errdefer_ok_1304:
ir_errdefer_end_1305:
    mov rax, [rbp - 520]
    jmp Lwrite_lock_file_exit
    jmp ir_if_end_1302
ir_if_next_1303:
ir_if_end_1302:
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (33 bytes)
    lea rax, [rel Lstr_struct486]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 536], rax
    ; IR call: fputs (2 args)
    sub rsp, 32
    mov rax, [rbp - 536]
    mov rcx, rax
    ; Load variable: fp
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rdx, rax
    call fputs
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 544], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (20 bytes)
    lea rax, [rel Lstr_struct488]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 552], rax
    ; IR call: fputs (2 args)
    sub rsp, 32
    mov rax, [rbp - 552]
    mov rcx, rax
    ; Load variable: fp
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rdx, rax
    call fputs
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 560], rax
    mov rax, 0
    ; Store to variable: i
    mov dword [rbp - 12], eax  ; To stack [rbp - 12]
ir_while_1306:
    ; Load variable: i
    movsxd rax, dword [rbp - 12]  ; From stack [rbp - 12]
    push rax
    ; Load variable: RESOLVED_COUNT
    movsxd rax, dword [rel RESOLVED_COUNT]  ; From global memory
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 568], rax
    mov rax, [rbp - 568]
    test rax, rax
    jz ir_while_end_1307
    mov rax, 0
    push rax
    mov rax, 32768
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 576], rax
    mov rax, [rbp - 576]
    test rax, rax
    jz ir_trap_bounds_1308
    jmp ir_in_bounds_1309
ir_trap_bounds_1308:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct490]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1309:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 584], rax
    ; Load variable: RESOLVED_NAME
    lea rax, [rel RESOLVED_NAME]  ; Array base address
    push rax
    mov rax, [rbp - 584]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 592], rax
    mov rax, 0
    push rax
    mov rax, 128
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 600], rax
    mov rax, [rbp - 600]
    test rax, rax
    jz ir_trap_bounds_1310
    jmp ir_in_bounds_1311
ir_trap_bounds_1310:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct492]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1311:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 608], rax
    ; Load variable: name_buf
    lea rax, [rbp - 144]  ; Local array base
    push rax
    mov rax, [rbp - 608]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 616], rax
    ; IR call: slot_to_buf (5 args)
    sub rsp, 48
    mov rax, 128
    mov [rsp + 32], rax
    mov rax, [rbp - 592]
    mov rcx, rax
    mov rax, 128
    mov rdx, rax
    ; Load variable: i
    movsxd rax, dword [rbp - 12]  ; From stack [rbp - 12]
    mov r8, rax
    mov rax, [rbp - 616]
    mov r9, rax
    call slot_to_buf
    add rsp, 48
    ; Void return - no value to handle
    mov [rbp - 624], rax
    mov rax, 0
    push rax
    mov rax, 16384
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 632], rax
    mov rax, [rbp - 632]
    test rax, rax
    jz ir_trap_bounds_1312
    jmp ir_in_bounds_1313
ir_trap_bounds_1312:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct494]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1313:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 640], rax
    ; Load variable: RESOLVED_VERSION
    lea rax, [rel RESOLVED_VERSION]  ; Array base address
    push rax
    mov rax, [rbp - 640]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 648], rax
    mov rax, 0
    push rax
    mov rax, 64
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 656], rax
    mov rax, [rbp - 656]
    test rax, rax
    jz ir_trap_bounds_1314
    jmp ir_in_bounds_1315
ir_trap_bounds_1314:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct496]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1315:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 664], rax
    ; Load variable: ver_buf
    lea rax, [rbp - 208]  ; Local array base
    push rax
    mov rax, [rbp - 664]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 672], rax
    ; IR call: slot_to_buf (5 args)
    sub rsp, 48
    mov rax, 64
    mov [rsp + 32], rax
    mov rax, [rbp - 648]
    mov rcx, rax
    mov rax, 64
    mov rdx, rax
    ; Load variable: i
    movsxd rax, dword [rbp - 12]  ; From stack [rbp - 12]
    mov r8, rax
    mov rax, [rbp - 672]
    mov r9, rax
    call slot_to_buf
    add rsp, 48
    ; Void return - no value to handle
    mov [rbp - 680], rax
    mov rax, 0
    push rax
    mov rax, 65536
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 688], rax
    mov rax, [rbp - 688]
    test rax, rax
    jz ir_trap_bounds_1316
    jmp ir_in_bounds_1317
ir_trap_bounds_1316:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct498]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1317:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 696], rax
    ; Load variable: RESOLVED_PATH
    lea rax, [rel RESOLVED_PATH]  ; Array base address
    push rax
    mov rax, [rbp - 696]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 704], rax
    mov rax, 0
    push rax
    mov rax, 256
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 712], rax
    mov rax, [rbp - 712]
    test rax, rax
    jz ir_trap_bounds_1318
    jmp ir_in_bounds_1319
ir_trap_bounds_1318:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct500]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1319:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 720], rax
    ; Load variable: path_buf
    lea rax, [rbp - 464]  ; Local array base
    push rax
    mov rax, [rbp - 720]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 728], rax
    ; IR call: slot_to_buf (5 args)
    sub rsp, 48
    mov rax, 256
    mov [rsp + 32], rax
    mov rax, [rbp - 704]
    mov rcx, rax
    mov rax, 256
    mov rdx, rax
    ; Load variable: i
    movsxd rax, dword [rbp - 12]  ; From stack [rbp - 12]
    mov r8, rax
    mov rax, [rbp - 728]
    mov r9, rax
    call slot_to_buf
    add rsp, 48
    ; Void return - no value to handle
    mov [rbp - 736], rax
    mov rax, 0
    push rax
    mov rax, 128
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 744], rax
    mov rax, [rbp - 744]
    test rax, rax
    jz ir_trap_bounds_1320
    jmp ir_in_bounds_1321
ir_trap_bounds_1320:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct502]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1321:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 752], rax
    ; Load variable: name_buf
    lea rax, [rbp - 144]  ; Local array base
    push rax
    mov rax, [rbp - 752]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 760], rax
    ; IR call: fputs (2 args)
    sub rsp, 32
    mov rax, [rbp - 760]
    mov rcx, rax
    ; Load variable: fp
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rdx, rax
    call fputs
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 768], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (1 bytes)
    lea rax, [rel Lstr_struct504]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 776], rax
    ; IR call: fputs (2 args)
    sub rsp, 32
    mov rax, [rbp - 776]
    mov rcx, rax
    ; Load variable: fp
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rdx, rax
    call fputs
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 784], rax
    mov rax, 0
    push rax
    mov rax, 64
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 792], rax
    mov rax, [rbp - 792]
    test rax, rax
    jz ir_trap_bounds_1322
    jmp ir_in_bounds_1323
ir_trap_bounds_1322:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct506]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1323:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 800], rax
    ; Load variable: ver_buf
    lea rax, [rbp - 208]  ; Local array base
    push rax
    mov rax, [rbp - 800]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 808], rax
    ; IR call: fputs (2 args)
    sub rsp, 32
    mov rax, [rbp - 808]
    mov rcx, rax
    ; Load variable: fp
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rdx, rax
    call fputs
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 816], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (1 bytes)
    lea rax, [rel Lstr_struct508]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 824], rax
    ; IR call: fputs (2 args)
    sub rsp, 32
    mov rax, [rbp - 824]
    mov rcx, rax
    ; Load variable: fp
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rdx, rax
    call fputs
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 832], rax
    mov rax, 0
    push rax
    mov rax, 256
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 840], rax
    mov rax, [rbp - 840]
    test rax, rax
    jz ir_trap_bounds_1324
    jmp ir_in_bounds_1325
ir_trap_bounds_1324:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct510]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1325:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 848], rax
    ; Load variable: path_buf
    lea rax, [rbp - 464]  ; Local array base
    push rax
    mov rax, [rbp - 848]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 856], rax
    ; IR call: fputs (2 args)
    sub rsp, 32
    mov rax, [rbp - 856]
    mov rcx, rax
    ; Load variable: fp
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rdx, rax
    call fputs
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 864], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (1 bytes)
    lea rax, [rel Lstr_struct512]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 872], rax
    ; IR call: fputs (2 args)
    sub rsp, 32
    mov rax, [rbp - 872]
    mov rcx, rax
    ; Load variable: fp
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rdx, rax
    call fputs
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 880], rax
    ; Load variable: i
    movsxd rax, dword [rbp - 12]  ; From stack [rbp - 12]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 888], rax
    mov rax, [rbp - 888]
    ; Store to variable: i
    mov dword [rbp - 12], eax  ; To stack [rbp - 12]
    jmp ir_while_1306
ir_while_end_1307:
    ; IR call: fclose (1 args)
    sub rsp, 32
    ; Load variable: fp
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call fclose
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 896], rax
    mov rax, 0
    mov [rbp - 904], rax
    mov rax, [rbp - 904]
    test rax, rax
    jz ir_errdefer_ok_1326
    jmp ir_errdefer_end_1327
ir_errdefer_ok_1326:
ir_errdefer_end_1327:
    mov rax, 0
    jmp Lwrite_lock_file_exit
Lwrite_lock_file_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global ensure_cache_dirs

ensure_cache_dirs:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 128    ; Allocate 128 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_1328:
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (5 bytes)
    lea rax, [rel Lstr_struct514]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 8], rax
    ; IR call: dir_create (1 args)
    sub rsp, 32
    mov rax, [rbp - 8]
    mov rcx, rax
    call dir_create
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 16], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: CACHE_DIR
    lea rax, [rel CACHE_DIR]  ; Address of global string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 24], rax
    ; IR call: dir_create (1 args)
    sub rsp, 32
    mov rax, [rbp - 24]
    mov rcx, rax
    call dir_create
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 32], rax
    mov rax, 0
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_errdefer_ok_1329
    jmp ir_errdefer_end_1330
ir_errdefer_ok_1329:
ir_errdefer_end_1330:
    mov rax, 0
    jmp Lensure_cache_dirs_exit
Lensure_cache_dirs_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global cmd_install

cmd_install:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 1872    ; Allocate 1872 bytes on stack (aligned)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 'argc'
    ; Parameter 'argc' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'argv'
    ; Parameter 'argv' arrived in register rdx
ir_entry_1331:
    ; IR call: resolve_all_dependencies (0 args)
    sub rsp, 32
    call resolve_all_dependencies
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 424], rax
    mov rax, [rbp - 424]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 432], rax
    mov rax, [rbp - 432]
    test rax, rax
    jz ir_if_next_1333
    mov rax, 1
    mov [rbp - 440], rax
    mov rax, [rbp - 440]
    test rax, rax
    jz ir_errdefer_ok_1334
    jmp ir_errdefer_end_1335
ir_errdefer_ok_1334:
ir_errdefer_end_1335:
    mov rax, 1
    jmp Lcmd_install_exit
    jmp ir_if_end_1332
ir_if_next_1333:
ir_if_end_1332:
    ; Load variable: RESOLVED_COUNT
    movsxd rax, dword [rel RESOLVED_COUNT]  ; From global memory
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 448], rax
    mov rax, [rbp - 448]
    test rax, rax
    jz ir_if_next_1337
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (28 bytes)
    lea rax, [rel Lstr_struct516]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 456], rax
    ; IR call: println (1 args)
    sub rsp, 32
    mov rax, [rbp - 456]
    mov rcx, rax
    call println
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 464], rax
    mov rax, 0
    mov [rbp - 472], rax
    mov rax, [rbp - 472]
    test rax, rax
    jz ir_errdefer_ok_1338
    jmp ir_errdefer_end_1339
ir_errdefer_ok_1338:
ir_errdefer_end_1339:
    mov rax, 0
    jmp Lcmd_install_exit
    jmp ir_if_end_1336
ir_if_next_1337:
ir_if_end_1336:
    ; IR call: ensure_cache_dirs (0 args)
    sub rsp, 32
    call ensure_cache_dirs
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 480], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (26 bytes)
    lea rax, [rel Lstr_struct518]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 488], rax
    ; IR call: println (1 args)
    sub rsp, 32
    mov rax, [rbp - 488]
    mov rcx, rax
    call println
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 496], rax
    mov rax, 0
    ; Store to variable: i
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
ir_while_1340:
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    ; Load variable: RESOLVED_COUNT
    movsxd rax, dword [rel RESOLVED_COUNT]  ; From global memory
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 504], rax
    mov rax, [rbp - 504]
    test rax, rax
    jz ir_while_end_1341
    mov rax, 0
    push rax
    mov rax, 32768
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 512], rax
    mov rax, [rbp - 512]
    test rax, rax
    jz ir_trap_bounds_1342
    jmp ir_in_bounds_1343
ir_trap_bounds_1342:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct520]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1343:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 520], rax
    ; Load variable: RESOLVED_NAME
    lea rax, [rel RESOLVED_NAME]  ; Array base address
    push rax
    mov rax, [rbp - 520]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 528], rax
    mov rax, 0
    push rax
    mov rax, 128
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 536], rax
    mov rax, [rbp - 536]
    test rax, rax
    jz ir_trap_bounds_1344
    jmp ir_in_bounds_1345
ir_trap_bounds_1344:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct522]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1345:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 544], rax
    ; Load variable: name_buf
    lea rax, [rbp - 152]  ; Local array base
    push rax
    mov rax, [rbp - 544]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 552], rax
    ; IR call: slot_to_buf (5 args)
    sub rsp, 48
    mov rax, 128
    mov [rsp + 32], rax
    mov rax, [rbp - 528]
    mov rcx, rax
    mov rax, 128
    mov rdx, rax
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    mov r8, rax
    mov rax, [rbp - 552]
    mov r9, rax
    call slot_to_buf
    add rsp, 48
    ; Void return - no value to handle
    mov [rbp - 560], rax
    mov rax, 0
    push rax
    mov rax, 65536
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 568], rax
    mov rax, [rbp - 568]
    test rax, rax
    jz ir_trap_bounds_1346
    jmp ir_in_bounds_1347
ir_trap_bounds_1346:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct524]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1347:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 576], rax
    ; Load variable: RESOLVED_PATH
    lea rax, [rel RESOLVED_PATH]  ; Array base address
    push rax
    mov rax, [rbp - 576]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 584], rax
    mov rax, 0
    push rax
    mov rax, 256
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 592], rax
    mov rax, [rbp - 592]
    test rax, rax
    jz ir_trap_bounds_1348
    jmp ir_in_bounds_1349
ir_trap_bounds_1348:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct526]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1349:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 600], rax
    ; Load variable: path_buf
    lea rax, [rbp - 408]  ; Local array base
    push rax
    mov rax, [rbp - 600]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 608], rax
    ; IR call: slot_to_buf (5 args)
    sub rsp, 48
    mov rax, 256
    mov [rsp + 32], rax
    mov rax, [rbp - 584]
    mov rcx, rax
    mov rax, 256
    mov rdx, rax
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    mov r8, rax
    mov rax, [rbp - 608]
    mov r9, rax
    call slot_to_buf
    add rsp, 48
    ; Void return - no value to handle
    mov [rbp - 616], rax
    mov rax, 0
    push rax
    mov rax, 128
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 624], rax
    mov rax, [rbp - 624]
    test rax, rax
    jz ir_trap_bounds_1350
    jmp ir_in_bounds_1351
ir_trap_bounds_1350:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct528]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1351:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 632], rax
    ; Load variable: name_buf
    lea rax, [rbp - 152]  ; Local array base
    push rax
    mov rax, [rbp - 632]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 640], rax
    mov rax, 0
    push rax
    mov rax, 256
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 648], rax
    mov rax, [rbp - 648]
    test rax, rax
    jz ir_trap_bounds_1352
    jmp ir_in_bounds_1353
ir_trap_bounds_1352:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct530]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1353:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 656], rax
    ; Load variable: path_buf
    lea rax, [rbp - 408]  ; Local array base
    push rax
    mov rax, [rbp - 656]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 664], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: CACHE_DIR
    lea rax, [rel CACHE_DIR]  ; Address of global string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 672], rax
    ; IR call: install_local_package (3 args)
    sub rsp, 32
    mov rax, [rbp - 640]
    mov rcx, rax
    mov rax, [rbp - 664]
    mov rdx, rax
    mov rax, [rbp - 672]
    mov r8, rax
    call install_local_package
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 680], rax
    mov rax, [rbp - 680]
    ; Store to variable: result
    mov dword [rbp - 412], eax  ; To stack [rbp - 412]
    mov rax, 1
    neg rax
    mov [rbp - 688], rax
    ; Load variable: result
    movsxd rax, dword [rbp - 412]  ; From stack [rbp - 412]
    push rax
    mov rax, [rbp - 688]
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 696], rax
    mov rax, [rbp - 696]
    test rax, rax
    jz ir_if_next_1355
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (35 bytes)
    lea rax, [rel Lstr_struct532]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 704], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    mov rax, [rbp - 704]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 712], rax
    mov rax, 0
    push rax
    mov rax, 128
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 720], rax
    mov rax, [rbp - 720]
    test rax, rax
    jz ir_trap_bounds_1356
    jmp ir_in_bounds_1357
ir_trap_bounds_1356:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct534]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1357:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 728], rax
    ; Load variable: name_buf
    lea rax, [rbp - 152]  ; Local array base
    push rax
    mov rax, [rbp - 728]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 736], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    mov rax, [rbp - 736]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 744], rax
    mov rax, 0
    push rax
    mov rax, 256
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 752], rax
    mov rax, [rbp - 752]
    test rax, rax
    jz ir_trap_bounds_1358
    jmp ir_in_bounds_1359
ir_trap_bounds_1358:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct536]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1359:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 760], rax
    ; Load variable: path_buf
    lea rax, [rbp - 408]  ; Local array base
    push rax
    mov rax, [rbp - 760]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 768], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    mov rax, [rbp - 768]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 776], rax
    mov rax, 1
    mov [rbp - 784], rax
    mov rax, [rbp - 784]
    test rax, rax
    jz ir_errdefer_ok_1360
    jmp ir_errdefer_end_1361
ir_errdefer_ok_1360:
ir_errdefer_end_1361:
    mov rax, 1
    jmp Lcmd_install_exit
    jmp ir_if_end_1354
ir_if_next_1355:
ir_if_end_1354:
    ; Load variable: result
    movsxd rax, dword [rbp - 412]  ; From stack [rbp - 412]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 792], rax
    mov rax, [rbp - 792]
    test rax, rax
    jz ir_if_next_1363
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (31 bytes)
    lea rax, [rel Lstr_struct538]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 800], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    mov rax, [rbp - 800]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 808], rax
    mov rax, 0
    push rax
    mov rax, 128
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 816], rax
    mov rax, [rbp - 816]
    test rax, rax
    jz ir_trap_bounds_1364
    jmp ir_in_bounds_1365
ir_trap_bounds_1364:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct540]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1365:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 824], rax
    ; Load variable: name_buf
    lea rax, [rbp - 152]  ; Local array base
    push rax
    mov rax, [rbp - 824]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 832], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    mov rax, [rbp - 832]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 840], rax
    mov rax, 1
    mov [rbp - 848], rax
    mov rax, [rbp - 848]
    test rax, rax
    jz ir_errdefer_ok_1366
    jmp ir_errdefer_end_1367
ir_errdefer_ok_1366:
ir_errdefer_end_1367:
    mov rax, 1
    jmp Lcmd_install_exit
    jmp ir_if_end_1362
ir_if_next_1363:
ir_if_end_1362:
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 856], rax
    mov rax, [rbp - 856]
    ; Store to variable: i
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
    jmp ir_while_1340
ir_while_end_1341:
    ; IR call: write_lock_file (0 args)
    sub rsp, 32
    call write_lock_file
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 864], rax
    mov rax, [rbp - 864]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 872], rax
    mov rax, [rbp - 872]
    test rax, rax
    jz ir_if_next_1369
    mov rax, 1
    mov [rbp - 880], rax
    mov rax, [rbp - 880]
    test rax, rax
    jz ir_errdefer_ok_1370
    jmp ir_errdefer_end_1371
ir_errdefer_ok_1370:
ir_errdefer_end_1371:
    mov rax, 1
    jmp Lcmd_install_exit
    jmp ir_if_end_1368
ir_if_next_1369:
ir_if_end_1368:
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (5 bytes)
    lea rax, [rel Lstr_struct542]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 888], rax
    ; IR call: println (1 args)
    sub rsp, 32
    mov rax, [rbp - 888]
    mov rcx, rax
    call println
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 896], rax
    mov rax, 0
    mov [rbp - 904], rax
    mov rax, [rbp - 904]
    test rax, rax
    jz ir_errdefer_ok_1372
    jmp ir_errdefer_end_1373
ir_errdefer_ok_1372:
ir_errdefer_end_1373:
    mov rax, 0
    jmp Lcmd_install_exit
Lcmd_install_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global cmd_list

cmd_list:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 2480    ; Allocate 2480 bytes on stack (aligned)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 'argc'
    ; Parameter 'argc' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'argv'
    ; Parameter 'argv' arrived in register rdx
ir_entry_1374:
    ; IR call: resolve_all_dependencies (0 args)
    sub rsp, 32
    call resolve_all_dependencies
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 808], rax
    mov rax, [rbp - 808]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 816], rax
    mov rax, [rbp - 816]
    test rax, rax
    jz ir_if_next_1376
    mov rax, 1
    mov [rbp - 824], rax
    mov rax, [rbp - 824]
    test rax, rax
    jz ir_errdefer_ok_1377
    jmp ir_errdefer_end_1378
ir_errdefer_ok_1377:
ir_errdefer_end_1378:
    mov rax, 1
    jmp Lcmd_list_exit
    jmp ir_if_end_1375
ir_if_next_1376:
ir_if_end_1375:
    ; Load variable: RESOLVED_COUNT
    movsxd rax, dword [rel RESOLVED_COUNT]  ; From global memory
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 832], rax
    mov rax, [rbp - 832]
    test rax, rax
    jz ir_if_next_1380
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (15 bytes)
    lea rax, [rel Lstr_struct544]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 840], rax
    ; IR call: println (1 args)
    sub rsp, 32
    mov rax, [rbp - 840]
    mov rcx, rax
    call println
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 848], rax
    mov rax, 0
    mov [rbp - 856], rax
    mov rax, [rbp - 856]
    test rax, rax
    jz ir_errdefer_ok_1381
    jmp ir_errdefer_end_1382
ir_errdefer_ok_1381:
ir_errdefer_end_1382:
    mov rax, 0
    jmp Lcmd_list_exit
    jmp ir_if_end_1379
ir_if_next_1380:
ir_if_end_1379:
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (15 bytes)
    lea rax, [rel Lstr_struct546]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 864], rax
    mov rax, [rbp - 864]
    ; Store to variable: cache_prefix
    mov qword [rbp - 24], rax  ; To stack [rbp - 24]
    mov rax, 0
    ; Store to variable: i
    mov dword [rbp - 28], eax  ; To stack [rbp - 28]
ir_while_1383:
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    ; Load variable: RESOLVED_COUNT
    movsxd rax, dword [rel RESOLVED_COUNT]  ; From global memory
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 872], rax
    mov rax, [rbp - 872]
    test rax, rax
    jz ir_while_end_1384
    mov rax, 0
    push rax
    mov rax, 32768
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 880], rax
    mov rax, [rbp - 880]
    test rax, rax
    jz ir_trap_bounds_1385
    jmp ir_in_bounds_1386
ir_trap_bounds_1385:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct548]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1386:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 888], rax
    ; Load variable: RESOLVED_NAME
    lea rax, [rel RESOLVED_NAME]  ; Array base address
    push rax
    mov rax, [rbp - 888]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 896], rax
    mov rax, 0
    push rax
    mov rax, 128
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 904], rax
    mov rax, [rbp - 904]
    test rax, rax
    jz ir_trap_bounds_1387
    jmp ir_in_bounds_1388
ir_trap_bounds_1387:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct550]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1388:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 912], rax
    ; Load variable: name_buf
    lea rax, [rbp - 160]  ; Local array base
    push rax
    mov rax, [rbp - 912]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 920], rax
    ; IR call: slot_to_buf (5 args)
    sub rsp, 48
    mov rax, 128
    mov [rsp + 32], rax
    mov rax, [rbp - 896]
    mov rcx, rax
    mov rax, 128
    mov rdx, rax
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    mov r8, rax
    mov rax, [rbp - 920]
    mov r9, rax
    call slot_to_buf
    add rsp, 48
    ; Void return - no value to handle
    mov [rbp - 928], rax
    mov rax, 0
    push rax
    mov rax, 16384
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 936], rax
    mov rax, [rbp - 936]
    test rax, rax
    jz ir_trap_bounds_1389
    jmp ir_in_bounds_1390
ir_trap_bounds_1389:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct552]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1390:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 944], rax
    ; Load variable: RESOLVED_VERSION
    lea rax, [rel RESOLVED_VERSION]  ; Array base address
    push rax
    mov rax, [rbp - 944]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 952], rax
    mov rax, 0
    push rax
    mov rax, 64
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 960], rax
    mov rax, [rbp - 960]
    test rax, rax
    jz ir_trap_bounds_1391
    jmp ir_in_bounds_1392
ir_trap_bounds_1391:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct554]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1392:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 968], rax
    ; Load variable: ver_buf
    lea rax, [rbp - 224]  ; Local array base
    push rax
    mov rax, [rbp - 968]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 976], rax
    ; IR call: slot_to_buf (5 args)
    sub rsp, 48
    mov rax, 64
    mov [rsp + 32], rax
    mov rax, [rbp - 952]
    mov rcx, rax
    mov rax, 64
    mov rdx, rax
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    mov r8, rax
    mov rax, [rbp - 976]
    mov r9, rax
    call slot_to_buf
    add rsp, 48
    ; Void return - no value to handle
    mov [rbp - 984], rax
    mov rax, 0
    push rax
    mov rax, 65536
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 992], rax
    mov rax, [rbp - 992]
    test rax, rax
    jz ir_trap_bounds_1393
    jmp ir_in_bounds_1394
ir_trap_bounds_1393:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct556]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1394:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1000], rax
    ; Load variable: RESOLVED_PATH
    lea rax, [rel RESOLVED_PATH]  ; Array base address
    push rax
    mov rax, [rbp - 1000]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1008], rax
    mov rax, 0
    push rax
    mov rax, 256
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1016], rax
    mov rax, [rbp - 1016]
    test rax, rax
    jz ir_trap_bounds_1395
    jmp ir_in_bounds_1396
ir_trap_bounds_1395:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct558]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1396:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1024], rax
    ; Load variable: path_buf
    lea rax, [rbp - 480]  ; Local array base
    push rax
    mov rax, [rbp - 1024]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1032], rax
    ; IR call: slot_to_buf (5 args)
    sub rsp, 48
    mov rax, 256
    mov [rsp + 32], rax
    mov rax, [rbp - 1008]
    mov rcx, rax
    mov rax, 256
    mov rdx, rax
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    mov r8, rax
    mov rax, [rbp - 1032]
    mov r9, rax
    call slot_to_buf
    add rsp, 48
    ; Void return - no value to handle
    mov [rbp - 1040], rax
    mov rax, 0
    push rax
    mov rax, 128
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1048], rax
    mov rax, [rbp - 1048]
    test rax, rax
    jz ir_trap_bounds_1397
    jmp ir_in_bounds_1398
ir_trap_bounds_1397:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct560]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1398:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1056], rax
    ; Load variable: name_buf
    lea rax, [rbp - 160]  ; Local array base
    push rax
    mov rax, [rbp - 1056]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1064], rax
    ; IR call: print (1 args)
    sub rsp, 32
    mov rax, [rbp - 1064]
    mov rcx, rax
    call print
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 1072], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (1 bytes)
    lea rax, [rel Lstr_struct562]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1080], rax
    ; IR call: print (1 args)
    sub rsp, 32
    mov rax, [rbp - 1080]
    mov rcx, rax
    call print
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 1088], rax
    mov rax, 0
    push rax
    mov rax, 64
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1096], rax
    mov rax, [rbp - 1096]
    test rax, rax
    jz ir_trap_bounds_1399
    jmp ir_in_bounds_1400
ir_trap_bounds_1399:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct564]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1400:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1104], rax
    ; Load variable: ver_buf
    lea rax, [rbp - 224]  ; Local array base
    push rax
    mov rax, [rbp - 1104]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1112], rax
    ; IR call: print (1 args)
    sub rsp, 32
    mov rax, [rbp - 1112]
    mov rcx, rax
    call print
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 1120], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (2 bytes)
    lea rax, [rel Lstr_struct566]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1128], rax
    ; IR call: print (1 args)
    sub rsp, 32
    mov rax, [rbp - 1128]
    mov rcx, rax
    call print
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 1136], rax
    mov rax, 0
    push rax
    mov rax, 256
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1144], rax
    mov rax, [rbp - 1144]
    test rax, rax
    jz ir_trap_bounds_1401
    jmp ir_in_bounds_1402
ir_trap_bounds_1401:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct568]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1402:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1152], rax
    ; Load variable: path_buf
    lea rax, [rbp - 480]  ; Local array base
    push rax
    mov rax, [rbp - 1152]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1160], rax
    ; IR call: print (1 args)
    sub rsp, 32
    mov rax, [rbp - 1160]
    mov rcx, rax
    call print
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 1168], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (2 bytes)
    lea rax, [rel Lstr_struct570]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1176], rax
    ; IR call: print (1 args)
    sub rsp, 32
    mov rax, [rbp - 1176]
    mov rcx, rax
    call print
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 1184], rax
    mov rax, 0
    push rax
    mov rax, 128
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1192], rax
    mov rax, [rbp - 1192]
    test rax, rax
    jz ir_trap_bounds_1405
    jmp ir_in_bounds_1406
ir_trap_bounds_1405:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct572]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1406:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1200], rax
    ; Load variable: name_buf
    lea rax, [rbp - 160]  ; Local array base
    push rax
    mov rax, [rbp - 1200]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1208], rax
    mov rax, 0
    push rax
    mov rax, 320
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1216], rax
    mov rax, [rbp - 1216]
    test rax, rax
    jz ir_trap_bounds_1407
    jmp ir_in_bounds_1408
ir_trap_bounds_1407:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct574]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1408:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1224], rax
    ; Load variable: pkg_path
    lea rax, [rbp - 800]  ; Local array base
    push rax
    mov rax, [rbp - 1224]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1232], rax
    ; IR call: path_join (4 args)
    sub rsp, 32
    ; Load variable: cache_prefix
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov rcx, rax
    mov rax, [rbp - 1208]
    mov rdx, rax
    mov rax, [rbp - 1232]
    mov r8, rax
    mov rax, 320
    mov r9, rax
    call path_join
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1240], rax
    mov rax, [rbp - 1240]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 1248], rax
    mov rax, [rbp - 1248]
    test rax, rax
    jz ir_sc_false_1411
ir_sc_rhs_1409:
    mov rax, 0
    push rax
    mov rax, 320
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1256], rax
    mov rax, [rbp - 1256]
    test rax, rax
    jz ir_trap_bounds_1413
    jmp ir_in_bounds_1414
ir_trap_bounds_1413:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct576]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1414:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1264], rax
    ; Load variable: pkg_path
    lea rax, [rbp - 800]  ; Local array base
    push rax
    mov rax, [rbp - 1264]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1272], rax
    ; IR call: dir_exists (1 args)
    sub rsp, 32
    mov rax, [rbp - 1272]
    mov rcx, rax
    call dir_exists
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1280], rax
    mov rax, [rbp - 1280]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 1288], rax
    mov rax, [rbp - 1288]
    test rax, rax
    jz ir_sc_false_1411
ir_sc_true_1410:
    mov rax, 1
    mov [rbp - 1296], rax
    jmp ir_sc_end_1412
ir_sc_false_1411:
    mov rax, 0
    mov [rbp - 1296], rax
ir_sc_end_1412:
    mov rax, [rbp - 1296]
    test rax, rax
    jz ir_if_next_1404
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (11 bytes)
    lea rax, [rel Lstr_struct578]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1312], rax
    ; IR call: println (1 args)
    sub rsp, 32
    mov rax, [rbp - 1312]
    mov rcx, rax
    call println
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 1320], rax
    jmp ir_if_end_1403
ir_if_next_1404:
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (15 bytes)
    lea rax, [rel Lstr_struct580]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1328], rax
    ; IR call: println (1 args)
    sub rsp, 32
    mov rax, [rbp - 1328]
    mov rcx, rax
    call println
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 1336], rax
ir_if_end_1403:
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1344], rax
    mov rax, [rbp - 1344]
    ; Store to variable: i
    mov dword [rbp - 28], eax  ; To stack [rbp - 28]
    jmp ir_while_1383
ir_while_end_1384:
    mov rax, 0
    mov [rbp - 1352], rax
    mov rax, [rbp - 1352]
    test rax, rax
    jz ir_errdefer_ok_1415
    jmp ir_errdefer_end_1416
ir_errdefer_ok_1415:
ir_errdefer_end_1416:
    mov rax, 0
    jmp Lcmd_list_exit
Lcmd_list_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global cmd_add

cmd_add:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 1216    ; Allocate 1216 bytes on stack (aligned)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 'argc'
    ; Parameter 'argc' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'argv'
    ; Parameter 'argv' arrived in register rdx
ir_entry_1417:
    ; Load variable: argc
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 4
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_if_next_1419
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (33 bytes)
    lea rax, [rel Lstr_struct582]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 56], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    mov rax, [rbp - 56]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 64], rax
    mov rax, 1
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    test rax, rax
    jz ir_errdefer_ok_1420
    jmp ir_errdefer_end_1421
ir_errdefer_ok_1420:
ir_errdefer_end_1421:
    mov rax, 1
    jmp Lcmd_add_exit
    jmp ir_if_end_1418
ir_if_next_1419:
ir_if_end_1418:
    ; Load variable: argv
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    test rax, rax
    jz ir_trap_null_1422
    jmp ir_nonnull_1423
ir_trap_null_1422:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct584]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1423:
    mov rax, 2
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 80], rax
    ; Load variable: argv
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, [rbp - 80]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    mov rax, qword [rax]
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    ; Store to variable: name
    mov qword [rbp - 24], rax  ; To stack [rbp - 24]
    ; Load variable: argv
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    test rax, rax
    jz ir_trap_null_1424
    jmp ir_nonnull_1425
ir_trap_null_1424:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct586]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1425:
    mov rax, 3
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 104], rax
    ; Load variable: argv
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, [rbp - 104]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    mov rax, qword [rax]
    mov [rbp - 120], rax
    mov rax, [rbp - 120]
    ; Store to variable: path
    mov qword [rbp - 32], rax  ; To stack [rbp - 32]
    ; IR call: is_valid_dep_name (1 args)
    sub rsp, 32
    ; Load variable: name
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov rcx, rax
    call is_valid_dep_name
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 128], rax
    mov rax, [rbp - 128]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 136], rax
    mov rax, [rbp - 136]
    test rax, rax
    jz ir_if_next_1427
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (47 bytes)
    lea rax, [rel Lstr_struct588]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 144], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    mov rax, [rbp - 144]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 152], rax
    mov rax, 1
    mov [rbp - 160], rax
    mov rax, [rbp - 160]
    test rax, rax
    jz ir_errdefer_ok_1428
    jmp ir_errdefer_end_1429
ir_errdefer_ok_1428:
ir_errdefer_end_1429:
    mov rax, 1
    jmp Lcmd_add_exit
    jmp ir_if_end_1426
ir_if_next_1427:
ir_if_end_1426:
    ; IR call: dir_exists (1 args)
    sub rsp, 32
    ; Load variable: path
    mov rax, qword [rbp - 32]  ; From stack [rbp - 32]
    mov rcx, rax
    call dir_exists
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 176], rax
    mov rax, [rbp - 176]
    test rax, rax
    jz ir_if_next_1431
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (57 bytes)
    lea rax, [rel Lstr_struct590]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 184], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    mov rax, [rbp - 184]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 192], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    ; Load variable: path
    mov rax, qword [rbp - 32]  ; From stack [rbp - 32]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 200], rax
    mov rax, 1
    mov [rbp - 208], rax
    mov rax, [rbp - 208]
    test rax, rax
    jz ir_errdefer_ok_1432
    jmp ir_errdefer_end_1433
ir_errdefer_ok_1432:
ir_errdefer_end_1433:
    mov rax, 1
    jmp Lcmd_add_exit
    jmp ir_if_end_1430
ir_if_next_1431:
ir_if_end_1430:
    ; IR call: dep_name_exists (1 args)
    sub rsp, 32
    ; Load variable: name
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov rcx, rax
    call dep_name_exists
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 216], rax
    mov rax, [rbp - 216]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 224], rax
    mov rax, [rbp - 224]
    test rax, rax
    jz ir_if_next_1435
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (44 bytes)
    lea rax, [rel Lstr_struct592]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 232], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    mov rax, [rbp - 232]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 240], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    ; Load variable: name
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 248], rax
    mov rax, 1
    mov [rbp - 256], rax
    mov rax, [rbp - 256]
    test rax, rax
    jz ir_errdefer_ok_1436
    jmp ir_errdefer_end_1437
ir_errdefer_ok_1436:
ir_errdefer_end_1437:
    mov rax, 1
    jmp Lcmd_add_exit
    jmp ir_if_end_1434
ir_if_next_1435:
ir_if_end_1434:
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: DEPS_FILE
    lea rax, [rel DEPS_FILE]  ; Address of global string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 264], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (1 bytes)
    lea rax, [rel Lstr_struct594]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 272], rax
    ; IR call: fopen (2 args)
    sub rsp, 32
    mov rax, [rbp - 264]
    mov rcx, rax
    mov rax, [rbp - 272]
    mov rdx, rax
    call fopen
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 280], rax
    mov rax, [rbp - 280]
    ; Store to variable: fp
    mov qword [rbp - 40], rax  ; To stack [rbp - 40]
    ; Load variable: fp
    mov rax, qword [rbp - 40]  ; From stack [rbp - 40]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 288], rax
    mov rax, [rbp - 288]
    test rax, rax
    jz ir_if_next_1439
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: DEPS_FILE
    lea rax, [rel DEPS_FILE]  ; Address of global string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 296], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (1 bytes)
    lea rax, [rel Lstr_struct596]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 304], rax
    ; IR call: fopen (2 args)
    sub rsp, 32
    mov rax, [rbp - 296]
    mov rcx, rax
    mov rax, [rbp - 304]
    mov rdx, rax
    call fopen
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 312], rax
    mov rax, [rbp - 312]
    ; Store to variable: fp
    mov qword [rbp - 40], rax  ; To stack [rbp - 40]
    ; Load variable: fp
    mov rax, qword [rbp - 40]  ; From stack [rbp - 40]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 320], rax
    mov rax, [rbp - 320]
    test rax, rax
    jz ir_if_next_1441
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (33 bytes)
    lea rax, [rel Lstr_struct598]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 328], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    mov rax, [rbp - 328]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 336], rax
    mov rax, 1
    mov [rbp - 344], rax
    mov rax, [rbp - 344]
    test rax, rax
    jz ir_errdefer_ok_1442
    jmp ir_errdefer_end_1443
ir_errdefer_ok_1442:
ir_errdefer_end_1443:
    mov rax, 1
    jmp Lcmd_add_exit
    jmp ir_if_end_1440
ir_if_next_1441:
ir_if_end_1440:
    jmp ir_if_end_1438
ir_if_next_1439:
ir_if_end_1438:
    ; IR call: fputs (2 args)
    sub rsp, 32
    ; Load variable: name
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov rcx, rax
    ; Load variable: fp
    mov rax, qword [rbp - 40]  ; From stack [rbp - 40]
    mov rdx, rax
    call fputs
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 352], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (1 bytes)
    lea rax, [rel Lstr_struct600]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 360], rax
    ; IR call: fputs (2 args)
    sub rsp, 32
    mov rax, [rbp - 360]
    mov rcx, rax
    ; Load variable: fp
    mov rax, qword [rbp - 40]  ; From stack [rbp - 40]
    mov rdx, rax
    call fputs
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 368], rax
    ; IR call: fputs (2 args)
    sub rsp, 32
    ; Load variable: path
    mov rax, qword [rbp - 32]  ; From stack [rbp - 32]
    mov rcx, rax
    ; Load variable: fp
    mov rax, qword [rbp - 40]  ; From stack [rbp - 40]
    mov rdx, rax
    call fputs
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 376], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (1 bytes)
    lea rax, [rel Lstr_struct602]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 384], rax
    ; IR call: fputs (2 args)
    sub rsp, 32
    mov rax, [rbp - 384]
    mov rcx, rax
    ; Load variable: fp
    mov rax, qword [rbp - 40]  ; From stack [rbp - 40]
    mov rdx, rax
    call fputs
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 392], rax
    ; IR call: fclose (1 args)
    sub rsp, 32
    ; Load variable: fp
    mov rax, qword [rbp - 40]  ; From stack [rbp - 40]
    mov rcx, rax
    call fclose
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 400], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (6 bytes)
    lea rax, [rel Lstr_struct604]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 408], rax
    ; IR call: println (1 args)
    sub rsp, 32
    mov rax, [rbp - 408]
    mov rcx, rax
    call println
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 416], rax
    ; IR call: println (1 args)
    sub rsp, 32
    ; Load variable: name
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov rcx, rax
    call println
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 424], rax
    mov rax, 0
    mov [rbp - 432], rax
    mov rax, [rbp - 432]
    test rax, rax
    jz ir_errdefer_ok_1444
    jmp ir_errdefer_end_1445
ir_errdefer_ok_1444:
ir_errdefer_end_1445:
    mov rax, 0
    jmp Lcmd_add_exit
Lcmd_add_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global cmd_remove

cmd_remove:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 3216    ; Allocate 3216 bytes on stack (aligned)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 'argc'
    ; Parameter 'argc' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'argv'
    ; Parameter 'argv' arrived in register rdx
ir_entry_1446:
    ; Load variable: argc
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 3
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 968], rax
    mov rax, [rbp - 968]
    test rax, rax
    jz ir_if_next_1448
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (29 bytes)
    lea rax, [rel Lstr_struct606]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 976], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    mov rax, [rbp - 976]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 984], rax
    mov rax, 1
    mov [rbp - 992], rax
    mov rax, [rbp - 992]
    test rax, rax
    jz ir_errdefer_ok_1449
    jmp ir_errdefer_end_1450
ir_errdefer_ok_1449:
ir_errdefer_end_1450:
    mov rax, 1
    jmp Lcmd_remove_exit
    jmp ir_if_end_1447
ir_if_next_1448:
ir_if_end_1447:
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: DEPS_FILE
    lea rax, [rel DEPS_FILE]  ; Address of global string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1000], rax
    ; IR call: file_exists (1 args)
    sub rsp, 32
    mov rax, [rbp - 1000]
    mov rcx, rax
    call file_exists
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1008], rax
    mov rax, [rbp - 1008]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 1016], rax
    mov rax, [rbp - 1016]
    test rax, rax
    jz ir_if_next_1452
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (26 bytes)
    lea rax, [rel Lstr_struct608]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1024], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    mov rax, [rbp - 1024]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 1032], rax
    mov rax, 1
    mov [rbp - 1040], rax
    mov rax, [rbp - 1040]
    test rax, rax
    jz ir_errdefer_ok_1453
    jmp ir_errdefer_end_1454
ir_errdefer_ok_1453:
ir_errdefer_end_1454:
    mov rax, 1
    jmp Lcmd_remove_exit
    jmp ir_if_end_1451
ir_if_next_1452:
ir_if_end_1451:
    ; Load variable: argv
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    test rax, rax
    jz ir_trap_null_1455
    jmp ir_nonnull_1456
ir_trap_null_1455:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct610]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1456:
    mov rax, 2
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1048], rax
    ; Load variable: argv
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, [rbp - 1048]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1056], rax
    mov rax, [rbp - 1056]
    mov rax, qword [rax]
    mov [rbp - 1064], rax
    mov rax, [rbp - 1064]
    ; Store to variable: name_to_remove
    mov qword [rbp - 24], rax  ; To stack [rbp - 24]
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: DEPS_FILE
    lea rax, [rel DEPS_FILE]  ; Address of global string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1072], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (1 bytes)
    lea rax, [rel Lstr_struct612]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1080], rax
    ; IR call: fopen (2 args)
    sub rsp, 32
    mov rax, [rbp - 1072]
    mov rcx, rax
    mov rax, [rbp - 1080]
    mov rdx, rax
    call fopen
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1088], rax
    mov rax, [rbp - 1088]
    ; Store to variable: in_fp
    mov qword [rbp - 32], rax  ; To stack [rbp - 32]
    ; Load variable: in_fp
    mov rax, qword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 1096], rax
    mov rax, [rbp - 1096]
    test rax, rax
    jz ir_if_next_1458
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (31 bytes)
    lea rax, [rel Lstr_struct614]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1104], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    mov rax, [rbp - 1104]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 1112], rax
    mov rax, 1
    mov [rbp - 1120], rax
    mov rax, [rbp - 1120]
    test rax, rax
    jz ir_errdefer_ok_1459
    jmp ir_errdefer_end_1460
ir_errdefer_ok_1459:
ir_errdefer_end_1460:
    mov rax, 1
    jmp Lcmd_remove_exit
    jmp ir_if_end_1457
ir_if_next_1458:
ir_if_end_1457:
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (13 bytes)
    lea rax, [rel Lstr_struct616]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1128], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (1 bytes)
    lea rax, [rel Lstr_struct618]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1136], rax
    ; IR call: fopen (2 args)
    sub rsp, 32
    mov rax, [rbp - 1128]
    mov rcx, rax
    mov rax, [rbp - 1136]
    mov rdx, rax
    call fopen
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1144], rax
    mov rax, [rbp - 1144]
    ; Store to variable: out_fp
    mov qword [rbp - 40], rax  ; To stack [rbp - 40]
    ; Load variable: out_fp
    mov rax, qword [rbp - 40]  ; From stack [rbp - 40]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 1152], rax
    mov rax, [rbp - 1152]
    test rax, rax
    jz ir_if_next_1462
    ; IR call: fclose (1 args)
    sub rsp, 32
    ; Load variable: in_fp
    mov rax, qword [rbp - 32]  ; From stack [rbp - 32]
    mov rcx, rax
    call fclose
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1160], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (42 bytes)
    lea rax, [rel Lstr_struct620]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1168], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    mov rax, [rbp - 1168]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 1176], rax
    mov rax, 1
    mov [rbp - 1184], rax
    mov rax, [rbp - 1184]
    test rax, rax
    jz ir_errdefer_ok_1463
    jmp ir_errdefer_end_1464
ir_errdefer_ok_1463:
ir_errdefer_end_1464:
    mov rax, 1
    jmp Lcmd_remove_exit
    jmp ir_if_end_1461
ir_if_next_1462:
ir_if_end_1461:
    mov rax, 0
    ; Store to variable: found
    mov dword [rbp - 44], eax  ; To stack [rbp - 44]
ir_while_1465:
    mov rax, 0
    push rax
    mov rax, 512
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1192], rax
    mov rax, [rbp - 1192]
    test rax, rax
    jz ir_trap_bounds_1467
    jmp ir_in_bounds_1468
ir_trap_bounds_1467:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct622]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1468:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1200], rax
    ; Load variable: line_buf
    lea rax, [rbp - 560]  ; Local array base
    push rax
    mov rax, [rbp - 1200]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1208], rax
    ; IR call: fgets (3 args)
    sub rsp, 32
    mov rax, [rbp - 1208]
    mov rcx, rax
    mov rax, 512
    mov rdx, rax
    ; Load variable: in_fp
    mov rax, qword [rbp - 32]  ; From stack [rbp - 32]
    mov r8, rax
    call fgets
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1216], rax
    mov rax, [rbp - 1216]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 1224], rax
    mov rax, [rbp - 1224]
    test rax, rax
    jz ir_while_end_1466
    mov rax, 0
    push rax
    mov rax, 512
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1232], rax
    mov rax, [rbp - 1232]
    test rax, rax
    jz ir_trap_bounds_1469
    jmp ir_in_bounds_1470
ir_trap_bounds_1469:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct624]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1470:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1240], rax
    ; Load variable: line_buf
    lea rax, [rbp - 560]  ; Local array base
    push rax
    mov rax, [rbp - 1240]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1248], rax
    ; IR call: strlen (1 args)
    sub rsp, 32
    mov rax, [rbp - 1248]
    mov rcx, rax
    call strlen
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1256], rax
    mov rax, [rbp - 1256]
    ; Store to variable: len
    mov qword [rbp - 952], rax  ; To stack [rbp - 952]
    ; Load variable: len
    mov rax, qword [rbp - 952]  ; From stack [rbp - 952]
    push rax
    mov rax, 511
    mov r10, rax
    pop rax
    cmp rax, r10
    setg al
    movzx rax, al
    mov [rbp - 1264], rax
    mov rax, [rbp - 1264]
    test rax, rax
    jz ir_if_next_1472
    mov rax, 511
    ; Store to variable: len
    mov qword [rbp - 952], rax  ; To stack [rbp - 952]
    jmp ir_if_end_1471
ir_if_next_1472:
ir_if_end_1471:
    mov rax, 0
    push rax
    mov rax, 512
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1272], rax
    mov rax, [rbp - 1272]
    test rax, rax
    jz ir_trap_bounds_1473
    jmp ir_in_bounds_1474
ir_trap_bounds_1473:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct626]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1474:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1280], rax
    ; Load variable: line_buf
    lea rax, [rbp - 560]  ; Local array base
    push rax
    mov rax, [rbp - 1280]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1288], rax
    mov rax, 0
    push rax
    mov rax, 128
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1296], rax
    mov rax, [rbp - 1296]
    test rax, rax
    jz ir_trap_bounds_1475
    jmp ir_in_bounds_1476
ir_trap_bounds_1475:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct628]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1476:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1304], rax
    ; Load variable: name_buf
    lea rax, [rbp - 688]  ; Local array base
    push rax
    mov rax, [rbp - 1304]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1312], rax
    mov rax, 0
    push rax
    mov rax, 256
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1320], rax
    mov rax, [rbp - 1320]
    test rax, rax
    jz ir_trap_bounds_1477
    jmp ir_in_bounds_1478
ir_trap_bounds_1477:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct630]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1478:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1328], rax
    ; Load variable: value_buf
    lea rax, [rbp - 944]  ; Local array base
    push rax
    mov rax, [rbp - 1328]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1336], rax
    ; IR call: parse_dep_line (4 args)
    sub rsp, 32
    mov rax, [rbp - 1288]
    mov rcx, rax
    ; Load variable: len
    mov rax, qword [rbp - 952]  ; From stack [rbp - 952]
    mov rdx, rax
    mov rax, [rbp - 1312]
    mov r8, rax
    mov rax, [rbp - 1336]
    mov r9, rax
    call parse_dep_line
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1344], rax
    mov rax, [rbp - 1344]
    ; Store to variable: parsed
    mov dword [rbp - 956], eax  ; To stack [rbp - 956]
    ; Load variable: parsed
    movsxd rax, dword [rbp - 956]  ; From stack [rbp - 956]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 1352], rax
    mov rax, [rbp - 1352]
    test rax, rax
    jz ir_if_next_1480
    mov rax, 0
    push rax
    mov rax, 128
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1360], rax
    mov rax, [rbp - 1360]
    test rax, rax
    jz ir_trap_bounds_1483
    jmp ir_in_bounds_1484
ir_trap_bounds_1483:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct632]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1484:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1368], rax
    ; Load variable: name_buf
    lea rax, [rbp - 688]  ; Local array base
    push rax
    mov rax, [rbp - 1368]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1376], rax
    ; IR call: streq (2 args)
    sub rsp, 32
    mov rax, [rbp - 1376]
    mov rcx, rax
    ; Load variable: name_to_remove
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov rdx, rax
    call streq
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1384], rax
    mov rax, [rbp - 1384]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 1392], rax
    mov rax, [rbp - 1392]
    test rax, rax
    jz ir_if_next_1482
    mov rax, 1
    ; Store to variable: found
    mov dword [rbp - 44], eax  ; To stack [rbp - 44]
    jmp ir_if_end_1481
ir_if_next_1482:
    mov rax, 0
    push rax
    mov rax, 128
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1400], rax
    mov rax, [rbp - 1400]
    test rax, rax
    jz ir_trap_bounds_1485
    jmp ir_in_bounds_1486
ir_trap_bounds_1485:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct634]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1486:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1408], rax
    ; Load variable: name_buf
    lea rax, [rbp - 688]  ; Local array base
    push rax
    mov rax, [rbp - 1408]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1416], rax
    ; IR call: fputs (2 args)
    sub rsp, 32
    mov rax, [rbp - 1416]
    mov rcx, rax
    ; Load variable: out_fp
    mov rax, qword [rbp - 40]  ; From stack [rbp - 40]
    mov rdx, rax
    call fputs
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1424], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (1 bytes)
    lea rax, [rel Lstr_struct636]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1432], rax
    ; IR call: fputs (2 args)
    sub rsp, 32
    mov rax, [rbp - 1432]
    mov rcx, rax
    ; Load variable: out_fp
    mov rax, qword [rbp - 40]  ; From stack [rbp - 40]
    mov rdx, rax
    call fputs
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1440], rax
    mov rax, 0
    push rax
    mov rax, 256
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1448], rax
    mov rax, [rbp - 1448]
    test rax, rax
    jz ir_trap_bounds_1487
    jmp ir_in_bounds_1488
ir_trap_bounds_1487:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct638]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1488:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1456], rax
    ; Load variable: value_buf
    lea rax, [rbp - 944]  ; Local array base
    push rax
    mov rax, [rbp - 1456]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1464], rax
    ; IR call: fputs (2 args)
    sub rsp, 32
    mov rax, [rbp - 1464]
    mov rcx, rax
    ; Load variable: out_fp
    mov rax, qword [rbp - 40]  ; From stack [rbp - 40]
    mov rdx, rax
    call fputs
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1472], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (1 bytes)
    lea rax, [rel Lstr_struct640]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1480], rax
    ; IR call: fputs (2 args)
    sub rsp, 32
    mov rax, [rbp - 1480]
    mov rcx, rax
    ; Load variable: out_fp
    mov rax, qword [rbp - 40]  ; From stack [rbp - 40]
    mov rdx, rax
    call fputs
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1488], rax
ir_if_end_1481:
    jmp ir_if_end_1479
ir_if_next_1480:
    mov rax, 0
    push rax
    mov rax, 512
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1496], rax
    mov rax, [rbp - 1496]
    test rax, rax
    jz ir_trap_bounds_1489
    jmp ir_in_bounds_1490
ir_trap_bounds_1489:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct642]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1490:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1504], rax
    ; Load variable: line_buf
    lea rax, [rbp - 560]  ; Local array base
    push rax
    mov rax, [rbp - 1504]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1512], rax
    ; IR call: fputs (2 args)
    sub rsp, 32
    mov rax, [rbp - 1512]
    mov rcx, rax
    ; Load variable: out_fp
    mov rax, qword [rbp - 40]  ; From stack [rbp - 40]
    mov rdx, rax
    call fputs
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1520], rax
ir_if_end_1479:
    jmp ir_while_1465
ir_while_end_1466:
    ; IR call: fclose (1 args)
    sub rsp, 32
    ; Load variable: in_fp
    mov rax, qword [rbp - 32]  ; From stack [rbp - 32]
    mov rcx, rax
    call fclose
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1528], rax
    ; IR call: fclose (1 args)
    sub rsp, 32
    ; Load variable: out_fp
    mov rax, qword [rbp - 40]  ; From stack [rbp - 40]
    mov rcx, rax
    call fclose
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1536], rax
    ; Load variable: found
    movsxd rax, dword [rbp - 44]  ; From stack [rbp - 44]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 1544], rax
    mov rax, [rbp - 1544]
    test rax, rax
    jz ir_if_next_1492
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (13 bytes)
    lea rax, [rel Lstr_struct644]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1552], rax
    ; IR call: remove (1 args)
    sub rsp, 32
    mov rax, [rbp - 1552]
    mov rcx, rax
    call remove
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1560], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (26 bytes)
    lea rax, [rel Lstr_struct646]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1568], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    mov rax, [rbp - 1568]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 1576], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    ; Load variable: name_to_remove
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 1584], rax
    mov rax, 1
    mov [rbp - 1592], rax
    mov rax, [rbp - 1592]
    test rax, rax
    jz ir_errdefer_ok_1493
    jmp ir_errdefer_end_1494
ir_errdefer_ok_1493:
ir_errdefer_end_1494:
    mov rax, 1
    jmp Lcmd_remove_exit
    jmp ir_if_end_1491
ir_if_next_1492:
ir_if_end_1491:
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: DEPS_FILE
    lea rax, [rel DEPS_FILE]  ; Address of global string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1600], rax
    ; IR call: remove (1 args)
    sub rsp, 32
    mov rax, [rbp - 1600]
    mov rcx, rax
    call remove
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1608], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (13 bytes)
    lea rax, [rel Lstr_struct648]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1616], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: DEPS_FILE
    lea rax, [rel DEPS_FILE]  ; Address of global string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1624], rax
    ; IR call: rename (2 args)
    sub rsp, 32
    mov rax, [rbp - 1616]
    mov rcx, rax
    mov rax, [rbp - 1624]
    mov rdx, rax
    call rename
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1632], rax
    mov rax, [rbp - 1632]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 1640], rax
    mov rax, [rbp - 1640]
    test rax, rax
    jz ir_if_next_1496
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (34 bytes)
    lea rax, [rel Lstr_struct650]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1648], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    mov rax, [rbp - 1648]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 1656], rax
    mov rax, 1
    mov [rbp - 1664], rax
    mov rax, [rbp - 1664]
    test rax, rax
    jz ir_errdefer_ok_1497
    jmp ir_errdefer_end_1498
ir_errdefer_ok_1497:
ir_errdefer_end_1498:
    mov rax, 1
    jmp Lcmd_remove_exit
    jmp ir_if_end_1495
ir_if_next_1496:
ir_if_end_1495:
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (8 bytes)
    lea rax, [rel Lstr_struct652]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1672], rax
    ; IR call: println (1 args)
    sub rsp, 32
    mov rax, [rbp - 1672]
    mov rcx, rax
    call println
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 1680], rax
    ; IR call: println (1 args)
    sub rsp, 32
    ; Load variable: name_to_remove
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov rcx, rax
    call println
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 1688], rax
    mov rax, 0
    mov [rbp - 1696], rax
    mov rax, [rbp - 1696]
    test rax, rax
    jz ir_errdefer_ok_1499
    jmp ir_errdefer_end_1500
ir_errdefer_ok_1499:
ir_errdefer_end_1500:
    mov rax, 0
    jmp Lcmd_remove_exit
Lcmd_remove_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global cmd_build

cmd_build:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    mov rax, 8576
    extern ___chkstk_ms
    sub rsp, 32
    call ___chkstk_ms
    add rsp, 32
    sub rsp, rax    ; Allocate 8576 bytes on stack (probed)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 'argc'
    ; Parameter 'argc' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'argv'
    ; Parameter 'argv' arrived in register rdx
ir_entry_1501:
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (9 bytes)
    lea rax, [rel Lstr_struct654]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1568], rax
    ; IR call: file_exists (1 args)
    sub rsp, 32
    mov rax, [rbp - 1568]
    mov rcx, rax
    call file_exists
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1576], rax
    mov rax, [rbp - 1576]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 1584], rax
    mov rax, [rbp - 1584]
    test rax, rax
    jz ir_if_next_1503
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (50 bytes)
    lea rax, [rel Lstr_struct656]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1592], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    mov rax, [rbp - 1592]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 1600], rax
    mov rax, 1
    mov [rbp - 1608], rax
    mov rax, [rbp - 1608]
    test rax, rax
    jz ir_errdefer_ok_1504
    jmp ir_errdefer_end_1505
ir_errdefer_ok_1504:
ir_errdefer_end_1505:
    mov rax, 1
    jmp Lcmd_build_exit
    jmp ir_if_end_1502
ir_if_next_1503:
ir_if_end_1502:
    ; IR call: resolve_all_dependencies (0 args)
    sub rsp, 32
    call resolve_all_dependencies
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1616], rax
    mov rax, [rbp - 1616]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 1624], rax
    mov rax, [rbp - 1624]
    test rax, rax
    jz ir_if_next_1507
    mov rax, 1
    mov [rbp - 1632], rax
    mov rax, [rbp - 1632]
    test rax, rax
    jz ir_errdefer_ok_1508
    jmp ir_errdefer_end_1509
ir_errdefer_ok_1508:
ir_errdefer_end_1509:
    mov rax, 1
    jmp Lcmd_build_exit
    jmp ir_if_end_1506
ir_if_next_1507:
ir_if_end_1506:
    ; IR call: ensure_cache_dirs (0 args)
    sub rsp, 32
    call ensure_cache_dirs
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1640], rax
    mov rax, 0
    ; Store to variable: i
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
ir_while_1510:
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    ; Load variable: RESOLVED_COUNT
    movsxd rax, dword [rel RESOLVED_COUNT]  ; From global memory
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1648], rax
    mov rax, [rbp - 1648]
    test rax, rax
    jz ir_while_end_1511
    mov rax, 0
    push rax
    mov rax, 32768
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1656], rax
    mov rax, [rbp - 1656]
    test rax, rax
    jz ir_trap_bounds_1512
    jmp ir_in_bounds_1513
ir_trap_bounds_1512:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct658]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1513:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1664], rax
    ; Load variable: RESOLVED_NAME
    lea rax, [rel RESOLVED_NAME]  ; Array base address
    push rax
    mov rax, [rbp - 1664]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1672], rax
    mov rax, 0
    push rax
    mov rax, 128
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1680], rax
    mov rax, [rbp - 1680]
    test rax, rax
    jz ir_trap_bounds_1514
    jmp ir_in_bounds_1515
ir_trap_bounds_1514:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct660]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1515:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1688], rax
    ; Load variable: name_buf
    lea rax, [rbp - 152]  ; Local array base
    push rax
    mov rax, [rbp - 1688]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1696], rax
    ; IR call: slot_to_buf (5 args)
    sub rsp, 48
    mov rax, 128
    mov [rsp + 32], rax
    mov rax, [rbp - 1672]
    mov rcx, rax
    mov rax, 128
    mov rdx, rax
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    mov r8, rax
    mov rax, [rbp - 1696]
    mov r9, rax
    call slot_to_buf
    add rsp, 48
    ; Void return - no value to handle
    mov [rbp - 1704], rax
    mov rax, 0
    push rax
    mov rax, 65536
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1712], rax
    mov rax, [rbp - 1712]
    test rax, rax
    jz ir_trap_bounds_1516
    jmp ir_in_bounds_1517
ir_trap_bounds_1516:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct662]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1517:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1720], rax
    ; Load variable: RESOLVED_PATH
    lea rax, [rel RESOLVED_PATH]  ; Array base address
    push rax
    mov rax, [rbp - 1720]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1728], rax
    mov rax, 0
    push rax
    mov rax, 256
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1736], rax
    mov rax, [rbp - 1736]
    test rax, rax
    jz ir_trap_bounds_1518
    jmp ir_in_bounds_1519
ir_trap_bounds_1518:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct664]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1519:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1744], rax
    ; Load variable: path_buf
    lea rax, [rbp - 408]  ; Local array base
    push rax
    mov rax, [rbp - 1744]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1752], rax
    ; IR call: slot_to_buf (5 args)
    sub rsp, 48
    mov rax, 256
    mov [rsp + 32], rax
    mov rax, [rbp - 1728]
    mov rcx, rax
    mov rax, 256
    mov rdx, rax
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    mov r8, rax
    mov rax, [rbp - 1752]
    mov r9, rax
    call slot_to_buf
    add rsp, 48
    ; Void return - no value to handle
    mov [rbp - 1760], rax
    mov rax, 0
    push rax
    mov rax, 128
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1768], rax
    mov rax, [rbp - 1768]
    test rax, rax
    jz ir_trap_bounds_1520
    jmp ir_in_bounds_1521
ir_trap_bounds_1520:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct666]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1521:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1776], rax
    ; Load variable: name_buf
    lea rax, [rbp - 152]  ; Local array base
    push rax
    mov rax, [rbp - 1776]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1784], rax
    mov rax, 0
    push rax
    mov rax, 256
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1792], rax
    mov rax, [rbp - 1792]
    test rax, rax
    jz ir_trap_bounds_1522
    jmp ir_in_bounds_1523
ir_trap_bounds_1522:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct668]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1523:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1800], rax
    ; Load variable: path_buf
    lea rax, [rbp - 408]  ; Local array base
    push rax
    mov rax, [rbp - 1800]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1808], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: CACHE_DIR
    lea rax, [rel CACHE_DIR]  ; Address of global string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1816], rax
    ; IR call: install_local_package (3 args)
    sub rsp, 32
    mov rax, [rbp - 1784]
    mov rcx, rax
    mov rax, [rbp - 1808]
    mov rdx, rax
    mov rax, [rbp - 1816]
    mov r8, rax
    call install_local_package
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1824], rax
    mov rax, [rbp - 1824]
    ; Store to variable: result_install
    mov dword [rbp - 412], eax  ; To stack [rbp - 412]
    ; Load variable: result_install
    movsxd rax, dword [rbp - 412]  ; From stack [rbp - 412]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 1832], rax
    mov rax, [rbp - 1832]
    test rax, rax
    jz ir_if_next_1525
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (49 bytes)
    lea rax, [rel Lstr_struct670]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1840], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    mov rax, [rbp - 1840]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 1848], rax
    mov rax, 0
    push rax
    mov rax, 128
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1856], rax
    mov rax, [rbp - 1856]
    test rax, rax
    jz ir_trap_bounds_1526
    jmp ir_in_bounds_1527
ir_trap_bounds_1526:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct672]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1527:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1864], rax
    ; Load variable: name_buf
    lea rax, [rbp - 152]  ; Local array base
    push rax
    mov rax, [rbp - 1864]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1872], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    mov rax, [rbp - 1872]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 1880], rax
    mov rax, 1
    mov [rbp - 1888], rax
    mov rax, [rbp - 1888]
    test rax, rax
    jz ir_errdefer_ok_1528
    jmp ir_errdefer_end_1529
ir_errdefer_ok_1528:
ir_errdefer_end_1529:
    mov rax, 1
    jmp Lcmd_build_exit
    jmp ir_if_end_1524
ir_if_next_1525:
ir_if_end_1524:
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1896], rax
    mov rax, [rbp - 1896]
    ; Store to variable: i
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
    jmp ir_while_1510
ir_while_end_1511:
    ; IR call: write_lock_file (0 args)
    sub rsp, 32
    call write_lock_file
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1904], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (7 bytes)
    lea rax, [rel Lstr_struct674]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1912], rax
    mov rax, [rbp - 1912]
    ; Store to variable: methasm_cmd
    mov qword [rbp - 424], rax  ; To stack [rbp - 424]
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (15 bytes)
    lea rax, [rel Lstr_struct676]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1920], rax
    ; IR call: file_exists (1 args)
    sub rsp, 32
    mov rax, [rbp - 1920]
    mov rcx, rax
    call file_exists
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1928], rax
    mov rax, [rbp - 1928]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 1936], rax
    mov rax, [rbp - 1936]
    test rax, rax
    jz ir_if_next_1531
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (15 bytes)
    lea rax, [rel Lstr_struct678]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1944], rax
    mov rax, [rbp - 1944]
    ; Store to variable: methasm_cmd
    mov qword [rbp - 424], rax  ; To stack [rbp - 424]
    jmp ir_if_end_1530
ir_if_next_1531:
    ; String literal (18 bytes)
    lea rax, [rel Lstr_struct680]  ; Load string struct address
    ; Store to variable: methasm_alt
    mov rcx, [rax]       ; string chars
    mov [rbp - 440], rcx
    mov rcx, [rax + 8]   ; string length
    mov [rbp - 432], rcx
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: methasm_alt
    lea rax, [rbp - 440]  ; Address of local string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1952], rax
    ; IR call: file_exists (1 args)
    sub rsp, 32
    mov rax, [rbp - 1952]
    mov rcx, rax
    call file_exists
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1960], rax
    mov rax, [rbp - 1960]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 1968], rax
    mov rax, [rbp - 1968]
    test rax, rax
    jz ir_if_next_1533
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: methasm_alt
    lea rax, [rbp - 440]  ; Address of local string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1976], rax
    mov rax, [rbp - 1976]
    ; Store to variable: methasm_cmd
    mov qword [rbp - 424], rax  ; To stack [rbp - 424]
    jmp ir_if_end_1532
ir_if_next_1533:
    ; String literal (21 bytes)
    lea rax, [rel Lstr_struct682]  ; Load string struct address
    ; Store to variable: methasm_alt2
    mov rcx, [rax]       ; string chars
    mov [rbp - 456], rcx
    mov rcx, [rax + 8]   ; string length
    mov [rbp - 448], rcx
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: methasm_alt2
    lea rax, [rbp - 456]  ; Address of local string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 1984], rax
    ; IR call: file_exists (1 args)
    sub rsp, 32
    mov rax, [rbp - 1984]
    mov rcx, rax
    call file_exists
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 1992], rax
    mov rax, [rbp - 1992]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 2000], rax
    mov rax, [rbp - 2000]
    test rax, rax
    jz ir_if_next_1535
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: methasm_alt2
    lea rax, [rbp - 456]  ; Address of local string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 2008], rax
    mov rax, [rbp - 2008]
    ; Store to variable: methasm_cmd
    mov qword [rbp - 424], rax  ; To stack [rbp - 424]
    jmp ir_if_end_1534
ir_if_next_1535:
ir_if_end_1534:
ir_if_end_1532:
ir_if_end_1530:
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (6 bytes)
    lea rax, [rel Lstr_struct684]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 2016], rax
    mov rax, [rbp - 2016]
    ; Store to variable: stdlib_path
    mov qword [rbp - 464], rax  ; To stack [rbp - 464]
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (18 bytes)
    lea rax, [rel Lstr_struct686]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 2024], rax
    ; IR call: file_exists (1 args)
    sub rsp, 32
    mov rax, [rbp - 2024]
    mov rcx, rax
    call file_exists
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 2032], rax
    mov rax, [rbp - 2032]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 2040], rax
    mov rax, [rbp - 2040]
    test rax, rax
    jz ir_if_next_1537
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (21 bytes)
    lea rax, [rel Lstr_struct688]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 2048], rax
    ; IR call: file_exists (1 args)
    sub rsp, 32
    mov rax, [rbp - 2048]
    mov rcx, rax
    call file_exists
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 2056], rax
    mov rax, [rbp - 2056]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 2064], rax
    mov rax, [rbp - 2064]
    test rax, rax
    jz ir_if_next_1539
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (9 bytes)
    lea rax, [rel Lstr_struct690]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 2072], rax
    mov rax, [rbp - 2072]
    ; Store to variable: stdlib_path
    mov qword [rbp - 464], rax  ; To stack [rbp - 464]
    jmp ir_if_end_1538
ir_if_next_1539:
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (24 bytes)
    lea rax, [rel Lstr_struct692]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 2080], rax
    ; IR call: file_exists (1 args)
    sub rsp, 32
    mov rax, [rbp - 2080]
    mov rcx, rax
    call file_exists
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 2088], rax
    mov rax, [rbp - 2088]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 2096], rax
    mov rax, [rbp - 2096]
    test rax, rax
    jz ir_if_next_1540
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (12 bytes)
    lea rax, [rel Lstr_struct694]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 2104], rax
    mov rax, [rbp - 2104]
    ; Store to variable: stdlib_path
    mov qword [rbp - 464], rax  ; To stack [rbp - 464]
    jmp ir_if_end_1538
ir_if_next_1540:
ir_if_end_1538:
    jmp ir_if_end_1536
ir_if_next_1537:
ir_if_end_1536:
    mov rax, 0
    ; Store to variable: pos
    mov dword [rbp - 1492], eax  ; To stack [rbp - 1492]
    mov rax, 0
    ; Store to variable: i
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
ir_while_1541:
    ; Load variable: methasm_cmd
    mov rax, qword [rbp - 424]  ; From stack [rbp - 424]
    test rax, rax
    jz ir_trap_null_1543
    jmp ir_nonnull_1544
ir_trap_null_1543:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct696]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1544:
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 2112], rax
    ; Load variable: methasm_cmd
    mov rax, qword [rbp - 424]  ; From stack [rbp - 424]
    push rax
    mov rax, [rbp - 2112]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2120], rax
    mov rax, [rbp - 2120]
    movzx rax, byte [rax]
    mov [rbp - 2128], rax
    mov rax, [rbp - 2128]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 2136], rax
    mov rax, [rbp - 2136]
    test rax, rax
    jz ir_sc_false_1547
ir_sc_rhs_1545:
    ; Load variable: pos
    movsxd rax, dword [rbp - 1492]  ; From stack [rbp - 1492]
    push rax
    mov rax, 1022
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 2144], rax
    mov rax, [rbp - 2144]
    test rax, rax
    jz ir_sc_false_1547
ir_sc_true_1546:
    mov rax, 1
    mov [rbp - 2152], rax
    jmp ir_sc_end_1548
ir_sc_false_1547:
    mov rax, 0
    mov [rbp - 2152], rax
ir_sc_end_1548:
    mov rax, [rbp - 2152]
    test rax, rax
    jz ir_while_end_1542
    ; Load variable: methasm_cmd
    mov rax, qword [rbp - 424]  ; From stack [rbp - 424]
    test rax, rax
    jz ir_trap_null_1549
    jmp ir_nonnull_1550
ir_trap_null_1549:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct698]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1550:
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 2168], rax
    ; Load variable: methasm_cmd
    mov rax, qword [rbp - 424]  ; From stack [rbp - 424]
    push rax
    mov rax, [rbp - 2168]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2176], rax
    mov rax, [rbp - 2176]
    movzx rax, byte [rax]
    mov [rbp - 2184], rax
    ; Load variable: pos
    movsxd rax, dword [rbp - 1492]  ; From stack [rbp - 1492]
    push rax
    mov rax, 1024
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 2192], rax
    mov rax, [rbp - 2192]
    test rax, rax
    jz ir_trap_bounds_1551
    jmp ir_in_bounds_1552
ir_trap_bounds_1551:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct700]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1552:
    ; Load variable: pos
    movsxd rax, dword [rbp - 1492]  ; From stack [rbp - 1492]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 2200], rax
    ; Load variable: cmd_buf
    lea rax, [rbp - 1488]  ; Local array base
    push rax
    mov rax, [rbp - 2200]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2208], rax
    mov rax, [rbp - 2208]
    push rax
    mov rax, [rbp - 2184]
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: pos
    movsxd rax, dword [rbp - 1492]  ; From stack [rbp - 1492]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2224], rax
    mov rax, [rbp - 2224]
    ; Store to variable: pos
    mov dword [rbp - 1492], eax  ; To stack [rbp - 1492]
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2232], rax
    mov rax, [rbp - 2232]
    ; Store to variable: i
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
    jmp ir_while_1541
ir_while_end_1542:
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (35 bytes)
    lea rax, [rel Lstr_struct702]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 2240], rax
    mov rax, [rbp - 2240]
    ; Store to variable: base_cmd
    mov qword [rbp - 1504], rax  ; To stack [rbp - 1504]
    mov rax, 0
    ; Store to variable: i
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
ir_while_1553:
    ; Load variable: base_cmd
    mov rax, qword [rbp - 1504]  ; From stack [rbp - 1504]
    test rax, rax
    jz ir_trap_null_1555
    jmp ir_nonnull_1556
ir_trap_null_1555:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct704]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1556:
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 2248], rax
    ; Load variable: base_cmd
    mov rax, qword [rbp - 1504]  ; From stack [rbp - 1504]
    push rax
    mov rax, [rbp - 2248]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2256], rax
    mov rax, [rbp - 2256]
    movzx rax, byte [rax]
    mov [rbp - 2264], rax
    mov rax, [rbp - 2264]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 2272], rax
    mov rax, [rbp - 2272]
    test rax, rax
    jz ir_sc_false_1559
ir_sc_rhs_1557:
    ; Load variable: pos
    movsxd rax, dword [rbp - 1492]  ; From stack [rbp - 1492]
    push rax
    mov rax, 1022
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 2280], rax
    mov rax, [rbp - 2280]
    test rax, rax
    jz ir_sc_false_1559
ir_sc_true_1558:
    mov rax, 1
    mov [rbp - 2288], rax
    jmp ir_sc_end_1560
ir_sc_false_1559:
    mov rax, 0
    mov [rbp - 2288], rax
ir_sc_end_1560:
    mov rax, [rbp - 2288]
    test rax, rax
    jz ir_while_end_1554
    ; Load variable: base_cmd
    mov rax, qword [rbp - 1504]  ; From stack [rbp - 1504]
    test rax, rax
    jz ir_trap_null_1561
    jmp ir_nonnull_1562
ir_trap_null_1561:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct706]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1562:
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 2304], rax
    ; Load variable: base_cmd
    mov rax, qword [rbp - 1504]  ; From stack [rbp - 1504]
    push rax
    mov rax, [rbp - 2304]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2312], rax
    mov rax, [rbp - 2312]
    movzx rax, byte [rax]
    mov [rbp - 2320], rax
    ; Load variable: pos
    movsxd rax, dword [rbp - 1492]  ; From stack [rbp - 1492]
    push rax
    mov rax, 1024
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 2328], rax
    mov rax, [rbp - 2328]
    test rax, rax
    jz ir_trap_bounds_1563
    jmp ir_in_bounds_1564
ir_trap_bounds_1563:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct708]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1564:
    ; Load variable: pos
    movsxd rax, dword [rbp - 1492]  ; From stack [rbp - 1492]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 2336], rax
    ; Load variable: cmd_buf
    lea rax, [rbp - 1488]  ; Local array base
    push rax
    mov rax, [rbp - 2336]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2344], rax
    mov rax, [rbp - 2344]
    push rax
    mov rax, [rbp - 2320]
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: pos
    movsxd rax, dword [rbp - 1492]  ; From stack [rbp - 1492]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2360], rax
    mov rax, [rbp - 2360]
    ; Store to variable: pos
    mov dword [rbp - 1492], eax  ; To stack [rbp - 1492]
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2368], rax
    mov rax, [rbp - 2368]
    ; Store to variable: i
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
    jmp ir_while_1553
ir_while_end_1554:
    mov rax, 0
    ; Store to variable: i
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
ir_while_1565:
    ; Load variable: stdlib_path
    mov rax, qword [rbp - 464]  ; From stack [rbp - 464]
    test rax, rax
    jz ir_trap_null_1567
    jmp ir_nonnull_1568
ir_trap_null_1567:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct710]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1568:
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 2376], rax
    ; Load variable: stdlib_path
    mov rax, qword [rbp - 464]  ; From stack [rbp - 464]
    push rax
    mov rax, [rbp - 2376]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2384], rax
    mov rax, [rbp - 2384]
    movzx rax, byte [rax]
    mov [rbp - 2392], rax
    mov rax, [rbp - 2392]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 2400], rax
    mov rax, [rbp - 2400]
    test rax, rax
    jz ir_sc_false_1571
ir_sc_rhs_1569:
    ; Load variable: pos
    movsxd rax, dword [rbp - 1492]  ; From stack [rbp - 1492]
    push rax
    mov rax, 1022
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 2408], rax
    mov rax, [rbp - 2408]
    test rax, rax
    jz ir_sc_false_1571
ir_sc_true_1570:
    mov rax, 1
    mov [rbp - 2416], rax
    jmp ir_sc_end_1572
ir_sc_false_1571:
    mov rax, 0
    mov [rbp - 2416], rax
ir_sc_end_1572:
    mov rax, [rbp - 2416]
    test rax, rax
    jz ir_while_end_1566
    ; Load variable: stdlib_path
    mov rax, qword [rbp - 464]  ; From stack [rbp - 464]
    test rax, rax
    jz ir_trap_null_1573
    jmp ir_nonnull_1574
ir_trap_null_1573:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct712]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1574:
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 2432], rax
    ; Load variable: stdlib_path
    mov rax, qword [rbp - 464]  ; From stack [rbp - 464]
    push rax
    mov rax, [rbp - 2432]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2440], rax
    mov rax, [rbp - 2440]
    movzx rax, byte [rax]
    mov [rbp - 2448], rax
    ; Load variable: pos
    movsxd rax, dword [rbp - 1492]  ; From stack [rbp - 1492]
    push rax
    mov rax, 1024
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 2456], rax
    mov rax, [rbp - 2456]
    test rax, rax
    jz ir_trap_bounds_1575
    jmp ir_in_bounds_1576
ir_trap_bounds_1575:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct714]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1576:
    ; Load variable: pos
    movsxd rax, dword [rbp - 1492]  ; From stack [rbp - 1492]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 2464], rax
    ; Load variable: cmd_buf
    lea rax, [rbp - 1488]  ; Local array base
    push rax
    mov rax, [rbp - 2464]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2472], rax
    mov rax, [rbp - 2472]
    push rax
    mov rax, [rbp - 2448]
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: pos
    movsxd rax, dword [rbp - 1492]  ; From stack [rbp - 1492]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2488], rax
    mov rax, [rbp - 2488]
    ; Store to variable: pos
    mov dword [rbp - 1492], eax  ; To stack [rbp - 1492]
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2496], rax
    mov rax, [rbp - 2496]
    ; Store to variable: i
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
    jmp ir_while_1565
ir_while_end_1566:
    ; Load variable: pos
    movsxd rax, dword [rbp - 1492]  ; From stack [rbp - 1492]
    push rax
    mov rax, 1022
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 2504], rax
    mov rax, [rbp - 2504]
    test rax, rax
    jz ir_if_next_1578
    ; Load variable: pos
    movsxd rax, dword [rbp - 1492]  ; From stack [rbp - 1492]
    push rax
    mov rax, 1024
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 2512], rax
    mov rax, [rbp - 2512]
    test rax, rax
    jz ir_trap_bounds_1579
    jmp ir_in_bounds_1580
ir_trap_bounds_1579:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct716]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1580:
    ; Load variable: pos
    movsxd rax, dword [rbp - 1492]  ; From stack [rbp - 1492]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 2520], rax
    ; Load variable: cmd_buf
    lea rax, [rbp - 1488]  ; Local array base
    push rax
    mov rax, [rbp - 2520]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2528], rax
    mov rax, [rbp - 2528]
    push rax
    mov rax, 34
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: pos
    movsxd rax, dword [rbp - 1492]  ; From stack [rbp - 1492]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2544], rax
    mov rax, [rbp - 2544]
    ; Store to variable: pos
    mov dword [rbp - 1492], eax  ; To stack [rbp - 1492]
    jmp ir_if_end_1577
ir_if_next_1578:
ir_if_end_1577:
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (20 bytes)
    lea rax, [rel Lstr_struct718]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 2552], rax
    mov rax, [rbp - 2552]
    ; Store to variable: include_cmd
    mov qword [rbp - 1512], rax  ; To stack [rbp - 1512]
    mov rax, 0
    ; Store to variable: i
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
ir_while_1581:
    ; Load variable: include_cmd
    mov rax, qword [rbp - 1512]  ; From stack [rbp - 1512]
    test rax, rax
    jz ir_trap_null_1583
    jmp ir_nonnull_1584
ir_trap_null_1583:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct720]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1584:
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 2560], rax
    ; Load variable: include_cmd
    mov rax, qword [rbp - 1512]  ; From stack [rbp - 1512]
    push rax
    mov rax, [rbp - 2560]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2568], rax
    mov rax, [rbp - 2568]
    movzx rax, byte [rax]
    mov [rbp - 2576], rax
    mov rax, [rbp - 2576]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 2584], rax
    mov rax, [rbp - 2584]
    test rax, rax
    jz ir_sc_false_1587
ir_sc_rhs_1585:
    ; Load variable: pos
    movsxd rax, dword [rbp - 1492]  ; From stack [rbp - 1492]
    push rax
    mov rax, 1022
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 2592], rax
    mov rax, [rbp - 2592]
    test rax, rax
    jz ir_sc_false_1587
ir_sc_true_1586:
    mov rax, 1
    mov [rbp - 2600], rax
    jmp ir_sc_end_1588
ir_sc_false_1587:
    mov rax, 0
    mov [rbp - 2600], rax
ir_sc_end_1588:
    mov rax, [rbp - 2600]
    test rax, rax
    jz ir_while_end_1582
    ; Load variable: include_cmd
    mov rax, qword [rbp - 1512]  ; From stack [rbp - 1512]
    test rax, rax
    jz ir_trap_null_1589
    jmp ir_nonnull_1590
ir_trap_null_1589:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct722]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1590:
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 2616], rax
    ; Load variable: include_cmd
    mov rax, qword [rbp - 1512]  ; From stack [rbp - 1512]
    push rax
    mov rax, [rbp - 2616]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2624], rax
    mov rax, [rbp - 2624]
    movzx rax, byte [rax]
    mov [rbp - 2632], rax
    ; Load variable: pos
    movsxd rax, dword [rbp - 1492]  ; From stack [rbp - 1492]
    push rax
    mov rax, 1024
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 2640], rax
    mov rax, [rbp - 2640]
    test rax, rax
    jz ir_trap_bounds_1591
    jmp ir_in_bounds_1592
ir_trap_bounds_1591:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct724]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1592:
    ; Load variable: pos
    movsxd rax, dword [rbp - 1492]  ; From stack [rbp - 1492]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 2648], rax
    ; Load variable: cmd_buf
    lea rax, [rbp - 1488]  ; Local array base
    push rax
    mov rax, [rbp - 2648]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2656], rax
    mov rax, [rbp - 2656]
    push rax
    mov rax, [rbp - 2632]
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: pos
    movsxd rax, dword [rbp - 1492]  ; From stack [rbp - 1492]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2672], rax
    mov rax, [rbp - 2672]
    ; Store to variable: pos
    mov dword [rbp - 1492], eax  ; To stack [rbp - 1492]
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2680], rax
    mov rax, [rbp - 2680]
    ; Store to variable: i
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
    jmp ir_while_1581
ir_while_end_1582:
    ; Load variable: pos
    movsxd rax, dword [rbp - 1492]  ; From stack [rbp - 1492]
    push rax
    mov rax, 1024
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 2688], rax
    mov rax, [rbp - 2688]
    test rax, rax
    jz ir_trap_bounds_1593
    jmp ir_in_bounds_1594
ir_trap_bounds_1593:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct726]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1594:
    ; Load variable: pos
    movsxd rax, dword [rbp - 1492]  ; From stack [rbp - 1492]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 2696], rax
    ; Load variable: cmd_buf
    lea rax, [rbp - 1488]  ; Local array base
    push rax
    mov rax, [rbp - 2696]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2704], rax
    mov rax, [rbp - 2704]
    push rax
    mov rax, 0
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    mov rax, 0
    push rax
    mov rax, 1024
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 2720], rax
    mov rax, [rbp - 2720]
    test rax, rax
    jz ir_trap_bounds_1595
    jmp ir_in_bounds_1596
ir_trap_bounds_1595:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct728]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1596:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 2728], rax
    ; Load variable: cmd_buf
    lea rax, [rbp - 1488]  ; Local array base
    push rax
    mov rax, [rbp - 2728]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 2736], rax
    ; IR call: system (1 args)
    sub rsp, 32
    mov rax, [rbp - 2736]
    mov rcx, rax
    call system
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 2744], rax
    mov rax, [rbp - 2744]
    ; Store to variable: result
    mov dword [rbp - 1516], eax  ; To stack [rbp - 1516]
    ; Load variable: result
    movsxd rax, dword [rbp - 1516]  ; From stack [rbp - 1516]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 2752], rax
    mov rax, [rbp - 2752]
    test rax, rax
    jz ir_if_next_1598
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (33 bytes)
    lea rax, [rel Lstr_struct730]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 2760], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    mov rax, [rbp - 2760]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 2768], rax
    mov rax, 1
    mov [rbp - 2776], rax
    mov rax, [rbp - 2776]
    test rax, rax
    jz ir_errdefer_ok_1599
    jmp ir_errdefer_end_1600
ir_errdefer_ok_1599:
ir_errdefer_end_1600:
    mov rax, 1
    jmp Lcmd_build_exit
    jmp ir_if_end_1597
ir_if_next_1598:
ir_if_end_1597:
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (34 bytes)
    lea rax, [rel Lstr_struct732]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 2784], rax
    ; IR call: system (1 args)
    sub rsp, 32
    mov rax, [rbp - 2784]
    mov rcx, rax
    call system
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 2792], rax
    mov rax, [rbp - 2792]
    ; Store to variable: result
    mov dword [rbp - 1516], eax  ; To stack [rbp - 1516]
    ; Load variable: result
    movsxd rax, dword [rbp - 1516]  ; From stack [rbp - 1516]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 2800], rax
    mov rax, [rbp - 2800]
    test rax, rax
    jz ir_if_next_1602
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (27 bytes)
    lea rax, [rel Lstr_struct734]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 2808], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    mov rax, [rbp - 2808]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 2816], rax
    mov rax, 1
    mov [rbp - 2824], rax
    mov rax, [rbp - 2824]
    test rax, rax
    jz ir_errdefer_ok_1603
    jmp ir_errdefer_end_1604
ir_errdefer_ok_1603:
ir_errdefer_end_1604:
    mov rax, 1
    jmp Lcmd_build_exit
    jmp ir_if_end_1601
ir_if_next_1602:
ir_if_end_1601:
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (16 bytes)
    lea rax, [rel Lstr_struct736]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 2832], rax
    mov rax, [rbp - 2832]
    ; Store to variable: gc_path
    mov qword [rbp - 1528], rax  ; To stack [rbp - 1528]
    ; IR call: file_exists (1 args)
    sub rsp, 32
    ; Load variable: gc_path
    mov rax, qword [rbp - 1528]  ; From stack [rbp - 1528]
    mov rcx, rax
    call file_exists
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 2840], rax
    mov rax, [rbp - 2840]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 2848], rax
    mov rax, [rbp - 2848]
    test rax, rax
    jz ir_if_next_1606
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (19 bytes)
    lea rax, [rel Lstr_struct738]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 2856], rax
    ; IR call: file_exists (1 args)
    sub rsp, 32
    mov rax, [rbp - 2856]
    mov rcx, rax
    call file_exists
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 2864], rax
    mov rax, [rbp - 2864]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 2872], rax
    mov rax, [rbp - 2872]
    test rax, rax
    jz ir_if_next_1608
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (19 bytes)
    lea rax, [rel Lstr_struct740]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 2880], rax
    mov rax, [rbp - 2880]
    ; Store to variable: gc_path
    mov qword [rbp - 1528], rax  ; To stack [rbp - 1528]
    jmp ir_if_end_1607
ir_if_next_1608:
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (22 bytes)
    lea rax, [rel Lstr_struct742]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 2888], rax
    ; IR call: file_exists (1 args)
    sub rsp, 32
    mov rax, [rbp - 2888]
    mov rcx, rax
    call file_exists
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 2896], rax
    mov rax, [rbp - 2896]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 2904], rax
    mov rax, [rbp - 2904]
    test rax, rax
    jz ir_if_next_1609
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (22 bytes)
    lea rax, [rel Lstr_struct744]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 2912], rax
    mov rax, [rbp - 2912]
    ; Store to variable: gc_path
    mov qword [rbp - 1528], rax  ; To stack [rbp - 1528]
    jmp ir_if_end_1607
ir_if_next_1609:
ir_if_end_1607:
    jmp ir_if_end_1605
ir_if_next_1606:
ir_if_end_1605:
    ; IR call: file_exists (1 args)
    sub rsp, 32
    ; Load variable: gc_path
    mov rax, qword [rbp - 1528]  ; From stack [rbp - 1528]
    mov rcx, rax
    call file_exists
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 2920], rax
    mov rax, [rbp - 2920]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 2928], rax
    mov rax, [rbp - 2928]
    test rax, rax
    jz ir_if_next_1611
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (54 bytes)
    lea rax, [rel Lstr_struct746]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 2936], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    mov rax, [rbp - 2936]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 2944], rax
    mov rax, 1
    mov [rbp - 2952], rax
    mov rax, [rbp - 2952]
    test rax, rax
    jz ir_errdefer_ok_1612
    jmp ir_errdefer_end_1613
ir_errdefer_ok_1612:
ir_errdefer_end_1613:
    mov rax, 1
    jmp Lcmd_build_exit
    jmp ir_if_end_1610
ir_if_next_1611:
ir_if_end_1610:
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (24 bytes)
    lea rax, [rel Lstr_struct748]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 2960], rax
    mov rax, [rbp - 2960]
    ; Store to variable: entry_path
    mov qword [rbp - 1536], rax  ; To stack [rbp - 1536]
    ; IR call: file_exists (1 args)
    sub rsp, 32
    ; Load variable: entry_path
    mov rax, qword [rbp - 1536]  ; From stack [rbp - 1536]
    mov rcx, rax
    call file_exists
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 2968], rax
    mov rax, [rbp - 2968]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 2976], rax
    mov rax, [rbp - 2976]
    test rax, rax
    jz ir_if_next_1615
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (27 bytes)
    lea rax, [rel Lstr_struct750]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 2984], rax
    ; IR call: file_exists (1 args)
    sub rsp, 32
    mov rax, [rbp - 2984]
    mov rcx, rax
    call file_exists
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 2992], rax
    mov rax, [rbp - 2992]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 3000], rax
    mov rax, [rbp - 3000]
    test rax, rax
    jz ir_if_next_1617
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (27 bytes)
    lea rax, [rel Lstr_struct752]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 3008], rax
    mov rax, [rbp - 3008]
    ; Store to variable: entry_path
    mov qword [rbp - 1536], rax  ; To stack [rbp - 1536]
    jmp ir_if_end_1616
ir_if_next_1617:
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (30 bytes)
    lea rax, [rel Lstr_struct754]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 3016], rax
    ; IR call: file_exists (1 args)
    sub rsp, 32
    mov rax, [rbp - 3016]
    mov rcx, rax
    call file_exists
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 3024], rax
    mov rax, [rbp - 3024]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 3032], rax
    mov rax, [rbp - 3032]
    test rax, rax
    jz ir_if_next_1618
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (30 bytes)
    lea rax, [rel Lstr_struct756]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 3040], rax
    mov rax, [rbp - 3040]
    ; Store to variable: entry_path
    mov qword [rbp - 1536], rax  ; To stack [rbp - 1536]
    jmp ir_if_end_1616
ir_if_next_1618:
ir_if_end_1616:
    jmp ir_if_end_1614
ir_if_next_1615:
ir_if_end_1614:
    ; IR call: file_exists (1 args)
    sub rsp, 32
    ; Load variable: entry_path
    mov rax, qword [rbp - 1536]  ; From stack [rbp - 1536]
    mov rcx, rax
    call file_exists
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 3048], rax
    mov rax, [rbp - 3048]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 3056], rax
    mov rax, [rbp - 3056]
    test rax, rax
    jz ir_if_next_1620
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (70 bytes)
    lea rax, [rel Lstr_struct758]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 3064], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    mov rax, [rbp - 3064]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 3072], rax
    mov rax, 1
    mov [rbp - 3080], rax
    mov rax, [rbp - 3080]
    test rax, rax
    jz ir_errdefer_ok_1621
    jmp ir_errdefer_end_1622
ir_errdefer_ok_1621:
ir_errdefer_end_1622:
    mov rax, 1
    jmp Lcmd_build_exit
    jmp ir_if_end_1619
ir_if_next_1620:
ir_if_end_1619:
    mov rax, 0
    ; Store to variable: pos
    mov dword [rbp - 1492], eax  ; To stack [rbp - 1492]
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (28 bytes)
    lea rax, [rel Lstr_struct760]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 3088], rax
    mov rax, [rbp - 3088]
    ; Store to variable: gcc_prefix
    mov qword [rbp - 1544], rax  ; To stack [rbp - 1544]
    mov rax, 0
    ; Store to variable: i
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
ir_while_1623:
    ; Load variable: gcc_prefix
    mov rax, qword [rbp - 1544]  ; From stack [rbp - 1544]
    test rax, rax
    jz ir_trap_null_1625
    jmp ir_nonnull_1626
ir_trap_null_1625:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct762]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1626:
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 3096], rax
    ; Load variable: gcc_prefix
    mov rax, qword [rbp - 1544]  ; From stack [rbp - 1544]
    push rax
    mov rax, [rbp - 3096]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 3104], rax
    mov rax, [rbp - 3104]
    movzx rax, byte [rax]
    mov [rbp - 3112], rax
    mov rax, [rbp - 3112]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 3120], rax
    mov rax, [rbp - 3120]
    test rax, rax
    jz ir_sc_false_1629
ir_sc_rhs_1627:
    ; Load variable: pos
    movsxd rax, dword [rbp - 1492]  ; From stack [rbp - 1492]
    push rax
    mov rax, 1022
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 3128], rax
    mov rax, [rbp - 3128]
    test rax, rax
    jz ir_sc_false_1629
ir_sc_true_1628:
    mov rax, 1
    mov [rbp - 3136], rax
    jmp ir_sc_end_1630
ir_sc_false_1629:
    mov rax, 0
    mov [rbp - 3136], rax
ir_sc_end_1630:
    mov rax, [rbp - 3136]
    test rax, rax
    jz ir_while_end_1624
    ; Load variable: gcc_prefix
    mov rax, qword [rbp - 1544]  ; From stack [rbp - 1544]
    test rax, rax
    jz ir_trap_null_1631
    jmp ir_nonnull_1632
ir_trap_null_1631:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct764]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1632:
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 3152], rax
    ; Load variable: gcc_prefix
    mov rax, qword [rbp - 1544]  ; From stack [rbp - 1544]
    push rax
    mov rax, [rbp - 3152]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 3160], rax
    mov rax, [rbp - 3160]
    movzx rax, byte [rax]
    mov [rbp - 3168], rax
    ; Load variable: pos
    movsxd rax, dword [rbp - 1492]  ; From stack [rbp - 1492]
    push rax
    mov rax, 1024
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 3176], rax
    mov rax, [rbp - 3176]
    test rax, rax
    jz ir_trap_bounds_1633
    jmp ir_in_bounds_1634
ir_trap_bounds_1633:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct766]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1634:
    ; Load variable: pos
    movsxd rax, dword [rbp - 1492]  ; From stack [rbp - 1492]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 3184], rax
    ; Load variable: cmd_buf
    lea rax, [rbp - 1488]  ; Local array base
    push rax
    mov rax, [rbp - 3184]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 3192], rax
    mov rax, [rbp - 3192]
    push rax
    mov rax, [rbp - 3168]
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: pos
    movsxd rax, dword [rbp - 1492]  ; From stack [rbp - 1492]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 3208], rax
    mov rax, [rbp - 3208]
    ; Store to variable: pos
    mov dword [rbp - 1492], eax  ; To stack [rbp - 1492]
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 3216], rax
    mov rax, [rbp - 3216]
    ; Store to variable: i
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
    jmp ir_while_1623
ir_while_end_1624:
    mov rax, 0
    ; Store to variable: i
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
ir_while_1635:
    ; Load variable: gc_path
    mov rax, qword [rbp - 1528]  ; From stack [rbp - 1528]
    test rax, rax
    jz ir_trap_null_1637
    jmp ir_nonnull_1638
ir_trap_null_1637:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct768]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1638:
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 3224], rax
    ; Load variable: gc_path
    mov rax, qword [rbp - 1528]  ; From stack [rbp - 1528]
    push rax
    mov rax, [rbp - 3224]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 3232], rax
    mov rax, [rbp - 3232]
    movzx rax, byte [rax]
    mov [rbp - 3240], rax
    mov rax, [rbp - 3240]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 3248], rax
    mov rax, [rbp - 3248]
    test rax, rax
    jz ir_sc_false_1641
ir_sc_rhs_1639:
    ; Load variable: pos
    movsxd rax, dword [rbp - 1492]  ; From stack [rbp - 1492]
    push rax
    mov rax, 1022
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 3256], rax
    mov rax, [rbp - 3256]
    test rax, rax
    jz ir_sc_false_1641
ir_sc_true_1640:
    mov rax, 1
    mov [rbp - 3264], rax
    jmp ir_sc_end_1642
ir_sc_false_1641:
    mov rax, 0
    mov [rbp - 3264], rax
ir_sc_end_1642:
    mov rax, [rbp - 3264]
    test rax, rax
    jz ir_while_end_1636
    ; Load variable: gc_path
    mov rax, qword [rbp - 1528]  ; From stack [rbp - 1528]
    test rax, rax
    jz ir_trap_null_1643
    jmp ir_nonnull_1644
ir_trap_null_1643:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct770]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1644:
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 3280], rax
    ; Load variable: gc_path
    mov rax, qword [rbp - 1528]  ; From stack [rbp - 1528]
    push rax
    mov rax, [rbp - 3280]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 3288], rax
    mov rax, [rbp - 3288]
    movzx rax, byte [rax]
    mov [rbp - 3296], rax
    ; Load variable: pos
    movsxd rax, dword [rbp - 1492]  ; From stack [rbp - 1492]
    push rax
    mov rax, 1024
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 3304], rax
    mov rax, [rbp - 3304]
    test rax, rax
    jz ir_trap_bounds_1645
    jmp ir_in_bounds_1646
ir_trap_bounds_1645:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct772]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1646:
    ; Load variable: pos
    movsxd rax, dword [rbp - 1492]  ; From stack [rbp - 1492]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 3312], rax
    ; Load variable: cmd_buf
    lea rax, [rbp - 1488]  ; Local array base
    push rax
    mov rax, [rbp - 3312]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 3320], rax
    mov rax, [rbp - 3320]
    push rax
    mov rax, [rbp - 3296]
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: pos
    movsxd rax, dword [rbp - 1492]  ; From stack [rbp - 1492]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 3336], rax
    mov rax, [rbp - 3336]
    ; Store to variable: pos
    mov dword [rbp - 1492], eax  ; To stack [rbp - 1492]
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 3344], rax
    mov rax, [rbp - 3344]
    ; Store to variable: i
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
    jmp ir_while_1635
ir_while_end_1636:
    ; Load variable: pos
    movsxd rax, dword [rbp - 1492]  ; From stack [rbp - 1492]
    push rax
    mov rax, 1022
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 3352], rax
    mov rax, [rbp - 3352]
    test rax, rax
    jz ir_if_next_1648
    ; Load variable: pos
    movsxd rax, dword [rbp - 1492]  ; From stack [rbp - 1492]
    push rax
    mov rax, 1024
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 3360], rax
    mov rax, [rbp - 3360]
    test rax, rax
    jz ir_trap_bounds_1649
    jmp ir_in_bounds_1650
ir_trap_bounds_1649:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct774]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1650:
    ; Load variable: pos
    movsxd rax, dword [rbp - 1492]  ; From stack [rbp - 1492]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 3368], rax
    ; Load variable: cmd_buf
    lea rax, [rbp - 1488]  ; Local array base
    push rax
    mov rax, [rbp - 3368]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 3376], rax
    mov rax, [rbp - 3376]
    push rax
    mov rax, 34
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: pos
    movsxd rax, dword [rbp - 1492]  ; From stack [rbp - 1492]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 3392], rax
    mov rax, [rbp - 3392]
    ; Store to variable: pos
    mov dword [rbp - 1492], eax  ; To stack [rbp - 1492]
    jmp ir_if_end_1647
ir_if_next_1648:
ir_if_end_1647:
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (2 bytes)
    lea rax, [rel Lstr_struct776]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 3400], rax
    mov rax, [rbp - 3400]
    ; Store to variable: gcc_mid
    mov qword [rbp - 1552], rax  ; To stack [rbp - 1552]
    mov rax, 0
    ; Store to variable: i
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
ir_while_1651:
    ; Load variable: gcc_mid
    mov rax, qword [rbp - 1552]  ; From stack [rbp - 1552]
    test rax, rax
    jz ir_trap_null_1653
    jmp ir_nonnull_1654
ir_trap_null_1653:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct778]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1654:
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 3408], rax
    ; Load variable: gcc_mid
    mov rax, qword [rbp - 1552]  ; From stack [rbp - 1552]
    push rax
    mov rax, [rbp - 3408]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 3416], rax
    mov rax, [rbp - 3416]
    movzx rax, byte [rax]
    mov [rbp - 3424], rax
    mov rax, [rbp - 3424]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 3432], rax
    mov rax, [rbp - 3432]
    test rax, rax
    jz ir_sc_false_1657
ir_sc_rhs_1655:
    ; Load variable: pos
    movsxd rax, dword [rbp - 1492]  ; From stack [rbp - 1492]
    push rax
    mov rax, 1022
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 3440], rax
    mov rax, [rbp - 3440]
    test rax, rax
    jz ir_sc_false_1657
ir_sc_true_1656:
    mov rax, 1
    mov [rbp - 3448], rax
    jmp ir_sc_end_1658
ir_sc_false_1657:
    mov rax, 0
    mov [rbp - 3448], rax
ir_sc_end_1658:
    mov rax, [rbp - 3448]
    test rax, rax
    jz ir_while_end_1652
    ; Load variable: gcc_mid
    mov rax, qword [rbp - 1552]  ; From stack [rbp - 1552]
    test rax, rax
    jz ir_trap_null_1659
    jmp ir_nonnull_1660
ir_trap_null_1659:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct780]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1660:
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 3464], rax
    ; Load variable: gcc_mid
    mov rax, qword [rbp - 1552]  ; From stack [rbp - 1552]
    push rax
    mov rax, [rbp - 3464]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 3472], rax
    mov rax, [rbp - 3472]
    movzx rax, byte [rax]
    mov [rbp - 3480], rax
    ; Load variable: pos
    movsxd rax, dword [rbp - 1492]  ; From stack [rbp - 1492]
    push rax
    mov rax, 1024
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 3488], rax
    mov rax, [rbp - 3488]
    test rax, rax
    jz ir_trap_bounds_1661
    jmp ir_in_bounds_1662
ir_trap_bounds_1661:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct782]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1662:
    ; Load variable: pos
    movsxd rax, dword [rbp - 1492]  ; From stack [rbp - 1492]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 3496], rax
    ; Load variable: cmd_buf
    lea rax, [rbp - 1488]  ; Local array base
    push rax
    mov rax, [rbp - 3496]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 3504], rax
    mov rax, [rbp - 3504]
    push rax
    mov rax, [rbp - 3480]
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: pos
    movsxd rax, dword [rbp - 1492]  ; From stack [rbp - 1492]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 3520], rax
    mov rax, [rbp - 3520]
    ; Store to variable: pos
    mov dword [rbp - 1492], eax  ; To stack [rbp - 1492]
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 3528], rax
    mov rax, [rbp - 3528]
    ; Store to variable: i
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
    jmp ir_while_1651
ir_while_end_1652:
    mov rax, 0
    ; Store to variable: i
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
ir_while_1663:
    ; Load variable: entry_path
    mov rax, qword [rbp - 1536]  ; From stack [rbp - 1536]
    test rax, rax
    jz ir_trap_null_1665
    jmp ir_nonnull_1666
ir_trap_null_1665:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct784]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1666:
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 3536], rax
    ; Load variable: entry_path
    mov rax, qword [rbp - 1536]  ; From stack [rbp - 1536]
    push rax
    mov rax, [rbp - 3536]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 3544], rax
    mov rax, [rbp - 3544]
    movzx rax, byte [rax]
    mov [rbp - 3552], rax
    mov rax, [rbp - 3552]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 3560], rax
    mov rax, [rbp - 3560]
    test rax, rax
    jz ir_sc_false_1669
ir_sc_rhs_1667:
    ; Load variable: pos
    movsxd rax, dword [rbp - 1492]  ; From stack [rbp - 1492]
    push rax
    mov rax, 1022
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 3568], rax
    mov rax, [rbp - 3568]
    test rax, rax
    jz ir_sc_false_1669
ir_sc_true_1668:
    mov rax, 1
    mov [rbp - 3576], rax
    jmp ir_sc_end_1670
ir_sc_false_1669:
    mov rax, 0
    mov [rbp - 3576], rax
ir_sc_end_1670:
    mov rax, [rbp - 3576]
    test rax, rax
    jz ir_while_end_1664
    ; Load variable: entry_path
    mov rax, qword [rbp - 1536]  ; From stack [rbp - 1536]
    test rax, rax
    jz ir_trap_null_1671
    jmp ir_nonnull_1672
ir_trap_null_1671:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct786]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1672:
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 3592], rax
    ; Load variable: entry_path
    mov rax, qword [rbp - 1536]  ; From stack [rbp - 1536]
    push rax
    mov rax, [rbp - 3592]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 3600], rax
    mov rax, [rbp - 3600]
    movzx rax, byte [rax]
    mov [rbp - 3608], rax
    ; Load variable: pos
    movsxd rax, dword [rbp - 1492]  ; From stack [rbp - 1492]
    push rax
    mov rax, 1024
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 3616], rax
    mov rax, [rbp - 3616]
    test rax, rax
    jz ir_trap_bounds_1673
    jmp ir_in_bounds_1674
ir_trap_bounds_1673:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct788]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1674:
    ; Load variable: pos
    movsxd rax, dword [rbp - 1492]  ; From stack [rbp - 1492]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 3624], rax
    ; Load variable: cmd_buf
    lea rax, [rbp - 1488]  ; Local array base
    push rax
    mov rax, [rbp - 3624]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 3632], rax
    mov rax, [rbp - 3632]
    push rax
    mov rax, [rbp - 3608]
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: pos
    movsxd rax, dword [rbp - 1492]  ; From stack [rbp - 1492]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 3648], rax
    mov rax, [rbp - 3648]
    ; Store to variable: pos
    mov dword [rbp - 1492], eax  ; To stack [rbp - 1492]
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 3656], rax
    mov rax, [rbp - 3656]
    ; Store to variable: i
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
    jmp ir_while_1663
ir_while_end_1664:
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (36 bytes)
    lea rax, [rel Lstr_struct790]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 3664], rax
    mov rax, [rbp - 3664]
    ; Store to variable: gcc_suffix
    mov qword [rbp - 1560], rax  ; To stack [rbp - 1560]
    mov rax, 0
    ; Store to variable: i
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
ir_while_1675:
    ; Load variable: gcc_suffix
    mov rax, qword [rbp - 1560]  ; From stack [rbp - 1560]
    test rax, rax
    jz ir_trap_null_1677
    jmp ir_nonnull_1678
ir_trap_null_1677:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct792]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1678:
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 3672], rax
    ; Load variable: gcc_suffix
    mov rax, qword [rbp - 1560]  ; From stack [rbp - 1560]
    push rax
    mov rax, [rbp - 3672]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 3680], rax
    mov rax, [rbp - 3680]
    movzx rax, byte [rax]
    mov [rbp - 3688], rax
    mov rax, [rbp - 3688]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 3696], rax
    mov rax, [rbp - 3696]
    test rax, rax
    jz ir_sc_false_1681
ir_sc_rhs_1679:
    ; Load variable: pos
    movsxd rax, dword [rbp - 1492]  ; From stack [rbp - 1492]
    push rax
    mov rax, 1022
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 3704], rax
    mov rax, [rbp - 3704]
    test rax, rax
    jz ir_sc_false_1681
ir_sc_true_1680:
    mov rax, 1
    mov [rbp - 3712], rax
    jmp ir_sc_end_1682
ir_sc_false_1681:
    mov rax, 0
    mov [rbp - 3712], rax
ir_sc_end_1682:
    mov rax, [rbp - 3712]
    test rax, rax
    jz ir_while_end_1676
    ; Load variable: gcc_suffix
    mov rax, qword [rbp - 1560]  ; From stack [rbp - 1560]
    test rax, rax
    jz ir_trap_null_1683
    jmp ir_nonnull_1684
ir_trap_null_1683:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct794]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1684:
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 3728], rax
    ; Load variable: gcc_suffix
    mov rax, qword [rbp - 1560]  ; From stack [rbp - 1560]
    push rax
    mov rax, [rbp - 3728]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 3736], rax
    mov rax, [rbp - 3736]
    movzx rax, byte [rax]
    mov [rbp - 3744], rax
    ; Load variable: pos
    movsxd rax, dword [rbp - 1492]  ; From stack [rbp - 1492]
    push rax
    mov rax, 1024
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 3752], rax
    mov rax, [rbp - 3752]
    test rax, rax
    jz ir_trap_bounds_1685
    jmp ir_in_bounds_1686
ir_trap_bounds_1685:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct796]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1686:
    ; Load variable: pos
    movsxd rax, dword [rbp - 1492]  ; From stack [rbp - 1492]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 3760], rax
    ; Load variable: cmd_buf
    lea rax, [rbp - 1488]  ; Local array base
    push rax
    mov rax, [rbp - 3760]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 3768], rax
    mov rax, [rbp - 3768]
    push rax
    mov rax, [rbp - 3744]
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: pos
    movsxd rax, dword [rbp - 1492]  ; From stack [rbp - 1492]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 3784], rax
    mov rax, [rbp - 3784]
    ; Store to variable: pos
    mov dword [rbp - 1492], eax  ; To stack [rbp - 1492]
    ; Load variable: i
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 3792], rax
    mov rax, [rbp - 3792]
    ; Store to variable: i
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
    jmp ir_while_1675
ir_while_end_1676:
    ; Load variable: pos
    movsxd rax, dword [rbp - 1492]  ; From stack [rbp - 1492]
    push rax
    mov rax, 1024
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 3800], rax
    mov rax, [rbp - 3800]
    test rax, rax
    jz ir_trap_bounds_1687
    jmp ir_in_bounds_1688
ir_trap_bounds_1687:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct798]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1688:
    ; Load variable: pos
    movsxd rax, dword [rbp - 1492]  ; From stack [rbp - 1492]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 3808], rax
    ; Load variable: cmd_buf
    lea rax, [rbp - 1488]  ; Local array base
    push rax
    mov rax, [rbp - 3808]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 3816], rax
    mov rax, [rbp - 3816]
    push rax
    mov rax, 0
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    mov rax, 0
    push rax
    mov rax, 1024
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 3832], rax
    mov rax, [rbp - 3832]
    test rax, rax
    jz ir_trap_bounds_1689
    jmp ir_in_bounds_1690
ir_trap_bounds_1689:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct800]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_1690:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 3840], rax
    ; Load variable: cmd_buf
    lea rax, [rbp - 1488]  ; Local array base
    push rax
    mov rax, [rbp - 3840]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 3848], rax
    ; IR call: system (1 args)
    sub rsp, 32
    mov rax, [rbp - 3848]
    mov rcx, rax
    call system
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 3856], rax
    mov rax, [rbp - 3856]
    ; Store to variable: result
    mov dword [rbp - 1516], eax  ; To stack [rbp - 1516]
    ; Load variable: result
    movsxd rax, dword [rbp - 1516]  ; From stack [rbp - 1516]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 3864], rax
    mov rax, [rbp - 3864]
    test rax, rax
    jz ir_if_next_1692
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (22 bytes)
    lea rax, [rel Lstr_struct802]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 3872], rax
    ; IR call: println_err (1 args)
    sub rsp, 32
    mov rax, [rbp - 3872]
    mov rcx, rax
    call println_err
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 3880], rax
    mov rax, 1
    mov [rbp - 3888], rax
    mov rax, [rbp - 3888]
    test rax, rax
    jz ir_errdefer_ok_1693
    jmp ir_errdefer_end_1694
ir_errdefer_ok_1693:
ir_errdefer_end_1694:
    mov rax, 1
    jmp Lcmd_build_exit
    jmp ir_if_end_1691
ir_if_next_1692:
ir_if_end_1691:
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (24 bytes)
    lea rax, [rel Lstr_struct804]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 3896], rax
    ; IR call: println (1 args)
    sub rsp, 32
    mov rax, [rbp - 3896]
    mov rcx, rax
    call println
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 3904], rax
    mov rax, 0
    mov [rbp - 3912], rax
    mov rax, [rbp - 3912]
    test rax, rax
    jz ir_errdefer_ok_1695
    jmp ir_errdefer_end_1696
ir_errdefer_ok_1695:
ir_errdefer_end_1696:
    mov rax, 0
    jmp Lcmd_build_exit
Lcmd_build_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global main

main:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 800    ; Allocate 800 bytes on stack (aligned)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 'argc'
    ; Parameter 'argc' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'argv'
    ; Parameter 'argv' arrived in register rdx
ir_entry_1697:
    ; Load variable: argc
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 2
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_if_next_1699
    ; IR call: print_usage (0 args)
    sub rsp, 32
    call print_usage
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 40], rax
    mov rax, 1
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_errdefer_ok_1700
    jmp ir_errdefer_end_1701
ir_errdefer_ok_1700:
ir_errdefer_end_1701:
    mov rax, 1
    jmp Lmain_exit
    jmp ir_if_end_1698
ir_if_next_1699:
ir_if_end_1698:
    ; Load variable: argv
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    test rax, rax
    jz ir_trap_null_1702
    jmp ir_nonnull_1703
ir_trap_null_1702:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct806]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_1703:
    mov rax, 1
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 56], rax
    ; Load variable: argv
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, [rbp - 56]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    mov rax, qword [rax]
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    ; Store to variable: cmd
    mov qword [rbp - 24], rax  ; To stack [rbp - 24]
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (7 bytes)
    lea rax, [rel Lstr_struct808]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 80], rax
    ; IR call: streq (2 args)
    sub rsp, 32
    ; Load variable: cmd
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov rcx, rax
    mov rax, [rbp - 80]
    mov rdx, rax
    call streq
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    test rax, rax
    jz ir_if_next_1705
    ; IR call: cmd_install (2 args)
    sub rsp, 32
    ; Load variable: argc
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    ; Load variable: argv
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov rdx, rax
    call cmd_install
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 104], rax
    mov rax, [rbp - 104]
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    test rax, rax
    jz ir_errdefer_ok_1706
    jmp ir_errdefer_end_1707
ir_errdefer_ok_1706:
ir_errdefer_end_1707:
    mov rax, [rbp - 104]
    jmp Lmain_exit
    jmp ir_if_end_1704
ir_if_next_1705:
ir_if_end_1704:
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (3 bytes)
    lea rax, [rel Lstr_struct810]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 120], rax
    ; IR call: streq (2 args)
    sub rsp, 32
    ; Load variable: cmd
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov rcx, rax
    mov rax, [rbp - 120]
    mov rdx, rax
    call streq
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 128], rax
    mov rax, [rbp - 128]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 136], rax
    mov rax, [rbp - 136]
    test rax, rax
    jz ir_if_next_1709
    ; IR call: cmd_add (2 args)
    sub rsp, 32
    ; Load variable: argc
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    ; Load variable: argv
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov rdx, rax
    call cmd_add
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 144], rax
    mov rax, [rbp - 144]
    mov [rbp - 152], rax
    mov rax, [rbp - 152]
    test rax, rax
    jz ir_errdefer_ok_1710
    jmp ir_errdefer_end_1711
ir_errdefer_ok_1710:
ir_errdefer_end_1711:
    mov rax, [rbp - 144]
    jmp Lmain_exit
    jmp ir_if_end_1708
ir_if_next_1709:
ir_if_end_1708:
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (6 bytes)
    lea rax, [rel Lstr_struct812]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 160], rax
    ; IR call: streq (2 args)
    sub rsp, 32
    ; Load variable: cmd
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov rcx, rax
    mov rax, [rbp - 160]
    mov rdx, rax
    call streq
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 176], rax
    mov rax, [rbp - 176]
    test rax, rax
    jz ir_if_next_1713
    ; IR call: cmd_remove (2 args)
    sub rsp, 32
    ; Load variable: argc
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    ; Load variable: argv
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov rdx, rax
    call cmd_remove
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 184], rax
    mov rax, [rbp - 184]
    mov [rbp - 192], rax
    mov rax, [rbp - 192]
    test rax, rax
    jz ir_errdefer_ok_1714
    jmp ir_errdefer_end_1715
ir_errdefer_ok_1714:
ir_errdefer_end_1715:
    mov rax, [rbp - 184]
    jmp Lmain_exit
    jmp ir_if_end_1712
ir_if_next_1713:
ir_if_end_1712:
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (5 bytes)
    lea rax, [rel Lstr_struct814]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 200], rax
    ; IR call: streq (2 args)
    sub rsp, 32
    ; Load variable: cmd
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov rcx, rax
    mov rax, [rbp - 200]
    mov rdx, rax
    call streq
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 208], rax
    mov rax, [rbp - 208]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 216], rax
    mov rax, [rbp - 216]
    test rax, rax
    jz ir_if_next_1717
    ; IR call: cmd_build (2 args)
    sub rsp, 32
    ; Load variable: argc
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    ; Load variable: argv
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov rdx, rax
    call cmd_build
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 224], rax
    mov rax, [rbp - 224]
    mov [rbp - 232], rax
    mov rax, [rbp - 232]
    test rax, rax
    jz ir_errdefer_ok_1718
    jmp ir_errdefer_end_1719
ir_errdefer_ok_1718:
ir_errdefer_end_1719:
    mov rax, [rbp - 224]
    jmp Lmain_exit
    jmp ir_if_end_1716
ir_if_next_1717:
ir_if_end_1716:
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (4 bytes)
    lea rax, [rel Lstr_struct816]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 240], rax
    ; IR call: streq (2 args)
    sub rsp, 32
    ; Load variable: cmd
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov rcx, rax
    mov rax, [rbp - 240]
    mov rdx, rax
    call streq
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 248], rax
    mov rax, [rbp - 248]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 256], rax
    mov rax, [rbp - 256]
    test rax, rax
    jz ir_if_next_1721
    ; IR call: cmd_list (2 args)
    sub rsp, 32
    ; Load variable: argc
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    ; Load variable: argv
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov rdx, rax
    call cmd_list
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 264], rax
    mov rax, [rbp - 264]
    mov [rbp - 272], rax
    mov rax, [rbp - 272]
    test rax, rax
    jz ir_errdefer_ok_1722
    jmp ir_errdefer_end_1723
ir_errdefer_ok_1722:
ir_errdefer_end_1723:
    mov rax, [rbp - 264]
    jmp Lmain_exit
    jmp ir_if_end_1720
ir_if_next_1721:
ir_if_end_1720:
    ; IR call: print_usage (0 args)
    sub rsp, 32
    call print_usage
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 280], rax
    mov rax, 1
    mov [rbp - 288], rax
    mov rax, [rbp - 288]
    test rax, rax
    jz ir_errdefer_ok_1724
    jmp ir_errdefer_end_1725
ir_errdefer_ok_1724:
ir_errdefer_end_1725:
    mov rax, 1
    jmp Lmain_exit
Lmain_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

; Default program entry point
global mainCRTStartup
mainCRTStartup:
    sub rsp, 40      ; Shadow space + alignment
    ; Initialize garbage collector runtime
    lea rcx, [rsp + 40]
    extern gc_init
    call gc_init
    extern gc_register_root
    lea rcx, [rel USAGE]
    call gc_register_root
    lea rcx, [rel CACHE_DIR]
    call gc_register_root
    lea rcx, [rel DEPS_FILE]
    call gc_register_root
    lea rcx, [rel LOCK_FILE]
    call gc_register_root
    lea rcx, [rel PKG_FILE]
    call gc_register_root
    lea rcx, [rel RESOLVED_NAME]
    call gc_register_root
    lea rcx, [rel RESOLVED_VERSION]
    call gc_register_root
    lea rcx, [rel RESOLVED_PATH]
    call gc_register_root
    ; Call user main function
    sub rsp, 48      ; Shadow + space for argc/argv
    lea rcx, [rsp + 32]  ; &argc
    lea rdx, [rsp + 40]  ; &argv
    extern masm_entry_get_args
    call masm_entry_get_args
    mov ecx, [rsp + 32]  ; argc
    mov rdx, [rsp + 40]  ; argv
    call main
    add rsp, 48      ; Restore stack
    mov [rsp + 32], rax ; Preserve main return code
    extern gc_shutdown
    call gc_shutdown
    mov rcx, [rsp + 32] ; Use main return as exit code
    extern ExitProcess
    call ExitProcess

; Data section for global variables
section .data
; Global variable: USAGE (string, 16 bytes)
USAGE:
    dq Lstr0  ; Pointer to string data
    dq 47  ; String length
Lstr0:
    db "masm-pkg <add|remove|list|install|build> [args]", 0

; Global variable: CACHE_DIR (string, 16 bytes)
CACHE_DIR:
    dq Lstr1  ; Pointer to string data
    dq 14  ; String length
Lstr1:
    db ".masm/packages", 0

; Global variable: DEPS_FILE (string, 16 bytes)
DEPS_FILE:
    dq Lstr2  ; Pointer to string data
    dq 9  ; String length
Lstr2:
    db "masm.deps", 0

; Global variable: LOCK_FILE (string, 16 bytes)
LOCK_FILE:
    dq Lstr3  ; Pointer to string data
    dq 9  ; String length
Lstr3:
    db "masm.lock", 0

; Global variable: PKG_FILE (string, 16 bytes)
PKG_FILE:
    dq Lstr4  ; Pointer to string data
    dq 8  ; String length
Lstr4:
    db "masm.pkg", 0

; Global variable: MAX_PACKAGES (int32, 4 bytes)
MAX_PACKAGES:
    dd 256

; Global variable: RESOLVED_NAME (int8[32768], 32768 bytes)
section .bss
RESOLVED_NAME:
    resb 32768
section .data

; Global variable: RESOLVED_VERSION (int8[16384], 16384 bytes)
section .bss
RESOLVED_VERSION:
    resb 16384
section .data

; Global variable: RESOLVED_PATH (int8[65536], 65536 bytes)
section .bss
RESOLVED_PATH:
    resb 65536
section .data

; Global variable: RESOLVED_COUNT (int32, 4 bytes)
RESOLVED_COUNT:
    dd 0

Lstr_chars5:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct6:
    dq Lstr_chars5
    dq 37

Lstr_chars7:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct8:
    dq Lstr_chars7
    dq 37

Lstr_chars9:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct10:
    dq Lstr_chars9
    dq 38

Lstr_chars11:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct12:
    dq Lstr_chars11
    dq 38

Lstr_chars13:
    db 10, 0
    align 8
Lstr_struct14:
    dq Lstr_chars13
    dq 1

Lstr_chars15:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct16:
    dq Lstr_chars15
    dq 37

Lstr_chars17:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct18:
    dq Lstr_chars17
    dq 37

Lstr_chars19:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct20:
    dq Lstr_chars19
    dq 37

Lstr_chars21:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct22:
    dq Lstr_chars21
    dq 37

Lstr_chars23:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct24:
    dq Lstr_chars23
    dq 37

Lstr_chars25:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct26:
    dq Lstr_chars25
    dq 37

Lstr_chars27:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct28:
    dq Lstr_chars27
    dq 37

Lstr_chars29:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct30:
    dq Lstr_chars29
    dq 37

Lstr_chars31:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct32:
    dq Lstr_chars31
    dq 37

Lstr_chars33:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct34:
    dq Lstr_chars33
    dq 37

Lstr_chars35:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct36:
    dq Lstr_chars35
    dq 37

Lstr_chars37:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct38:
    dq Lstr_chars37
    dq 37

Lstr_chars39:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct40:
    dq Lstr_chars39
    dq 37

Lstr_chars41:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct42:
    dq Lstr_chars41
    dq 37

Lstr_chars43:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct44:
    dq Lstr_chars43
    dq 37

Lstr_chars45:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct46:
    dq Lstr_chars45
    dq 37

Lstr_chars47:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct48:
    dq Lstr_chars47
    dq 37

Lstr_chars49:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct50:
    dq Lstr_chars49
    dq 37

Lstr_chars51:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct52:
    dq Lstr_chars51
    dq 37

Lstr_chars53:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct54:
    dq Lstr_chars53
    dq 37

Lstr_chars55:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct56:
    dq Lstr_chars55
    dq 37

Lstr_chars57:
    db ".masm", 0
    align 8
Lstr_struct58:
    dq Lstr_chars57
    dq 5

Lstr_chars59:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct60:
    dq Lstr_chars59
    dq 38

Lstr_chars61:
    db "xcopy /E /I /Y ", 34, 0
    align 8
Lstr_struct62:
    dq Lstr_chars61
    dq 16

Lstr_chars63:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct64:
    dq Lstr_chars63
    dq 38

Lstr_chars65:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct66:
    dq Lstr_chars65
    dq 38

Lstr_chars67:
    db 34, " ", 34, 0
    align 8
Lstr_struct68:
    dq Lstr_chars67
    dq 3

Lstr_chars69:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct70:
    dq Lstr_chars69
    dq 38

Lstr_chars71:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct72:
    dq Lstr_chars71
    dq 38

Lstr_chars73:
    db 92, 0
    align 8
Lstr_struct74:
    dq Lstr_chars73
    dq 1

Lstr_chars75:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct76:
    dq Lstr_chars75
    dq 38

Lstr_chars77:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct78:
    dq Lstr_chars77
    dq 38

Lstr_chars79:
    db 34, 0
    align 8
Lstr_struct80:
    dq Lstr_chars79
    dq 1

Lstr_chars81:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct82:
    dq Lstr_chars81
    dq 38

Lstr_chars83:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct84:
    dq Lstr_chars83
    dq 38

Lstr_chars85:
    db "http://", 0
    align 8
Lstr_struct86:
    dq Lstr_chars85
    dq 7

Lstr_chars87:
    db "https://", 0
    align 8
Lstr_struct88:
    dq Lstr_chars87
    dq 8

Lstr_chars89:
    db ".masm", 0
    align 8
Lstr_struct90:
    dq Lstr_chars89
    dq 5

Lstr_chars91:
    db ".masm", 92, "remote", 0
    align 8
Lstr_struct92:
    dq Lstr_chars91
    dq 12

Lstr_chars93:
    db ".masm", 92, "remote", 92, 0
    align 8
Lstr_struct94:
    dq Lstr_chars93
    dq 13

Lstr_chars95:
    db 0
    align 8
Lstr_struct96:
    dq Lstr_chars95
    dq 0

Lstr_chars97:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct98:
    dq Lstr_chars97
    dq 38

Lstr_chars99:
    db ".masm", 92, "remote", 92, 0
    align 8
Lstr_struct100:
    dq Lstr_chars99
    dq 13

Lstr_chars101:
    db ".zip", 0
    align 8
Lstr_struct102:
    dq Lstr_chars101
    dq 4

Lstr_chars103:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct104:
    dq Lstr_chars103
    dq 38

Lstr_chars105:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct106:
    dq Lstr_chars105
    dq 38

Lstr_chars107:
    db "powershell -NoProfile -ExecutionPolicy Bypass -Command ", 34, "Invoke-WebRequest -UseBasicParsing -Uri '", 0
    align 8
Lstr_struct108:
    dq Lstr_chars107
    dq 97

Lstr_chars109:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct110:
    dq Lstr_chars109
    dq 38

Lstr_chars111:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct112:
    dq Lstr_chars111
    dq 38

Lstr_chars113:
    db "' -OutFile '", 0
    align 8
Lstr_struct114:
    dq Lstr_chars113
    dq 12

Lstr_chars115:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct116:
    dq Lstr_chars115
    dq 38

Lstr_chars117:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct118:
    dq Lstr_chars117
    dq 38

Lstr_chars119:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct120:
    dq Lstr_chars119
    dq 38

Lstr_chars121:
    db "'", 34, 0
    align 8
Lstr_struct122:
    dq Lstr_chars121
    dq 2

Lstr_chars123:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct124:
    dq Lstr_chars123
    dq 38

Lstr_chars125:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct126:
    dq Lstr_chars125
    dq 38

Lstr_chars127:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct128:
    dq Lstr_chars127
    dq 38

Lstr_chars129:
    db "powershell -NoProfile -ExecutionPolicy Bypass -Command ", 34, "$d='", 0
    align 8
Lstr_struct130:
    dq Lstr_chars129
    dq 60

Lstr_chars131:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct132:
    dq Lstr_chars131
    dq 38

Lstr_chars133:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct134:
    dq Lstr_chars133
    dq 38

Lstr_chars135:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct136:
    dq Lstr_chars135
    dq 38

Lstr_chars137:
    db "'; if (Test-Path $d) { Remove-Item -Recurse -Force $d }; New-Item -ItemType Directory -Force $d | Out-Null; Expand-Archive -Path '", 0
    align 8
Lstr_struct138:
    dq Lstr_chars137
    dq 130

Lstr_chars139:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct140:
    dq Lstr_chars139
    dq 38

Lstr_chars141:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct142:
    dq Lstr_chars141
    dq 38

Lstr_chars143:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct144:
    dq Lstr_chars143
    dq 38

Lstr_chars145:
    db "' -DestinationPath $d -Force", 34, 0
    align 8
Lstr_struct146:
    dq Lstr_chars145
    dq 29

Lstr_chars147:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct148:
    dq Lstr_chars147
    dq 38

Lstr_chars149:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct150:
    dq Lstr_chars149
    dq 38

Lstr_chars151:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct152:
    dq Lstr_chars151
    dq 38

Lstr_chars153:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct154:
    dq Lstr_chars153
    dq 38

Lstr_chars155:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct156:
    dq Lstr_chars155
    dq 37

Lstr_chars157:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct158:
    dq Lstr_chars157
    dq 37

Lstr_chars159:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct160:
    dq Lstr_chars159
    dq 37

Lstr_chars161:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct162:
    dq Lstr_chars161
    dq 37

Lstr_chars163:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct164:
    dq Lstr_chars163
    dq 37

Lstr_chars165:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct166:
    dq Lstr_chars165
    dq 37

Lstr_chars167:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct168:
    dq Lstr_chars167
    dq 37

Lstr_chars169:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct170:
    dq Lstr_chars169
    dq 37

Lstr_chars171:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct172:
    dq Lstr_chars171
    dq 37

Lstr_chars173:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct174:
    dq Lstr_chars173
    dq 37

Lstr_chars175:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct176:
    dq Lstr_chars175
    dq 37

Lstr_chars177:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct178:
    dq Lstr_chars177
    dq 37

Lstr_chars179:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct180:
    dq Lstr_chars179
    dq 37

Lstr_chars181:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct182:
    dq Lstr_chars181
    dq 37

Lstr_chars183:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct184:
    dq Lstr_chars183
    dq 37

Lstr_chars185:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct186:
    dq Lstr_chars185
    dq 37

Lstr_chars187:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct188:
    dq Lstr_chars187
    dq 37

Lstr_chars189:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct190:
    dq Lstr_chars189
    dq 37

Lstr_chars191:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct192:
    dq Lstr_chars191
    dq 37

Lstr_chars193:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct194:
    dq Lstr_chars193
    dq 37

Lstr_chars195:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct196:
    dq Lstr_chars195
    dq 37

Lstr_chars197:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct198:
    dq Lstr_chars197
    dq 37

Lstr_chars199:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct200:
    dq Lstr_chars199
    dq 37

Lstr_chars201:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct202:
    dq Lstr_chars201
    dq 37

Lstr_chars203:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct204:
    dq Lstr_chars203
    dq 37

Lstr_chars205:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct206:
    dq Lstr_chars205
    dq 37

Lstr_chars207:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct208:
    dq Lstr_chars207
    dq 37

Lstr_chars209:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct210:
    dq Lstr_chars209
    dq 37

Lstr_chars211:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct212:
    dq Lstr_chars211
    dq 37

Lstr_chars213:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct214:
    dq Lstr_chars213
    dq 37

Lstr_chars215:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct216:
    dq Lstr_chars215
    dq 37

Lstr_chars217:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct218:
    dq Lstr_chars217
    dq 37

Lstr_chars219:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct220:
    dq Lstr_chars219
    dq 37

Lstr_chars221:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct222:
    dq Lstr_chars221
    dq 37

Lstr_chars223:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct224:
    dq Lstr_chars223
    dq 37

Lstr_chars225:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct226:
    dq Lstr_chars225
    dq 37

Lstr_chars227:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct228:
    dq Lstr_chars227
    dq 37

Lstr_chars229:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct230:
    dq Lstr_chars229
    dq 37

Lstr_chars231:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct232:
    dq Lstr_chars231
    dq 37

Lstr_chars233:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct234:
    dq Lstr_chars233
    dq 37

Lstr_chars235:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct236:
    dq Lstr_chars235
    dq 37

Lstr_chars237:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct238:
    dq Lstr_chars237
    dq 37

Lstr_chars239:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct240:
    dq Lstr_chars239
    dq 37

Lstr_chars241:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct242:
    dq Lstr_chars241
    dq 37

Lstr_chars243:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct244:
    dq Lstr_chars243
    dq 37

Lstr_chars245:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct246:
    dq Lstr_chars245
    dq 37

Lstr_chars247:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct248:
    dq Lstr_chars247
    dq 37

Lstr_chars249:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct250:
    dq Lstr_chars249
    dq 37

Lstr_chars251:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct252:
    dq Lstr_chars251
    dq 37

Lstr_chars253:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct254:
    dq Lstr_chars253
    dq 37

Lstr_chars255:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct256:
    dq Lstr_chars255
    dq 37

Lstr_chars257:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct258:
    dq Lstr_chars257
    dq 37

Lstr_chars259:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct260:
    dq Lstr_chars259
    dq 37

Lstr_chars261:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct262:
    dq Lstr_chars261
    dq 37

Lstr_chars263:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct264:
    dq Lstr_chars263
    dq 37

Lstr_chars265:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct266:
    dq Lstr_chars265
    dq 37

Lstr_chars267:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct268:
    dq Lstr_chars267
    dq 37

Lstr_chars269:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct270:
    dq Lstr_chars269
    dq 37

Lstr_chars271:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct272:
    dq Lstr_chars271
    dq 37

Lstr_chars273:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct274:
    dq Lstr_chars273
    dq 37

Lstr_chars275:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct276:
    dq Lstr_chars275
    dq 37

Lstr_chars277:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct278:
    dq Lstr_chars277
    dq 37

Lstr_chars279:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct280:
    dq Lstr_chars279
    dq 37

Lstr_chars281:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct282:
    dq Lstr_chars281
    dq 37

Lstr_chars283:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct284:
    dq Lstr_chars283
    dq 37

Lstr_chars285:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct286:
    dq Lstr_chars285
    dq 37

Lstr_chars287:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct288:
    dq Lstr_chars287
    dq 37

Lstr_chars289:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct290:
    dq Lstr_chars289
    dq 37

Lstr_chars291:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct292:
    dq Lstr_chars291
    dq 37

Lstr_chars293:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct294:
    dq Lstr_chars293
    dq 37

Lstr_chars295:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct296:
    dq Lstr_chars295
    dq 37

Lstr_chars297:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct298:
    dq Lstr_chars297
    dq 37

Lstr_chars299:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct300:
    dq Lstr_chars299
    dq 38

Lstr_chars301:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct302:
    dq Lstr_chars301
    dq 38

Lstr_chars303:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct304:
    dq Lstr_chars303
    dq 38

Lstr_chars305:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct306:
    dq Lstr_chars305
    dq 38

Lstr_chars307:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct308:
    dq Lstr_chars307
    dq 38

Lstr_chars309:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct310:
    dq Lstr_chars309
    dq 38

Lstr_chars311:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct312:
    dq Lstr_chars311
    dq 38

Lstr_chars313:
    db "Error: dependency conflict for package: ", 0
    align 8
Lstr_struct314:
    dq Lstr_chars313
    dq 40

Lstr_chars315:
    db "Already resolved as:", 0
    align 8
Lstr_struct316:
    dq Lstr_chars315
    dq 20

Lstr_chars317:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct318:
    dq Lstr_chars317
    dq 38

Lstr_chars319:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct320:
    dq Lstr_chars319
    dq 38

Lstr_chars321:
    db "Conflicts with:", 0
    align 8
Lstr_struct322:
    dq Lstr_chars321
    dq 15

Lstr_chars323:
    db "Error: dependency graph too large.", 0
    align 8
Lstr_struct324:
    dq Lstr_chars323
    dq 34

Lstr_chars325:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct326:
    dq Lstr_chars325
    dq 38

Lstr_chars327:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct328:
    dq Lstr_chars327
    dq 38

Lstr_chars329:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct330:
    dq Lstr_chars329
    dq 38

Lstr_chars331:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct332:
    dq Lstr_chars331
    dq 38

Lstr_chars333:
    db "0.0.0-local", 0
    align 8
Lstr_struct334:
    dq Lstr_chars333
    dq 11

Lstr_chars335:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct336:
    dq Lstr_chars335
    dq 37

Lstr_chars337:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct338:
    dq Lstr_chars337
    dq 38

Lstr_chars339:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct340:
    dq Lstr_chars339
    dq 37

Lstr_chars341:
    db "Error: missing masm.pkg and no fallback package name for path:", 0
    align 8
Lstr_struct342:
    dq Lstr_chars341
    dq 62

Lstr_chars343:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct344:
    dq Lstr_chars343
    dq 38

Lstr_chars345:
    db "r", 0
    align 8
Lstr_struct346:
    dq Lstr_chars345
    dq 1

Lstr_chars347:
    db "Error: could not read package manifest:", 0
    align 8
Lstr_struct348:
    dq Lstr_chars347
    dq 39

Lstr_chars349:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct350:
    dq Lstr_chars349
    dq 38

Lstr_chars351:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct352:
    dq Lstr_chars351
    dq 38

Lstr_chars353:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct354:
    dq Lstr_chars353
    dq 38

Lstr_chars355:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct356:
    dq Lstr_chars355
    dq 38

Lstr_chars357:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct358:
    dq Lstr_chars357
    dq 38

Lstr_chars359:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct360:
    dq Lstr_chars359
    dq 38

Lstr_chars361:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct362:
    dq Lstr_chars361
    dq 38

Lstr_chars363:
    db "name", 0
    align 8
Lstr_struct364:
    dq Lstr_chars363
    dq 4

Lstr_chars365:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct366:
    dq Lstr_chars365
    dq 38

Lstr_chars367:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct368:
    dq Lstr_chars367
    dq 38

Lstr_chars369:
    db "version", 0
    align 8
Lstr_struct370:
    dq Lstr_chars369
    dq 7

Lstr_chars371:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct372:
    dq Lstr_chars371
    dq 38

Lstr_chars373:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct374:
    dq Lstr_chars373
    dq 37

Lstr_chars375:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct376:
    dq Lstr_chars375
    dq 37

Lstr_chars377:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct378:
    dq Lstr_chars377
    dq 37

Lstr_chars379:
    db "Error: package manifest missing name:", 0
    align 8
Lstr_struct380:
    dq Lstr_chars379
    dq 37

Lstr_chars381:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct382:
    dq Lstr_chars381
    dq 38

Lstr_chars383:
    db "Error: invalid package name in manifest:", 0
    align 8
Lstr_struct384:
    dq Lstr_chars383
    dq 40

Lstr_chars385:
    db "Error: package path not found:", 0
    align 8
Lstr_struct386:
    dq Lstr_chars385
    dq 30

Lstr_chars387:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct388:
    dq Lstr_chars387
    dq 38

Lstr_chars389:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct390:
    dq Lstr_chars389
    dq 38

Lstr_chars391:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct392:
    dq Lstr_chars391
    dq 38

Lstr_chars393:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct394:
    dq Lstr_chars393
    dq 38

Lstr_chars395:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct396:
    dq Lstr_chars395
    dq 38

Lstr_chars397:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct398:
    dq Lstr_chars397
    dq 38

Lstr_chars399:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct400:
    dq Lstr_chars399
    dq 38

Lstr_chars401:
    db "r", 0
    align 8
Lstr_struct402:
    dq Lstr_chars401
    dq 1

Lstr_chars403:
    db "Error: could not read package manifest:", 0
    align 8
Lstr_struct404:
    dq Lstr_chars403
    dq 39

Lstr_chars405:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct406:
    dq Lstr_chars405
    dq 38

Lstr_chars407:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct408:
    dq Lstr_chars407
    dq 38

Lstr_chars409:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct410:
    dq Lstr_chars409
    dq 38

Lstr_chars411:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct412:
    dq Lstr_chars411
    dq 38

Lstr_chars413:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct414:
    dq Lstr_chars413
    dq 38

Lstr_chars415:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct416:
    dq Lstr_chars415
    dq 38

Lstr_chars417:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct418:
    dq Lstr_chars417
    dq 38

Lstr_chars419:
    db "dep", 0
    align 8
Lstr_struct420:
    dq Lstr_chars419
    dq 3

Lstr_chars421:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct422:
    dq Lstr_chars421
    dq 38

Lstr_chars423:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct424:
    dq Lstr_chars423
    dq 38

Lstr_chars425:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct426:
    dq Lstr_chars425
    dq 38

Lstr_chars427:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct428:
    dq Lstr_chars427
    dq 38

Lstr_chars429:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct430:
    dq Lstr_chars429
    dq 38

Lstr_chars431:
    db "Error: dependency path too long in manifest:", 0
    align 8
Lstr_struct432:
    dq Lstr_chars431
    dq 44

Lstr_chars433:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct434:
    dq Lstr_chars433
    dq 38

Lstr_chars435:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct436:
    dq Lstr_chars435
    dq 38

Lstr_chars437:
    db 0
    align 8
Lstr_struct438:
    dq Lstr_chars437
    dq 0

Lstr_chars439:
    db "Error: while resolving transitive dependency from package:", 0
    align 8
Lstr_struct440:
    dq Lstr_chars439
    dq 58

Lstr_chars441:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct442:
    dq Lstr_chars441
    dq 38

Lstr_chars443:
    db "Error: invalid line in package manifest:", 0
    align 8
Lstr_struct444:
    dq Lstr_chars443
    dq 40

Lstr_chars445:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct446:
    dq Lstr_chars445
    dq 38

Lstr_chars447:
    db "r", 0
    align 8
Lstr_struct448:
    dq Lstr_chars447
    dq 1

Lstr_chars449:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct450:
    dq Lstr_chars449
    dq 38

Lstr_chars451:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct452:
    dq Lstr_chars451
    dq 38

Lstr_chars453:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct454:
    dq Lstr_chars453
    dq 38

Lstr_chars455:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct456:
    dq Lstr_chars455
    dq 38

Lstr_chars457:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct458:
    dq Lstr_chars457
    dq 38

Lstr_chars459:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct460:
    dq Lstr_chars459
    dq 38

Lstr_chars461:
    db "r", 0
    align 8
Lstr_struct462:
    dq Lstr_chars461
    dq 1

Lstr_chars463:
    db "Error: Could not read masm.deps", 0
    align 8
Lstr_struct464:
    dq Lstr_chars463
    dq 31

Lstr_chars465:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct466:
    dq Lstr_chars465
    dq 38

Lstr_chars467:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct468:
    dq Lstr_chars467
    dq 38

Lstr_chars469:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct470:
    dq Lstr_chars469
    dq 38

Lstr_chars471:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct472:
    dq Lstr_chars471
    dq 38

Lstr_chars473:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct474:
    dq Lstr_chars473
    dq 38

Lstr_chars475:
    db "Error: Invalid line in masm.deps", 0
    align 8
Lstr_struct476:
    dq Lstr_chars475
    dq 32

Lstr_chars477:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct478:
    dq Lstr_chars477
    dq 38

Lstr_chars479:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct480:
    dq Lstr_chars479
    dq 38

Lstr_chars481:
    db "w", 0
    align 8
Lstr_struct482:
    dq Lstr_chars481
    dq 1

Lstr_chars483:
    db "Error: Could not write masm.lock", 0
    align 8
Lstr_struct484:
    dq Lstr_chars483
    dq 32

Lstr_chars485:
    db "# masm-pkg lockfile (local-only)", 10, 0
    align 8
Lstr_struct486:
    dq Lstr_chars485
    dq 33

Lstr_chars487:
    db "# name=version|path", 10, 0
    align 8
Lstr_struct488:
    dq Lstr_chars487
    dq 20

Lstr_chars489:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct490:
    dq Lstr_chars489
    dq 38

Lstr_chars491:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct492:
    dq Lstr_chars491
    dq 38

Lstr_chars493:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct494:
    dq Lstr_chars493
    dq 38

Lstr_chars495:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct496:
    dq Lstr_chars495
    dq 38

Lstr_chars497:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct498:
    dq Lstr_chars497
    dq 38

Lstr_chars499:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct500:
    dq Lstr_chars499
    dq 38

Lstr_chars501:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct502:
    dq Lstr_chars501
    dq 38

Lstr_chars503:
    db "=", 0
    align 8
Lstr_struct504:
    dq Lstr_chars503
    dq 1

Lstr_chars505:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct506:
    dq Lstr_chars505
    dq 38

Lstr_chars507:
    db "|", 0
    align 8
Lstr_struct508:
    dq Lstr_chars507
    dq 1

Lstr_chars509:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct510:
    dq Lstr_chars509
    dq 38

Lstr_chars511:
    db 10, 0
    align 8
Lstr_struct512:
    dq Lstr_chars511
    dq 1

Lstr_chars513:
    db ".masm", 0
    align 8
Lstr_struct514:
    dq Lstr_chars513
    dq 5

Lstr_chars515:
    db "No dependencies in masm.deps", 0
    align 8
Lstr_struct516:
    dq Lstr_chars515
    dq 28

Lstr_chars517:
    db "Installing dependencies...", 0
    align 8
Lstr_struct518:
    dq Lstr_chars517
    dq 26

Lstr_chars519:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct520:
    dq Lstr_chars519
    dq 38

Lstr_chars521:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct522:
    dq Lstr_chars521
    dq 38

Lstr_chars523:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct524:
    dq Lstr_chars523
    dq 38

Lstr_chars525:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct526:
    dq Lstr_chars525
    dq 38

Lstr_chars527:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct528:
    dq Lstr_chars527
    dq 38

Lstr_chars529:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct530:
    dq Lstr_chars529
    dq 38

Lstr_chars531:
    db "Error: Path not found for package: ", 0
    align 8
Lstr_struct532:
    dq Lstr_chars531
    dq 35

Lstr_chars533:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct534:
    dq Lstr_chars533
    dq 38

Lstr_chars535:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct536:
    dq Lstr_chars535
    dq 38

Lstr_chars537:
    db "Error: Failed to copy package: ", 0
    align 8
Lstr_struct538:
    dq Lstr_chars537
    dq 31

Lstr_chars539:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct540:
    dq Lstr_chars539
    dq 38

Lstr_chars541:
    db "Done.", 0
    align 8
Lstr_struct542:
    dq Lstr_chars541
    dq 5

Lstr_chars543:
    db "No dependencies", 0
    align 8
Lstr_struct544:
    dq Lstr_chars543
    dq 15

Lstr_chars545:
    db ".masm/packages/", 0
    align 8
Lstr_struct546:
    dq Lstr_chars545
    dq 15

Lstr_chars547:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct548:
    dq Lstr_chars547
    dq 38

Lstr_chars549:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct550:
    dq Lstr_chars549
    dq 38

Lstr_chars551:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct552:
    dq Lstr_chars551
    dq 38

Lstr_chars553:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct554:
    dq Lstr_chars553
    dq 38

Lstr_chars555:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct556:
    dq Lstr_chars555
    dq 38

Lstr_chars557:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct558:
    dq Lstr_chars557
    dq 38

Lstr_chars559:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct560:
    dq Lstr_chars559
    dq 38

Lstr_chars561:
    db "@", 0
    align 8
Lstr_struct562:
    dq Lstr_chars561
    dq 1

Lstr_chars563:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct564:
    dq Lstr_chars563
    dq 38

Lstr_chars565:
    db "  ", 0
    align 8
Lstr_struct566:
    dq Lstr_chars565
    dq 2

Lstr_chars567:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct568:
    dq Lstr_chars567
    dq 38

Lstr_chars569:
    db "  ", 0
    align 8
Lstr_struct570:
    dq Lstr_chars569
    dq 2

Lstr_chars571:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct572:
    dq Lstr_chars571
    dq 38

Lstr_chars573:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct574:
    dq Lstr_chars573
    dq 38

Lstr_chars575:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct576:
    dq Lstr_chars575
    dq 38

Lstr_chars577:
    db "[installed]", 0
    align 8
Lstr_struct578:
    dq Lstr_chars577
    dq 11

Lstr_chars579:
    db "[not installed]", 0
    align 8
Lstr_struct580:
    dq Lstr_chars579
    dq 15

Lstr_chars581:
    db "Usage: masm-pkg add <name> <path>", 0
    align 8
Lstr_struct582:
    dq Lstr_chars581
    dq 33

Lstr_chars583:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct584:
    dq Lstr_chars583
    dq 37

Lstr_chars585:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct586:
    dq Lstr_chars585
    dq 37

Lstr_chars587:
    db "Error: Invalid package name. Use [A-Za-z0-9_-].", 0
    align 8
Lstr_struct588:
    dq Lstr_chars587
    dq 47

Lstr_chars589:
    db "Error: Package path does not exist or is not a directory.", 0
    align 8
Lstr_struct590:
    dq Lstr_chars589
    dq 57

Lstr_chars591:
    db "Error: Package already exists in masm.deps: ", 0
    align 8
Lstr_struct592:
    dq Lstr_chars591
    dq 44

Lstr_chars593:
    db "a", 0
    align 8
Lstr_struct594:
    dq Lstr_chars593
    dq 1

Lstr_chars595:
    db "w", 0
    align 8
Lstr_struct596:
    dq Lstr_chars595
    dq 1

Lstr_chars597:
    db "Error: Could not create masm.deps", 0
    align 8
Lstr_struct598:
    dq Lstr_chars597
    dq 33

Lstr_chars599:
    db "=", 0
    align 8
Lstr_struct600:
    dq Lstr_chars599
    dq 1

Lstr_chars601:
    db 10, 0
    align 8
Lstr_struct602:
    dq Lstr_chars601
    dq 1

Lstr_chars603:
    db "Added ", 0
    align 8
Lstr_struct604:
    dq Lstr_chars603
    dq 6

Lstr_chars605:
    db "Usage: masm-pkg remove <name>", 0
    align 8
Lstr_struct606:
    dq Lstr_chars605
    dq 29

Lstr_chars607:
    db "Error: masm.deps not found", 0
    align 8
Lstr_struct608:
    dq Lstr_chars607
    dq 26

Lstr_chars609:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct610:
    dq Lstr_chars609
    dq 37

Lstr_chars611:
    db "r", 0
    align 8
Lstr_struct612:
    dq Lstr_chars611
    dq 1

Lstr_chars613:
    db "Error: Could not read masm.deps", 0
    align 8
Lstr_struct614:
    dq Lstr_chars613
    dq 31

Lstr_chars615:
    db "masm.deps.tmp", 0
    align 8
Lstr_struct616:
    dq Lstr_chars615
    dq 13

Lstr_chars617:
    db "w", 0
    align 8
Lstr_struct618:
    dq Lstr_chars617
    dq 1

Lstr_chars619:
    db "Error: Could not write temporary deps file", 0
    align 8
Lstr_struct620:
    dq Lstr_chars619
    dq 42

Lstr_chars621:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct622:
    dq Lstr_chars621
    dq 38

Lstr_chars623:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct624:
    dq Lstr_chars623
    dq 38

Lstr_chars625:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct626:
    dq Lstr_chars625
    dq 38

Lstr_chars627:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct628:
    dq Lstr_chars627
    dq 38

Lstr_chars629:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct630:
    dq Lstr_chars629
    dq 38

Lstr_chars631:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct632:
    dq Lstr_chars631
    dq 38

Lstr_chars633:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct634:
    dq Lstr_chars633
    dq 38

Lstr_chars635:
    db "=", 0
    align 8
Lstr_struct636:
    dq Lstr_chars635
    dq 1

Lstr_chars637:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct638:
    dq Lstr_chars637
    dq 38

Lstr_chars639:
    db 10, 0
    align 8
Lstr_struct640:
    dq Lstr_chars639
    dq 1

Lstr_chars641:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct642:
    dq Lstr_chars641
    dq 38

Lstr_chars643:
    db "masm.deps.tmp", 0
    align 8
Lstr_struct644:
    dq Lstr_chars643
    dq 13

Lstr_chars645:
    db "Error: Package not found: ", 0
    align 8
Lstr_struct646:
    dq Lstr_chars645
    dq 26

Lstr_chars647:
    db "masm.deps.tmp", 0
    align 8
Lstr_struct648:
    dq Lstr_chars647
    dq 13

Lstr_chars649:
    db "Error: Could not replace masm.deps", 0
    align 8
Lstr_struct650:
    dq Lstr_chars649
    dq 34

Lstr_chars651:
    db "Removed ", 0
    align 8
Lstr_struct652:
    dq Lstr_chars651
    dq 8

Lstr_chars653:
    db "main.masm", 0
    align 8
Lstr_struct654:
    dq Lstr_chars653
    dq 9

Lstr_chars655:
    db "Error: main.masm not found. Run from project root.", 0
    align 8
Lstr_struct656:
    dq Lstr_chars655
    dq 50

Lstr_chars657:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct658:
    dq Lstr_chars657
    dq 38

Lstr_chars659:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct660:
    dq Lstr_chars659
    dq 38

Lstr_chars661:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct662:
    dq Lstr_chars661
    dq 38

Lstr_chars663:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct664:
    dq Lstr_chars663
    dq 38

Lstr_chars665:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct666:
    dq Lstr_chars665
    dq 38

Lstr_chars667:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct668:
    dq Lstr_chars667
    dq 38

Lstr_chars669:
    db "Error: failed to install dependency before build:", 0
    align 8
Lstr_struct670:
    dq Lstr_chars669
    dq 49

Lstr_chars671:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct672:
    dq Lstr_chars671
    dq 38

Lstr_chars673:
    db "methasm", 0
    align 8
Lstr_struct674:
    dq Lstr_chars673
    dq 7

Lstr_chars675:
    db "bin", 92, "methasm.exe", 0
    align 8
Lstr_struct676:
    dq Lstr_chars675
    dq 15

Lstr_chars677:
    db "bin", 92, "methasm.exe", 0
    align 8
Lstr_struct678:
    dq Lstr_chars677
    dq 15

Lstr_chars679:
    db "..", 92, "bin", 92, "methasm.exe", 0
    align 8
Lstr_struct680:
    dq Lstr_chars679
    dq 18

Lstr_chars681:
    db "..", 92, "..", 92, "bin", 92, "methasm.exe", 0
    align 8
Lstr_struct682:
    dq Lstr_chars681
    dq 21

Lstr_chars683:
    db "stdlib", 0
    align 8
Lstr_struct684:
    dq Lstr_chars683
    dq 6

Lstr_chars685:
    db "stdlib", 92, "std", 92, "io.masm", 0
    align 8
Lstr_struct686:
    dq Lstr_chars685
    dq 18

Lstr_chars687:
    db "..", 92, "stdlib", 92, "std", 92, "io.masm", 0
    align 8
Lstr_struct688:
    dq Lstr_chars687
    dq 21

Lstr_chars689:
    db "..", 92, "stdlib", 0
    align 8
Lstr_struct690:
    dq Lstr_chars689
    dq 9

Lstr_chars691:
    db "..", 92, "..", 92, "stdlib", 92, "std", 92, "io.masm", 0
    align 8
Lstr_struct692:
    dq Lstr_chars691
    dq 24

Lstr_chars693:
    db "..", 92, "..", 92, "stdlib", 0
    align 8
Lstr_struct694:
    dq Lstr_chars693
    dq 12

Lstr_chars695:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct696:
    dq Lstr_chars695
    dq 37

Lstr_chars697:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct698:
    dq Lstr_chars697
    dq 37

Lstr_chars699:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct700:
    dq Lstr_chars699
    dq 38

Lstr_chars701:
    db " ", 34, "main.masm", 34, " -o ", 34, "main.s", 34, " --stdlib ", 34, 0
    align 8
Lstr_struct702:
    dq Lstr_chars701
    dq 35

Lstr_chars703:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct704:
    dq Lstr_chars703
    dq 37

Lstr_chars705:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct706:
    dq Lstr_chars705
    dq 37

Lstr_chars707:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct708:
    dq Lstr_chars707
    dq 38

Lstr_chars709:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct710:
    dq Lstr_chars709
    dq 37

Lstr_chars711:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct712:
    dq Lstr_chars711
    dq 37

Lstr_chars713:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct714:
    dq Lstr_chars713
    dq 38

Lstr_chars715:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct716:
    dq Lstr_chars715
    dq 38

Lstr_chars717:
    db " -I ", 34, ".masm", 92, "packages", 34, 0
    align 8
Lstr_struct718:
    dq Lstr_chars717
    dq 20

Lstr_chars719:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct720:
    dq Lstr_chars719
    dq 37

Lstr_chars721:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct722:
    dq Lstr_chars721
    dq 37

Lstr_chars723:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct724:
    dq Lstr_chars723
    dq 38

Lstr_chars725:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct726:
    dq Lstr_chars725
    dq 38

Lstr_chars727:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct728:
    dq Lstr_chars727
    dq 38

Lstr_chars729:
    db "Error: methasm compilation failed", 0
    align 8
Lstr_struct730:
    dq Lstr_chars729
    dq 33

Lstr_chars731:
    db "nasm -f win64 ", 34, "main.s", 34, " -o ", 34, "main.o", 34, 0
    align 8
Lstr_struct732:
    dq Lstr_chars731
    dq 34

Lstr_chars733:
    db "Error: nasm assembly failed", 0
    align 8
Lstr_struct734:
    dq Lstr_chars733
    dq 27

Lstr_chars735:
    db "src", 92, "runtime", 92, "gc.c", 0
    align 8
Lstr_struct736:
    dq Lstr_chars735
    dq 16

Lstr_chars737:
    db "..", 92, "src", 92, "runtime", 92, "gc.c", 0
    align 8
Lstr_struct738:
    dq Lstr_chars737
    dq 19

Lstr_chars739:
    db "..", 92, "src", 92, "runtime", 92, "gc.c", 0
    align 8
Lstr_struct740:
    dq Lstr_chars739
    dq 19

Lstr_chars741:
    db "..", 92, "..", 92, "src", 92, "runtime", 92, "gc.c", 0
    align 8
Lstr_struct742:
    dq Lstr_chars741
    dq 22

Lstr_chars743:
    db "..", 92, "..", 92, "src", 92, "runtime", 92, "gc.c", 0
    align 8
Lstr_struct744:
    dq Lstr_chars743
    dq 22

Lstr_chars745:
    db "Error: gc runtime not found. Expected src/runtime/gc.c", 0
    align 8
Lstr_struct746:
    dq Lstr_chars745
    dq 54

Lstr_chars747:
    db "src", 92, "runtime", 92, "masm_entry.c", 0
    align 8
Lstr_struct748:
    dq Lstr_chars747
    dq 24

Lstr_chars749:
    db "..", 92, "src", 92, "runtime", 92, "masm_entry.c", 0
    align 8
Lstr_struct750:
    dq Lstr_chars749
    dq 27

Lstr_chars751:
    db "..", 92, "src", 92, "runtime", 92, "masm_entry.c", 0
    align 8
Lstr_struct752:
    dq Lstr_chars751
    dq 27

Lstr_chars753:
    db "..", 92, "..", 92, "src", 92, "runtime", 92, "masm_entry.c", 0
    align 8
Lstr_struct754:
    dq Lstr_chars753
    dq 30

Lstr_chars755:
    db "..", 92, "..", 92, "src", 92, "runtime", 92, "masm_entry.c", 0
    align 8
Lstr_struct756:
    dq Lstr_chars755
    dq 30

Lstr_chars757:
    db "Error: masm_entry runtime not found. Expected src/runtime/masm_entry.c", 0
    align 8
Lstr_struct758:
    dq Lstr_chars757
    dq 70

Lstr_chars759:
    db "gcc -nostartfiles ", 34, "main.o", 34, " ", 34, 0
    align 8
Lstr_struct760:
    dq Lstr_chars759
    dq 28

Lstr_chars761:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct762:
    dq Lstr_chars761
    dq 37

Lstr_chars763:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct764:
    dq Lstr_chars763
    dq 37

Lstr_chars765:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct766:
    dq Lstr_chars765
    dq 38

Lstr_chars767:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct768:
    dq Lstr_chars767
    dq 37

Lstr_chars769:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct770:
    dq Lstr_chars769
    dq 37

Lstr_chars771:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct772:
    dq Lstr_chars771
    dq 38

Lstr_chars773:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct774:
    dq Lstr_chars773
    dq 38

Lstr_chars775:
    db " ", 34, 0
    align 8
Lstr_struct776:
    dq Lstr_chars775
    dq 2

Lstr_chars777:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct778:
    dq Lstr_chars777
    dq 37

Lstr_chars779:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct780:
    dq Lstr_chars779
    dq 37

Lstr_chars781:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct782:
    dq Lstr_chars781
    dq 38

Lstr_chars783:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct784:
    dq Lstr_chars783
    dq 37

Lstr_chars785:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct786:
    dq Lstr_chars785
    dq 37

Lstr_chars787:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct788:
    dq Lstr_chars787
    dq 38

Lstr_chars789:
    db 34, " -o ", 34, "main.exe", 34, " -lkernel32 -lshell32", 0
    align 8
Lstr_struct790:
    dq Lstr_chars789
    dq 36

Lstr_chars791:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct792:
    dq Lstr_chars791
    dq 37

Lstr_chars793:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct794:
    dq Lstr_chars793
    dq 37

Lstr_chars795:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct796:
    dq Lstr_chars795
    dq 38

Lstr_chars797:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct798:
    dq Lstr_chars797
    dq 38

Lstr_chars799:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct800:
    dq Lstr_chars799
    dq 38

Lstr_chars801:
    db "Error: gcc link failed", 0
    align 8
Lstr_struct802:
    dq Lstr_chars801
    dq 22

Lstr_chars803:
    db "Build complete: main.exe", 0
    align 8
Lstr_struct804:
    dq Lstr_chars803
    dq 24

Lstr_chars805:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct806:
    dq Lstr_chars805
    dq 37

Lstr_chars807:
    db "install", 0
    align 8
Lstr_struct808:
    dq Lstr_chars807
    dq 7

Lstr_chars809:
    db "add", 0
    align 8
Lstr_struct810:
    dq Lstr_chars809
    dq 3

Lstr_chars811:
    db "remove", 0
    align 8
Lstr_struct812:
    dq Lstr_chars811
    dq 6

Lstr_chars813:
    db "build", 0
    align 8
Lstr_struct814:
    dq Lstr_chars813
    dq 5

Lstr_chars815:
    db "list", 0
    align 8
Lstr_struct816:
    dq Lstr_chars815
    dq 4

