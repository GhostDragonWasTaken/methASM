; Generated by MethASM
; x86-64 Assembly Output

section .text
; Code section

; First pass: processing 44 declarations
; Declaration 0 type: 4 (AST_INLINE_ASM = 21)
; Declaration 1 type: 4 (AST_INLINE_ASM = 21)
; Declaration 2 type: 4 (AST_INLINE_ASM = 21)
; Declaration 3 type: 4 (AST_INLINE_ASM = 21)
; Declaration 4 type: 4 (AST_INLINE_ASM = 21)
; Declaration 5 type: 4 (AST_INLINE_ASM = 21)
; Declaration 6 type: 4 (AST_INLINE_ASM = 21)
; Declaration 7 type: 4 (AST_INLINE_ASM = 21)
; Declaration 8 type: 4 (AST_INLINE_ASM = 21)
; Declaration 9 type: 4 (AST_INLINE_ASM = 21)
; Declaration 10 type: 4 (AST_INLINE_ASM = 21)
; Declaration 11 type: 4 (AST_INLINE_ASM = 21)
; Declaration 12 type: 4 (AST_INLINE_ASM = 21)
; Declaration 13 type: 4 (AST_INLINE_ASM = 21)
; Declaration 14 type: 4 (AST_INLINE_ASM = 21)
; Declaration 15 type: 4 (AST_INLINE_ASM = 21)
; Declaration 16 type: 4 (AST_INLINE_ASM = 21)
; Declaration 17 type: 4 (AST_INLINE_ASM = 21)
; Declaration 18 type: 4 (AST_INLINE_ASM = 21)
; Declaration 19 type: 4 (AST_INLINE_ASM = 21)
; Declaration 20 type: 4 (AST_INLINE_ASM = 21)
; Declaration 21 type: 4 (AST_INLINE_ASM = 21)
; Declaration 22 type: 4 (AST_INLINE_ASM = 21)
; Declaration 23 type: 4 (AST_INLINE_ASM = 21)
; Declaration 24 type: 4 (AST_INLINE_ASM = 21)
; Declaration 25 type: 4 (AST_INLINE_ASM = 21)
; Declaration 26 type: 4 (AST_INLINE_ASM = 21)
; Declaration 27 type: 4 (AST_INLINE_ASM = 21)
; Declaration 28 type: 4 (AST_INLINE_ASM = 21)
; Declaration 29 type: 4 (AST_INLINE_ASM = 21)
; Declaration 30 type: 4 (AST_INLINE_ASM = 21)
; Declaration 31 type: 4 (AST_INLINE_ASM = 21)
; Declaration 32 type: 4 (AST_INLINE_ASM = 21)
; Declaration 33 type: 4 (AST_INLINE_ASM = 21)
; Declaration 34 type: 4 (AST_INLINE_ASM = 21)
; Declaration 35 type: 4 (AST_INLINE_ASM = 21)
; Declaration 36 type: 4 (AST_INLINE_ASM = 21)
; Declaration 37 type: 3 (AST_INLINE_ASM = 21)
; Declaration 38 type: 5 (AST_INLINE_ASM = 21)
; Declaration 39 type: 4 (AST_INLINE_ASM = 21)
; Declaration 40 type: 4 (AST_INLINE_ASM = 21)
; Declaration 41 type: 4 (AST_INLINE_ASM = 21)
; Declaration 42 type: 4 (AST_INLINE_ASM = 21)
; Declaration 43 type: 4 (AST_INLINE_ASM = 21)

section .text
    extern puts
    extern putchar
    extern getchar

global cstr

cstr:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 80    ; Allocate 80 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 's'
    ; Parameter 's' arrived in register rcx
ir_entry_0:
    ; Load variable: s
    mov rax, qword [rbp - 8]  ; String param ptr
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    mov rax, qword [rax]
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_1
    jmp ir_errdefer_end_2
ir_errdefer_ok_1:
ir_errdefer_end_2:
    mov rax, [rbp - 24]
    jmp Lcstr_exit
Lcstr_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global print

print:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 272    ; Allocate 272 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'msg'
    ; Parameter 'msg' arrived in register rcx
ir_entry_3:
    mov rax, 0
    ; Store to variable: i
    mov qword [rbp - 16], rax  ; To stack [rbp - 16]
ir_while_4:
    ; Load variable: msg
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_6
    jmp ir_nonnull_7
ir_trap_null_6:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct2]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    extern exit
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_7:
    ; Load variable: i
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 24], rax
    ; Load variable: msg
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 24]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    movzx rax, byte [rax]
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_while_end_5
    ; Load variable: msg
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_8
    jmp ir_nonnull_9
ir_trap_null_8:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct4]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_9:
    ; Load variable: i
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 56], rax
    ; Load variable: msg
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 56]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    movzx rax, byte [rax]
    mov [rbp - 72], rax
    ; IR call: putchar (1 args)
    sub rsp, 32
    mov rax, [rbp - 72]
    mov rcx, rax
    call putchar
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 80], rax
    ; Load variable: i
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    ; Store to variable: i
    mov qword [rbp - 16], rax  ; To stack [rbp - 16]
    jmp ir_while_4
ir_while_end_5:
    mov rax, 0
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    test rax, rax
    jz ir_errdefer_ok_10
    jmp ir_errdefer_end_11
ir_errdefer_ok_10:
ir_errdefer_end_11:
    jmp Lprint_exit
Lprint_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global println

println:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 64    ; Allocate 64 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'msg'
    ; Parameter 'msg' arrived in register rcx
ir_entry_12:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; Load variable: msg
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 16], rax
    mov rax, 0
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_errdefer_ok_13
    jmp ir_errdefer_end_14
ir_errdefer_ok_13:
ir_errdefer_end_14:
    jmp Lprintln_exit
Lprintln_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global newline

newline:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 48    ; Allocate 48 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_15:
    ; IR call: putchar (1 args)
    sub rsp, 32
    mov rax, 10
    mov rcx, rax
    call putchar
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 8], rax
    mov rax, 0
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_errdefer_ok_16
    jmp ir_errdefer_end_17
ir_errdefer_ok_16:
ir_errdefer_end_17:
    jmp Lnewline_exit
Lnewline_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global print_int

print_int:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 752    ; Allocate 752 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'n'
    ; Parameter 'n' arrived in register rcx
ir_entry_18:
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 104], rax
    mov rax, [rbp - 104]
    test rax, rax
    jz ir_if_next_20
    ; IR call: putchar (1 args)
    sub rsp, 32
    mov rax, 45
    mov rcx, rax
    call putchar
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 112], rax
    mov rax, 0
    push rax
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 120], rax
    mov rax, [rbp - 120]
    ; Store to variable: n
    mov qword [rbp - 8], rax  ; To stack [rbp - 8]
    jmp ir_if_end_19
ir_if_next_20:
ir_if_end_19:
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 128], rax
    mov rax, [rbp - 128]
    test rax, rax
    jz ir_if_next_22
    ; IR call: putchar (1 args)
    sub rsp, 32
    mov rax, 48
    mov rcx, rax
    call putchar
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 136], rax
    mov rax, 0
    mov [rbp - 144], rax
    mov rax, [rbp - 144]
    test rax, rax
    jz ir_errdefer_ok_23
    jmp ir_errdefer_end_24
ir_errdefer_ok_23:
ir_errdefer_end_24:
    jmp Lprint_int_exit
    jmp ir_if_end_21
ir_if_next_22:
ir_if_end_21:
    mov rax, 0
    ; Store to variable: len
    mov dword [rbp - 92], eax  ; To stack [rbp - 92]
ir_while_25:
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setg al
    movzx rax, al
    mov [rbp - 152], rax
    mov rax, [rbp - 152]
    test rax, rax
    jz ir_while_end_26
    mov rax, 48
    push rax
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 160], rax
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 10
    mov r10, rax
    pop rax
    cqo
    idiv r10
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    push rax
    mov rax, 10
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 176], rax
    mov rax, [rbp - 160]
    push rax
    mov rax, [rbp - 176]
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 184], rax
    ; Load variable: len
    movsxd rax, dword [rbp - 92]  ; From stack [rbp - 92]
    push rax
    mov rax, 20
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 192], rax
    mov rax, [rbp - 192]
    test rax, rax
    jz ir_trap_bounds_27
    jmp ir_in_bounds_28
ir_trap_bounds_27:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct6]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_28:
    ; Load variable: len
    movsxd rax, dword [rbp - 92]  ; From stack [rbp - 92]
    push rax
    mov rax, 4
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 200], rax
    ; Load variable: buf
    lea rax, [rbp - 88]  ; Local array base
    push rax
    mov rax, [rbp - 200]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 208], rax
    mov rax, [rbp - 208]
    push rax
    mov rax, [rbp - 184]
    mov rcx, rax
    pop rax
    mov dword [rax], ecx
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 10
    mov r10, rax
    pop rax
    cqo
    idiv r10
    mov [rbp - 224], rax
    mov rax, [rbp - 224]
    ; Store to variable: n
    mov qword [rbp - 8], rax  ; To stack [rbp - 8]
    ; Load variable: len
    movsxd rax, dword [rbp - 92]  ; From stack [rbp - 92]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 232], rax
    mov rax, [rbp - 232]
    ; Store to variable: len
    mov dword [rbp - 92], eax  ; To stack [rbp - 92]
    jmp ir_while_25
ir_while_end_26:
    ; Load variable: len
    movsxd rax, dword [rbp - 92]  ; From stack [rbp - 92]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 240], rax
    mov rax, [rbp - 240]
    ; Store to variable: i
    mov dword [rbp - 96], eax  ; To stack [rbp - 96]
ir_while_29:
    ; Load variable: i
    movsxd rax, dword [rbp - 96]  ; From stack [rbp - 96]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 248], rax
    mov rax, [rbp - 248]
    test rax, rax
    jz ir_while_end_30
    ; Load variable: i
    movsxd rax, dword [rbp - 96]  ; From stack [rbp - 96]
    push rax
    mov rax, 20
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 256], rax
    mov rax, [rbp - 256]
    test rax, rax
    jz ir_trap_bounds_31
    jmp ir_in_bounds_32
ir_trap_bounds_31:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct8]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_32:
    ; Load variable: i
    movsxd rax, dword [rbp - 96]  ; From stack [rbp - 96]
    push rax
    mov rax, 4
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 264], rax
    ; Load variable: buf
    lea rax, [rbp - 88]  ; Local array base
    push rax
    mov rax, [rbp - 264]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 272], rax
    mov rax, [rbp - 272]
    mov eax, dword [rax]
    mov [rbp - 280], rax
    ; IR call: putchar (1 args)
    sub rsp, 32
    mov rax, [rbp - 280]
    mov rcx, rax
    call putchar
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 288], rax
    ; Load variable: i
    movsxd rax, dword [rbp - 96]  ; From stack [rbp - 96]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 296], rax
    mov rax, [rbp - 296]
    ; Store to variable: i
    mov dword [rbp - 96], eax  ; To stack [rbp - 96]
    jmp ir_while_29
ir_while_end_30:
    mov rax, 0
    mov [rbp - 304], rax
    mov rax, [rbp - 304]
    test rax, rax
    jz ir_errdefer_ok_33
    jmp ir_errdefer_end_34
ir_errdefer_ok_33:
ir_errdefer_end_34:
    jmp Lprint_int_exit
Lprint_int_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global println_int

println_int:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 80    ; Allocate 80 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'n'
    ; Parameter 'n' arrived in register rcx
ir_entry_35:
    ; IR call: print_int (1 args)
    sub rsp, 32
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call print_int
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 16], rax
    ; IR call: putchar (1 args)
    sub rsp, 32
    mov rax, 10
    mov rcx, rax
    call putchar
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 24], rax
    mov rax, 0
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_36
    jmp ir_errdefer_end_37
ir_errdefer_ok_36:
ir_errdefer_end_37:
    jmp Lprintln_int_exit
Lprintln_int_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller
    extern fopen
    extern fclose
    extern fread
    extern fwrite
    extern fputs
    extern fgets
    extern fflush
    extern __acrt_iob_func

global get_stdin

get_stdin:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 48    ; Allocate 48 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_38:
    ; IR call: __acrt_iob_func (1 args)
    sub rsp, 32
    mov rax, 0
    mov rcx, rax
    call __acrt_iob_func
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 8], rax
    mov rax, [rbp - 8]
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_errdefer_ok_39
    jmp ir_errdefer_end_40
ir_errdefer_ok_39:
ir_errdefer_end_40:
    mov rax, [rbp - 8]
    jmp Lget_stdin_exit
Lget_stdin_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global get_stdout

get_stdout:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 48    ; Allocate 48 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_41:
    ; IR call: __acrt_iob_func (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call __acrt_iob_func
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 8], rax
    mov rax, [rbp - 8]
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_errdefer_ok_42
    jmp ir_errdefer_end_43
ir_errdefer_ok_42:
ir_errdefer_end_43:
    mov rax, [rbp - 8]
    jmp Lget_stdout_exit
Lget_stdout_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global get_stderr

get_stderr:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 48    ; Allocate 48 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_44:
    ; IR call: __acrt_iob_func (1 args)
    sub rsp, 32
    mov rax, 2
    mov rcx, rax
    call __acrt_iob_func
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 8], rax
    mov rax, [rbp - 8]
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_errdefer_ok_45
    jmp ir_errdefer_end_46
ir_errdefer_ok_45:
ir_errdefer_end_46:
    mov rax, [rbp - 8]
    jmp Lget_stderr_exit
Lget_stderr_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global print_err

print_err:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 80    ; Allocate 80 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'msg'
    ; Parameter 'msg' arrived in register rcx
ir_entry_47:
    ; IR call: get_stderr (0 args)
    sub rsp, 32
    call get_stderr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 16], rax
    ; IR call: fputs (2 args)
    sub rsp, 32
    ; Load variable: msg
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    mov rax, [rbp - 16]
    mov rdx, rax
    call fputs
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 24], rax
    mov rax, 0
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_48
    jmp ir_errdefer_end_49
ir_errdefer_ok_48:
ir_errdefer_end_49:
    jmp Lprint_err_exit
Lprint_err_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global println_err

println_err:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 160    ; Allocate 160 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'msg'
    ; Parameter 'msg' arrived in register rcx
ir_entry_50:
    ; IR call: get_stderr (0 args)
    sub rsp, 32
    call get_stderr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 16], rax
    ; IR call: fputs (2 args)
    sub rsp, 32
    ; Load variable: msg
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    mov rax, [rbp - 16]
    mov rdx, rax
    call fputs
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 24], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (1 bytes)
    lea rax, [rel Lstr_struct10]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 32], rax
    ; IR call: get_stderr (0 args)
    sub rsp, 32
    call get_stderr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 40], rax
    ; IR call: fputs (2 args)
    sub rsp, 32
    mov rax, [rbp - 32]
    mov rcx, rax
    mov rax, [rbp - 40]
    mov rdx, rax
    call fputs
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 48], rax
    mov rax, 0
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    test rax, rax
    jz ir_errdefer_ok_51
    jmp ir_errdefer_end_52
ir_errdefer_ok_51:
ir_errdefer_end_52:
    jmp Lprintln_err_exit
Lprintln_err_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller
    extern atoi
    extern atol

global digit_to_char

digit_to_char:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 64    ; Allocate 64 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'd'
    ; Parameter 'd' arrived in register rcx
ir_entry_53:
    ; Load variable: d
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 48
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_errdefer_ok_54
    jmp ir_errdefer_end_55
ir_errdefer_ok_54:
ir_errdefer_end_55:
    mov rax, [rbp - 16]
    jmp Ldigit_to_char_exit
Ldigit_to_char_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global char_to_digit

char_to_digit:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 64    ; Allocate 64 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_56:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 48
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_errdefer_ok_57
    jmp ir_errdefer_end_58
ir_errdefer_ok_57:
ir_errdefer_end_58:
    mov rax, [rbp - 16]
    jmp Lchar_to_digit_exit
Lchar_to_digit_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global is_digit

is_digit:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 112    ; Allocate 112 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_59:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 48
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_if_next_61
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 57
    mov r10, rax
    pop rax
    cmp rax, r10
    setle al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_next_63
    mov rax, 1
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_64
    jmp ir_errdefer_end_65
ir_errdefer_ok_64:
ir_errdefer_end_65:
    mov rax, 1
    jmp Lis_digit_exit
    jmp ir_if_end_62
ir_if_next_63:
ir_if_end_62:
    jmp ir_if_end_60
ir_if_next_61:
ir_if_end_60:
    mov rax, 0
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_errdefer_ok_66
    jmp ir_errdefer_end_67
ir_errdefer_ok_66:
ir_errdefer_end_67:
    mov rax, 0
    jmp Lis_digit_exit
Lis_digit_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global is_upper

is_upper:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 112    ; Allocate 112 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_68:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 65
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_if_next_70
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 90
    mov r10, rax
    pop rax
    cmp rax, r10
    setle al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_next_72
    mov rax, 1
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_73
    jmp ir_errdefer_end_74
ir_errdefer_ok_73:
ir_errdefer_end_74:
    mov rax, 1
    jmp Lis_upper_exit
    jmp ir_if_end_71
ir_if_next_72:
ir_if_end_71:
    jmp ir_if_end_69
ir_if_next_70:
ir_if_end_69:
    mov rax, 0
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_errdefer_ok_75
    jmp ir_errdefer_end_76
ir_errdefer_ok_75:
ir_errdefer_end_76:
    mov rax, 0
    jmp Lis_upper_exit
Lis_upper_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global is_lower

is_lower:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 112    ; Allocate 112 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_77:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 97
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_if_next_79
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 122
    mov r10, rax
    pop rax
    cmp rax, r10
    setle al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_next_81
    mov rax, 1
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_82
    jmp ir_errdefer_end_83
ir_errdefer_ok_82:
ir_errdefer_end_83:
    mov rax, 1
    jmp Lis_lower_exit
    jmp ir_if_end_80
ir_if_next_81:
ir_if_end_80:
    jmp ir_if_end_78
ir_if_next_79:
ir_if_end_78:
    mov rax, 0
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_errdefer_ok_84
    jmp ir_errdefer_end_85
ir_errdefer_ok_84:
ir_errdefer_end_85:
    mov rax, 0
    jmp Lis_lower_exit
Lis_lower_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global is_alpha

is_alpha:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 176    ; Allocate 176 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_86:
    ; IR call: is_upper (1 args)
    sub rsp, 32
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call is_upper
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_next_88
    mov rax, 1
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_89
    jmp ir_errdefer_end_90
ir_errdefer_ok_89:
ir_errdefer_end_90:
    mov rax, 1
    jmp Lis_alpha_exit
    jmp ir_if_end_87
ir_if_next_88:
ir_if_end_87:
    ; IR call: is_lower (1 args)
    sub rsp, 32
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call is_lower
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_if_next_92
    mov rax, 1
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    test rax, rax
    jz ir_errdefer_ok_93
    jmp ir_errdefer_end_94
ir_errdefer_ok_93:
ir_errdefer_end_94:
    mov rax, 1
    jmp Lis_alpha_exit
    jmp ir_if_end_91
ir_if_next_92:
ir_if_end_91:
    mov rax, 0
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    test rax, rax
    jz ir_errdefer_ok_95
    jmp ir_errdefer_end_96
ir_errdefer_ok_95:
ir_errdefer_end_96:
    mov rax, 0
    jmp Lis_alpha_exit
Lis_alpha_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global is_alnum

is_alnum:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 176    ; Allocate 176 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_97:
    ; IR call: is_alpha (1 args)
    sub rsp, 32
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call is_alpha
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_next_99
    mov rax, 1
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_100
    jmp ir_errdefer_end_101
ir_errdefer_ok_100:
ir_errdefer_end_101:
    mov rax, 1
    jmp Lis_alnum_exit
    jmp ir_if_end_98
ir_if_next_99:
ir_if_end_98:
    ; IR call: is_digit (1 args)
    sub rsp, 32
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call is_digit
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_if_next_103
    mov rax, 1
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    test rax, rax
    jz ir_errdefer_ok_104
    jmp ir_errdefer_end_105
ir_errdefer_ok_104:
ir_errdefer_end_105:
    mov rax, 1
    jmp Lis_alnum_exit
    jmp ir_if_end_102
ir_if_next_103:
ir_if_end_102:
    mov rax, 0
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    test rax, rax
    jz ir_errdefer_ok_106
    jmp ir_errdefer_end_107
ir_errdefer_ok_106:
ir_errdefer_end_107:
    mov rax, 0
    jmp Lis_alnum_exit
Lis_alnum_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global is_space

is_space:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 320    ; Allocate 320 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_108:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 32
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_if_next_110
    mov rax, 1
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_errdefer_ok_111
    jmp ir_errdefer_end_112
ir_errdefer_ok_111:
ir_errdefer_end_112:
    mov rax, 1
    jmp Lis_space_exit
    jmp ir_if_end_109
ir_if_next_110:
ir_if_end_109:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 9
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_if_next_114
    mov rax, 1
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_errdefer_ok_115
    jmp ir_errdefer_end_116
ir_errdefer_ok_115:
ir_errdefer_end_116:
    mov rax, 1
    jmp Lis_space_exit
    jmp ir_if_end_113
ir_if_next_114:
ir_if_end_113:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 10
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_if_next_118
    mov rax, 1
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    test rax, rax
    jz ir_errdefer_ok_119
    jmp ir_errdefer_end_120
ir_errdefer_ok_119:
ir_errdefer_end_120:
    mov rax, 1
    jmp Lis_space_exit
    jmp ir_if_end_117
ir_if_next_118:
ir_if_end_117:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 13
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    test rax, rax
    jz ir_if_next_122
    mov rax, 1
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    test rax, rax
    jz ir_errdefer_ok_123
    jmp ir_errdefer_end_124
ir_errdefer_ok_123:
ir_errdefer_end_124:
    mov rax, 1
    jmp Lis_space_exit
    jmp ir_if_end_121
ir_if_next_122:
ir_if_end_121:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 12
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 80], rax
    mov rax, [rbp - 80]
    test rax, rax
    jz ir_if_next_126
    mov rax, 1
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    test rax, rax
    jz ir_errdefer_ok_127
    jmp ir_errdefer_end_128
ir_errdefer_ok_127:
ir_errdefer_end_128:
    mov rax, 1
    jmp Lis_space_exit
    jmp ir_if_end_125
ir_if_next_126:
ir_if_end_125:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 11
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    test rax, rax
    jz ir_if_next_130
    mov rax, 1
    mov [rbp - 104], rax
    mov rax, [rbp - 104]
    test rax, rax
    jz ir_errdefer_ok_131
    jmp ir_errdefer_end_132
ir_errdefer_ok_131:
ir_errdefer_end_132:
    mov rax, 1
    jmp Lis_space_exit
    jmp ir_if_end_129
ir_if_next_130:
ir_if_end_129:
    mov rax, 0
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    test rax, rax
    jz ir_errdefer_ok_133
    jmp ir_errdefer_end_134
ir_errdefer_ok_133:
ir_errdefer_end_134:
    mov rax, 0
    jmp Lis_space_exit
Lis_space_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global to_lower

to_lower:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 128    ; Allocate 128 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_135:
    ; IR call: is_upper (1 args)
    sub rsp, 32
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call is_upper
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_next_137
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 32
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_errdefer_ok_138
    jmp ir_errdefer_end_139
ir_errdefer_ok_138:
ir_errdefer_end_139:
    mov rax, [rbp - 32]
    jmp Lto_lower_exit
    jmp ir_if_end_136
ir_if_next_137:
ir_if_end_136:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_errdefer_ok_140
    jmp ir_errdefer_end_141
ir_errdefer_ok_140:
ir_errdefer_end_141:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    jmp Lto_lower_exit
Lto_lower_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global to_upper

to_upper:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 128    ; Allocate 128 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_142:
    ; IR call: is_lower (1 args)
    sub rsp, 32
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call is_lower
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_next_144
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 32
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_errdefer_ok_145
    jmp ir_errdefer_end_146
ir_errdefer_ok_145:
ir_errdefer_end_146:
    mov rax, [rbp - 32]
    jmp Lto_upper_exit
    jmp ir_if_end_143
ir_if_next_144:
ir_if_end_143:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_errdefer_ok_147
    jmp ir_errdefer_end_148
ir_errdefer_ok_147:
ir_errdefer_end_148:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    jmp Lto_upper_exit
Lto_upper_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global strlen

strlen:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 176    ; Allocate 176 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 's'
    ; Parameter 's' arrived in register rcx
ir_entry_149:
    mov rax, 0
    ; Store to variable: i
    mov qword [rbp - 16], rax  ; To stack [rbp - 16]
ir_while_150:
    ; Load variable: s
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_152
    jmp ir_nonnull_153
ir_trap_null_152:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct12]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_153:
    ; Load variable: i
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 24], rax
    ; Load variable: s
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 24]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    movzx rax, byte [rax]
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_while_end_151
    ; Load variable: i
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    ; Store to variable: i
    mov qword [rbp - 16], rax  ; To stack [rbp - 16]
    jmp ir_while_150
ir_while_end_151:
    ; Load variable: i
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    test rax, rax
    jz ir_errdefer_ok_154
    jmp ir_errdefer_end_155
ir_errdefer_ok_154:
ir_errdefer_end_155:
    ; Load variable: i
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    jmp Lstrlen_exit
Lstrlen_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global streq

streq:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 480    ; Allocate 480 bytes on stack (aligned)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 'a'
    ; Parameter 'a' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'b'
    ; Parameter 'b' arrived in register rdx
ir_entry_156:
    mov rax, 0
    ; Store to variable: i
    mov qword [rbp - 24], rax  ; To stack [rbp - 24]
ir_while_157:
    ; Load variable: a
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_159
    jmp ir_nonnull_160
ir_trap_null_159:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct14]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_160:
    ; Load variable: i
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 32], rax
    ; Load variable: a
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 32]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    movzx rax, byte [rax]
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    test rax, rax
    jz ir_while_end_158
    ; Load variable: a
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_163
    jmp ir_nonnull_164
ir_trap_null_163:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct16]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_164:
    ; Load variable: i
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 64], rax
    ; Load variable: a
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 64]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    movzx rax, byte [rax]
    mov [rbp - 80], rax
    ; Load variable: b
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    test rax, rax
    jz ir_trap_null_165
    jmp ir_nonnull_166
ir_trap_null_165:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct18]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_166:
    ; Load variable: i
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 88], rax
    ; Load variable: b
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, [rbp - 88]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    movzx rax, byte [rax]
    mov [rbp - 104], rax
    mov rax, [rbp - 80]
    push rax
    mov rax, [rbp - 104]
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    test rax, rax
    jz ir_if_next_162
    mov rax, 0
    mov [rbp - 120], rax
    mov rax, [rbp - 120]
    test rax, rax
    jz ir_errdefer_ok_167
    jmp ir_errdefer_end_168
ir_errdefer_ok_167:
ir_errdefer_end_168:
    mov rax, 0
    jmp Lstreq_exit
    jmp ir_if_end_161
ir_if_next_162:
ir_if_end_161:
    ; Load variable: i
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 128], rax
    mov rax, [rbp - 128]
    ; Store to variable: i
    mov qword [rbp - 24], rax  ; To stack [rbp - 24]
    jmp ir_while_157
ir_while_end_158:
    ; Load variable: b
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    test rax, rax
    jz ir_trap_null_171
    jmp ir_nonnull_172
ir_trap_null_171:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct20]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_172:
    ; Load variable: i
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 136], rax
    ; Load variable: b
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, [rbp - 136]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 144], rax
    mov rax, [rbp - 144]
    movzx rax, byte [rax]
    mov [rbp - 152], rax
    mov rax, [rbp - 152]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 160], rax
    mov rax, [rbp - 160]
    test rax, rax
    jz ir_if_next_170
    mov rax, 0
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    test rax, rax
    jz ir_errdefer_ok_173
    jmp ir_errdefer_end_174
ir_errdefer_ok_173:
ir_errdefer_end_174:
    mov rax, 0
    jmp Lstreq_exit
    jmp ir_if_end_169
ir_if_next_170:
ir_if_end_169:
    mov rax, 1
    mov [rbp - 176], rax
    mov rax, [rbp - 176]
    test rax, rax
    jz ir_errdefer_ok_175
    jmp ir_errdefer_end_176
ir_errdefer_ok_175:
ir_errdefer_end_176:
    mov rax, 1
    jmp Lstreq_exit
Lstreq_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global strncmp

strncmp:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 960    ; Allocate 960 bytes on stack (aligned)
    ; Registering 4 function parameters
    mov [rbp - 8], rcx  ; Home param 'buf'
    ; Parameter 'buf' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'offset'
    ; Parameter 'offset' arrived in register rdx
    mov [rbp - 24], r8  ; Home param 'needle'
    ; Parameter 'needle' arrived in register r8
    mov [rbp - 32], r9  ; Home param 'buf_len'
    ; Parameter 'buf_len' arrived in register r9
ir_entry_177:
    ; Load variable: offset
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_if_next_179
    mov rax, 1
    neg rax
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    test rax, rax
    jz ir_errdefer_ok_180
    jmp ir_errdefer_end_181
ir_errdefer_ok_180:
ir_errdefer_end_181:
    mov rax, [rbp - 56]
    jmp Lstrncmp_exit
    jmp ir_if_end_178
ir_if_next_179:
ir_if_end_178:
    ; Load variable: buf_len
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    test rax, rax
    jz ir_if_next_183
    mov rax, 1
    neg rax
    mov [rbp - 80], rax
    mov rax, [rbp - 80]
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    test rax, rax
    jz ir_errdefer_ok_184
    jmp ir_errdefer_end_185
ir_errdefer_ok_184:
ir_errdefer_end_185:
    mov rax, [rbp - 80]
    jmp Lstrncmp_exit
    jmp ir_if_end_182
ir_if_next_183:
ir_if_end_182:
    ; Load variable: offset
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    ; Load variable: buf_len
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    mov r10, rax
    pop rax
    cmp rax, r10
    setg al
    movzx rax, al
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    test rax, rax
    jz ir_if_next_187
    mov rax, 1
    neg rax
    mov [rbp - 104], rax
    mov rax, [rbp - 104]
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    test rax, rax
    jz ir_errdefer_ok_188
    jmp ir_errdefer_end_189
ir_errdefer_ok_188:
ir_errdefer_end_189:
    mov rax, [rbp - 104]
    jmp Lstrncmp_exit
    jmp ir_if_end_186
ir_if_next_187:
ir_if_end_186:
    mov rax, 0
    ; Store to variable: i
    mov dword [rbp - 36], eax  ; To stack [rbp - 36]
ir_while_190:
    ; Load variable: needle
    mov rax, qword [rbp - 24]  ; String param ptr
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 120], rax
    mov rax, [rbp - 120]
    mov rax, qword [rax]
    mov [rbp - 128], rax
    ; Load variable: i
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    push rax
    mov rax, [rbp - 128]
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 136], rax
    mov rax, [rbp - 136]
    test rax, rax
    jz ir_while_end_191
    ; Load variable: offset
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    ; Load variable: i
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 144], rax
    mov rax, [rbp - 144]
    push rax
    ; Load variable: buf_len
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 152], rax
    mov rax, [rbp - 152]
    test rax, rax
    jz ir_if_next_193
    mov rax, 1
    neg rax
    mov [rbp - 160], rax
    mov rax, [rbp - 160]
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    test rax, rax
    jz ir_errdefer_ok_194
    jmp ir_errdefer_end_195
ir_errdefer_ok_194:
ir_errdefer_end_195:
    mov rax, [rbp - 160]
    jmp Lstrncmp_exit
    jmp ir_if_end_192
ir_if_next_193:
ir_if_end_192:
    ; Load variable: offset
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    ; Load variable: i
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 176], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_198
    jmp ir_nonnull_199
ir_trap_null_198:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct22]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_199:
    mov rax, [rbp - 176]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 184], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 184]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 192], rax
    mov rax, [rbp - 192]
    movzx rax, byte [rax]
    mov [rbp - 200], rax
    ; Load variable: needle
    mov rax, qword [rbp - 24]  ; String param ptr
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 208], rax
    mov rax, [rbp - 208]
    mov rax, qword [rax]
    mov [rbp - 216], rax
    mov rax, [rbp - 216]
    test rax, rax
    jz ir_trap_null_200
    jmp ir_nonnull_201
ir_trap_null_200:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct24]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_201:
    ; Load variable: i
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 224], rax
    mov rax, [rbp - 216]
    push rax
    mov rax, [rbp - 224]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 232], rax
    mov rax, [rbp - 232]
    movzx rax, byte [rax]
    mov [rbp - 240], rax
    mov rax, [rbp - 200]
    push rax
    mov rax, [rbp - 240]
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 248], rax
    mov rax, [rbp - 248]
    test rax, rax
    jz ir_if_next_197
    ; Load variable: offset
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    ; Load variable: i
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 256], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_202
    jmp ir_nonnull_203
ir_trap_null_202:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct26]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_203:
    mov rax, [rbp - 256]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 264], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 264]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 272], rax
    mov rax, [rbp - 272]
    movzx rax, byte [rax]
    mov [rbp - 280], rax
    ; Load variable: needle
    mov rax, qword [rbp - 24]  ; String param ptr
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 288], rax
    mov rax, [rbp - 288]
    mov rax, qword [rax]
    mov [rbp - 296], rax
    mov rax, [rbp - 296]
    test rax, rax
    jz ir_trap_null_204
    jmp ir_nonnull_205
ir_trap_null_204:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct28]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_205:
    ; Load variable: i
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 304], rax
    mov rax, [rbp - 296]
    push rax
    mov rax, [rbp - 304]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 312], rax
    mov rax, [rbp - 312]
    movzx rax, byte [rax]
    mov [rbp - 320], rax
    mov rax, [rbp - 280]
    push rax
    mov rax, [rbp - 320]
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 328], rax
    mov rax, [rbp - 328]
    mov [rbp - 336], rax
    mov rax, [rbp - 336]
    test rax, rax
    jz ir_errdefer_ok_206
    jmp ir_errdefer_end_207
ir_errdefer_ok_206:
ir_errdefer_end_207:
    mov rax, [rbp - 328]
    jmp Lstrncmp_exit
    jmp ir_if_end_196
ir_if_next_197:
ir_if_end_196:
    ; Load variable: i
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 344], rax
    mov rax, [rbp - 344]
    ; Store to variable: i
    mov dword [rbp - 36], eax  ; To stack [rbp - 36]
    jmp ir_while_190
ir_while_end_191:
    mov rax, 0
    mov [rbp - 352], rax
    mov rax, [rbp - 352]
    test rax, rax
    jz ir_errdefer_ok_208
    jmp ir_errdefer_end_209
ir_errdefer_ok_208:
ir_errdefer_end_209:
    mov rax, 0
    jmp Lstrncmp_exit
Lstrncmp_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller
    ; Struct declaration: BuildConfig
    ; Struct BuildConfig: size=928, alignment=1

global copy_str

copy_str:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 480    ; Allocate 480 bytes on stack (aligned)
    ; Registering 3 function parameters
    mov [rbp - 8], rcx  ; Home param 'dst'
    ; Parameter 'dst' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'src'
    ; Parameter 'src' arrived in register rdx
    mov [rbp - 24], r8  ; Home param 'max_len'
    ; Parameter 'max_len' arrived in register r8
ir_entry_210:
    mov rax, 0
    ; Store to variable: i
    mov dword [rbp - 28], eax  ; To stack [rbp - 28]
ir_while_211:
    ; Load variable: max_len
    movsxd rax, dword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 40], rax
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, [rbp - 40]
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_sc_false_215
ir_sc_rhs_213:
    ; Load variable: src
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    test rax, rax
    jz ir_trap_null_217
    jmp ir_nonnull_218
ir_trap_null_217:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct30]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_218:
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 56], rax
    ; Load variable: src
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, [rbp - 56]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    movzx rax, byte [rax]
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 80], rax
    mov rax, [rbp - 80]
    test rax, rax
    jz ir_sc_false_215
ir_sc_true_214:
    mov rax, 1
    mov [rbp - 88], rax
    jmp ir_sc_end_216
ir_sc_false_215:
    mov rax, 0
    mov [rbp - 88], rax
ir_sc_end_216:
    mov rax, [rbp - 88]
    test rax, rax
    jz ir_while_end_212
    ; Load variable: src
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    test rax, rax
    jz ir_trap_null_219
    jmp ir_nonnull_220
ir_trap_null_219:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct32]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_220:
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 104], rax
    ; Load variable: src
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, [rbp - 104]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    movzx rax, byte [rax]
    mov [rbp - 120], rax
    ; Load variable: dst
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_221
    jmp ir_nonnull_222
ir_trap_null_221:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct34]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_222:
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 128], rax
    ; Load variable: dst
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 128]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 136], rax
    mov rax, [rbp - 136]
    push rax
    mov rax, [rbp - 120]
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 152], rax
    mov rax, [rbp - 152]
    ; Store to variable: i
    mov dword [rbp - 28], eax  ; To stack [rbp - 28]
    jmp ir_while_211
ir_while_end_212:
    ; Load variable: dst
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_223
    jmp ir_nonnull_224
ir_trap_null_223:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct36]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_224:
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 160], rax
    ; Load variable: dst
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 160]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    push rax
    mov rax, 0
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    mov rax, 0
    mov [rbp - 184], rax
    mov rax, [rbp - 184]
    test rax, rax
    jz ir_errdefer_ok_225
    jmp ir_errdefer_end_226
ir_errdefer_ok_225:
ir_errdefer_end_226:
    jmp Lcopy_str_exit
Lcopy_str_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global set_config_field

set_config_field:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 1728    ; Allocate 1728 bytes on stack (aligned)
    ; Registering 3 function parameters
    mov [rbp - 8], rcx  ; Home param 'config'
    ; Parameter 'config' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'key'
    ; Parameter 'key' arrived in register rdx
    mov [rbp - 24], r8  ; Home param 'val'
    ; Parameter 'val' arrived in register r8
ir_entry_227:
    ; String literal (5 bytes)
    lea rax, [rel Lstr_struct38]  ; Load string struct address
    ; Store to variable: k_entry
    mov rcx, [rax]       ; string chars
    mov [rbp - 40], rcx
    mov rcx, [rax + 8]   ; string length
    mov [rbp - 32], rcx
    ; String literal (6 bytes)
    lea rax, [rel Lstr_struct40]  ; Load string struct address
    ; Store to variable: k_output
    mov rcx, [rax]       ; string chars
    mov [rbp - 56], rcx
    mov rcx, [rax + 8]   ; string length
    mov [rbp - 48], rcx
    ; String literal (3 bytes)
    lea rax, [rel Lstr_struct42]  ; Load string struct address
    ; Store to variable: k_asm
    mov rcx, [rax]       ; string chars
    mov [rbp - 72], rcx
    mov rcx, [rax + 8]   ; string length
    mov [rbp - 64], rcx
    ; String literal (3 bytes)
    lea rax, [rel Lstr_struct44]  ; Load string struct address
    ; Store to variable: k_obj
    mov rcx, [rax]       ; string chars
    mov [rbp - 88], rcx
    mov rcx, [rax + 8]   ; string length
    mov [rbp - 80], rcx
    ; String literal (2 bytes)
    lea rax, [rel Lstr_struct46]  ; Load string struct address
    ; Store to variable: k_gc
    mov rcx, [rax]       ; string chars
    mov [rbp - 104], rcx
    mov rcx, [rax + 8]   ; string length
    mov [rbp - 96], rcx
    ; String literal (4 bytes)
    lea rax, [rel Lstr_struct48]  ; Load string struct address
    ; Store to variable: k_libs
    mov rcx, [rax]       ; string chars
    mov [rbp - 120], rcx
    mov rcx, [rax + 8]   ; string length
    mov [rbp - 112], rcx
    ; String literal (11 bytes)
    lea rax, [rel Lstr_struct50]  ; Load string struct address
    ; Store to variable: k_nasm
    mov rcx, [rax]       ; string chars
    mov [rbp - 136], rcx
    mov rcx, [rax + 8]   ; string length
    mov [rbp - 128], rcx
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: k_entry
    lea rax, [rbp - 40]  ; Address of local string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 144], rax
    ; IR call: streq (2 args)
    sub rsp, 32
    ; Load variable: key
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov rcx, rax
    mov rax, [rbp - 144]
    mov rdx, rax
    call streq
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 152], rax
    mov rax, [rbp - 152]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 160], rax
    mov rax, [rbp - 160]
    test rax, rax
    jz ir_if_next_229
    ; Load variable: config
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_230
    jmp ir_nonnull_231
ir_trap_null_230:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct52]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_231:
    ; Load variable: config
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    mov rax, qword [rax]
    mov [rbp - 176], rax
    mov rax, 0
    push rax
    mov rax, 128
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 184], rax
    mov rax, [rbp - 184]
    test rax, rax
    jz ir_trap_bounds_232
    jmp ir_in_bounds_233
ir_trap_bounds_232:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct54]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_233:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 192], rax
    mov rax, [rbp - 176]
    push rax
    mov rax, [rbp - 192]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 200], rax
    ; IR call: copy_str (3 args)
    sub rsp, 32
    mov rax, [rbp - 200]
    mov rcx, rax
    ; Load variable: val
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov rdx, rax
    mov rax, 128
    mov r8, rax
    call copy_str
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 208], rax
    jmp ir_if_end_228
ir_if_next_229:
ir_if_end_228:
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: k_output
    lea rax, [rbp - 56]  ; Address of local string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 216], rax
    ; IR call: streq (2 args)
    sub rsp, 32
    ; Load variable: key
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov rcx, rax
    mov rax, [rbp - 216]
    mov rdx, rax
    call streq
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 224], rax
    mov rax, [rbp - 224]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 232], rax
    mov rax, [rbp - 232]
    test rax, rax
    jz ir_if_next_235
    ; Load variable: config
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_236
    jmp ir_nonnull_237
ir_trap_null_236:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct56]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_237:
    ; Load variable: config
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 128
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 240], rax
    mov rax, [rbp - 240]
    mov rax, qword [rax]
    mov [rbp - 248], rax
    mov rax, 0
    push rax
    mov rax, 128
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 256], rax
    mov rax, [rbp - 256]
    test rax, rax
    jz ir_trap_bounds_238
    jmp ir_in_bounds_239
ir_trap_bounds_238:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct58]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_239:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 264], rax
    mov rax, [rbp - 248]
    push rax
    mov rax, [rbp - 264]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 272], rax
    ; IR call: copy_str (3 args)
    sub rsp, 32
    mov rax, [rbp - 272]
    mov rcx, rax
    ; Load variable: val
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov rdx, rax
    mov rax, 128
    mov r8, rax
    call copy_str
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 280], rax
    jmp ir_if_end_234
ir_if_next_235:
ir_if_end_234:
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: k_asm
    lea rax, [rbp - 72]  ; Address of local string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 288], rax
    ; IR call: streq (2 args)
    sub rsp, 32
    ; Load variable: key
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov rcx, rax
    mov rax, [rbp - 288]
    mov rdx, rax
    call streq
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 296], rax
    mov rax, [rbp - 296]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 304], rax
    mov rax, [rbp - 304]
    test rax, rax
    jz ir_if_next_241
    ; Load variable: config
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_242
    jmp ir_nonnull_243
ir_trap_null_242:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct60]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_243:
    ; Load variable: config
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 256
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 312], rax
    mov rax, [rbp - 312]
    mov rax, qword [rax]
    mov [rbp - 320], rax
    mov rax, 0
    push rax
    mov rax, 128
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 328], rax
    mov rax, [rbp - 328]
    test rax, rax
    jz ir_trap_bounds_244
    jmp ir_in_bounds_245
ir_trap_bounds_244:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct62]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_245:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 336], rax
    mov rax, [rbp - 320]
    push rax
    mov rax, [rbp - 336]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 344], rax
    ; IR call: copy_str (3 args)
    sub rsp, 32
    mov rax, [rbp - 344]
    mov rcx, rax
    ; Load variable: val
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov rdx, rax
    mov rax, 128
    mov r8, rax
    call copy_str
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 352], rax
    jmp ir_if_end_240
ir_if_next_241:
ir_if_end_240:
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: k_obj
    lea rax, [rbp - 88]  ; Address of local string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 360], rax
    ; IR call: streq (2 args)
    sub rsp, 32
    ; Load variable: key
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov rcx, rax
    mov rax, [rbp - 360]
    mov rdx, rax
    call streq
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 368], rax
    mov rax, [rbp - 368]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 376], rax
    mov rax, [rbp - 376]
    test rax, rax
    jz ir_if_next_247
    ; Load variable: config
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_248
    jmp ir_nonnull_249
ir_trap_null_248:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct64]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_249:
    ; Load variable: config
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 384
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 384], rax
    mov rax, [rbp - 384]
    mov rax, qword [rax]
    mov [rbp - 392], rax
    mov rax, 0
    push rax
    mov rax, 128
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 400], rax
    mov rax, [rbp - 400]
    test rax, rax
    jz ir_trap_bounds_250
    jmp ir_in_bounds_251
ir_trap_bounds_250:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct66]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_251:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 408], rax
    mov rax, [rbp - 392]
    push rax
    mov rax, [rbp - 408]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 416], rax
    ; IR call: copy_str (3 args)
    sub rsp, 32
    mov rax, [rbp - 416]
    mov rcx, rax
    ; Load variable: val
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov rdx, rax
    mov rax, 128
    mov r8, rax
    call copy_str
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 424], rax
    jmp ir_if_end_246
ir_if_next_247:
ir_if_end_246:
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: k_gc
    lea rax, [rbp - 104]  ; Address of local string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 432], rax
    ; IR call: streq (2 args)
    sub rsp, 32
    ; Load variable: key
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov rcx, rax
    mov rax, [rbp - 432]
    mov rdx, rax
    call streq
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 440], rax
    mov rax, [rbp - 440]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 448], rax
    mov rax, [rbp - 448]
    test rax, rax
    jz ir_if_next_253
    ; Load variable: config
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_254
    jmp ir_nonnull_255
ir_trap_null_254:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct68]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_255:
    ; Load variable: config
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 512
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 456], rax
    mov rax, [rbp - 456]
    mov rax, qword [rax]
    mov [rbp - 464], rax
    mov rax, 0
    push rax
    mov rax, 256
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 472], rax
    mov rax, [rbp - 472]
    test rax, rax
    jz ir_trap_bounds_256
    jmp ir_in_bounds_257
ir_trap_bounds_256:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct70]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_257:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 480], rax
    mov rax, [rbp - 464]
    push rax
    mov rax, [rbp - 480]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 488], rax
    ; IR call: copy_str (3 args)
    sub rsp, 32
    mov rax, [rbp - 488]
    mov rcx, rax
    ; Load variable: val
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov rdx, rax
    mov rax, 256
    mov r8, rax
    call copy_str
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 496], rax
    jmp ir_if_end_252
ir_if_next_253:
ir_if_end_252:
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: k_libs
    lea rax, [rbp - 120]  ; Address of local string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 504], rax
    ; IR call: streq (2 args)
    sub rsp, 32
    ; Load variable: key
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov rcx, rax
    mov rax, [rbp - 504]
    mov rdx, rax
    call streq
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 512], rax
    mov rax, [rbp - 512]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 520], rax
    mov rax, [rbp - 520]
    test rax, rax
    jz ir_if_next_259
    ; Load variable: config
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_260
    jmp ir_nonnull_261
ir_trap_null_260:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct72]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_261:
    ; Load variable: config
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 768
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 528], rax
    mov rax, [rbp - 528]
    mov rax, qword [rax]
    mov [rbp - 536], rax
    mov rax, 0
    push rax
    mov rax, 128
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 544], rax
    mov rax, [rbp - 544]
    test rax, rax
    jz ir_trap_bounds_262
    jmp ir_in_bounds_263
ir_trap_bounds_262:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct74]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_263:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 552], rax
    mov rax, [rbp - 536]
    push rax
    mov rax, [rbp - 552]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 560], rax
    ; IR call: copy_str (3 args)
    sub rsp, 32
    mov rax, [rbp - 560]
    mov rcx, rax
    ; Load variable: val
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov rdx, rax
    mov rax, 128
    mov r8, rax
    call copy_str
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 568], rax
    jmp ir_if_end_258
ir_if_next_259:
ir_if_end_258:
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: k_nasm
    lea rax, [rbp - 136]  ; Address of local string
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 576], rax
    ; IR call: streq (2 args)
    sub rsp, 32
    ; Load variable: key
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov rcx, rax
    mov rax, [rbp - 576]
    mov rdx, rax
    call streq
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 584], rax
    mov rax, [rbp - 584]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 592], rax
    mov rax, [rbp - 592]
    test rax, rax
    jz ir_if_next_265
    ; Load variable: config
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_266
    jmp ir_nonnull_267
ir_trap_null_266:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct76]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_267:
    ; Load variable: config
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 896
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 600], rax
    mov rax, [rbp - 600]
    mov rax, qword [rax]
    mov [rbp - 608], rax
    mov rax, 0
    push rax
    mov rax, 32
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 616], rax
    mov rax, [rbp - 616]
    test rax, rax
    jz ir_trap_bounds_268
    jmp ir_in_bounds_269
ir_trap_bounds_268:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct78]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_269:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 624], rax
    mov rax, [rbp - 608]
    push rax
    mov rax, [rbp - 624]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 632], rax
    ; IR call: copy_str (3 args)
    sub rsp, 32
    mov rax, [rbp - 632]
    mov rcx, rax
    ; Load variable: val
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov rdx, rax
    mov rax, 32
    mov r8, rax
    call copy_str
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 640], rax
    jmp ir_if_end_264
ir_if_next_265:
ir_if_end_264:
    mov rax, 0
    mov [rbp - 648], rax
    mov rax, [rbp - 648]
    test rax, rax
    jz ir_errdefer_ok_270
    jmp ir_errdefer_end_271
ir_errdefer_ok_270:
ir_errdefer_end_271:
    jmp Lset_config_field_exit
Lset_config_field_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global get_default_config

get_default_config:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 1232    ; Allocate 1232 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'config'
    ; Parameter 'config' arrived in register rcx
ir_entry_272:
    ; Load variable: config
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_if_next_274
    mov rax, 1
    neg rax
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_275
    jmp ir_errdefer_end_276
ir_errdefer_ok_275:
ir_errdefer_end_276:
    mov rax, [rbp - 24]
    jmp Lget_default_config_exit
    jmp ir_if_end_273
ir_if_next_274:
ir_if_end_273:
    ; Load variable: config
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_277
    jmp ir_nonnull_278
ir_trap_null_277:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct80]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_278:
    ; Load variable: config
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    mov rax, qword [rax]
    mov [rbp - 48], rax
    mov rax, 0
    push rax
    mov rax, 128
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    test rax, rax
    jz ir_trap_bounds_279
    jmp ir_in_bounds_280
ir_trap_bounds_279:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct82]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_280:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 64], rax
    mov rax, [rbp - 48]
    push rax
    mov rax, [rbp - 64]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 72], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (9 bytes)
    lea rax, [rel Lstr_struct84]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 80], rax
    ; IR call: copy_str (3 args)
    sub rsp, 32
    mov rax, [rbp - 72]
    mov rcx, rax
    mov rax, [rbp - 80]
    mov rdx, rax
    mov rax, 128
    mov r8, rax
    call copy_str
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 88], rax
    ; Load variable: config
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_281
    jmp ir_nonnull_282
ir_trap_null_281:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct86]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_282:
    ; Load variable: config
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 128
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    mov rax, qword [rax]
    mov [rbp - 104], rax
    mov rax, 0
    push rax
    mov rax, 128
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    test rax, rax
    jz ir_trap_bounds_283
    jmp ir_in_bounds_284
ir_trap_bounds_283:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct88]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_284:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 120], rax
    mov rax, [rbp - 104]
    push rax
    mov rax, [rbp - 120]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 128], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (8 bytes)
    lea rax, [rel Lstr_struct90]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 136], rax
    ; IR call: copy_str (3 args)
    sub rsp, 32
    mov rax, [rbp - 128]
    mov rcx, rax
    mov rax, [rbp - 136]
    mov rdx, rax
    mov rax, 128
    mov r8, rax
    call copy_str
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 144], rax
    ; Load variable: config
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_285
    jmp ir_nonnull_286
ir_trap_null_285:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct92]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_286:
    ; Load variable: config
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 256
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 152], rax
    mov rax, [rbp - 152]
    mov rax, qword [rax]
    mov [rbp - 160], rax
    mov rax, 0
    push rax
    mov rax, 128
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    test rax, rax
    jz ir_trap_bounds_287
    jmp ir_in_bounds_288
ir_trap_bounds_287:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct94]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_288:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 176], rax
    mov rax, [rbp - 160]
    push rax
    mov rax, [rbp - 176]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 184], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (6 bytes)
    lea rax, [rel Lstr_struct96]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 192], rax
    ; IR call: copy_str (3 args)
    sub rsp, 32
    mov rax, [rbp - 184]
    mov rcx, rax
    mov rax, [rbp - 192]
    mov rdx, rax
    mov rax, 128
    mov r8, rax
    call copy_str
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 200], rax
    ; Load variable: config
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_289
    jmp ir_nonnull_290
ir_trap_null_289:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct98]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_290:
    ; Load variable: config
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 384
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 208], rax
    mov rax, [rbp - 208]
    mov rax, qword [rax]
    mov [rbp - 216], rax
    mov rax, 0
    push rax
    mov rax, 128
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 224], rax
    mov rax, [rbp - 224]
    test rax, rax
    jz ir_trap_bounds_291
    jmp ir_in_bounds_292
ir_trap_bounds_291:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct100]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_292:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 232], rax
    mov rax, [rbp - 216]
    push rax
    mov rax, [rbp - 232]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 240], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (6 bytes)
    lea rax, [rel Lstr_struct102]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 248], rax
    ; IR call: copy_str (3 args)
    sub rsp, 32
    mov rax, [rbp - 240]
    mov rcx, rax
    mov rax, [rbp - 248]
    mov rdx, rax
    mov rax, 128
    mov r8, rax
    call copy_str
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 256], rax
    ; Load variable: config
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_293
    jmp ir_nonnull_294
ir_trap_null_293:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct104]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_294:
    ; Load variable: config
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 512
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 264], rax
    mov rax, [rbp - 264]
    mov rax, qword [rax]
    mov [rbp - 272], rax
    mov rax, 0
    push rax
    mov rax, 256
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 280], rax
    mov rax, [rbp - 280]
    test rax, rax
    jz ir_trap_bounds_295
    jmp ir_in_bounds_296
ir_trap_bounds_295:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct106]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_296:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 288], rax
    mov rax, [rbp - 272]
    push rax
    mov rax, [rbp - 288]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 296], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (16 bytes)
    lea rax, [rel Lstr_struct108]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 304], rax
    ; IR call: copy_str (3 args)
    sub rsp, 32
    mov rax, [rbp - 296]
    mov rcx, rax
    mov rax, [rbp - 304]
    mov rdx, rax
    mov rax, 256
    mov r8, rax
    call copy_str
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 312], rax
    ; Load variable: config
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_297
    jmp ir_nonnull_298
ir_trap_null_297:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct110]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_298:
    ; Load variable: config
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 768
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 320], rax
    mov rax, [rbp - 320]
    mov rax, qword [rax]
    mov [rbp - 328], rax
    mov rax, 0
    push rax
    mov rax, 128
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 336], rax
    mov rax, [rbp - 336]
    test rax, rax
    jz ir_trap_bounds_299
    jmp ir_in_bounds_300
ir_trap_bounds_299:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct112]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_300:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 344], rax
    mov rax, [rbp - 328]
    push rax
    mov rax, [rbp - 344]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 352], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (8 bytes)
    lea rax, [rel Lstr_struct114]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 360], rax
    ; IR call: copy_str (3 args)
    sub rsp, 32
    mov rax, [rbp - 352]
    mov rcx, rax
    mov rax, [rbp - 360]
    mov rdx, rax
    mov rax, 128
    mov r8, rax
    call copy_str
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 368], rax
    ; Load variable: config
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_301
    jmp ir_nonnull_302
ir_trap_null_301:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct116]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_302:
    ; Load variable: config
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 896
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 376], rax
    mov rax, [rbp - 376]
    mov rax, qword [rax]
    mov [rbp - 384], rax
    mov rax, 0
    push rax
    mov rax, 32
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 392], rax
    mov rax, [rbp - 392]
    test rax, rax
    jz ir_trap_bounds_303
    jmp ir_in_bounds_304
ir_trap_bounds_303:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct118]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_304:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 400], rax
    mov rax, [rbp - 384]
    push rax
    mov rax, [rbp - 400]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 408], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (5 bytes)
    lea rax, [rel Lstr_struct120]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 416], rax
    ; IR call: copy_str (3 args)
    sub rsp, 32
    mov rax, [rbp - 408]
    mov rcx, rax
    mov rax, [rbp - 416]
    mov rdx, rax
    mov rax, 32
    mov r8, rax
    call copy_str
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 424], rax
    mov rax, 0
    mov [rbp - 432], rax
    mov rax, [rbp - 432]
    test rax, rax
    jz ir_errdefer_ok_305
    jmp ir_errdefer_end_306
ir_errdefer_ok_305:
ir_errdefer_end_306:
    mov rax, 0
    jmp Lget_default_config_exit
Lget_default_config_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global parse_config_line

parse_config_line:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 3936    ; Allocate 3936 bytes on stack (aligned)
    ; Registering 3 function parameters
    mov [rbp - 8], rcx  ; Home param 'line'
    ; Parameter 'line' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'line_len'
    ; Parameter 'line_len' arrived in register rdx
    mov [rbp - 24], r8  ; Home param 'config'
    ; Parameter 'config' arrived in register r8
ir_entry_307:
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 392], rax
    mov rax, [rbp - 392]
    test rax, rax
    jz ir_sc_rhs_310
    jmp ir_sc_true_311
ir_sc_rhs_310:
    ; Load variable: config
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 400], rax
    mov rax, [rbp - 400]
    test rax, rax
    jz ir_sc_false_312
ir_sc_true_311:
    mov rax, 1
    mov [rbp - 408], rax
    jmp ir_sc_end_313
ir_sc_false_312:
    mov rax, 0
    mov [rbp - 408], rax
ir_sc_end_313:
    mov rax, [rbp - 408]
    test rax, rax
    jz ir_if_next_309
    mov rax, 0
    mov [rbp - 424], rax
    mov rax, [rbp - 424]
    test rax, rax
    jz ir_errdefer_ok_314
    jmp ir_errdefer_end_315
ir_errdefer_ok_314:
ir_errdefer_end_315:
    mov rax, 0
    jmp Lparse_config_line_exit
    jmp ir_if_end_308
ir_if_next_309:
ir_if_end_308:
    mov rax, 0
    ; Store to variable: i
    mov dword [rbp - 28], eax  ; To stack [rbp - 28]
ir_while_316:
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    ; Load variable: line_len
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 432], rax
    mov rax, [rbp - 432]
    test rax, rax
    jz ir_sc_false_320
ir_sc_rhs_318:
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_322
    jmp ir_nonnull_323
ir_trap_null_322:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct122]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_323:
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 440], rax
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 440]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 448], rax
    mov rax, [rbp - 448]
    movzx rax, byte [rax]
    mov [rbp - 456], rax
    mov rax, [rbp - 456]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 464], rax
    mov rax, [rbp - 464]
    test rax, rax
    jz ir_sc_false_320
ir_sc_true_319:
    mov rax, 1
    mov [rbp - 472], rax
    jmp ir_sc_end_321
ir_sc_false_320:
    mov rax, 0
    mov [rbp - 472], rax
ir_sc_end_321:
    mov rax, [rbp - 472]
    test rax, rax
    jz ir_while_end_317
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_326
    jmp ir_nonnull_327
ir_trap_null_326:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct124]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_327:
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 488], rax
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 488]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 496], rax
    mov rax, [rbp - 496]
    movzx rax, byte [rax]
    mov [rbp - 504], rax
    ; IR call: is_space (1 args)
    sub rsp, 32
    mov rax, [rbp - 504]
    mov rcx, rax
    call is_space
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 512], rax
    mov rax, [rbp - 512]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 520], rax
    mov rax, [rbp - 520]
    test rax, rax
    jz ir_if_next_325
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 528], rax
    mov rax, [rbp - 528]
    ; Store to variable: i
    mov dword [rbp - 28], eax  ; To stack [rbp - 28]
    jmp ir_if_end_324
ir_if_next_325:
    jmp ir_while_end_317
ir_if_end_324:
    jmp ir_while_316
ir_while_end_317:
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    ; Load variable: line_len
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 536], rax
    mov rax, [rbp - 536]
    test rax, rax
    jz ir_sc_rhs_330
    jmp ir_sc_true_331
ir_sc_rhs_330:
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_334
    jmp ir_nonnull_335
ir_trap_null_334:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct126]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_335:
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 544], rax
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 544]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 552], rax
    mov rax, [rbp - 552]
    movzx rax, byte [rax]
    mov [rbp - 560], rax
    mov rax, [rbp - 560]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 568], rax
    mov rax, [rbp - 568]
    test rax, rax
    jz ir_sc_false_332
ir_sc_true_331:
    mov rax, 1
    mov [rbp - 576], rax
    jmp ir_sc_end_333
ir_sc_false_332:
    mov rax, 0
    mov [rbp - 576], rax
ir_sc_end_333:
    mov rax, [rbp - 576]
    test rax, rax
    jz ir_sc_rhs_336
    jmp ir_sc_true_337
ir_sc_rhs_336:
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_340
    jmp ir_nonnull_341
ir_trap_null_340:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct128]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_341:
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 592], rax
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 592]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 600], rax
    mov rax, [rbp - 600]
    movzx rax, byte [rax]
    mov [rbp - 608], rax
    mov rax, [rbp - 608]
    push rax
    mov rax, 10
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 616], rax
    mov rax, [rbp - 616]
    test rax, rax
    jz ir_sc_false_338
ir_sc_true_337:
    mov rax, 1
    mov [rbp - 624], rax
    jmp ir_sc_end_339
ir_sc_false_338:
    mov rax, 0
    mov [rbp - 624], rax
ir_sc_end_339:
    mov rax, [rbp - 624]
    test rax, rax
    jz ir_sc_rhs_342
    jmp ir_sc_true_343
ir_sc_rhs_342:
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_346
    jmp ir_nonnull_347
ir_trap_null_346:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct130]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_347:
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 640], rax
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 640]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 648], rax
    mov rax, [rbp - 648]
    movzx rax, byte [rax]
    mov [rbp - 656], rax
    mov rax, [rbp - 656]
    push rax
    mov rax, 13
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 664], rax
    mov rax, [rbp - 664]
    test rax, rax
    jz ir_sc_false_344
ir_sc_true_343:
    mov rax, 1
    mov [rbp - 672], rax
    jmp ir_sc_end_345
ir_sc_false_344:
    mov rax, 0
    mov [rbp - 672], rax
ir_sc_end_345:
    mov rax, [rbp - 672]
    test rax, rax
    jz ir_sc_rhs_348
    jmp ir_sc_true_349
ir_sc_rhs_348:
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_352
    jmp ir_nonnull_353
ir_trap_null_352:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct132]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_353:
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 688], rax
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 688]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 696], rax
    mov rax, [rbp - 696]
    movzx rax, byte [rax]
    mov [rbp - 704], rax
    mov rax, [rbp - 704]
    push rax
    mov rax, 35
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 712], rax
    mov rax, [rbp - 712]
    test rax, rax
    jz ir_sc_false_350
ir_sc_true_349:
    mov rax, 1
    mov [rbp - 720], rax
    jmp ir_sc_end_351
ir_sc_false_350:
    mov rax, 0
    mov [rbp - 720], rax
ir_sc_end_351:
    mov rax, [rbp - 720]
    test rax, rax
    jz ir_if_next_329
    mov rax, 0
    mov [rbp - 736], rax
    mov rax, [rbp - 736]
    test rax, rax
    jz ir_errdefer_ok_354
    jmp ir_errdefer_end_355
ir_errdefer_ok_354:
ir_errdefer_end_355:
    mov rax, 0
    jmp Lparse_config_line_exit
    jmp ir_if_end_328
ir_if_next_329:
ir_if_end_328:
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    ; Store to variable: key_start
    mov dword [rbp - 32], eax  ; To stack [rbp - 32]
ir_while_356:
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    ; Load variable: line_len
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 744], rax
    mov rax, [rbp - 744]
    test rax, rax
    jz ir_sc_false_360
ir_sc_rhs_358:
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_362
    jmp ir_nonnull_363
ir_trap_null_362:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct134]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_363:
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 752], rax
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 752]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 760], rax
    mov rax, [rbp - 760]
    movzx rax, byte [rax]
    mov [rbp - 768], rax
    mov rax, [rbp - 768]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 776], rax
    mov rax, [rbp - 776]
    test rax, rax
    jz ir_sc_false_360
ir_sc_true_359:
    mov rax, 1
    mov [rbp - 784], rax
    jmp ir_sc_end_361
ir_sc_false_360:
    mov rax, 0
    mov [rbp - 784], rax
ir_sc_end_361:
    mov rax, [rbp - 784]
    test rax, rax
    jz ir_sc_false_366
ir_sc_rhs_364:
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_368
    jmp ir_nonnull_369
ir_trap_null_368:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct136]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_369:
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 800], rax
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 800]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 808], rax
    mov rax, [rbp - 808]
    movzx rax, byte [rax]
    mov [rbp - 816], rax
    mov rax, [rbp - 816]
    push rax
    mov rax, 61
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 824], rax
    mov rax, [rbp - 824]
    test rax, rax
    jz ir_sc_false_366
ir_sc_true_365:
    mov rax, 1
    mov [rbp - 832], rax
    jmp ir_sc_end_367
ir_sc_false_366:
    mov rax, 0
    mov [rbp - 832], rax
ir_sc_end_367:
    mov rax, [rbp - 832]
    test rax, rax
    jz ir_sc_false_372
ir_sc_rhs_370:
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_374
    jmp ir_nonnull_375
ir_trap_null_374:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct138]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_375:
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 848], rax
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 848]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 856], rax
    mov rax, [rbp - 856]
    movzx rax, byte [rax]
    mov [rbp - 864], rax
    mov rax, [rbp - 864]
    push rax
    mov rax, 10
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 872], rax
    mov rax, [rbp - 872]
    test rax, rax
    jz ir_sc_false_372
ir_sc_true_371:
    mov rax, 1
    mov [rbp - 880], rax
    jmp ir_sc_end_373
ir_sc_false_372:
    mov rax, 0
    mov [rbp - 880], rax
ir_sc_end_373:
    mov rax, [rbp - 880]
    test rax, rax
    jz ir_sc_false_378
ir_sc_rhs_376:
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_380
    jmp ir_nonnull_381
ir_trap_null_380:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct140]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_381:
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 896], rax
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 896]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 904], rax
    mov rax, [rbp - 904]
    movzx rax, byte [rax]
    mov [rbp - 912], rax
    mov rax, [rbp - 912]
    push rax
    mov rax, 13
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 920], rax
    mov rax, [rbp - 920]
    test rax, rax
    jz ir_sc_false_378
ir_sc_true_377:
    mov rax, 1
    mov [rbp - 928], rax
    jmp ir_sc_end_379
ir_sc_false_378:
    mov rax, 0
    mov [rbp - 928], rax
ir_sc_end_379:
    mov rax, [rbp - 928]
    test rax, rax
    jz ir_while_end_357
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 944], rax
    mov rax, [rbp - 944]
    ; Store to variable: i
    mov dword [rbp - 28], eax  ; To stack [rbp - 28]
    jmp ir_while_356
ir_while_end_357:
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    ; Load variable: line_len
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 952], rax
    mov rax, [rbp - 952]
    test rax, rax
    jz ir_sc_rhs_384
    jmp ir_sc_true_385
ir_sc_rhs_384:
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_388
    jmp ir_nonnull_389
ir_trap_null_388:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct142]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_389:
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 960], rax
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 960]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 968], rax
    mov rax, [rbp - 968]
    movzx rax, byte [rax]
    mov [rbp - 976], rax
    mov rax, [rbp - 976]
    push rax
    mov rax, 61
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 984], rax
    mov rax, [rbp - 984]
    test rax, rax
    jz ir_sc_false_386
ir_sc_true_385:
    mov rax, 1
    mov [rbp - 992], rax
    jmp ir_sc_end_387
ir_sc_false_386:
    mov rax, 0
    mov [rbp - 992], rax
ir_sc_end_387:
    mov rax, [rbp - 992]
    test rax, rax
    jz ir_if_next_383
    mov rax, 0
    mov [rbp - 1008], rax
    mov rax, [rbp - 1008]
    test rax, rax
    jz ir_errdefer_ok_390
    jmp ir_errdefer_end_391
ir_errdefer_ok_390:
ir_errdefer_end_391:
    mov rax, 0
    jmp Lparse_config_line_exit
    jmp ir_if_end_382
ir_if_next_383:
ir_if_end_382:
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    ; Store to variable: key_end
    mov dword [rbp - 36], eax  ; To stack [rbp - 36]
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1016], rax
    mov rax, [rbp - 1016]
    ; Store to variable: i
    mov dword [rbp - 28], eax  ; To stack [rbp - 28]
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    ; Store to variable: val_start
    mov dword [rbp - 40], eax  ; To stack [rbp - 40]
ir_while_392:
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    ; Load variable: line_len
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1024], rax
    mov rax, [rbp - 1024]
    test rax, rax
    jz ir_sc_false_396
ir_sc_rhs_394:
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_398
    jmp ir_nonnull_399
ir_trap_null_398:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct144]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_399:
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1032], rax
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 1032]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1040], rax
    mov rax, [rbp - 1040]
    movzx rax, byte [rax]
    mov [rbp - 1048], rax
    mov rax, [rbp - 1048]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 1056], rax
    mov rax, [rbp - 1056]
    test rax, rax
    jz ir_sc_false_396
ir_sc_true_395:
    mov rax, 1
    mov [rbp - 1064], rax
    jmp ir_sc_end_397
ir_sc_false_396:
    mov rax, 0
    mov [rbp - 1064], rax
ir_sc_end_397:
    mov rax, [rbp - 1064]
    test rax, rax
    jz ir_sc_false_402
ir_sc_rhs_400:
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_404
    jmp ir_nonnull_405
ir_trap_null_404:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct146]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_405:
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1080], rax
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 1080]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1088], rax
    mov rax, [rbp - 1088]
    movzx rax, byte [rax]
    mov [rbp - 1096], rax
    mov rax, [rbp - 1096]
    push rax
    mov rax, 10
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 1104], rax
    mov rax, [rbp - 1104]
    test rax, rax
    jz ir_sc_false_402
ir_sc_true_401:
    mov rax, 1
    mov [rbp - 1112], rax
    jmp ir_sc_end_403
ir_sc_false_402:
    mov rax, 0
    mov [rbp - 1112], rax
ir_sc_end_403:
    mov rax, [rbp - 1112]
    test rax, rax
    jz ir_sc_false_408
ir_sc_rhs_406:
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_410
    jmp ir_nonnull_411
ir_trap_null_410:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct148]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_411:
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1128], rax
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 1128]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1136], rax
    mov rax, [rbp - 1136]
    movzx rax, byte [rax]
    mov [rbp - 1144], rax
    mov rax, [rbp - 1144]
    push rax
    mov rax, 13
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 1152], rax
    mov rax, [rbp - 1152]
    test rax, rax
    jz ir_sc_false_408
ir_sc_true_407:
    mov rax, 1
    mov [rbp - 1160], rax
    jmp ir_sc_end_409
ir_sc_false_408:
    mov rax, 0
    mov [rbp - 1160], rax
ir_sc_end_409:
    mov rax, [rbp - 1160]
    test rax, rax
    jz ir_while_end_393
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1176], rax
    mov rax, [rbp - 1176]
    ; Store to variable: i
    mov dword [rbp - 28], eax  ; To stack [rbp - 28]
    jmp ir_while_392
ir_while_end_393:
    ; Load variable: i
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    ; Store to variable: val_end
    mov dword [rbp - 44], eax  ; To stack [rbp - 44]
    ; Load variable: key_end
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    push rax
    ; Load variable: key_start
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 1184], rax
    mov rax, [rbp - 1184]
    ; Store to variable: key_len
    mov dword [rbp - 48], eax  ; To stack [rbp - 48]
    ; Load variable: val_end
    movsxd rax, dword [rbp - 44]  ; From stack [rbp - 44]
    push rax
    ; Load variable: val_start
    movsxd rax, dword [rbp - 40]  ; From stack [rbp - 40]
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 1192], rax
    mov rax, [rbp - 1192]
    ; Store to variable: val_len
    mov dword [rbp - 52], eax  ; To stack [rbp - 52]
    ; Load variable: key_len
    movsxd rax, dword [rbp - 48]  ; From stack [rbp - 48]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setle al
    movzx rax, al
    mov [rbp - 1200], rax
    mov rax, [rbp - 1200]
    test rax, rax
    jz ir_sc_rhs_414
    jmp ir_sc_true_415
ir_sc_rhs_414:
    ; Load variable: key_len
    movsxd rax, dword [rbp - 48]  ; From stack [rbp - 48]
    push rax
    mov rax, 64
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 1208], rax
    mov rax, [rbp - 1208]
    test rax, rax
    jz ir_sc_false_416
ir_sc_true_415:
    mov rax, 1
    mov [rbp - 1216], rax
    jmp ir_sc_end_417
ir_sc_false_416:
    mov rax, 0
    mov [rbp - 1216], rax
ir_sc_end_417:
    mov rax, [rbp - 1216]
    test rax, rax
    jz ir_sc_rhs_418
    jmp ir_sc_true_419
ir_sc_rhs_418:
    ; Load variable: val_len
    movsxd rax, dword [rbp - 52]  ; From stack [rbp - 52]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setle al
    movzx rax, al
    mov [rbp - 1232], rax
    mov rax, [rbp - 1232]
    test rax, rax
    jz ir_sc_false_420
ir_sc_true_419:
    mov rax, 1
    mov [rbp - 1240], rax
    jmp ir_sc_end_421
ir_sc_false_420:
    mov rax, 0
    mov [rbp - 1240], rax
ir_sc_end_421:
    mov rax, [rbp - 1240]
    test rax, rax
    jz ir_sc_rhs_422
    jmp ir_sc_true_423
ir_sc_rhs_422:
    ; Load variable: val_len
    movsxd rax, dword [rbp - 52]  ; From stack [rbp - 52]
    push rax
    mov rax, 256
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 1256], rax
    mov rax, [rbp - 1256]
    test rax, rax
    jz ir_sc_false_424
ir_sc_true_423:
    mov rax, 1
    mov [rbp - 1264], rax
    jmp ir_sc_end_425
ir_sc_false_424:
    mov rax, 0
    mov [rbp - 1264], rax
ir_sc_end_425:
    mov rax, [rbp - 1264]
    test rax, rax
    jz ir_if_next_413
    mov rax, 0
    mov [rbp - 1280], rax
    mov rax, [rbp - 1280]
    test rax, rax
    jz ir_errdefer_ok_426
    jmp ir_errdefer_end_427
ir_errdefer_ok_426:
ir_errdefer_end_427:
    mov rax, 0
    jmp Lparse_config_line_exit
    jmp ir_if_end_412
ir_if_next_413:
ir_if_end_412:
    mov rax, 0
    ; Store to variable: j
    mov dword [rbp - 124], eax  ; To stack [rbp - 124]
ir_while_428:
    ; Load variable: j
    movsxd rax, dword [rbp - 124]  ; From stack [rbp - 124]
    push rax
    ; Load variable: key_len
    movsxd rax, dword [rbp - 48]  ; From stack [rbp - 48]
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1288], rax
    mov rax, [rbp - 1288]
    test rax, rax
    jz ir_while_end_429
    ; Load variable: key_start
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    ; Load variable: j
    movsxd rax, dword [rbp - 124]  ; From stack [rbp - 124]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1296], rax
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_430
    jmp ir_nonnull_431
ir_trap_null_430:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct150]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_431:
    mov rax, [rbp - 1296]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1304], rax
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 1304]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1312], rax
    mov rax, [rbp - 1312]
    movzx rax, byte [rax]
    mov [rbp - 1320], rax
    ; Load variable: j
    movsxd rax, dword [rbp - 124]  ; From stack [rbp - 124]
    push rax
    mov rax, 64
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1328], rax
    mov rax, [rbp - 1328]
    test rax, rax
    jz ir_trap_bounds_432
    jmp ir_in_bounds_433
ir_trap_bounds_432:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct152]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_433:
    ; Load variable: j
    movsxd rax, dword [rbp - 124]  ; From stack [rbp - 124]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1336], rax
    ; Load variable: key_buf
    lea rax, [rbp - 120]  ; Local array base
    push rax
    mov rax, [rbp - 1336]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1344], rax
    mov rax, [rbp - 1344]
    push rax
    mov rax, [rbp - 1320]
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: j
    movsxd rax, dword [rbp - 124]  ; From stack [rbp - 124]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1360], rax
    mov rax, [rbp - 1360]
    ; Store to variable: j
    mov dword [rbp - 124], eax  ; To stack [rbp - 124]
    jmp ir_while_428
ir_while_end_429:
    ; Load variable: j
    movsxd rax, dword [rbp - 124]  ; From stack [rbp - 124]
    push rax
    mov rax, 64
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1368], rax
    mov rax, [rbp - 1368]
    test rax, rax
    jz ir_trap_bounds_434
    jmp ir_in_bounds_435
ir_trap_bounds_434:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct154]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_435:
    ; Load variable: j
    movsxd rax, dword [rbp - 124]  ; From stack [rbp - 124]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1376], rax
    ; Load variable: key_buf
    lea rax, [rbp - 120]  ; Local array base
    push rax
    mov rax, [rbp - 1376]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1384], rax
    mov rax, [rbp - 1384]
    push rax
    mov rax, 0
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    mov rax, 0
    ; Store to variable: j
    mov dword [rbp - 124], eax  ; To stack [rbp - 124]
ir_while_436:
    ; Load variable: j
    movsxd rax, dword [rbp - 124]  ; From stack [rbp - 124]
    push rax
    ; Load variable: val_len
    movsxd rax, dword [rbp - 52]  ; From stack [rbp - 52]
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1400], rax
    mov rax, [rbp - 1400]
    test rax, rax
    jz ir_while_end_437
    ; Load variable: val_start
    movsxd rax, dword [rbp - 40]  ; From stack [rbp - 40]
    push rax
    ; Load variable: j
    movsxd rax, dword [rbp - 124]  ; From stack [rbp - 124]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1408], rax
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_438
    jmp ir_nonnull_439
ir_trap_null_438:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct156]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_439:
    mov rax, [rbp - 1408]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1416], rax
    ; Load variable: line
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 1416]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1424], rax
    mov rax, [rbp - 1424]
    movzx rax, byte [rax]
    mov [rbp - 1432], rax
    ; Load variable: j
    movsxd rax, dword [rbp - 124]  ; From stack [rbp - 124]
    push rax
    mov rax, 256
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1440], rax
    mov rax, [rbp - 1440]
    test rax, rax
    jz ir_trap_bounds_440
    jmp ir_in_bounds_441
ir_trap_bounds_440:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct158]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_441:
    ; Load variable: j
    movsxd rax, dword [rbp - 124]  ; From stack [rbp - 124]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1448], rax
    ; Load variable: val_buf
    lea rax, [rbp - 384]  ; Local array base
    push rax
    mov rax, [rbp - 1448]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1456], rax
    mov rax, [rbp - 1456]
    push rax
    mov rax, [rbp - 1432]
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: j
    movsxd rax, dword [rbp - 124]  ; From stack [rbp - 124]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1472], rax
    mov rax, [rbp - 1472]
    ; Store to variable: j
    mov dword [rbp - 124], eax  ; To stack [rbp - 124]
    jmp ir_while_436
ir_while_end_437:
    ; Load variable: j
    movsxd rax, dword [rbp - 124]  ; From stack [rbp - 124]
    push rax
    mov rax, 256
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1480], rax
    mov rax, [rbp - 1480]
    test rax, rax
    jz ir_trap_bounds_442
    jmp ir_in_bounds_443
ir_trap_bounds_442:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct160]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_443:
    ; Load variable: j
    movsxd rax, dword [rbp - 124]  ; From stack [rbp - 124]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1488], rax
    ; Load variable: val_buf
    lea rax, [rbp - 384]  ; Local array base
    push rax
    mov rax, [rbp - 1488]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1496], rax
    mov rax, [rbp - 1496]
    push rax
    mov rax, 0
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    mov rax, 0
    push rax
    mov rax, 64
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1512], rax
    mov rax, [rbp - 1512]
    test rax, rax
    jz ir_trap_bounds_444
    jmp ir_in_bounds_445
ir_trap_bounds_444:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct162]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_445:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1520], rax
    ; Load variable: key_buf
    lea rax, [rbp - 120]  ; Local array base
    push rax
    mov rax, [rbp - 1520]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1528], rax
    mov rax, 0
    push rax
    mov rax, 256
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 1536], rax
    mov rax, [rbp - 1536]
    test rax, rax
    jz ir_trap_bounds_446
    jmp ir_in_bounds_447
ir_trap_bounds_446:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct164]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_447:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 1544], rax
    ; Load variable: val_buf
    lea rax, [rbp - 384]  ; Local array base
    push rax
    mov rax, [rbp - 1544]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 1552], rax
    ; IR call: set_config_field (3 args)
    sub rsp, 32
    ; Load variable: config
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov rcx, rax
    mov rax, [rbp - 1528]
    mov rdx, rax
    mov rax, [rbp - 1552]
    mov r8, rax
    call set_config_field
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 1560], rax
    mov rax, 1
    mov [rbp - 1568], rax
    mov rax, [rbp - 1568]
    test rax, rax
    jz ir_errdefer_ok_448
    jmp ir_errdefer_end_449
ir_errdefer_ok_448:
ir_errdefer_end_449:
    mov rax, 1
    jmp Lparse_config_line_exit
Lparse_config_line_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global load_config

load_config:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 1264    ; Allocate 1264 bytes on stack (aligned)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 'path'
    ; Parameter 'path' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'config'
    ; Parameter 'config' arrived in register rdx
ir_entry_450:
    ; Load variable: path
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 568], rax
    mov rax, [rbp - 568]
    test rax, rax
    jz ir_sc_rhs_453
    jmp ir_sc_true_454
ir_sc_rhs_453:
    ; Load variable: config
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 576], rax
    mov rax, [rbp - 576]
    test rax, rax
    jz ir_sc_false_455
ir_sc_true_454:
    mov rax, 1
    mov [rbp - 584], rax
    jmp ir_sc_end_456
ir_sc_false_455:
    mov rax, 0
    mov [rbp - 584], rax
ir_sc_end_456:
    mov rax, [rbp - 584]
    test rax, rax
    jz ir_if_next_452
    mov rax, 1
    neg rax
    mov [rbp - 600], rax
    mov rax, [rbp - 600]
    mov [rbp - 608], rax
    mov rax, [rbp - 608]
    test rax, rax
    jz ir_errdefer_ok_457
    jmp ir_errdefer_end_458
ir_errdefer_ok_457:
ir_errdefer_end_458:
    mov rax, [rbp - 600]
    jmp Lload_config_exit
    jmp ir_if_end_451
ir_if_next_452:
ir_if_end_451:
    ; IR call: get_default_config (1 args)
    sub rsp, 32
    ; Load variable: config
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov rcx, rax
    call get_default_config
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 616], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (1 bytes)
    lea rax, [rel Lstr_struct166]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 624], rax
    mov rax, [rbp - 624]
    ; Store to variable: mode_r
    mov qword [rbp - 24], rax  ; To stack [rbp - 24]
    ; IR call: fopen (2 args)
    sub rsp, 32
    ; Load variable: path
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    ; Load variable: mode_r
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov rdx, rax
    call fopen
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 632], rax
    mov rax, [rbp - 632]
    ; Store to variable: fp
    mov qword [rbp - 32], rax  ; To stack [rbp - 32]
    ; Load variable: fp
    mov rax, qword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 640], rax
    mov rax, [rbp - 640]
    test rax, rax
    jz ir_if_next_460
    mov rax, 0
    mov [rbp - 648], rax
    mov rax, [rbp - 648]
    test rax, rax
    jz ir_errdefer_ok_461
    jmp ir_errdefer_end_462
ir_errdefer_ok_461:
ir_errdefer_end_462:
    mov rax, 0
    jmp Lload_config_exit
    jmp ir_if_end_459
ir_if_next_460:
ir_if_end_459:
ir_while_463:
    mov rax, 0
    push rax
    mov rax, 512
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 656], rax
    mov rax, [rbp - 656]
    test rax, rax
    jz ir_trap_bounds_465
    jmp ir_in_bounds_466
ir_trap_bounds_465:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct168]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_466:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 664], rax
    ; Load variable: line_buf
    lea rax, [rbp - 544]  ; Local array base
    push rax
    mov rax, [rbp - 664]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 672], rax
    ; IR call: fgets (3 args)
    sub rsp, 32
    mov rax, [rbp - 672]
    mov rcx, rax
    mov rax, 512
    mov rdx, rax
    ; Load variable: fp
    mov rax, qword [rbp - 32]  ; From stack [rbp - 32]
    mov r8, rax
    call fgets
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 680], rax
    mov rax, [rbp - 680]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 688], rax
    mov rax, [rbp - 688]
    test rax, rax
    jz ir_while_end_464
    mov rax, 0
    push rax
    mov rax, 512
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 696], rax
    mov rax, [rbp - 696]
    test rax, rax
    jz ir_trap_bounds_467
    jmp ir_in_bounds_468
ir_trap_bounds_467:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct170]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_468:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 704], rax
    ; Load variable: line_buf
    lea rax, [rbp - 544]  ; Local array base
    push rax
    mov rax, [rbp - 704]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 712], rax
    ; IR call: strlen (1 args)
    sub rsp, 32
    mov rax, [rbp - 712]
    mov rcx, rax
    call strlen
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 720], rax
    mov rax, [rbp - 720]
    ; Store to variable: len
    mov qword [rbp - 552], rax  ; To stack [rbp - 552]
    ; Load variable: len
    mov rax, qword [rbp - 552]  ; From stack [rbp - 552]
    push rax
    mov rax, 511
    mov r10, rax
    pop rax
    cmp rax, r10
    setg al
    movzx rax, al
    mov [rbp - 728], rax
    mov rax, [rbp - 728]
    test rax, rax
    jz ir_if_next_470
    mov rax, 511
    ; Store to variable: len
    mov qword [rbp - 552], rax  ; To stack [rbp - 552]
    jmp ir_if_end_469
ir_if_next_470:
ir_if_end_469:
    ; Load variable: len
    mov rax, qword [rbp - 552]  ; From stack [rbp - 552]
    ; Store to variable: len32
    mov dword [rbp - 556], eax  ; To stack [rbp - 556]
    mov rax, 0
    push rax
    mov rax, 512
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 736], rax
    mov rax, [rbp - 736]
    test rax, rax
    jz ir_trap_bounds_471
    jmp ir_in_bounds_472
ir_trap_bounds_471:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct172]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_in_bounds_472:
    mov rax, 0
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 744], rax
    ; Load variable: line_buf
    lea rax, [rbp - 544]  ; Local array base
    push rax
    mov rax, [rbp - 744]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 752], rax
    ; IR call: parse_config_line (3 args)
    sub rsp, 32
    mov rax, [rbp - 752]
    mov rcx, rax
    ; Load variable: len32
    movsxd rax, dword [rbp - 556]  ; From stack [rbp - 556]
    mov rdx, rax
    ; Load variable: config
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov r8, rax
    call parse_config_line
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 760], rax
    jmp ir_while_463
ir_while_end_464:
    ; IR call: fclose (1 args)
    sub rsp, 32
    ; Load variable: fp
    mov rax, qword [rbp - 32]  ; From stack [rbp - 32]
    mov rcx, rax
    call fclose
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 768], rax
    mov rax, 0
    mov [rbp - 776], rax
    mov rax, [rbp - 776]
    test rax, rax
    jz ir_errdefer_ok_473
    jmp ir_errdefer_end_474
ir_errdefer_ok_473:
ir_errdefer_end_474:
    mov rax, 0
    jmp Lload_config_exit
Lload_config_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

; Default program entry point
global mainCRTStartup
mainCRTStartup:
    sub rsp, 40      ; Shadow space + alignment
    ; Initialize garbage collector runtime
    lea rcx, [rsp + 40]
    extern gc_init
    call gc_init
    extern gc_register_root
    lea rcx, [rel CONFIG_FILE]
    call gc_register_root
    extern gc_shutdown
    call gc_shutdown
    mov rcx, 0       ; Default exit status
    extern ExitProcess
    call ExitProcess

; Data section for global variables
section .data
; Global variable: CONFIG_FILE (string, 16 bytes)
CONFIG_FILE:
    dq Lstr0  ; Pointer to string data
    dq 11  ; String length
Lstr0:
    db "masm.config", 0

Lstr_chars1:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct2:
    dq Lstr_chars1
    dq 37

Lstr_chars3:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct4:
    dq Lstr_chars3
    dq 37

Lstr_chars5:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct6:
    dq Lstr_chars5
    dq 38

Lstr_chars7:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct8:
    dq Lstr_chars7
    dq 38

Lstr_chars9:
    db 10, 0
    align 8
Lstr_struct10:
    dq Lstr_chars9
    dq 1

Lstr_chars11:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct12:
    dq Lstr_chars11
    dq 37

Lstr_chars13:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct14:
    dq Lstr_chars13
    dq 37

Lstr_chars15:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct16:
    dq Lstr_chars15
    dq 37

Lstr_chars17:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct18:
    dq Lstr_chars17
    dq 37

Lstr_chars19:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct20:
    dq Lstr_chars19
    dq 37

Lstr_chars21:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct22:
    dq Lstr_chars21
    dq 37

Lstr_chars23:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct24:
    dq Lstr_chars23
    dq 37

Lstr_chars25:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct26:
    dq Lstr_chars25
    dq 37

Lstr_chars27:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct28:
    dq Lstr_chars27
    dq 37

Lstr_chars29:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct30:
    dq Lstr_chars29
    dq 37

Lstr_chars31:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct32:
    dq Lstr_chars31
    dq 37

Lstr_chars33:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct34:
    dq Lstr_chars33
    dq 37

Lstr_chars35:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct36:
    dq Lstr_chars35
    dq 37

Lstr_chars37:
    db "entry", 0
    align 8
Lstr_struct38:
    dq Lstr_chars37
    dq 5

Lstr_chars39:
    db "output", 0
    align 8
Lstr_struct40:
    dq Lstr_chars39
    dq 6

Lstr_chars41:
    db "asm", 0
    align 8
Lstr_struct42:
    dq Lstr_chars41
    dq 3

Lstr_chars43:
    db "obj", 0
    align 8
Lstr_struct44:
    dq Lstr_chars43
    dq 3

Lstr_chars45:
    db "gc", 0
    align 8
Lstr_struct46:
    dq Lstr_chars45
    dq 2

Lstr_chars47:
    db "libs", 0
    align 8
Lstr_struct48:
    dq Lstr_chars47
    dq 4

Lstr_chars49:
    db "nasm_format", 0
    align 8
Lstr_struct50:
    dq Lstr_chars49
    dq 11

Lstr_chars51:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct52:
    dq Lstr_chars51
    dq 37

Lstr_chars53:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct54:
    dq Lstr_chars53
    dq 38

Lstr_chars55:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct56:
    dq Lstr_chars55
    dq 37

Lstr_chars57:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct58:
    dq Lstr_chars57
    dq 38

Lstr_chars59:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct60:
    dq Lstr_chars59
    dq 37

Lstr_chars61:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct62:
    dq Lstr_chars61
    dq 38

Lstr_chars63:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct64:
    dq Lstr_chars63
    dq 37

Lstr_chars65:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct66:
    dq Lstr_chars65
    dq 38

Lstr_chars67:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct68:
    dq Lstr_chars67
    dq 37

Lstr_chars69:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct70:
    dq Lstr_chars69
    dq 38

Lstr_chars71:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct72:
    dq Lstr_chars71
    dq 37

Lstr_chars73:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct74:
    dq Lstr_chars73
    dq 38

Lstr_chars75:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct76:
    dq Lstr_chars75
    dq 37

Lstr_chars77:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct78:
    dq Lstr_chars77
    dq 38

Lstr_chars79:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct80:
    dq Lstr_chars79
    dq 37

Lstr_chars81:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct82:
    dq Lstr_chars81
    dq 38

Lstr_chars83:
    db "main.masm", 0
    align 8
Lstr_struct84:
    dq Lstr_chars83
    dq 9

Lstr_chars85:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct86:
    dq Lstr_chars85
    dq 37

Lstr_chars87:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct88:
    dq Lstr_chars87
    dq 38

Lstr_chars89:
    db "main.exe", 0
    align 8
Lstr_struct90:
    dq Lstr_chars89
    dq 8

Lstr_chars91:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct92:
    dq Lstr_chars91
    dq 37

Lstr_chars93:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct94:
    dq Lstr_chars93
    dq 38

Lstr_chars95:
    db "main.s", 0
    align 8
Lstr_struct96:
    dq Lstr_chars95
    dq 6

Lstr_chars97:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct98:
    dq Lstr_chars97
    dq 37

Lstr_chars99:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct100:
    dq Lstr_chars99
    dq 38

Lstr_chars101:
    db "main.o", 0
    align 8
Lstr_struct102:
    dq Lstr_chars101
    dq 6

Lstr_chars103:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct104:
    dq Lstr_chars103
    dq 37

Lstr_chars105:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct106:
    dq Lstr_chars105
    dq 38

Lstr_chars107:
    db "src/runtime/gc.c", 0
    align 8
Lstr_struct108:
    dq Lstr_chars107
    dq 16

Lstr_chars109:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct110:
    dq Lstr_chars109
    dq 37

Lstr_chars111:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct112:
    dq Lstr_chars111
    dq 38

Lstr_chars113:
    db "kernel32", 0
    align 8
Lstr_struct114:
    dq Lstr_chars113
    dq 8

Lstr_chars115:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct116:
    dq Lstr_chars115
    dq 37

Lstr_chars117:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct118:
    dq Lstr_chars117
    dq 38

Lstr_chars119:
    db "win64", 0
    align 8
Lstr_struct120:
    dq Lstr_chars119
    dq 5

Lstr_chars121:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct122:
    dq Lstr_chars121
    dq 37

Lstr_chars123:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct124:
    dq Lstr_chars123
    dq 37

Lstr_chars125:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct126:
    dq Lstr_chars125
    dq 37

Lstr_chars127:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct128:
    dq Lstr_chars127
    dq 37

Lstr_chars129:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct130:
    dq Lstr_chars129
    dq 37

Lstr_chars131:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct132:
    dq Lstr_chars131
    dq 37

Lstr_chars133:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct134:
    dq Lstr_chars133
    dq 37

Lstr_chars135:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct136:
    dq Lstr_chars135
    dq 37

Lstr_chars137:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct138:
    dq Lstr_chars137
    dq 37

Lstr_chars139:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct140:
    dq Lstr_chars139
    dq 37

Lstr_chars141:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct142:
    dq Lstr_chars141
    dq 37

Lstr_chars143:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct144:
    dq Lstr_chars143
    dq 37

Lstr_chars145:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct146:
    dq Lstr_chars145
    dq 37

Lstr_chars147:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct148:
    dq Lstr_chars147
    dq 37

Lstr_chars149:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct150:
    dq Lstr_chars149
    dq 37

Lstr_chars151:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct152:
    dq Lstr_chars151
    dq 38

Lstr_chars153:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct154:
    dq Lstr_chars153
    dq 38

Lstr_chars155:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct156:
    dq Lstr_chars155
    dq 37

Lstr_chars157:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct158:
    dq Lstr_chars157
    dq 38

Lstr_chars159:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct160:
    dq Lstr_chars159
    dq 38

Lstr_chars161:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct162:
    dq Lstr_chars161
    dq 38

Lstr_chars163:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct164:
    dq Lstr_chars163
    dq 38

Lstr_chars165:
    db "r", 0
    align 8
Lstr_struct166:
    dq Lstr_chars165
    dq 1

Lstr_chars167:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct168:
    dq Lstr_chars167
    dq 38

Lstr_chars169:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct170:
    dq Lstr_chars169
    dq 38

Lstr_chars171:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct172:
    dq Lstr_chars171
    dq 38

