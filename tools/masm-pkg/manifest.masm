// Manifest parsing for masm-pkg
// masm.deps format: one line per dependency, name=path
// Example:
//   mylib=../shared/mylib
//
// Returns dependency count and fills fixed-size arrays.
// Max 64 dependencies, max 256 chars per name/value.

import "std/io";
import "std/conv";
import "std/mem";

// Max deps and string lengths
export var MAX_DEPS: int32 = 64;
export var MAX_NAME_LEN: int32 = 128;
export var MAX_VALUE_LEN: int32 = 256;

// Parsed dependency: name and source path
export struct Dep {
  name: int8[128];
  value: int8[256];
}

// Parse one line "name=value" into dep. Returns 1 on success, 0 on empty/skip, -1 on error.
export function parse_dep_line(line: cstring, line_len: int32, dep: Dep*) -> int32 {
  if (line == 0 || dep == 0) {
    return -1;
  }
  var i: int32 = 0;
  while (i < line_len && line[i] != 0) {
    if (is_space(line[i]) == 1) {
      i = i + 1;
    } else {
      break;
    }
  }
  if (i >= line_len || line[i] == 0 || line[i] == 10 || line[i] == 13) {
    return 0;
  }
  if (line[i] == 35) {
    return 0;
  }
  var name_start: int32 = i;
  while (i < line_len && line[i] != 0 && line[i] != 61 && line[i] != 10 && line[i] != 13) {
    i = i + 1;
  }
  if (i >= line_len || line[i] != 61) {
    return 0;
  }
  var name_end: int32 = i;
  i = i + 1;
  var value_start: int32 = i;
  while (i < line_len && line[i] != 0 && line[i] != 10 && line[i] != 13) {
    i = i + 1;
  }
  var value_end: int32 = i;
  var name_len: int32 = name_end - name_start;
  var value_len: int32 = value_end - value_start;
  if (name_len <= 0 || name_len >= 128) {
    return -1;
  }
  if (value_len >= 256) {
    return -1;
  }
  var j: int32 = 0;
  while (j < name_len) {
    dep->name[j] = line[name_start + j];
    j = j + 1;
  }
  dep->name[name_len] = 0;
  j = 0;
  while (j < value_len) {
    dep->value[j] = line[value_start + j];
    j = j + 1;
  }
  dep->value[j] = 0;
  return 1;
}

// Load deps from masm.deps file. Returns count, or -1 on error.
export function load_deps(path: cstring, deps: Dep*, max_deps: int32) -> int32 {
  if (path == 0 || deps == 0 || max_deps <= 0) {
    return -1;
  }
  var mode_r: cstring = cstr("r");
  var fp: cstring = fopen(path, mode_r);
  if (fp == 0) {
    return -1;
  }
  var count: int32 = 0;
  var line_buf: int8[512];
  while (fgets(&line_buf[0], 512, fp) != 0 && count < max_deps) {
    var len: int64 = strlen(&line_buf[0]);
    if (len > 511) {
      len = 511;
    }
    var len32: int32 = len;
    var result: int32 = parse_dep_line(&line_buf[0], len32, &deps[count]);
    if (result == 1) {
      count = count + 1;
    } else if (result == -1) {
      fclose(fp);
      return -1;
    }
  }
  fclose(fp);
  return count;
}

// Save deps to masm.deps file. Returns 0 on success, -1 on error.
export function save_deps(path: cstring, deps: Dep*, count: int32) -> int32 {
  if (path == 0 || deps == 0 || count < 0) {
    return -1;
  }
  var mode_w: cstring = cstr("w");
  var fp: cstring = fopen(path, mode_w);
  if (fp == 0) {
    return -1;
  }
  var i: int32 = 0;
  while (i < count) {
    fputs(&deps[i].name[0], fp);
    fputs(cstr("="), fp);
    fputs(&deps[i].value[0], fp);
    fputs(cstr("\n"), fp);
    i = i + 1;
  }
  fclose(fp);
  return 0;
}
