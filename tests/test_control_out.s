; Generated by MethASM
; x86-64 Assembly Output

section .text
; Code section

; First pass: processing 1 declarations
; Declaration 0 type: 4 (AST_INLINE_ASM = 18)

section .text

global main

main:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 208    ; Allocate 208 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_0:
    mov rax, 0
    ; Store to variable: x
    mov dword [rbp - 4], eax  ; To stack [rbp - 4]
    mov rax, 0
    ; Store to variable: i
    mov dword [rbp - 8], eax  ; To stack [rbp - 8]
ir_for_cond_1:
    ; Load variable: i
    mov eax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_for_end_3
    ; Load variable: i
    mov eax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 2
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_else_4
    jmp ir_for_step_2
    jmp ir_if_end_5
ir_if_else_4:
ir_if_end_5:
    ; Load variable: i
    mov eax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    je ir_case_7
    ; Load variable: i
    mov eax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 5
    mov r10, rax
    pop rax
    cmp rax, r10
    je ir_case_8
    jmp ir_case_9
ir_case_7:
    ; Load variable: x
    mov eax, dword [rbp - 4]  ; From stack [rbp - 4]
    push rax
    mov rax, 10
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    ; Store to variable: x
    mov dword [rbp - 4], eax  ; To stack [rbp - 4]
    jmp ir_switch_end_6
ir_case_8:
    ; Load variable: x
    mov eax, dword [rbp - 4]  ; From stack [rbp - 4]
    push rax
    mov rax, 50
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    ; Store to variable: x
    mov dword [rbp - 4], eax  ; To stack [rbp - 4]
    jmp ir_switch_end_6
ir_case_9:
    ; Load variable: x
    mov eax, dword [rbp - 4]  ; From stack [rbp - 4]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    ; Store to variable: x
    mov dword [rbp - 4], eax  ; To stack [rbp - 4]
ir_switch_end_6:
    ; Load variable: i
    mov eax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 6
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    test rax, rax
    jz ir_if_else_10
    jmp ir_for_end_3
    jmp ir_if_end_11
ir_if_else_10:
ir_if_end_11:
ir_for_step_2:
    ; Load variable: i
    mov eax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    ; Store to variable: i
    mov dword [rbp - 8], eax  ; To stack [rbp - 8]
    jmp ir_for_cond_1
ir_for_end_3:
    ; Load variable: x
    mov eax, dword [rbp - 4]  ; From stack [rbp - 4]
    jmp Lmain_exit
Lmain_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

; Default program entry point
global mainCRTStartup
mainCRTStartup:
    sub rsp, 40      ; Shadow space + alignment
    ; Initialize garbage collector runtime
    lea rcx, [rsp + 40]
    extern gc_init
    call gc_init
    ; Call user main function
    call main
    mov [rsp + 32], rax ; Preserve main return code
    extern gc_shutdown
    call gc_shutdown
    mov rcx, [rsp + 32] ; Use main return as exit code
    extern ExitProcess
    call ExitProcess
