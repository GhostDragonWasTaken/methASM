; Generated by MethASM
; x86-64 Assembly Output

section .text
; Code section

; First pass: processing 2 declarations
; Declaration 0 type: 4 (AST_INLINE_ASM = 18)
; Declaration 1 type: 4 (AST_INLINE_ASM = 18)

section .text

global sum5f

sum5f:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 144    ; Allocate 144 bytes on stack (aligned)
    ; Registering 5 function parameters
    movsd [rbp - 8], xmm0  ; Home param 'a'
    ; Parameter 'a' arrived in register xmm0
    movsd [rbp - 16], xmm1  ; Home param 'b'
    ; Parameter 'b' arrived in register xmm1
    movsd [rbp - 24], xmm2  ; Home param 'c'
    ; Parameter 'c' arrived in register xmm2
    movsd [rbp - 32], xmm3  ; Home param 'd'
    ; Parameter 'd' arrived in register xmm3
    mov rax, [rbp + 48]  ; Load stack param 'e'
    mov [rbp - 40], rax  ; Home param 'e'
    ; Parameter 'e' arrived on stack [rbp + 48]
ir_entry_0:
    ; Load variable: a
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    ; Load variable: b
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov r10, rax
    pop rax
    movq xmm0, rax
    movq xmm1, r10
    addsd xmm0, xmm1
    movq rax, xmm0
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    push rax
    ; Load variable: c
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov r10, rax
    pop rax
    movq xmm0, rax
    movq xmm1, r10
    addsd xmm0, xmm1
    movq rax, xmm0
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    push rax
    ; Load variable: d
    mov rax, qword [rbp - 32]  ; From stack [rbp - 32]
    mov r10, rax
    pop rax
    movq xmm0, rax
    movq xmm1, r10
    addsd xmm0, xmm1
    movq rax, xmm0
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    push rax
    ; Load variable: e
    mov rax, qword [rbp - 40]  ; From stack [rbp - 40]
    mov r10, rax
    pop rax
    movq xmm0, rax
    movq xmm1, r10
    addsd xmm0, xmm1
    movq rax, xmm0
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    jmp Lsum5f_exit
Lsum5f_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global main

main:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 256    ; Allocate 256 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_1:
    mov rax, 0x3ff0000000000000
    ; Store to variable: p
    mov qword [rbp - 8], rax  ; To stack [rbp - 8]
    mov rax, 0x4000000000000000
    ; Store to variable: q
    mov qword [rbp - 16], rax  ; To stack [rbp - 16]
    mov rax, 0x4008000000000000
    ; Store to variable: r
    mov qword [rbp - 24], rax  ; To stack [rbp - 24]
    mov rax, 0x4010000000000000
    ; Store to variable: s
    mov qword [rbp - 32], rax  ; To stack [rbp - 32]
    mov rax, 0x4014000000000000
    ; Store to variable: t
    mov qword [rbp - 40], rax  ; To stack [rbp - 40]
    ; IR call: sum5f (5 args)
    sub rsp, 48
    ; Load variable: t
    mov rax, qword [rbp - 40]  ; From stack [rbp - 40]
    mov [rsp + 32], rax
    ; Load variable: p
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    movq xmm0, rax
    ; Load variable: q
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    movq xmm1, rax
    ; Load variable: r
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    movq xmm2, rax
    ; Load variable: s
    mov rax, qword [rbp - 32]  ; From stack [rbp - 32]
    movq xmm3, rax
    call sum5f
    add rsp, 48
    movq rax, xmm0
    ; Float return value in xmm0
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    ; Store to variable: out
    mov qword [rbp - 48], rax  ; To stack [rbp - 48]
    ; Load variable: out
    mov rax, qword [rbp - 48]  ; From stack [rbp - 48]
    push rax
    mov rax, 0x402dcccccccccccd
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    test rax, rax
    jz ir_sc_false_6
ir_sc_rhs_4:
    ; Load variable: out
    mov rax, qword [rbp - 48]  ; From stack [rbp - 48]
    push rax
    mov rax, 0x402e333333333333
    mov r10, rax
    pop rax
    cmp rax, r10
    setle al
    movzx rax, al
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    test rax, rax
    jz ir_sc_false_6
ir_sc_true_5:
    mov rax, 1
    mov [rbp - 80], rax
    jmp ir_sc_end_7
ir_sc_false_6:
    mov rax, 0
    mov [rbp - 80], rax
ir_sc_end_7:
    mov rax, [rbp - 80]
    test rax, rax
    jz ir_if_next_3
    mov rax, 1
    jmp Lmain_exit
    jmp ir_if_end_2
ir_if_next_3:
ir_if_end_2:
    mov rax, 0
    jmp Lmain_exit
Lmain_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

; Default program entry point
global mainCRTStartup
mainCRTStartup:
    sub rsp, 40      ; Shadow space + alignment
    ; Initialize garbage collector runtime
    lea rcx, [rsp + 40]
    extern gc_init
    call gc_init
    ; Call user main function
    call main
    mov [rsp + 32], rax ; Preserve main return code
    extern gc_shutdown
    call gc_shutdown
    mov rcx, [rsp + 32] ; Use main return as exit code
    extern ExitProcess
    call ExitProcess
