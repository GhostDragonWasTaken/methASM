; Generated by MethASM
; x86-64 Assembly Output

section .text
; Code section

; First pass: processing 3 declarations
; Declaration 0 type: 4 (AST_INLINE_ASM = 21)
; Declaration 1 type: 4 (AST_INLINE_ASM = 21)
; Declaration 2 type: 4 (AST_INLINE_ASM = 21)

section .text

global add

add:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 64    ; Allocate 64 bytes on stack (aligned)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 'a'
    ; Parameter 'a' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'b'
    ; Parameter 'b' arrived in register rdx
ir_entry_0:
    ; Load variable: a
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    ; Load variable: b
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_1
    jmp ir_errdefer_end_2
ir_errdefer_ok_1:
ir_errdefer_end_2:
    mov rax, [rbp - 24]
    jmp Ladd_exit
Ladd_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global multiply

multiply:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 64    ; Allocate 64 bytes on stack (aligned)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 'a'
    ; Parameter 'a' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'b'
    ; Parameter 'b' arrived in register rdx
ir_entry_3:
    ; Load variable: a
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    ; Load variable: b
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_4
    jmp ir_errdefer_end_5
ir_errdefer_ok_4:
ir_errdefer_end_5:
    mov rax, [rbp - 24]
    jmp Lmultiply_exit
Lmultiply_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global main

main:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 240    ; Allocate 240 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_6:
    lea rax, [rel add]
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    ; Store to variable: fp
    mov qword [rbp - 8], rax  ; To stack [rbp - 8]
    ; Indirect function call
    sub rsp, 32
    mov rax, 3
    mov rcx, rax
    mov rax, 4
    mov rdx, rax
    ; Load variable: fp
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    call rax
    add rsp, 32
    ; Unknown return type - assuming integer
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    ; Store to variable: result
    mov dword [rbp - 12], eax  ; To stack [rbp - 12]
    ; Load variable: result
    movsxd rax, dword [rbp - 12]  ; From stack [rbp - 12]
    push rax
    mov rax, 7
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_if_next_8
    lea rax, [rel multiply]
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    ; Store to variable: fp
    mov qword [rbp - 8], rax  ; To stack [rbp - 8]
    ; Indirect function call
    sub rsp, 32
    mov rax, 3
    mov rcx, rax
    mov rax, 4
    mov rdx, rax
    ; Load variable: fp
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    call rax
    add rsp, 32
    ; Unknown return type - assuming integer
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    ; Store to variable: result
    mov dword [rbp - 12], eax  ; To stack [rbp - 12]
    ; Load variable: result
    movsxd rax, dword [rbp - 12]  ; From stack [rbp - 12]
    push rax
    mov rax, 12
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    test rax, rax
    jz ir_if_next_10
    mov rax, 1
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    test rax, rax
    jz ir_errdefer_ok_11
    jmp ir_errdefer_end_12
ir_errdefer_ok_11:
ir_errdefer_end_12:
    mov rax, 1
    jmp Lmain_exit
    jmp ir_if_end_9
ir_if_next_10:
ir_if_end_9:
    jmp ir_if_end_7
ir_if_next_8:
ir_if_end_7:
    mov rax, 0
    mov [rbp - 80], rax
    mov rax, [rbp - 80]
    test rax, rax
    jz ir_errdefer_ok_13
    jmp ir_errdefer_end_14
ir_errdefer_ok_13:
ir_errdefer_end_14:
    mov rax, 0
    jmp Lmain_exit
Lmain_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

; Default program entry point
global mainCRTStartup
mainCRTStartup:
    sub rsp, 40      ; Shadow space + alignment
    ; Initialize garbage collector runtime
    lea rcx, [rsp + 40]
    extern gc_init
    call gc_init
    ; Call user main function
    call main
    mov [rsp + 32], rax ; Preserve main return code
    extern gc_shutdown
    call gc_shutdown
    mov rcx, [rsp + 32] ; Use main return as exit code
    extern ExitProcess
    call ExitProcess
