; Generated by MethASM
; x86-64 Assembly Output

section .text
; Code section

; First pass: processing 1 declarations
; Declaration 0 type: 4 (AST_INLINE_ASM = 21)

section .text

global main

main:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 928    ; Allocate 928 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_0:
    mov rax, 0
    test rax, rax
    setz al
    movzx rax, al
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    ; Store to variable: a
    mov dword [rbp - 4], eax  ; To stack [rbp - 4]
    ; Load variable: a
    movsxd rax, dword [rbp - 4]  ; From stack [rbp - 4]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    test rax, rax
    jz ir_if_next_2
    mov rax, 1
    mov [rbp - 80], rax
    mov rax, [rbp - 80]
    test rax, rax
    jz ir_errdefer_ok_3
    jmp ir_errdefer_end_4
ir_errdefer_ok_3:
ir_errdefer_end_4:
    mov rax, 1
    jmp Lmain_exit
    jmp ir_if_end_1
ir_if_next_2:
ir_if_end_1:
    mov rax, 1
    test rax, rax
    setz al
    movzx rax, al
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    ; Store to variable: b
    mov dword [rbp - 8], eax  ; To stack [rbp - 8]
    ; Load variable: b
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    test rax, rax
    jz ir_if_next_6
    mov rax, 2
    mov [rbp - 104], rax
    mov rax, [rbp - 104]
    test rax, rax
    jz ir_errdefer_ok_7
    jmp ir_errdefer_end_8
ir_errdefer_ok_7:
ir_errdefer_end_8:
    mov rax, 2
    jmp Lmain_exit
    jmp ir_if_end_5
ir_if_next_6:
ir_if_end_5:
    mov rax, 42
    test rax, rax
    setz al
    movzx rax, al
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    ; Store to variable: c
    mov dword [rbp - 12], eax  ; To stack [rbp - 12]
    ; Load variable: c
    movsxd rax, dword [rbp - 12]  ; From stack [rbp - 12]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 120], rax
    mov rax, [rbp - 120]
    test rax, rax
    jz ir_if_next_10
    mov rax, 3
    mov [rbp - 128], rax
    mov rax, [rbp - 128]
    test rax, rax
    jz ir_errdefer_ok_11
    jmp ir_errdefer_end_12
ir_errdefer_ok_11:
ir_errdefer_end_12:
    mov rax, 3
    jmp Lmain_exit
    jmp ir_if_end_9
ir_if_next_10:
ir_if_end_9:
    mov rax, 5
    test rax, rax
    setz al
    movzx rax, al
    mov [rbp - 136], rax
    mov rax, [rbp - 136]
    test rax, rax
    setz al
    movzx rax, al
    mov [rbp - 144], rax
    mov rax, [rbp - 144]
    ; Store to variable: d
    mov dword [rbp - 16], eax  ; To stack [rbp - 16]
    ; Load variable: d
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 152], rax
    mov rax, [rbp - 152]
    test rax, rax
    jz ir_if_next_14
    mov rax, 4
    mov [rbp - 160], rax
    mov rax, [rbp - 160]
    test rax, rax
    jz ir_errdefer_ok_15
    jmp ir_errdefer_end_16
ir_errdefer_ok_15:
ir_errdefer_end_16:
    mov rax, 4
    jmp Lmain_exit
    jmp ir_if_end_13
ir_if_next_14:
ir_if_end_13:
    mov rax, 0
    ; Store to variable: x
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
    ; Load variable: x
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    test rax, rax
    setz al
    movzx rax, al
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    test rax, rax
    jz ir_if_next_18
    mov rax, 10
    ; Store to variable: x
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
    jmp ir_if_end_17
ir_if_next_18:
ir_if_end_17:
    ; Load variable: x
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 10
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 176], rax
    mov rax, [rbp - 176]
    test rax, rax
    jz ir_if_next_20
    mov rax, 5
    mov [rbp - 184], rax
    mov rax, [rbp - 184]
    test rax, rax
    jz ir_errdefer_ok_21
    jmp ir_errdefer_end_22
ir_errdefer_ok_21:
ir_errdefer_end_22:
    mov rax, 5
    jmp Lmain_exit
    jmp ir_if_end_19
ir_if_next_20:
ir_if_end_19:
    mov rax, 7
    ; Store to variable: y
    mov dword [rbp - 24], eax  ; To stack [rbp - 24]
    ; Load variable: y
    movsxd rax, dword [rbp - 24]  ; From stack [rbp - 24]
    test rax, rax
    setz al
    movzx rax, al
    mov [rbp - 192], rax
    mov rax, [rbp - 192]
    test rax, rax
    jz ir_if_next_24
    mov rax, 6
    mov [rbp - 200], rax
    mov rax, [rbp - 200]
    test rax, rax
    jz ir_errdefer_ok_25
    jmp ir_errdefer_end_26
ir_errdefer_ok_25:
ir_errdefer_end_26:
    mov rax, 6
    jmp Lmain_exit
    jmp ir_if_end_23
ir_if_next_24:
ir_if_end_23:
    mov rax, 0
    ; Store to variable: ptr
    mov qword [rbp - 32], rax  ; To stack [rbp - 32]
    ; Load variable: ptr
    mov rax, qword [rbp - 32]  ; From stack [rbp - 32]
    test rax, rax
    setz al
    movzx rax, al
    mov [rbp - 208], rax
    mov rax, [rbp - 208]
    ; Store to variable: not_ptr
    mov dword [rbp - 36], eax  ; To stack [rbp - 36]
    ; Load variable: not_ptr
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 216], rax
    mov rax, [rbp - 216]
    test rax, rax
    jz ir_if_next_28
    mov rax, 7
    mov [rbp - 224], rax
    mov rax, [rbp - 224]
    test rax, rax
    jz ir_errdefer_ok_29
    jmp ir_errdefer_end_30
ir_errdefer_ok_29:
ir_errdefer_end_30:
    mov rax, 7
    jmp Lmain_exit
    jmp ir_if_end_27
ir_if_next_28:
ir_if_end_27:
    mov rax, 99
    ; Store to variable: z
    mov dword [rbp - 40], eax  ; To stack [rbp - 40]
    lea rax, [rbp - 40]
    mov [rbp - 232], rax
    mov rax, [rbp - 232]
    ; Store to variable: ptr2
    mov qword [rbp - 48], rax  ; To stack [rbp - 48]
    ; Load variable: ptr2
    mov rax, qword [rbp - 48]  ; From stack [rbp - 48]
    test rax, rax
    setz al
    movzx rax, al
    mov [rbp - 240], rax
    mov rax, [rbp - 240]
    ; Store to variable: not_ptr2
    mov dword [rbp - 52], eax  ; To stack [rbp - 52]
    ; Load variable: not_ptr2
    movsxd rax, dword [rbp - 52]  ; From stack [rbp - 52]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 248], rax
    mov rax, [rbp - 248]
    test rax, rax
    jz ir_if_next_32
    mov rax, 8
    mov [rbp - 256], rax
    mov rax, [rbp - 256]
    test rax, rax
    jz ir_errdefer_ok_33
    jmp ir_errdefer_end_34
ir_errdefer_ok_33:
ir_errdefer_end_34:
    mov rax, 8
    jmp Lmain_exit
    jmp ir_if_end_31
ir_if_next_32:
ir_if_end_31:
    mov rax, 1
    neg rax
    mov [rbp - 264], rax
    mov rax, [rbp - 264]
    test rax, rax
    setz al
    movzx rax, al
    mov [rbp - 272], rax
    mov rax, [rbp - 272]
    ; Store to variable: neg
    mov dword [rbp - 56], eax  ; To stack [rbp - 56]
    ; Load variable: neg
    movsxd rax, dword [rbp - 56]  ; From stack [rbp - 56]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 280], rax
    mov rax, [rbp - 280]
    test rax, rax
    jz ir_if_next_36
    mov rax, 9
    mov [rbp - 288], rax
    mov rax, [rbp - 288]
    test rax, rax
    jz ir_errdefer_ok_37
    jmp ir_errdefer_end_38
ir_errdefer_ok_37:
ir_errdefer_end_38:
    mov rax, 9
    jmp Lmain_exit
    jmp ir_if_end_35
ir_if_next_36:
ir_if_end_35:
    mov rax, 0
    mov [rbp - 296], rax
    mov rax, [rbp - 296]
    test rax, rax
    jz ir_errdefer_ok_39
    jmp ir_errdefer_end_40
ir_errdefer_ok_39:
ir_errdefer_end_40:
    mov rax, 0
    jmp Lmain_exit
Lmain_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

; Default program entry point
global mainCRTStartup
mainCRTStartup:
    sub rsp, 40      ; Shadow space + alignment
    ; Initialize garbage collector runtime
    lea rcx, [rsp + 40]
    extern gc_init
    call gc_init
    ; Call user main function
    call main
    mov [rsp + 32], rax ; Preserve main return code
    extern gc_shutdown
    call gc_shutdown
    mov rcx, [rsp + 32] ; Use main return as exit code
    extern ExitProcess
    call ExitProcess
