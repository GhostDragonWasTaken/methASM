; Generated by MethASM
; x86-64 Assembly Output

bits 64

section .text
; Code section

; First pass: processing 56 declarations
; Declaration 0 type: 4 (AST_INLINE_ASM = 21)
; Declaration 1 type: 4 (AST_INLINE_ASM = 21)
; Declaration 2 type: 4 (AST_INLINE_ASM = 21)
; Declaration 3 type: 4 (AST_INLINE_ASM = 21)
; Declaration 4 type: 4 (AST_INLINE_ASM = 21)
; Declaration 5 type: 4 (AST_INLINE_ASM = 21)
; Declaration 6 type: 4 (AST_INLINE_ASM = 21)
; Declaration 7 type: 4 (AST_INLINE_ASM = 21)
; Declaration 8 type: 4 (AST_INLINE_ASM = 21)
; Declaration 9 type: 4 (AST_INLINE_ASM = 21)
; Declaration 10 type: 4 (AST_INLINE_ASM = 21)
; Declaration 11 type: 4 (AST_INLINE_ASM = 21)
; Declaration 12 type: 4 (AST_INLINE_ASM = 21)
; Declaration 13 type: 4 (AST_INLINE_ASM = 21)
; Declaration 14 type: 4 (AST_INLINE_ASM = 21)
; Declaration 15 type: 4 (AST_INLINE_ASM = 21)
; Declaration 16 type: 4 (AST_INLINE_ASM = 21)
; Declaration 17 type: 4 (AST_INLINE_ASM = 21)
; Declaration 18 type: 4 (AST_INLINE_ASM = 21)
; Declaration 19 type: 4 (AST_INLINE_ASM = 21)
; Declaration 20 type: 4 (AST_INLINE_ASM = 21)
; Declaration 21 type: 4 (AST_INLINE_ASM = 21)
; Declaration 22 type: 4 (AST_INLINE_ASM = 21)
; Declaration 23 type: 4 (AST_INLINE_ASM = 21)
; Declaration 24 type: 4 (AST_INLINE_ASM = 21)
; Declaration 25 type: 4 (AST_INLINE_ASM = 21)
; Declaration 26 type: 4 (AST_INLINE_ASM = 21)
; Declaration 27 type: 4 (AST_INLINE_ASM = 21)
; Declaration 28 type: 4 (AST_INLINE_ASM = 21)
; Declaration 29 type: 4 (AST_INLINE_ASM = 21)
; Declaration 30 type: 4 (AST_INLINE_ASM = 21)
; Declaration 31 type: 4 (AST_INLINE_ASM = 21)
; Declaration 32 type: 4 (AST_INLINE_ASM = 21)
; Declaration 33 type: 4 (AST_INLINE_ASM = 21)
; Declaration 34 type: 4 (AST_INLINE_ASM = 21)
; Declaration 35 type: 4 (AST_INLINE_ASM = 21)
; Declaration 36 type: 4 (AST_INLINE_ASM = 21)
; Declaration 37 type: 4 (AST_INLINE_ASM = 21)
; Declaration 38 type: 4 (AST_INLINE_ASM = 21)
; Declaration 39 type: 4 (AST_INLINE_ASM = 21)
; Declaration 40 type: 4 (AST_INLINE_ASM = 21)
; Declaration 41 type: 4 (AST_INLINE_ASM = 21)
; Declaration 42 type: 4 (AST_INLINE_ASM = 21)
; Declaration 43 type: 4 (AST_INLINE_ASM = 21)
; Declaration 44 type: 4 (AST_INLINE_ASM = 21)
; Declaration 45 type: 4 (AST_INLINE_ASM = 21)
; Declaration 46 type: 4 (AST_INLINE_ASM = 21)
; Declaration 47 type: 4 (AST_INLINE_ASM = 21)
; Declaration 48 type: 4 (AST_INLINE_ASM = 21)
; Declaration 49 type: 4 (AST_INLINE_ASM = 21)
; Declaration 50 type: 3 (AST_INLINE_ASM = 21)
; Declaration 51 type: 3 (AST_INLINE_ASM = 21)
; Declaration 52 type: 4 (AST_INLINE_ASM = 21)
; Declaration 53 type: 4 (AST_INLINE_ASM = 21)
; Declaration 54 type: 4 (AST_INLINE_ASM = 21)
; Declaration 55 type: 4 (AST_INLINE_ASM = 21)

section .text
    extern puts
    extern putchar
    extern getchar

global cstr

cstr:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 80    ; Allocate 80 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 's'
    ; Parameter 's' arrived in register rcx
ir_entry_0:
    ; Load variable: s
    mov rax, qword [rbp - 8]  ; String param ptr
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    mov rax, qword [rax]
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_1
    jmp ir_errdefer_end_2
ir_errdefer_ok_1:
ir_errdefer_end_2:
    mov rax, [rbp - 24]
    jmp Lcstr_exit
Lcstr_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global print

print:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 272    ; Allocate 272 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'msg'
    ; Parameter 'msg' arrived in register rcx
ir_entry_3:
    mov rax, 0
    ; Store to variable: i
    mov qword [rbp - 16], rax  ; To stack [rbp - 16]
ir_while_4:
    ; Load variable: msg
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_6
    jmp ir_nonnull_7
ir_trap_null_6:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct1]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    extern exit
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Void return - no value to handle
ir_nonnull_7:
    ; Load variable: i
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 24], rax
    ; Load variable: msg
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 24]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    movzx rax, byte [rax]
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_while_end_5
    ; Load variable: msg
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_8
    jmp ir_nonnull_9
ir_trap_null_8:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct3]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Void return - no value to handle
ir_nonnull_9:
    ; Load variable: i
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 56], rax
    ; Load variable: msg
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 56]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    movzx rax, byte [rax]
    mov [rbp - 72], rax
    ; IR call: putchar (1 args)
    sub rsp, 32
    mov rax, [rbp - 72]
    mov rcx, rax
    call putchar
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 80], rax
    ; Load variable: i
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    ; Store to variable: i
    mov qword [rbp - 16], rax  ; To stack [rbp - 16]
    jmp ir_while_4
ir_while_end_5:
    mov rax, 0
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    test rax, rax
    jz ir_errdefer_ok_10
    jmp ir_errdefer_end_11
ir_errdefer_ok_10:
ir_errdefer_end_11:
    jmp Lprint_exit
Lprint_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global println

println:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 64    ; Allocate 64 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'msg'
    ; Parameter 'msg' arrived in register rcx
ir_entry_12:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; Load variable: msg
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 16], rax
    mov rax, 0
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_errdefer_ok_13
    jmp ir_errdefer_end_14
ir_errdefer_ok_13:
ir_errdefer_end_14:
    jmp Lprintln_exit
Lprintln_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global newline

newline:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 48    ; Allocate 48 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_15:
    ; IR call: putchar (1 args)
    sub rsp, 32
    mov rax, 10
    mov rcx, rax
    call putchar
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 8], rax
    mov rax, 0
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_errdefer_ok_16
    jmp ir_errdefer_end_17
ir_errdefer_ok_16:
ir_errdefer_end_17:
    jmp Lnewline_exit
Lnewline_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global print_int

print_int:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 752    ; Allocate 752 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'n'
    ; Parameter 'n' arrived in register rcx
ir_entry_18:
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 104], rax
    mov rax, [rbp - 104]
    test rax, rax
    jz ir_if_next_20
    ; IR call: putchar (1 args)
    sub rsp, 32
    mov rax, 45
    mov rcx, rax
    call putchar
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 112], rax
    mov rax, 0
    push rax
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 120], rax
    mov rax, [rbp - 120]
    ; Store to variable: n
    mov qword [rbp - 8], rax  ; To stack [rbp - 8]
    jmp ir_if_end_19
ir_if_next_20:
ir_if_end_19:
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 128], rax
    mov rax, [rbp - 128]
    test rax, rax
    jz ir_if_next_22
    ; IR call: putchar (1 args)
    sub rsp, 32
    mov rax, 48
    mov rcx, rax
    call putchar
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 136], rax
    mov rax, 0
    mov [rbp - 144], rax
    mov rax, [rbp - 144]
    test rax, rax
    jz ir_errdefer_ok_23
    jmp ir_errdefer_end_24
ir_errdefer_ok_23:
ir_errdefer_end_24:
    jmp Lprint_int_exit
    jmp ir_if_end_21
ir_if_next_22:
ir_if_end_21:
    mov rax, 0
    ; Store to variable: len
    mov dword [rbp - 92], eax  ; To stack [rbp - 92]
ir_while_25:
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setg al
    movzx rax, al
    mov [rbp - 152], rax
    mov rax, [rbp - 152]
    test rax, rax
    jz ir_while_end_26
    mov rax, 48
    push rax
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 160], rax
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 10
    mov r10, rax
    pop rax
    cqo
    idiv r10
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    push rax
    mov rax, 10
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 176], rax
    mov rax, [rbp - 160]
    push rax
    mov rax, [rbp - 176]
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 184], rax
    ; Load variable: len
    movsxd rax, dword [rbp - 92]  ; From stack [rbp - 92]
    push rax
    mov rax, 20
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 192], rax
    mov rax, [rbp - 192]
    test rax, rax
    jz ir_trap_bounds_27
    jmp ir_in_bounds_28
ir_trap_bounds_27:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct5]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Void return - no value to handle
ir_in_bounds_28:
    ; Load variable: len
    movsxd rax, dword [rbp - 92]  ; From stack [rbp - 92]
    push rax
    mov rax, 4
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 200], rax
    ; Load variable: buf
    lea rax, [rbp - 88]  ; Local array base
    push rax
    mov rax, [rbp - 200]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 208], rax
    mov rax, [rbp - 208]
    push rax
    mov rax, [rbp - 184]
    mov rcx, rax
    pop rax
    mov dword [rax], ecx
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 10
    mov r10, rax
    pop rax
    cqo
    idiv r10
    mov [rbp - 224], rax
    mov rax, [rbp - 224]
    ; Store to variable: n
    mov qword [rbp - 8], rax  ; To stack [rbp - 8]
    ; Load variable: len
    movsxd rax, dword [rbp - 92]  ; From stack [rbp - 92]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 232], rax
    mov rax, [rbp - 232]
    ; Store to variable: len
    mov dword [rbp - 92], eax  ; To stack [rbp - 92]
    jmp ir_while_25
ir_while_end_26:
    ; Load variable: len
    movsxd rax, dword [rbp - 92]  ; From stack [rbp - 92]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 240], rax
    mov rax, [rbp - 240]
    ; Store to variable: i
    mov dword [rbp - 96], eax  ; To stack [rbp - 96]
ir_while_29:
    ; Load variable: i
    movsxd rax, dword [rbp - 96]  ; From stack [rbp - 96]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 248], rax
    mov rax, [rbp - 248]
    test rax, rax
    jz ir_while_end_30
    ; Load variable: i
    movsxd rax, dword [rbp - 96]  ; From stack [rbp - 96]
    push rax
    mov rax, 20
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 256], rax
    mov rax, [rbp - 256]
    test rax, rax
    jz ir_trap_bounds_31
    jmp ir_in_bounds_32
ir_trap_bounds_31:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct7]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Void return - no value to handle
ir_in_bounds_32:
    ; Load variable: i
    movsxd rax, dword [rbp - 96]  ; From stack [rbp - 96]
    push rax
    mov rax, 4
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 264], rax
    ; Load variable: buf
    lea rax, [rbp - 88]  ; Local array base
    push rax
    mov rax, [rbp - 264]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 272], rax
    mov rax, [rbp - 272]
    mov eax, dword [rax]
    mov [rbp - 280], rax
    ; IR call: putchar (1 args)
    sub rsp, 32
    mov rax, [rbp - 280]
    mov rcx, rax
    call putchar
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 288], rax
    ; Load variable: i
    movsxd rax, dword [rbp - 96]  ; From stack [rbp - 96]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 296], rax
    mov rax, [rbp - 296]
    ; Store to variable: i
    mov dword [rbp - 96], eax  ; To stack [rbp - 96]
    jmp ir_while_29
ir_while_end_30:
    mov rax, 0
    mov [rbp - 304], rax
    mov rax, [rbp - 304]
    test rax, rax
    jz ir_errdefer_ok_33
    jmp ir_errdefer_end_34
ir_errdefer_ok_33:
ir_errdefer_end_34:
    jmp Lprint_int_exit
Lprint_int_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global println_int

println_int:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 80    ; Allocate 80 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'n'
    ; Parameter 'n' arrived in register rcx
ir_entry_35:
    ; IR call: print_int (1 args)
    sub rsp, 32
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call print_int
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 16], rax
    ; IR call: putchar (1 args)
    sub rsp, 32
    mov rax, 10
    mov rcx, rax
    call putchar
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 24], rax
    mov rax, 0
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_36
    jmp ir_errdefer_end_37
ir_errdefer_ok_36:
ir_errdefer_end_37:
    jmp Lprintln_int_exit
Lprintln_int_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller
    extern fopen
    extern fclose
    extern fread
    extern fwrite
    extern fputs
    extern fgets
    extern fflush
    extern __acrt_iob_func

global get_stdin

get_stdin:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 48    ; Allocate 48 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_38:
    ; IR call: __acrt_iob_func (1 args)
    sub rsp, 32
    mov rax, 0
    mov rcx, rax
    call __acrt_iob_func
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 8], rax
    mov rax, [rbp - 8]
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_errdefer_ok_39
    jmp ir_errdefer_end_40
ir_errdefer_ok_39:
ir_errdefer_end_40:
    mov rax, [rbp - 8]
    jmp Lget_stdin_exit
Lget_stdin_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global get_stdout

get_stdout:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 48    ; Allocate 48 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_41:
    ; IR call: __acrt_iob_func (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call __acrt_iob_func
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 8], rax
    mov rax, [rbp - 8]
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_errdefer_ok_42
    jmp ir_errdefer_end_43
ir_errdefer_ok_42:
ir_errdefer_end_43:
    mov rax, [rbp - 8]
    jmp Lget_stdout_exit
Lget_stdout_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global get_stderr

get_stderr:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 48    ; Allocate 48 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_44:
    ; IR call: __acrt_iob_func (1 args)
    sub rsp, 32
    mov rax, 2
    mov rcx, rax
    call __acrt_iob_func
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 8], rax
    mov rax, [rbp - 8]
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_errdefer_ok_45
    jmp ir_errdefer_end_46
ir_errdefer_ok_45:
ir_errdefer_end_46:
    mov rax, [rbp - 8]
    jmp Lget_stderr_exit
Lget_stderr_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global print_err

print_err:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 80    ; Allocate 80 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'msg'
    ; Parameter 'msg' arrived in register rcx
ir_entry_47:
    ; IR call: get_stderr (0 args)
    sub rsp, 32
    call get_stderr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 16], rax
    ; IR call: fputs (2 args)
    sub rsp, 32
    ; Load variable: msg
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    mov rax, [rbp - 16]
    mov rdx, rax
    call fputs
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 24], rax
    mov rax, 0
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_48
    jmp ir_errdefer_end_49
ir_errdefer_ok_48:
ir_errdefer_end_49:
    jmp Lprint_err_exit
Lprint_err_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global println_err

println_err:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 160    ; Allocate 160 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'msg'
    ; Parameter 'msg' arrived in register rcx
ir_entry_50:
    ; IR call: get_stderr (0 args)
    sub rsp, 32
    call get_stderr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 16], rax
    ; IR call: fputs (2 args)
    sub rsp, 32
    ; Load variable: msg
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    mov rax, [rbp - 16]
    mov rdx, rax
    call fputs
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 24], rax
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; String literal (1 bytes)
    lea rax, [rel Lstr_struct9]  ; Load string struct address
    mov rcx, rax
    call cstr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 32], rax
    ; IR call: get_stderr (0 args)
    sub rsp, 32
    call get_stderr
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 40], rax
    ; IR call: fputs (2 args)
    sub rsp, 32
    mov rax, [rbp - 32]
    mov rcx, rax
    mov rax, [rbp - 40]
    mov rdx, rax
    call fputs
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 48], rax
    mov rax, 0
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    test rax, rax
    jz ir_errdefer_ok_51
    jmp ir_errdefer_end_52
ir_errdefer_ok_51:
ir_errdefer_end_52:
    jmp Lprintln_err_exit
Lprintln_err_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller
    extern malloc
    extern calloc
    extern realloc
    extern free
    extern memset
    extern memcpy
    extern memmove
    extern memcmp

global alloc_zeroed

alloc_zeroed:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 64    ; Allocate 64 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'n'
    ; Parameter 'n' arrived in register rcx
ir_entry_53:
    ; IR call: calloc (2 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rdx, rax
    call calloc
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_errdefer_ok_54
    jmp ir_errdefer_end_55
ir_errdefer_ok_54:
ir_errdefer_end_55:
    mov rax, [rbp - 16]
    jmp Lalloc_zeroed_exit
Lalloc_zeroed_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global buf_dup

buf_dup:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 160    ; Allocate 160 bytes on stack (aligned)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 'src'
    ; Parameter 'src' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'len'
    ; Parameter 'len' arrived in register rdx
ir_entry_56:
    ; IR call: malloc (1 args)
    sub rsp, 32
    ; Load variable: len
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov rcx, rax
    call malloc
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    ; Store to variable: dst
    mov qword [rbp - 24], rax  ; To stack [rbp - 24]
    ; Load variable: dst
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_if_next_58
    mov rax, 0
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_errdefer_ok_59
    jmp ir_errdefer_end_60
ir_errdefer_ok_59:
ir_errdefer_end_60:
    mov rax, 0
    jmp Lbuf_dup_exit
    jmp ir_if_end_57
ir_if_next_58:
ir_if_end_57:
    ; IR call: memcpy (3 args)
    sub rsp, 32
    ; Load variable: dst
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov rcx, rax
    ; Load variable: src
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rdx, rax
    ; Load variable: len
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov r8, rax
    call memcpy
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 56], rax
    ; Load variable: dst
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    test rax, rax
    jz ir_errdefer_ok_61
    jmp ir_errdefer_end_62
ir_errdefer_ok_61:
ir_errdefer_end_62:
    ; Load variable: dst
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    jmp Lbuf_dup_exit
Lbuf_dup_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller
    extern atoi
    extern atol

global digit_to_char

digit_to_char:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 64    ; Allocate 64 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'd'
    ; Parameter 'd' arrived in register rcx
ir_entry_63:
    ; Load variable: d
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 48
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_errdefer_ok_64
    jmp ir_errdefer_end_65
ir_errdefer_ok_64:
ir_errdefer_end_65:
    mov rax, [rbp - 16]
    jmp Ldigit_to_char_exit
Ldigit_to_char_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global char_to_digit

char_to_digit:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 64    ; Allocate 64 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_66:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 48
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_errdefer_ok_67
    jmp ir_errdefer_end_68
ir_errdefer_ok_67:
ir_errdefer_end_68:
    mov rax, [rbp - 16]
    jmp Lchar_to_digit_exit
Lchar_to_digit_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global is_digit

is_digit:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 112    ; Allocate 112 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_69:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 48
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_if_next_71
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 57
    mov r10, rax
    pop rax
    cmp rax, r10
    setle al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_next_73
    mov rax, 1
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_74
    jmp ir_errdefer_end_75
ir_errdefer_ok_74:
ir_errdefer_end_75:
    mov rax, 1
    jmp Lis_digit_exit
    jmp ir_if_end_72
ir_if_next_73:
ir_if_end_72:
    jmp ir_if_end_70
ir_if_next_71:
ir_if_end_70:
    mov rax, 0
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_errdefer_ok_76
    jmp ir_errdefer_end_77
ir_errdefer_ok_76:
ir_errdefer_end_77:
    mov rax, 0
    jmp Lis_digit_exit
Lis_digit_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global is_upper

is_upper:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 112    ; Allocate 112 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_78:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 65
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_if_next_80
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 90
    mov r10, rax
    pop rax
    cmp rax, r10
    setle al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_next_82
    mov rax, 1
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_83
    jmp ir_errdefer_end_84
ir_errdefer_ok_83:
ir_errdefer_end_84:
    mov rax, 1
    jmp Lis_upper_exit
    jmp ir_if_end_81
ir_if_next_82:
ir_if_end_81:
    jmp ir_if_end_79
ir_if_next_80:
ir_if_end_79:
    mov rax, 0
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_errdefer_ok_85
    jmp ir_errdefer_end_86
ir_errdefer_ok_85:
ir_errdefer_end_86:
    mov rax, 0
    jmp Lis_upper_exit
Lis_upper_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global is_lower

is_lower:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 112    ; Allocate 112 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_87:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 97
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_if_next_89
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 122
    mov r10, rax
    pop rax
    cmp rax, r10
    setle al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_next_91
    mov rax, 1
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_92
    jmp ir_errdefer_end_93
ir_errdefer_ok_92:
ir_errdefer_end_93:
    mov rax, 1
    jmp Lis_lower_exit
    jmp ir_if_end_90
ir_if_next_91:
ir_if_end_90:
    jmp ir_if_end_88
ir_if_next_89:
ir_if_end_88:
    mov rax, 0
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_errdefer_ok_94
    jmp ir_errdefer_end_95
ir_errdefer_ok_94:
ir_errdefer_end_95:
    mov rax, 0
    jmp Lis_lower_exit
Lis_lower_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global is_alpha

is_alpha:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 176    ; Allocate 176 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_96:
    ; IR call: is_upper (1 args)
    sub rsp, 32
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call is_upper
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_next_98
    mov rax, 1
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_99
    jmp ir_errdefer_end_100
ir_errdefer_ok_99:
ir_errdefer_end_100:
    mov rax, 1
    jmp Lis_alpha_exit
    jmp ir_if_end_97
ir_if_next_98:
ir_if_end_97:
    ; IR call: is_lower (1 args)
    sub rsp, 32
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call is_lower
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_if_next_102
    mov rax, 1
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    test rax, rax
    jz ir_errdefer_ok_103
    jmp ir_errdefer_end_104
ir_errdefer_ok_103:
ir_errdefer_end_104:
    mov rax, 1
    jmp Lis_alpha_exit
    jmp ir_if_end_101
ir_if_next_102:
ir_if_end_101:
    mov rax, 0
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    test rax, rax
    jz ir_errdefer_ok_105
    jmp ir_errdefer_end_106
ir_errdefer_ok_105:
ir_errdefer_end_106:
    mov rax, 0
    jmp Lis_alpha_exit
Lis_alpha_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global is_alnum

is_alnum:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 176    ; Allocate 176 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_107:
    ; IR call: is_alpha (1 args)
    sub rsp, 32
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call is_alpha
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_next_109
    mov rax, 1
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_110
    jmp ir_errdefer_end_111
ir_errdefer_ok_110:
ir_errdefer_end_111:
    mov rax, 1
    jmp Lis_alnum_exit
    jmp ir_if_end_108
ir_if_next_109:
ir_if_end_108:
    ; IR call: is_digit (1 args)
    sub rsp, 32
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call is_digit
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_if_next_113
    mov rax, 1
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    test rax, rax
    jz ir_errdefer_ok_114
    jmp ir_errdefer_end_115
ir_errdefer_ok_114:
ir_errdefer_end_115:
    mov rax, 1
    jmp Lis_alnum_exit
    jmp ir_if_end_112
ir_if_next_113:
ir_if_end_112:
    mov rax, 0
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    test rax, rax
    jz ir_errdefer_ok_116
    jmp ir_errdefer_end_117
ir_errdefer_ok_116:
ir_errdefer_end_117:
    mov rax, 0
    jmp Lis_alnum_exit
Lis_alnum_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global is_space

is_space:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 320    ; Allocate 320 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_118:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 32
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_if_next_120
    mov rax, 1
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_errdefer_ok_121
    jmp ir_errdefer_end_122
ir_errdefer_ok_121:
ir_errdefer_end_122:
    mov rax, 1
    jmp Lis_space_exit
    jmp ir_if_end_119
ir_if_next_120:
ir_if_end_119:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 9
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_if_next_124
    mov rax, 1
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_errdefer_ok_125
    jmp ir_errdefer_end_126
ir_errdefer_ok_125:
ir_errdefer_end_126:
    mov rax, 1
    jmp Lis_space_exit
    jmp ir_if_end_123
ir_if_next_124:
ir_if_end_123:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 10
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_if_next_128
    mov rax, 1
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    test rax, rax
    jz ir_errdefer_ok_129
    jmp ir_errdefer_end_130
ir_errdefer_ok_129:
ir_errdefer_end_130:
    mov rax, 1
    jmp Lis_space_exit
    jmp ir_if_end_127
ir_if_next_128:
ir_if_end_127:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 13
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    test rax, rax
    jz ir_if_next_132
    mov rax, 1
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    test rax, rax
    jz ir_errdefer_ok_133
    jmp ir_errdefer_end_134
ir_errdefer_ok_133:
ir_errdefer_end_134:
    mov rax, 1
    jmp Lis_space_exit
    jmp ir_if_end_131
ir_if_next_132:
ir_if_end_131:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 12
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 80], rax
    mov rax, [rbp - 80]
    test rax, rax
    jz ir_if_next_136
    mov rax, 1
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    test rax, rax
    jz ir_errdefer_ok_137
    jmp ir_errdefer_end_138
ir_errdefer_ok_137:
ir_errdefer_end_138:
    mov rax, 1
    jmp Lis_space_exit
    jmp ir_if_end_135
ir_if_next_136:
ir_if_end_135:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 11
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    test rax, rax
    jz ir_if_next_140
    mov rax, 1
    mov [rbp - 104], rax
    mov rax, [rbp - 104]
    test rax, rax
    jz ir_errdefer_ok_141
    jmp ir_errdefer_end_142
ir_errdefer_ok_141:
ir_errdefer_end_142:
    mov rax, 1
    jmp Lis_space_exit
    jmp ir_if_end_139
ir_if_next_140:
ir_if_end_139:
    mov rax, 0
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    test rax, rax
    jz ir_errdefer_ok_143
    jmp ir_errdefer_end_144
ir_errdefer_ok_143:
ir_errdefer_end_144:
    mov rax, 0
    jmp Lis_space_exit
Lis_space_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global to_lower

to_lower:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 128    ; Allocate 128 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_145:
    ; IR call: is_upper (1 args)
    sub rsp, 32
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call is_upper
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_next_147
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 32
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_errdefer_ok_148
    jmp ir_errdefer_end_149
ir_errdefer_ok_148:
ir_errdefer_end_149:
    mov rax, [rbp - 32]
    jmp Lto_lower_exit
    jmp ir_if_end_146
ir_if_next_147:
ir_if_end_146:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_errdefer_ok_150
    jmp ir_errdefer_end_151
ir_errdefer_ok_150:
ir_errdefer_end_151:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    jmp Lto_lower_exit
Lto_lower_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global to_upper

to_upper:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 128    ; Allocate 128 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_152:
    ; IR call: is_lower (1 args)
    sub rsp, 32
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call is_lower
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_next_154
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 32
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_errdefer_ok_155
    jmp ir_errdefer_end_156
ir_errdefer_ok_155:
ir_errdefer_end_156:
    mov rax, [rbp - 32]
    jmp Lto_upper_exit
    jmp ir_if_end_153
ir_if_next_154:
ir_if_end_153:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_errdefer_ok_157
    jmp ir_errdefer_end_158
ir_errdefer_ok_157:
ir_errdefer_end_158:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    jmp Lto_upper_exit
Lto_upper_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global strlen

strlen:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 176    ; Allocate 176 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 's'
    ; Parameter 's' arrived in register rcx
ir_entry_159:
    mov rax, 0
    ; Store to variable: i
    mov qword [rbp - 16], rax  ; To stack [rbp - 16]
ir_while_160:
    ; Load variable: s
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_162
    jmp ir_nonnull_163
ir_trap_null_162:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct11]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Void return - no value to handle
ir_nonnull_163:
    ; Load variable: i
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 24], rax
    ; Load variable: s
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 24]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    movzx rax, byte [rax]
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_while_end_161
    ; Load variable: i
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    ; Store to variable: i
    mov qword [rbp - 16], rax  ; To stack [rbp - 16]
    jmp ir_while_160
ir_while_end_161:
    ; Load variable: i
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    test rax, rax
    jz ir_errdefer_ok_164
    jmp ir_errdefer_end_165
ir_errdefer_ok_164:
ir_errdefer_end_165:
    ; Load variable: i
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    jmp Lstrlen_exit
Lstrlen_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global streq

streq:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 480    ; Allocate 480 bytes on stack (aligned)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 'a'
    ; Parameter 'a' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'b'
    ; Parameter 'b' arrived in register rdx
ir_entry_166:
    mov rax, 0
    ; Store to variable: i
    mov qword [rbp - 24], rax  ; To stack [rbp - 24]
ir_while_167:
    ; Load variable: a
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_169
    jmp ir_nonnull_170
ir_trap_null_169:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct13]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Void return - no value to handle
ir_nonnull_170:
    ; Load variable: i
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 32], rax
    ; Load variable: a
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 32]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    movzx rax, byte [rax]
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    test rax, rax
    jz ir_while_end_168
    ; Load variable: a
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_173
    jmp ir_nonnull_174
ir_trap_null_173:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct15]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Void return - no value to handle
ir_nonnull_174:
    ; Load variable: i
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 64], rax
    ; Load variable: a
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 64]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    movzx rax, byte [rax]
    mov [rbp - 80], rax
    ; Load variable: b
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    test rax, rax
    jz ir_trap_null_175
    jmp ir_nonnull_176
ir_trap_null_175:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct17]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Void return - no value to handle
ir_nonnull_176:
    ; Load variable: i
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 88], rax
    ; Load variable: b
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, [rbp - 88]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    movzx rax, byte [rax]
    mov [rbp - 104], rax
    mov rax, [rbp - 80]
    push rax
    mov rax, [rbp - 104]
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    test rax, rax
    jz ir_if_next_172
    mov rax, 0
    mov [rbp - 120], rax
    mov rax, [rbp - 120]
    test rax, rax
    jz ir_errdefer_ok_177
    jmp ir_errdefer_end_178
ir_errdefer_ok_177:
ir_errdefer_end_178:
    mov rax, 0
    jmp Lstreq_exit
    jmp ir_if_end_171
ir_if_next_172:
ir_if_end_171:
    ; Load variable: i
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 128], rax
    mov rax, [rbp - 128]
    ; Store to variable: i
    mov qword [rbp - 24], rax  ; To stack [rbp - 24]
    jmp ir_while_167
ir_while_end_168:
    ; Load variable: b
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    test rax, rax
    jz ir_trap_null_181
    jmp ir_nonnull_182
ir_trap_null_181:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct19]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Void return - no value to handle
ir_nonnull_182:
    ; Load variable: i
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 136], rax
    ; Load variable: b
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, [rbp - 136]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 144], rax
    mov rax, [rbp - 144]
    movzx rax, byte [rax]
    mov [rbp - 152], rax
    mov rax, [rbp - 152]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 160], rax
    mov rax, [rbp - 160]
    test rax, rax
    jz ir_if_next_180
    mov rax, 0
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    test rax, rax
    jz ir_errdefer_ok_183
    jmp ir_errdefer_end_184
ir_errdefer_ok_183:
ir_errdefer_end_184:
    mov rax, 0
    jmp Lstreq_exit
    jmp ir_if_end_179
ir_if_next_180:
ir_if_end_179:
    mov rax, 1
    mov [rbp - 176], rax
    mov rax, [rbp - 176]
    test rax, rax
    jz ir_errdefer_ok_185
    jmp ir_errdefer_end_186
ir_errdefer_ok_185:
ir_errdefer_end_186:
    mov rax, 1
    jmp Lstreq_exit
Lstreq_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global strncmp

strncmp:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 960    ; Allocate 960 bytes on stack (aligned)
    ; Registering 4 function parameters
    mov [rbp - 8], rcx  ; Home param 'buf'
    ; Parameter 'buf' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'offset'
    ; Parameter 'offset' arrived in register rdx
    mov [rbp - 24], r8  ; Home param 'needle'
    ; Parameter 'needle' arrived in register r8
    mov [rbp - 32], r9  ; Home param 'buf_len'
    ; Parameter 'buf_len' arrived in register r9
ir_entry_187:
    ; Load variable: offset
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_if_next_189
    mov rax, 1
    neg rax
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    test rax, rax
    jz ir_errdefer_ok_190
    jmp ir_errdefer_end_191
ir_errdefer_ok_190:
ir_errdefer_end_191:
    mov rax, [rbp - 56]
    jmp Lstrncmp_exit
    jmp ir_if_end_188
ir_if_next_189:
ir_if_end_188:
    ; Load variable: buf_len
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    test rax, rax
    jz ir_if_next_193
    mov rax, 1
    neg rax
    mov [rbp - 80], rax
    mov rax, [rbp - 80]
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    test rax, rax
    jz ir_errdefer_ok_194
    jmp ir_errdefer_end_195
ir_errdefer_ok_194:
ir_errdefer_end_195:
    mov rax, [rbp - 80]
    jmp Lstrncmp_exit
    jmp ir_if_end_192
ir_if_next_193:
ir_if_end_192:
    ; Load variable: offset
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    ; Load variable: buf_len
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    mov r10, rax
    pop rax
    cmp rax, r10
    setg al
    movzx rax, al
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    test rax, rax
    jz ir_if_next_197
    mov rax, 1
    neg rax
    mov [rbp - 104], rax
    mov rax, [rbp - 104]
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    test rax, rax
    jz ir_errdefer_ok_198
    jmp ir_errdefer_end_199
ir_errdefer_ok_198:
ir_errdefer_end_199:
    mov rax, [rbp - 104]
    jmp Lstrncmp_exit
    jmp ir_if_end_196
ir_if_next_197:
ir_if_end_196:
    mov rax, 0
    ; Store to variable: i
    mov dword [rbp - 36], eax  ; To stack [rbp - 36]
ir_while_200:
    ; Load variable: needle
    mov rax, qword [rbp - 24]  ; String param ptr
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 120], rax
    mov rax, [rbp - 120]
    mov rax, qword [rax]
    mov [rbp - 128], rax
    ; Load variable: i
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    push rax
    mov rax, [rbp - 128]
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 136], rax
    mov rax, [rbp - 136]
    test rax, rax
    jz ir_while_end_201
    ; Load variable: offset
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    ; Load variable: i
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 144], rax
    mov rax, [rbp - 144]
    push rax
    ; Load variable: buf_len
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 152], rax
    mov rax, [rbp - 152]
    test rax, rax
    jz ir_if_next_203
    mov rax, 1
    neg rax
    mov [rbp - 160], rax
    mov rax, [rbp - 160]
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    test rax, rax
    jz ir_errdefer_ok_204
    jmp ir_errdefer_end_205
ir_errdefer_ok_204:
ir_errdefer_end_205:
    mov rax, [rbp - 160]
    jmp Lstrncmp_exit
    jmp ir_if_end_202
ir_if_next_203:
ir_if_end_202:
    ; Load variable: offset
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    ; Load variable: i
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 176], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_208
    jmp ir_nonnull_209
ir_trap_null_208:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct21]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Void return - no value to handle
ir_nonnull_209:
    mov rax, [rbp - 176]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 184], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 184]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 192], rax
    mov rax, [rbp - 192]
    movzx rax, byte [rax]
    mov [rbp - 200], rax
    ; Load variable: needle
    mov rax, qword [rbp - 24]  ; String param ptr
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 208], rax
    mov rax, [rbp - 208]
    mov rax, qword [rax]
    mov [rbp - 216], rax
    mov rax, [rbp - 216]
    test rax, rax
    jz ir_trap_null_210
    jmp ir_nonnull_211
ir_trap_null_210:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct23]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Void return - no value to handle
ir_nonnull_211:
    ; Load variable: i
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 224], rax
    mov rax, [rbp - 216]
    push rax
    mov rax, [rbp - 224]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 232], rax
    mov rax, [rbp - 232]
    movzx rax, byte [rax]
    mov [rbp - 240], rax
    mov rax, [rbp - 200]
    push rax
    mov rax, [rbp - 240]
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 248], rax
    mov rax, [rbp - 248]
    test rax, rax
    jz ir_if_next_207
    ; Load variable: offset
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    ; Load variable: i
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 256], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_212
    jmp ir_nonnull_213
ir_trap_null_212:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct25]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Void return - no value to handle
ir_nonnull_213:
    mov rax, [rbp - 256]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 264], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 264]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 272], rax
    mov rax, [rbp - 272]
    movzx rax, byte [rax]
    mov [rbp - 280], rax
    ; Load variable: needle
    mov rax, qword [rbp - 24]  ; String param ptr
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 288], rax
    mov rax, [rbp - 288]
    mov rax, qword [rax]
    mov [rbp - 296], rax
    mov rax, [rbp - 296]
    test rax, rax
    jz ir_trap_null_214
    jmp ir_nonnull_215
ir_trap_null_214:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct27]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Void return - no value to handle
ir_nonnull_215:
    ; Load variable: i
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 304], rax
    mov rax, [rbp - 296]
    push rax
    mov rax, [rbp - 304]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 312], rax
    mov rax, [rbp - 312]
    movzx rax, byte [rax]
    mov [rbp - 320], rax
    mov rax, [rbp - 280]
    push rax
    mov rax, [rbp - 320]
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 328], rax
    mov rax, [rbp - 328]
    mov [rbp - 336], rax
    mov rax, [rbp - 336]
    test rax, rax
    jz ir_errdefer_ok_216
    jmp ir_errdefer_end_217
ir_errdefer_ok_216:
ir_errdefer_end_217:
    mov rax, [rbp - 328]
    jmp Lstrncmp_exit
    jmp ir_if_end_206
ir_if_next_207:
ir_if_end_206:
    ; Load variable: i
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 344], rax
    mov rax, [rbp - 344]
    ; Store to variable: i
    mov dword [rbp - 36], eax  ; To stack [rbp - 36]
    jmp ir_while_200
ir_while_end_201:
    mov rax, 0
    mov [rbp - 352], rax
    mov rax, [rbp - 352]
    test rax, rax
    jz ir_errdefer_ok_218
    jmp ir_errdefer_end_219
ir_errdefer_ok_218:
ir_errdefer_end_219:
    mov rax, 0
    jmp Lstrncmp_exit
Lstrncmp_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller
    extern rand
    extern srand

global find_matching_close

find_matching_close:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 464    ; Allocate 464 bytes on stack (aligned)
    ; Registering 3 function parameters
    mov [rbp - 8], rcx  ; Home param 'program'
    ; Parameter 'program' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'pc'
    ; Parameter 'pc' arrived in register rdx
    mov [rbp - 24], r8  ; Home param 'len'
    ; Parameter 'len' arrived in register r8
ir_entry_220:
    mov rax, 1
    ; Store to variable: depth
    mov dword [rbp - 28], eax  ; To stack [rbp - 28]
    ; Load variable: pc
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    ; Store to variable: i
    mov dword [rbp - 32], eax  ; To stack [rbp - 32]
ir_while_221:
    ; Load variable: i
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    ; Load variable: len
    movsxd rax, dword [rbp - 24]  ; From stack [rbp - 24]
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_while_end_222
    ; Load variable: program
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_225
    jmp ir_nonnull_226
ir_trap_null_225:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct29]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Void return - no value to handle
ir_nonnull_226:
    ; Load variable: i
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 56], rax
    ; Load variable: program
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 56]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    movzx rax, byte [rax]
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    push rax
    mov rax, 91
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 80], rax
    mov rax, [rbp - 80]
    test rax, rax
    jz ir_if_next_224
    ; Load variable: depth
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    ; Store to variable: depth
    mov dword [rbp - 28], eax  ; To stack [rbp - 28]
    jmp ir_if_end_223
ir_if_next_224:
ir_if_end_223:
    ; Load variable: program
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_229
    jmp ir_nonnull_230
ir_trap_null_229:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct31]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Void return - no value to handle
ir_nonnull_230:
    ; Load variable: i
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 96], rax
    ; Load variable: program
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 96]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 104], rax
    mov rax, [rbp - 104]
    movzx rax, byte [rax]
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    push rax
    mov rax, 93
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 120], rax
    mov rax, [rbp - 120]
    test rax, rax
    jz ir_if_next_228
    ; Load variable: depth
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 128], rax
    mov rax, [rbp - 128]
    ; Store to variable: depth
    mov dword [rbp - 28], eax  ; To stack [rbp - 28]
    ; Load variable: depth
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 136], rax
    mov rax, [rbp - 136]
    test rax, rax
    jz ir_if_next_232
    ; Load variable: i
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    mov [rbp - 144], rax
    mov rax, [rbp - 144]
    test rax, rax
    jz ir_errdefer_ok_233
    jmp ir_errdefer_end_234
ir_errdefer_ok_233:
ir_errdefer_end_234:
    ; Load variable: i
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    jmp Lfind_matching_close_exit
    jmp ir_if_end_231
ir_if_next_232:
ir_if_end_231:
    jmp ir_if_end_227
ir_if_next_228:
ir_if_end_227:
    ; Load variable: i
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 152], rax
    mov rax, [rbp - 152]
    ; Store to variable: i
    mov dword [rbp - 32], eax  ; To stack [rbp - 32]
    jmp ir_while_221
ir_while_end_222:
    mov rax, 1
    neg rax
    mov [rbp - 160], rax
    mov rax, [rbp - 160]
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    test rax, rax
    jz ir_errdefer_ok_235
    jmp ir_errdefer_end_236
ir_errdefer_ok_235:
ir_errdefer_end_236:
    mov rax, [rbp - 160]
    jmp Lfind_matching_close_exit
Lfind_matching_close_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global find_matching_open

find_matching_open:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 448    ; Allocate 448 bytes on stack (aligned)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 'program'
    ; Parameter 'program' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'pc'
    ; Parameter 'pc' arrived in register rdx
ir_entry_237:
    mov rax, 1
    ; Store to variable: depth
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
    ; Load variable: pc
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    ; Store to variable: i
    mov dword [rbp - 24], eax  ; To stack [rbp - 24]
ir_while_238:
    ; Load variable: i
    movsxd rax, dword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_while_end_239
    ; Load variable: program
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_242
    jmp ir_nonnull_243
ir_trap_null_242:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct33]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Void return - no value to handle
ir_nonnull_243:
    ; Load variable: i
    movsxd rax, dword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 48], rax
    ; Load variable: program
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 48]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    movzx rax, byte [rax]
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    push rax
    mov rax, 93
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    test rax, rax
    jz ir_if_next_241
    ; Load variable: depth
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 80], rax
    mov rax, [rbp - 80]
    ; Store to variable: depth
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
    jmp ir_if_end_240
ir_if_next_241:
ir_if_end_240:
    ; Load variable: program
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_246
    jmp ir_nonnull_247
ir_trap_null_246:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct35]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Void return - no value to handle
ir_nonnull_247:
    ; Load variable: i
    movsxd rax, dword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 88], rax
    ; Load variable: program
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 88]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    movzx rax, byte [rax]
    mov [rbp - 104], rax
    mov rax, [rbp - 104]
    push rax
    mov rax, 91
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    test rax, rax
    jz ir_if_next_245
    ; Load variable: depth
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 120], rax
    mov rax, [rbp - 120]
    ; Store to variable: depth
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
    ; Load variable: depth
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 128], rax
    mov rax, [rbp - 128]
    test rax, rax
    jz ir_if_next_249
    ; Load variable: i
    movsxd rax, dword [rbp - 24]  ; From stack [rbp - 24]
    mov [rbp - 136], rax
    mov rax, [rbp - 136]
    test rax, rax
    jz ir_errdefer_ok_250
    jmp ir_errdefer_end_251
ir_errdefer_ok_250:
ir_errdefer_end_251:
    ; Load variable: i
    movsxd rax, dword [rbp - 24]  ; From stack [rbp - 24]
    jmp Lfind_matching_open_exit
    jmp ir_if_end_248
ir_if_next_249:
ir_if_end_248:
    jmp ir_if_end_244
ir_if_next_245:
ir_if_end_244:
    ; Load variable: i
    movsxd rax, dword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 144], rax
    mov rax, [rbp - 144]
    ; Store to variable: i
    mov dword [rbp - 24], eax  ; To stack [rbp - 24]
    jmp ir_while_238
ir_while_end_239:
    mov rax, 1
    neg rax
    mov [rbp - 152], rax
    mov rax, [rbp - 152]
    mov [rbp - 160], rax
    mov rax, [rbp - 160]
    test rax, rax
    jz ir_errdefer_ok_252
    jmp ir_errdefer_end_253
ir_errdefer_ok_252:
ir_errdefer_end_253:
    mov rax, [rbp - 152]
    jmp Lfind_matching_open_exit
Lfind_matching_open_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global bf_run

bf_run:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 1856    ; Allocate 1856 bytes on stack (aligned)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 'program'
    ; Parameter 'program' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'len'
    ; Parameter 'len' arrived in register rdx
ir_entry_254:
    mov rax, 0
    ; Store to variable: pc
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
    mov rax, 0
    ; Store to variable: j
    mov dword [rbp - 24], eax  ; To stack [rbp - 24]
ir_while_255:
    ; Load variable: j
    movsxd rax, dword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 30000
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_while_end_256
    ; Load variable: j
    movsxd rax, dword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 30000
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    test rax, rax
    jz ir_trap_bounds_257
    jmp ir_in_bounds_258
ir_trap_bounds_257:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct37]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Void return - no value to handle
ir_in_bounds_258:
    ; Load variable: j
    movsxd rax, dword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 64], rax
    ; Load variable: tape
    lea rax, [rel tape]  ; Array base address
    push rax
    mov rax, [rbp - 64]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    push rax
    mov rax, 0
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: j
    movsxd rax, dword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    ; Store to variable: j
    mov dword [rbp - 24], eax  ; To stack [rbp - 24]
    jmp ir_while_255
ir_while_end_256:
    mov rax, 0
    ; Store to variable: tape_ptr
    mov dword [rel tape_ptr], eax  ; To global memory
ir_while_259:
    ; Load variable: pc
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    ; Load variable: len
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    test rax, rax
    jz ir_while_end_260
    ; Load variable: program
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_261
    jmp ir_nonnull_262
ir_trap_null_261:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct39]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Void return - no value to handle
ir_nonnull_262:
    ; Load variable: pc
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 104], rax
    ; Load variable: program
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 104]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    movzx rax, byte [rax]
    mov [rbp - 120], rax
    mov rax, [rbp - 120]
    ; Store to variable: cmd
    mov byte [rbp - 25], al  ; To stack [rbp - 25]
    ; Load variable: cmd
    movzx rax, byte [rbp - 25]  ; From stack [rbp - 25]
    push rax
    mov rax, 62
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 128], rax
    mov rax, [rbp - 128]
    test rax, rax
    jz ir_if_next_264
    ; Load variable: tape_ptr
    movsxd rax, dword [rel tape_ptr]  ; From global memory
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 136], rax
    mov rax, [rbp - 136]
    ; Store to variable: tape_ptr
    mov dword [rel tape_ptr], eax  ; To global memory
    ; Load variable: tape_ptr
    movsxd rax, dword [rel tape_ptr]  ; From global memory
    push rax
    mov rax, 30000
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 144], rax
    mov rax, [rbp - 144]
    test rax, rax
    jz ir_if_next_266
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (34 bytes)
    lea rax, [rel Lstr_struct41]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 152], rax
    mov rax, 1
    mov [rbp - 160], rax
    mov rax, [rbp - 160]
    test rax, rax
    jz ir_errdefer_ok_267
    jmp ir_errdefer_end_268
ir_errdefer_ok_267:
ir_errdefer_end_268:
    mov rax, 1
    jmp Lbf_run_exit
    jmp ir_if_end_265
ir_if_next_266:
ir_if_end_265:
    jmp ir_if_end_263
ir_if_next_264:
ir_if_end_263:
    ; Load variable: cmd
    movzx rax, byte [rbp - 25]  ; From stack [rbp - 25]
    push rax
    mov rax, 60
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    test rax, rax
    jz ir_if_next_270
    ; Load variable: tape_ptr
    movsxd rax, dword [rel tape_ptr]  ; From global memory
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 176], rax
    mov rax, [rbp - 176]
    ; Store to variable: tape_ptr
    mov dword [rel tape_ptr], eax  ; To global memory
    ; Load variable: tape_ptr
    movsxd rax, dword [rel tape_ptr]  ; From global memory
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 184], rax
    mov rax, [rbp - 184]
    test rax, rax
    jz ir_if_next_272
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (34 bytes)
    lea rax, [rel Lstr_struct43]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 192], rax
    mov rax, 1
    mov [rbp - 200], rax
    mov rax, [rbp - 200]
    test rax, rax
    jz ir_errdefer_ok_273
    jmp ir_errdefer_end_274
ir_errdefer_ok_273:
ir_errdefer_end_274:
    mov rax, 1
    jmp Lbf_run_exit
    jmp ir_if_end_271
ir_if_next_272:
ir_if_end_271:
    jmp ir_if_end_269
ir_if_next_270:
ir_if_end_269:
    ; Load variable: cmd
    movzx rax, byte [rbp - 25]  ; From stack [rbp - 25]
    push rax
    mov rax, 43
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 208], rax
    mov rax, [rbp - 208]
    test rax, rax
    jz ir_if_next_276
    ; Load variable: tape_ptr
    movsxd rax, dword [rel tape_ptr]  ; From global memory
    push rax
    mov rax, 30000
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 216], rax
    mov rax, [rbp - 216]
    test rax, rax
    jz ir_trap_bounds_277
    jmp ir_in_bounds_278
ir_trap_bounds_277:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct45]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Void return - no value to handle
ir_in_bounds_278:
    ; Load variable: tape_ptr
    movsxd rax, dword [rel tape_ptr]  ; From global memory
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 224], rax
    ; Load variable: tape
    lea rax, [rel tape]  ; Array base address
    push rax
    mov rax, [rbp - 224]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 232], rax
    mov rax, [rbp - 232]
    movzx rax, byte [rax]
    mov [rbp - 240], rax
    mov rax, [rbp - 240]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 248], rax
    ; Load variable: tape_ptr
    movsxd rax, dword [rel tape_ptr]  ; From global memory
    push rax
    mov rax, 30000
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 256], rax
    mov rax, [rbp - 256]
    test rax, rax
    jz ir_trap_bounds_279
    jmp ir_in_bounds_280
ir_trap_bounds_279:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct47]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Void return - no value to handle
ir_in_bounds_280:
    ; Load variable: tape_ptr
    movsxd rax, dword [rel tape_ptr]  ; From global memory
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 264], rax
    ; Load variable: tape
    lea rax, [rel tape]  ; Array base address
    push rax
    mov rax, [rbp - 264]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 272], rax
    mov rax, [rbp - 272]
    push rax
    mov rax, [rbp - 248]
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    jmp ir_if_end_275
ir_if_next_276:
ir_if_end_275:
    ; Load variable: cmd
    movzx rax, byte [rbp - 25]  ; From stack [rbp - 25]
    push rax
    mov rax, 45
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 288], rax
    mov rax, [rbp - 288]
    test rax, rax
    jz ir_if_next_282
    ; Load variable: tape_ptr
    movsxd rax, dword [rel tape_ptr]  ; From global memory
    push rax
    mov rax, 30000
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 296], rax
    mov rax, [rbp - 296]
    test rax, rax
    jz ir_trap_bounds_283
    jmp ir_in_bounds_284
ir_trap_bounds_283:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct49]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Void return - no value to handle
ir_in_bounds_284:
    ; Load variable: tape_ptr
    movsxd rax, dword [rel tape_ptr]  ; From global memory
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 304], rax
    ; Load variable: tape
    lea rax, [rel tape]  ; Array base address
    push rax
    mov rax, [rbp - 304]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 312], rax
    mov rax, [rbp - 312]
    movzx rax, byte [rax]
    mov [rbp - 320], rax
    mov rax, [rbp - 320]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 328], rax
    ; Load variable: tape_ptr
    movsxd rax, dword [rel tape_ptr]  ; From global memory
    push rax
    mov rax, 30000
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 336], rax
    mov rax, [rbp - 336]
    test rax, rax
    jz ir_trap_bounds_285
    jmp ir_in_bounds_286
ir_trap_bounds_285:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct51]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Void return - no value to handle
ir_in_bounds_286:
    ; Load variable: tape_ptr
    movsxd rax, dword [rel tape_ptr]  ; From global memory
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 344], rax
    ; Load variable: tape
    lea rax, [rel tape]  ; Array base address
    push rax
    mov rax, [rbp - 344]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 352], rax
    mov rax, [rbp - 352]
    push rax
    mov rax, [rbp - 328]
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    jmp ir_if_end_281
ir_if_next_282:
ir_if_end_281:
    ; Load variable: cmd
    movzx rax, byte [rbp - 25]  ; From stack [rbp - 25]
    push rax
    mov rax, 46
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 368], rax
    mov rax, [rbp - 368]
    test rax, rax
    jz ir_if_next_288
    ; Load variable: tape_ptr
    movsxd rax, dword [rel tape_ptr]  ; From global memory
    push rax
    mov rax, 30000
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 376], rax
    mov rax, [rbp - 376]
    test rax, rax
    jz ir_trap_bounds_289
    jmp ir_in_bounds_290
ir_trap_bounds_289:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct53]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Void return - no value to handle
ir_in_bounds_290:
    ; Load variable: tape_ptr
    movsxd rax, dword [rel tape_ptr]  ; From global memory
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 384], rax
    ; Load variable: tape
    lea rax, [rel tape]  ; Array base address
    push rax
    mov rax, [rbp - 384]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 392], rax
    mov rax, [rbp - 392]
    movzx rax, byte [rax]
    mov [rbp - 400], rax
    ; IR call: putchar (1 args)
    sub rsp, 32
    mov rax, [rbp - 400]
    mov rcx, rax
    call putchar
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 408], rax
    jmp ir_if_end_287
ir_if_next_288:
ir_if_end_287:
    ; Load variable: cmd
    movzx rax, byte [rbp - 25]  ; From stack [rbp - 25]
    push rax
    mov rax, 44
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 416], rax
    mov rax, [rbp - 416]
    test rax, rax
    jz ir_if_next_292
    ; IR call: getchar (0 args)
    sub rsp, 32
    call getchar
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 424], rax
    ; Load variable: tape_ptr
    movsxd rax, dword [rel tape_ptr]  ; From global memory
    push rax
    mov rax, 30000
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 432], rax
    mov rax, [rbp - 432]
    test rax, rax
    jz ir_trap_bounds_293
    jmp ir_in_bounds_294
ir_trap_bounds_293:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct55]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Void return - no value to handle
ir_in_bounds_294:
    ; Load variable: tape_ptr
    movsxd rax, dword [rel tape_ptr]  ; From global memory
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 440], rax
    ; Load variable: tape
    lea rax, [rel tape]  ; Array base address
    push rax
    mov rax, [rbp - 440]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 448], rax
    mov rax, [rbp - 448]
    push rax
    mov rax, [rbp - 424]
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    jmp ir_if_end_291
ir_if_next_292:
ir_if_end_291:
    ; Load variable: cmd
    movzx rax, byte [rbp - 25]  ; From stack [rbp - 25]
    push rax
    mov rax, 91
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 464], rax
    mov rax, [rbp - 464]
    test rax, rax
    jz ir_if_next_296
    ; Load variable: tape_ptr
    movsxd rax, dword [rel tape_ptr]  ; From global memory
    push rax
    mov rax, 30000
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 472], rax
    mov rax, [rbp - 472]
    test rax, rax
    jz ir_trap_bounds_299
    jmp ir_in_bounds_300
ir_trap_bounds_299:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct57]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Void return - no value to handle
ir_in_bounds_300:
    ; Load variable: tape_ptr
    movsxd rax, dword [rel tape_ptr]  ; From global memory
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 480], rax
    ; Load variable: tape
    lea rax, [rel tape]  ; Array base address
    push rax
    mov rax, [rbp - 480]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 488], rax
    mov rax, [rbp - 488]
    movzx rax, byte [rax]
    mov [rbp - 496], rax
    mov rax, [rbp - 496]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 504], rax
    mov rax, [rbp - 504]
    test rax, rax
    jz ir_if_next_298
    ; IR call: find_matching_close (3 args)
    sub rsp, 32
    ; Load variable: program
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    ; Load variable: pc
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    mov rdx, rax
    ; Load variable: len
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    mov r8, rax
    call find_matching_close
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 512], rax
    mov rax, [rbp - 512]
    ; Store to variable: close
    mov dword [rbp - 32], eax  ; To stack [rbp - 32]
    mov rax, 1
    neg rax
    mov [rbp - 520], rax
    ; Load variable: close
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, [rbp - 520]
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 528], rax
    mov rax, [rbp - 528]
    test rax, rax
    jz ir_if_next_302
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (19 bytes)
    lea rax, [rel Lstr_struct59]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 536], rax
    mov rax, 1
    mov [rbp - 544], rax
    mov rax, [rbp - 544]
    test rax, rax
    jz ir_errdefer_ok_303
    jmp ir_errdefer_end_304
ir_errdefer_ok_303:
ir_errdefer_end_304:
    mov rax, 1
    jmp Lbf_run_exit
    jmp ir_if_end_301
ir_if_next_302:
ir_if_end_301:
    ; Load variable: close
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    ; Store to variable: pc
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
    jmp ir_if_end_297
ir_if_next_298:
ir_if_end_297:
    jmp ir_if_end_295
ir_if_next_296:
ir_if_end_295:
    ; Load variable: cmd
    movzx rax, byte [rbp - 25]  ; From stack [rbp - 25]
    push rax
    mov rax, 93
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 552], rax
    mov rax, [rbp - 552]
    test rax, rax
    jz ir_if_next_306
    ; Load variable: tape_ptr
    movsxd rax, dword [rel tape_ptr]  ; From global memory
    push rax
    mov rax, 30000
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 560], rax
    mov rax, [rbp - 560]
    test rax, rax
    jz ir_trap_bounds_309
    jmp ir_in_bounds_310
ir_trap_bounds_309:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct61]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Void return - no value to handle
ir_in_bounds_310:
    ; Load variable: tape_ptr
    movsxd rax, dword [rel tape_ptr]  ; From global memory
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 568], rax
    ; Load variable: tape
    lea rax, [rel tape]  ; Array base address
    push rax
    mov rax, [rbp - 568]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 576], rax
    mov rax, [rbp - 576]
    movzx rax, byte [rax]
    mov [rbp - 584], rax
    mov rax, [rbp - 584]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 592], rax
    mov rax, [rbp - 592]
    test rax, rax
    jz ir_if_next_308
    ; IR call: find_matching_open (2 args)
    sub rsp, 32
    ; Load variable: program
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    ; Load variable: pc
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    mov rdx, rax
    call find_matching_open
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 600], rax
    mov rax, [rbp - 600]
    ; Store to variable: open
    mov dword [rbp - 36], eax  ; To stack [rbp - 36]
    mov rax, 1
    neg rax
    mov [rbp - 608], rax
    ; Load variable: open
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    push rax
    mov rax, [rbp - 608]
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 616], rax
    mov rax, [rbp - 616]
    test rax, rax
    jz ir_if_next_312
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (19 bytes)
    lea rax, [rel Lstr_struct63]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 624], rax
    mov rax, 1
    mov [rbp - 632], rax
    mov rax, [rbp - 632]
    test rax, rax
    jz ir_errdefer_ok_313
    jmp ir_errdefer_end_314
ir_errdefer_ok_313:
ir_errdefer_end_314:
    mov rax, 1
    jmp Lbf_run_exit
    jmp ir_if_end_311
ir_if_next_312:
ir_if_end_311:
    ; Load variable: open
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    ; Store to variable: pc
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
    jmp ir_if_end_307
ir_if_next_308:
ir_if_end_307:
    jmp ir_if_end_305
ir_if_next_306:
ir_if_end_305:
    ; Load variable: pc
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 640], rax
    mov rax, [rbp - 640]
    ; Store to variable: pc
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
    jmp ir_while_259
ir_while_end_260:
    mov rax, 0
    mov [rbp - 648], rax
    mov rax, [rbp - 648]
    test rax, rax
    jz ir_errdefer_ok_315
    jmp ir_errdefer_end_316
ir_errdefer_ok_315:
ir_errdefer_end_316:
    mov rax, 0
    jmp Lbf_run_exit
Lbf_run_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global main

main:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 192    ; Allocate 192 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_317:
    ; String literal (557 bytes)
    lea rax, [rel Lstr_struct65]  ; Load string struct address
    ; Store to variable: hello
    mov rcx, [rax]       ; string chars
    mov [rbp - 16], rcx
    mov rcx, [rax + 8]   ; string length
    mov [rbp - 8], rcx
    ; Load variable: hello
    lea rax, [rbp - 16]  ; Address of local string
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    mov rax, qword [rax]
    mov [rbp - 40], rax
    ; Load variable: hello
    lea rax, [rbp - 16]  ; Address of local string
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    mov rax, qword [rax]
    mov [rbp - 56], rax
    ; IR call: bf_run (2 args)
    sub rsp, 32
    mov rax, [rbp - 40]
    mov rcx, rax
    mov rax, [rbp - 56]
    mov rdx, rax
    call bf_run
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    ; Store to variable: result
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
    ; Load variable: result
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    test rax, rax
    jz ir_errdefer_ok_318
    jmp ir_errdefer_end_319
ir_errdefer_ok_318:
ir_errdefer_end_319:
    ; Load variable: result
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    jmp Lmain_exit
Lmain_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

; Default program entry point
global mainCRTStartup
mainCRTStartup:
    sub rsp, 40      ; Shadow space + alignment
    ; Initialize garbage collector runtime
    lea rcx, [rsp + 40]
    extern gc_init
    call gc_init
    extern gc_register_root
    lea rcx, [rel tape]
    call gc_register_root
    ; Call user main function
    call main
    mov [rsp + 32], rax ; Preserve main return code
    extern gc_shutdown
    call gc_shutdown
    mov rcx, [rsp + 32] ; Use main return as exit code
    extern ExitProcess
    call ExitProcess

; Data section for global variables
section .data
; Global variable: tape (uint8[30000], 30000 bytes)
section .bss
tape:
    resb 30000
section .data

; Global variable: tape_ptr (int32, 4 bytes)
tape_ptr:
    dd 0

Lstr_chars0:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct1:
    dq Lstr_chars0
    dq 37

Lstr_chars2:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct3:
    dq Lstr_chars2
    dq 37

Lstr_chars4:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct5:
    dq Lstr_chars4
    dq 38

Lstr_chars6:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct7:
    dq Lstr_chars6
    dq 38

Lstr_chars8:
    db 10, 0
    align 8
Lstr_struct9:
    dq Lstr_chars8
    dq 1

Lstr_chars10:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct11:
    dq Lstr_chars10
    dq 37

Lstr_chars12:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct13:
    dq Lstr_chars12
    dq 37

Lstr_chars14:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct15:
    dq Lstr_chars14
    dq 37

Lstr_chars16:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct17:
    dq Lstr_chars16
    dq 37

Lstr_chars18:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct19:
    dq Lstr_chars18
    dq 37

Lstr_chars20:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct21:
    dq Lstr_chars20
    dq 37

Lstr_chars22:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct23:
    dq Lstr_chars22
    dq 37

Lstr_chars24:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct25:
    dq Lstr_chars24
    dq 37

Lstr_chars26:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct27:
    dq Lstr_chars26
    dq 37

Lstr_chars28:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct29:
    dq Lstr_chars28
    dq 37

Lstr_chars30:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct31:
    dq Lstr_chars30
    dq 37

Lstr_chars32:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct33:
    dq Lstr_chars32
    dq 37

Lstr_chars34:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct35:
    dq Lstr_chars34
    dq 37

Lstr_chars36:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct37:
    dq Lstr_chars36
    dq 38

Lstr_chars38:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct39:
    dq Lstr_chars38
    dq 37

Lstr_chars40:
    db "Error: tape pointer out of bounds", 10, 0
    align 8
Lstr_struct41:
    dq Lstr_chars40
    dq 34

Lstr_chars42:
    db "Error: tape pointer out of bounds", 10, 0
    align 8
Lstr_struct43:
    dq Lstr_chars42
    dq 34

Lstr_chars44:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct45:
    dq Lstr_chars44
    dq 38

Lstr_chars46:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct47:
    dq Lstr_chars46
    dq 38

Lstr_chars48:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct49:
    dq Lstr_chars48
    dq 38

Lstr_chars50:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct51:
    dq Lstr_chars50
    dq 38

Lstr_chars52:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct53:
    dq Lstr_chars52
    dq 38

Lstr_chars54:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct55:
    dq Lstr_chars54
    dq 38

Lstr_chars56:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct57:
    dq Lstr_chars56
    dq 38

Lstr_chars58:
    db "Error: unmatched [", 10, 0
    align 8
Lstr_struct59:
    dq Lstr_chars58
    dq 19

Lstr_chars60:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct61:
    dq Lstr_chars60
    dq 38

Lstr_chars62:
    db "Error: unmatched ]", 10, 0
    align 8
Lstr_struct63:
    dq Lstr_chars62
    dq 19

Lstr_chars64:
    db "++++++++++[>+++++++>+++>++++++++++>++++++++++++>++++++++++>+++++++++++>+++++++++++>+++++++++++>++++++++++>+++>++++++++++>++++++++++>++++++++++++>++++++++++>+++>++++++++++++>+++++++++++>+++++++++++>+++++++++++>+++++++++++>+++++++++++>++++++++++>+++>++++++++++++>+++++++++++>++++++++++++>++++++++++>+++>++++++++>++++++++++++>++++++++++++>++++++++++>+++++++++++>+++++++++++<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<-]>+++.>++.>++.>---.>-.>---.>-----.>.>+++.>++.>++++.>---.>----.>+.>++.>-.>+.>++++.>---.>-----.>.>+++.>++.>-.>-----.>----.>++++.>++.>.>+.>----.>++++.>+.>.", 0
    align 8
Lstr_struct65:
    dq Lstr_chars64
    dq 557

