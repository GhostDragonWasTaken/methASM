; Generated by MethASM
; x86-64 Assembly Output

section .text
; Code section

; First pass: processing 54 declarations
; Declaration 0 type: 4 (AST_INLINE_ASM = 20)
; Declaration 1 type: 4 (AST_INLINE_ASM = 20)
; Declaration 2 type: 4 (AST_INLINE_ASM = 20)
; Declaration 3 type: 4 (AST_INLINE_ASM = 20)
; Declaration 4 type: 4 (AST_INLINE_ASM = 20)
; Declaration 5 type: 4 (AST_INLINE_ASM = 20)
; Declaration 6 type: 4 (AST_INLINE_ASM = 20)
; Declaration 7 type: 4 (AST_INLINE_ASM = 20)
; Declaration 8 type: 4 (AST_INLINE_ASM = 20)
; Declaration 9 type: 4 (AST_INLINE_ASM = 20)
; Declaration 10 type: 4 (AST_INLINE_ASM = 20)
; Declaration 11 type: 4 (AST_INLINE_ASM = 20)
; Declaration 12 type: 4 (AST_INLINE_ASM = 20)
; Declaration 13 type: 4 (AST_INLINE_ASM = 20)
; Declaration 14 type: 4 (AST_INLINE_ASM = 20)
; Declaration 15 type: 4 (AST_INLINE_ASM = 20)
; Declaration 16 type: 4 (AST_INLINE_ASM = 20)
; Declaration 17 type: 4 (AST_INLINE_ASM = 20)
; Declaration 18 type: 4 (AST_INLINE_ASM = 20)
; Declaration 19 type: 4 (AST_INLINE_ASM = 20)
; Declaration 20 type: 4 (AST_INLINE_ASM = 20)
; Declaration 21 type: 4 (AST_INLINE_ASM = 20)
; Declaration 22 type: 4 (AST_INLINE_ASM = 20)
; Declaration 23 type: 4 (AST_INLINE_ASM = 20)
; Declaration 24 type: 4 (AST_INLINE_ASM = 20)
; Declaration 25 type: 4 (AST_INLINE_ASM = 20)
; Declaration 26 type: 4 (AST_INLINE_ASM = 20)
; Declaration 27 type: 4 (AST_INLINE_ASM = 20)
; Declaration 28 type: 4 (AST_INLINE_ASM = 20)
; Declaration 29 type: 4 (AST_INLINE_ASM = 20)
; Declaration 30 type: 4 (AST_INLINE_ASM = 20)
; Declaration 31 type: 4 (AST_INLINE_ASM = 20)
; Declaration 32 type: 4 (AST_INLINE_ASM = 20)
; Declaration 33 type: 4 (AST_INLINE_ASM = 20)
; Declaration 34 type: 4 (AST_INLINE_ASM = 20)
; Declaration 35 type: 4 (AST_INLINE_ASM = 20)
; Declaration 36 type: 4 (AST_INLINE_ASM = 20)
; Declaration 37 type: 4 (AST_INLINE_ASM = 20)
; Declaration 38 type: 4 (AST_INLINE_ASM = 20)
; Declaration 39 type: 4 (AST_INLINE_ASM = 20)
; Declaration 40 type: 4 (AST_INLINE_ASM = 20)
; Declaration 41 type: 4 (AST_INLINE_ASM = 20)
; Declaration 42 type: 4 (AST_INLINE_ASM = 20)
; Declaration 43 type: 4 (AST_INLINE_ASM = 20)
; Declaration 44 type: 4 (AST_INLINE_ASM = 20)
; Declaration 45 type: 4 (AST_INLINE_ASM = 20)
; Declaration 46 type: 4 (AST_INLINE_ASM = 20)
; Declaration 47 type: 4 (AST_INLINE_ASM = 20)
; Declaration 48 type: 3 (AST_INLINE_ASM = 20)
; Declaration 49 type: 3 (AST_INLINE_ASM = 20)
; Declaration 50 type: 4 (AST_INLINE_ASM = 20)
; Declaration 51 type: 4 (AST_INLINE_ASM = 20)
; Declaration 52 type: 4 (AST_INLINE_ASM = 20)
; Declaration 53 type: 4 (AST_INLINE_ASM = 20)

section .text
    extern puts
    extern putchar
    extern getchar

global cstr

cstr:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 80    ; Allocate 80 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 's'
    ; Parameter 's' arrived in register rcx
ir_entry_0:
    ; Load variable: s
    mov rax, qword [rbp - 8]  ; String param ptr
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    mov rax, qword [rax]
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_1
    jmp ir_errdefer_end_2
ir_errdefer_ok_1:
ir_errdefer_end_2:
    mov rax, [rbp - 24]
    jmp Lcstr_exit
Lcstr_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global print

print:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 272    ; Allocate 272 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'msg'
    ; Parameter 'msg' arrived in register rcx
ir_entry_3:
    mov rax, 0
    ; Store to variable: i
    mov qword [rbp - 16], rax  ; To stack [rbp - 16]
ir_while_4:
    ; Load variable: msg
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_6
    jmp ir_nonnull_7
ir_trap_null_6:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct1]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    extern exit
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Void return - no value to handle
ir_nonnull_7:
    ; Load variable: i
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 24], rax
    ; Load variable: msg
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 24]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    movzx rax, byte [rax]
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_while_end_5
    ; Load variable: msg
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_8
    jmp ir_nonnull_9
ir_trap_null_8:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct3]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Void return - no value to handle
ir_nonnull_9:
    ; Load variable: i
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 56], rax
    ; Load variable: msg
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 56]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    movzx rax, byte [rax]
    mov [rbp - 72], rax
    ; IR call: putchar (1 args)
    sub rsp, 32
    mov rax, [rbp - 72]
    mov rcx, rax
    call putchar
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 80], rax
    ; Load variable: i
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    ; Store to variable: i
    mov qword [rbp - 16], rax  ; To stack [rbp - 16]
    jmp ir_while_4
ir_while_end_5:
    mov rax, 0
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    test rax, rax
    jz ir_errdefer_ok_10
    jmp ir_errdefer_end_11
ir_errdefer_ok_10:
ir_errdefer_end_11:
    jmp Lprint_exit
Lprint_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global println

println:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 64    ; Allocate 64 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'msg'
    ; Parameter 'msg' arrived in register rcx
ir_entry_12:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; Load variable: msg
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 16], rax
    mov rax, 0
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_errdefer_ok_13
    jmp ir_errdefer_end_14
ir_errdefer_ok_13:
ir_errdefer_end_14:
    jmp Lprintln_exit
Lprintln_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global newline

newline:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 48    ; Allocate 48 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_15:
    ; IR call: putchar (1 args)
    sub rsp, 32
    mov rax, 10
    mov rcx, rax
    call putchar
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 8], rax
    mov rax, 0
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_errdefer_ok_16
    jmp ir_errdefer_end_17
ir_errdefer_ok_16:
ir_errdefer_end_17:
    jmp Lnewline_exit
Lnewline_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global print_int

print_int:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 752    ; Allocate 752 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'n'
    ; Parameter 'n' arrived in register rcx
ir_entry_18:
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 104], rax
    mov rax, [rbp - 104]
    test rax, rax
    jz ir_if_next_20
    ; IR call: putchar (1 args)
    sub rsp, 32
    mov rax, 45
    mov rcx, rax
    call putchar
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 112], rax
    mov rax, 0
    push rax
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 120], rax
    mov rax, [rbp - 120]
    ; Store to variable: n
    mov qword [rbp - 8], rax  ; To stack [rbp - 8]
    jmp ir_if_end_19
ir_if_next_20:
ir_if_end_19:
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 128], rax
    mov rax, [rbp - 128]
    test rax, rax
    jz ir_if_next_22
    ; IR call: putchar (1 args)
    sub rsp, 32
    mov rax, 48
    mov rcx, rax
    call putchar
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 136], rax
    mov rax, 0
    mov [rbp - 144], rax
    mov rax, [rbp - 144]
    test rax, rax
    jz ir_errdefer_ok_23
    jmp ir_errdefer_end_24
ir_errdefer_ok_23:
ir_errdefer_end_24:
    jmp Lprint_int_exit
    jmp ir_if_end_21
ir_if_next_22:
ir_if_end_21:
    mov rax, 0
    ; Store to variable: len
    mov dword [rbp - 92], eax  ; To stack [rbp - 92]
ir_while_25:
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setg al
    movzx rax, al
    mov [rbp - 152], rax
    mov rax, [rbp - 152]
    test rax, rax
    jz ir_while_end_26
    mov rax, 48
    push rax
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 160], rax
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 10
    mov r10, rax
    pop rax
    cqo
    idiv r10
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    push rax
    mov rax, 10
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 176], rax
    mov rax, [rbp - 160]
    push rax
    mov rax, [rbp - 176]
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 184], rax
    ; Load variable: len
    movsxd rax, dword [rbp - 92]  ; From stack [rbp - 92]
    push rax
    mov rax, 20
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 192], rax
    mov rax, [rbp - 192]
    test rax, rax
    jz ir_trap_bounds_27
    jmp ir_in_bounds_28
ir_trap_bounds_27:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct5]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Void return - no value to handle
ir_in_bounds_28:
    ; Load variable: len
    movsxd rax, dword [rbp - 92]  ; From stack [rbp - 92]
    push rax
    mov rax, 4
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 200], rax
    ; Load variable: buf
    lea rax, [rbp - 88]  ; Local array base
    push rax
    mov rax, [rbp - 200]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 208], rax
    mov rax, [rbp - 208]
    push rax
    mov rax, [rbp - 184]
    mov rcx, rax
    pop rax
    mov dword [rax], ecx
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 10
    mov r10, rax
    pop rax
    cqo
    idiv r10
    mov [rbp - 224], rax
    mov rax, [rbp - 224]
    ; Store to variable: n
    mov qword [rbp - 8], rax  ; To stack [rbp - 8]
    ; Load variable: len
    movsxd rax, dword [rbp - 92]  ; From stack [rbp - 92]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 232], rax
    mov rax, [rbp - 232]
    ; Store to variable: len
    mov dword [rbp - 92], eax  ; To stack [rbp - 92]
    jmp ir_while_25
ir_while_end_26:
    ; Load variable: len
    movsxd rax, dword [rbp - 92]  ; From stack [rbp - 92]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 240], rax
    mov rax, [rbp - 240]
    ; Store to variable: i
    mov dword [rbp - 96], eax  ; To stack [rbp - 96]
ir_while_29:
    ; Load variable: i
    movsxd rax, dword [rbp - 96]  ; From stack [rbp - 96]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 248], rax
    mov rax, [rbp - 248]
    test rax, rax
    jz ir_while_end_30
    ; Load variable: i
    movsxd rax, dword [rbp - 96]  ; From stack [rbp - 96]
    push rax
    mov rax, 20
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 256], rax
    mov rax, [rbp - 256]
    test rax, rax
    jz ir_trap_bounds_31
    jmp ir_in_bounds_32
ir_trap_bounds_31:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct7]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Void return - no value to handle
ir_in_bounds_32:
    ; Load variable: i
    movsxd rax, dword [rbp - 96]  ; From stack [rbp - 96]
    push rax
    mov rax, 4
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 264], rax
    ; Load variable: buf
    lea rax, [rbp - 88]  ; Local array base
    push rax
    mov rax, [rbp - 264]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 272], rax
    mov rax, [rbp - 272]
    mov eax, dword [rax]
    mov [rbp - 280], rax
    ; IR call: putchar (1 args)
    sub rsp, 32
    mov rax, [rbp - 280]
    mov rcx, rax
    call putchar
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 288], rax
    ; Load variable: i
    movsxd rax, dword [rbp - 96]  ; From stack [rbp - 96]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 296], rax
    mov rax, [rbp - 296]
    ; Store to variable: i
    mov dword [rbp - 96], eax  ; To stack [rbp - 96]
    jmp ir_while_29
ir_while_end_30:
    mov rax, 0
    mov [rbp - 304], rax
    mov rax, [rbp - 304]
    test rax, rax
    jz ir_errdefer_ok_33
    jmp ir_errdefer_end_34
ir_errdefer_ok_33:
ir_errdefer_end_34:
    jmp Lprint_int_exit
Lprint_int_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global println_int

println_int:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 80    ; Allocate 80 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'n'
    ; Parameter 'n' arrived in register rcx
ir_entry_35:
    ; IR call: print_int (1 args)
    sub rsp, 32
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call print_int
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 16], rax
    ; IR call: putchar (1 args)
    sub rsp, 32
    mov rax, 10
    mov rcx, rax
    call putchar
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 24], rax
    mov rax, 0
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_36
    jmp ir_errdefer_end_37
ir_errdefer_ok_36:
ir_errdefer_end_37:
    jmp Lprintln_int_exit
Lprintln_int_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller
    extern fopen
    extern fclose
    extern fread
    extern fwrite
    extern fputs
    extern fgets
    extern fflush
    extern __acrt_iob_func

global get_stdin

get_stdin:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 48    ; Allocate 48 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_38:
    ; IR call: __acrt_iob_func (1 args)
    sub rsp, 32
    mov rax, 0
    mov rcx, rax
    call __acrt_iob_func
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 8], rax
    mov rax, [rbp - 8]
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_errdefer_ok_39
    jmp ir_errdefer_end_40
ir_errdefer_ok_39:
ir_errdefer_end_40:
    mov rax, [rbp - 8]
    jmp Lget_stdin_exit
Lget_stdin_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global get_stdout

get_stdout:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 48    ; Allocate 48 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_41:
    ; IR call: __acrt_iob_func (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call __acrt_iob_func
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 8], rax
    mov rax, [rbp - 8]
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_errdefer_ok_42
    jmp ir_errdefer_end_43
ir_errdefer_ok_42:
ir_errdefer_end_43:
    mov rax, [rbp - 8]
    jmp Lget_stdout_exit
Lget_stdout_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global get_stderr

get_stderr:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 48    ; Allocate 48 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_44:
    ; IR call: __acrt_iob_func (1 args)
    sub rsp, 32
    mov rax, 2
    mov rcx, rax
    call __acrt_iob_func
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 8], rax
    mov rax, [rbp - 8]
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_errdefer_ok_45
    jmp ir_errdefer_end_46
ir_errdefer_ok_45:
ir_errdefer_end_46:
    mov rax, [rbp - 8]
    jmp Lget_stderr_exit
Lget_stderr_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller
    extern malloc
    extern calloc
    extern realloc
    extern free
    extern memset
    extern memcpy
    extern memmove
    extern memcmp

global alloc_zeroed

alloc_zeroed:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 64    ; Allocate 64 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'n'
    ; Parameter 'n' arrived in register rcx
ir_entry_47:
    ; IR call: calloc (2 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rdx, rax
    call calloc
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_errdefer_ok_48
    jmp ir_errdefer_end_49
ir_errdefer_ok_48:
ir_errdefer_end_49:
    mov rax, [rbp - 16]
    jmp Lalloc_zeroed_exit
Lalloc_zeroed_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global buf_dup

buf_dup:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 160    ; Allocate 160 bytes on stack (aligned)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 'src'
    ; Parameter 'src' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'len'
    ; Parameter 'len' arrived in register rdx
ir_entry_50:
    ; IR call: malloc (1 args)
    sub rsp, 32
    ; Load variable: len
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov rcx, rax
    call malloc
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    ; Store to variable: dst
    mov qword [rbp - 24], rax  ; To stack [rbp - 24]
    ; Load variable: dst
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_if_next_52
    mov rax, 0
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_errdefer_ok_53
    jmp ir_errdefer_end_54
ir_errdefer_ok_53:
ir_errdefer_end_54:
    mov rax, 0
    jmp Lbuf_dup_exit
    jmp ir_if_end_51
ir_if_next_52:
ir_if_end_51:
    ; IR call: memcpy (3 args)
    sub rsp, 32
    ; Load variable: dst
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov rcx, rax
    ; Load variable: src
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rdx, rax
    ; Load variable: len
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov r8, rax
    call memcpy
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 56], rax
    ; Load variable: dst
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    test rax, rax
    jz ir_errdefer_ok_55
    jmp ir_errdefer_end_56
ir_errdefer_ok_55:
ir_errdefer_end_56:
    ; Load variable: dst
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    jmp Lbuf_dup_exit
Lbuf_dup_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller
    extern atoi
    extern atol

global digit_to_char

digit_to_char:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 64    ; Allocate 64 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'd'
    ; Parameter 'd' arrived in register rcx
ir_entry_57:
    ; Load variable: d
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 48
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_errdefer_ok_58
    jmp ir_errdefer_end_59
ir_errdefer_ok_58:
ir_errdefer_end_59:
    mov rax, [rbp - 16]
    jmp Ldigit_to_char_exit
Ldigit_to_char_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global char_to_digit

char_to_digit:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 64    ; Allocate 64 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_60:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 48
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_errdefer_ok_61
    jmp ir_errdefer_end_62
ir_errdefer_ok_61:
ir_errdefer_end_62:
    mov rax, [rbp - 16]
    jmp Lchar_to_digit_exit
Lchar_to_digit_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global is_digit

is_digit:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 112    ; Allocate 112 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_63:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 48
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_if_next_65
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 57
    mov r10, rax
    pop rax
    cmp rax, r10
    setle al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_next_67
    mov rax, 1
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_68
    jmp ir_errdefer_end_69
ir_errdefer_ok_68:
ir_errdefer_end_69:
    mov rax, 1
    jmp Lis_digit_exit
    jmp ir_if_end_66
ir_if_next_67:
ir_if_end_66:
    jmp ir_if_end_64
ir_if_next_65:
ir_if_end_64:
    mov rax, 0
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_errdefer_ok_70
    jmp ir_errdefer_end_71
ir_errdefer_ok_70:
ir_errdefer_end_71:
    mov rax, 0
    jmp Lis_digit_exit
Lis_digit_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global is_upper

is_upper:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 112    ; Allocate 112 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_72:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 65
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_if_next_74
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 90
    mov r10, rax
    pop rax
    cmp rax, r10
    setle al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_next_76
    mov rax, 1
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_77
    jmp ir_errdefer_end_78
ir_errdefer_ok_77:
ir_errdefer_end_78:
    mov rax, 1
    jmp Lis_upper_exit
    jmp ir_if_end_75
ir_if_next_76:
ir_if_end_75:
    jmp ir_if_end_73
ir_if_next_74:
ir_if_end_73:
    mov rax, 0
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_errdefer_ok_79
    jmp ir_errdefer_end_80
ir_errdefer_ok_79:
ir_errdefer_end_80:
    mov rax, 0
    jmp Lis_upper_exit
Lis_upper_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global is_lower

is_lower:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 112    ; Allocate 112 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_81:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 97
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_if_next_83
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 122
    mov r10, rax
    pop rax
    cmp rax, r10
    setle al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_next_85
    mov rax, 1
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_86
    jmp ir_errdefer_end_87
ir_errdefer_ok_86:
ir_errdefer_end_87:
    mov rax, 1
    jmp Lis_lower_exit
    jmp ir_if_end_84
ir_if_next_85:
ir_if_end_84:
    jmp ir_if_end_82
ir_if_next_83:
ir_if_end_82:
    mov rax, 0
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_errdefer_ok_88
    jmp ir_errdefer_end_89
ir_errdefer_ok_88:
ir_errdefer_end_89:
    mov rax, 0
    jmp Lis_lower_exit
Lis_lower_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global is_alpha

is_alpha:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 176    ; Allocate 176 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_90:
    ; IR call: is_upper (1 args)
    sub rsp, 32
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call is_upper
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_next_92
    mov rax, 1
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_93
    jmp ir_errdefer_end_94
ir_errdefer_ok_93:
ir_errdefer_end_94:
    mov rax, 1
    jmp Lis_alpha_exit
    jmp ir_if_end_91
ir_if_next_92:
ir_if_end_91:
    ; IR call: is_lower (1 args)
    sub rsp, 32
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call is_lower
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_if_next_96
    mov rax, 1
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    test rax, rax
    jz ir_errdefer_ok_97
    jmp ir_errdefer_end_98
ir_errdefer_ok_97:
ir_errdefer_end_98:
    mov rax, 1
    jmp Lis_alpha_exit
    jmp ir_if_end_95
ir_if_next_96:
ir_if_end_95:
    mov rax, 0
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    test rax, rax
    jz ir_errdefer_ok_99
    jmp ir_errdefer_end_100
ir_errdefer_ok_99:
ir_errdefer_end_100:
    mov rax, 0
    jmp Lis_alpha_exit
Lis_alpha_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global is_alnum

is_alnum:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 176    ; Allocate 176 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_101:
    ; IR call: is_alpha (1 args)
    sub rsp, 32
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call is_alpha
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_next_103
    mov rax, 1
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_104
    jmp ir_errdefer_end_105
ir_errdefer_ok_104:
ir_errdefer_end_105:
    mov rax, 1
    jmp Lis_alnum_exit
    jmp ir_if_end_102
ir_if_next_103:
ir_if_end_102:
    ; IR call: is_digit (1 args)
    sub rsp, 32
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call is_digit
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_if_next_107
    mov rax, 1
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    test rax, rax
    jz ir_errdefer_ok_108
    jmp ir_errdefer_end_109
ir_errdefer_ok_108:
ir_errdefer_end_109:
    mov rax, 1
    jmp Lis_alnum_exit
    jmp ir_if_end_106
ir_if_next_107:
ir_if_end_106:
    mov rax, 0
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    test rax, rax
    jz ir_errdefer_ok_110
    jmp ir_errdefer_end_111
ir_errdefer_ok_110:
ir_errdefer_end_111:
    mov rax, 0
    jmp Lis_alnum_exit
Lis_alnum_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global is_space

is_space:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 320    ; Allocate 320 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_112:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 32
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_if_next_114
    mov rax, 1
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_errdefer_ok_115
    jmp ir_errdefer_end_116
ir_errdefer_ok_115:
ir_errdefer_end_116:
    mov rax, 1
    jmp Lis_space_exit
    jmp ir_if_end_113
ir_if_next_114:
ir_if_end_113:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 9
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_if_next_118
    mov rax, 1
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_errdefer_ok_119
    jmp ir_errdefer_end_120
ir_errdefer_ok_119:
ir_errdefer_end_120:
    mov rax, 1
    jmp Lis_space_exit
    jmp ir_if_end_117
ir_if_next_118:
ir_if_end_117:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 10
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_if_next_122
    mov rax, 1
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    test rax, rax
    jz ir_errdefer_ok_123
    jmp ir_errdefer_end_124
ir_errdefer_ok_123:
ir_errdefer_end_124:
    mov rax, 1
    jmp Lis_space_exit
    jmp ir_if_end_121
ir_if_next_122:
ir_if_end_121:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 13
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    test rax, rax
    jz ir_if_next_126
    mov rax, 1
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    test rax, rax
    jz ir_errdefer_ok_127
    jmp ir_errdefer_end_128
ir_errdefer_ok_127:
ir_errdefer_end_128:
    mov rax, 1
    jmp Lis_space_exit
    jmp ir_if_end_125
ir_if_next_126:
ir_if_end_125:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 12
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 80], rax
    mov rax, [rbp - 80]
    test rax, rax
    jz ir_if_next_130
    mov rax, 1
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    test rax, rax
    jz ir_errdefer_ok_131
    jmp ir_errdefer_end_132
ir_errdefer_ok_131:
ir_errdefer_end_132:
    mov rax, 1
    jmp Lis_space_exit
    jmp ir_if_end_129
ir_if_next_130:
ir_if_end_129:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 11
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    test rax, rax
    jz ir_if_next_134
    mov rax, 1
    mov [rbp - 104], rax
    mov rax, [rbp - 104]
    test rax, rax
    jz ir_errdefer_ok_135
    jmp ir_errdefer_end_136
ir_errdefer_ok_135:
ir_errdefer_end_136:
    mov rax, 1
    jmp Lis_space_exit
    jmp ir_if_end_133
ir_if_next_134:
ir_if_end_133:
    mov rax, 0
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    test rax, rax
    jz ir_errdefer_ok_137
    jmp ir_errdefer_end_138
ir_errdefer_ok_137:
ir_errdefer_end_138:
    mov rax, 0
    jmp Lis_space_exit
Lis_space_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global to_lower

to_lower:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 128    ; Allocate 128 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_139:
    ; IR call: is_upper (1 args)
    sub rsp, 32
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call is_upper
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_next_141
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 32
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_errdefer_ok_142
    jmp ir_errdefer_end_143
ir_errdefer_ok_142:
ir_errdefer_end_143:
    mov rax, [rbp - 32]
    jmp Lto_lower_exit
    jmp ir_if_end_140
ir_if_next_141:
ir_if_end_140:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_errdefer_ok_144
    jmp ir_errdefer_end_145
ir_errdefer_ok_144:
ir_errdefer_end_145:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    jmp Lto_lower_exit
Lto_lower_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global to_upper

to_upper:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 128    ; Allocate 128 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_146:
    ; IR call: is_lower (1 args)
    sub rsp, 32
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call is_lower
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_next_148
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 32
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_errdefer_ok_149
    jmp ir_errdefer_end_150
ir_errdefer_ok_149:
ir_errdefer_end_150:
    mov rax, [rbp - 32]
    jmp Lto_upper_exit
    jmp ir_if_end_147
ir_if_next_148:
ir_if_end_147:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_errdefer_ok_151
    jmp ir_errdefer_end_152
ir_errdefer_ok_151:
ir_errdefer_end_152:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    jmp Lto_upper_exit
Lto_upper_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global strlen

strlen:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 176    ; Allocate 176 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 's'
    ; Parameter 's' arrived in register rcx
ir_entry_153:
    mov rax, 0
    ; Store to variable: i
    mov qword [rbp - 16], rax  ; To stack [rbp - 16]
ir_while_154:
    ; Load variable: s
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_156
    jmp ir_nonnull_157
ir_trap_null_156:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct9]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Void return - no value to handle
ir_nonnull_157:
    ; Load variable: i
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 24], rax
    ; Load variable: s
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 24]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    movzx rax, byte [rax]
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_while_end_155
    ; Load variable: i
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    ; Store to variable: i
    mov qword [rbp - 16], rax  ; To stack [rbp - 16]
    jmp ir_while_154
ir_while_end_155:
    ; Load variable: i
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    test rax, rax
    jz ir_errdefer_ok_158
    jmp ir_errdefer_end_159
ir_errdefer_ok_158:
ir_errdefer_end_159:
    ; Load variable: i
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    jmp Lstrlen_exit
Lstrlen_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global streq

streq:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 480    ; Allocate 480 bytes on stack (aligned)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 'a'
    ; Parameter 'a' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'b'
    ; Parameter 'b' arrived in register rdx
ir_entry_160:
    mov rax, 0
    ; Store to variable: i
    mov qword [rbp - 24], rax  ; To stack [rbp - 24]
ir_while_161:
    ; Load variable: a
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_163
    jmp ir_nonnull_164
ir_trap_null_163:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct11]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Void return - no value to handle
ir_nonnull_164:
    ; Load variable: i
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 32], rax
    ; Load variable: a
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 32]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    movzx rax, byte [rax]
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    test rax, rax
    jz ir_while_end_162
    ; Load variable: a
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_167
    jmp ir_nonnull_168
ir_trap_null_167:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct13]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Void return - no value to handle
ir_nonnull_168:
    ; Load variable: i
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 64], rax
    ; Load variable: a
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 64]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    movzx rax, byte [rax]
    mov [rbp - 80], rax
    ; Load variable: b
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    test rax, rax
    jz ir_trap_null_169
    jmp ir_nonnull_170
ir_trap_null_169:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct15]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Void return - no value to handle
ir_nonnull_170:
    ; Load variable: i
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 88], rax
    ; Load variable: b
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, [rbp - 88]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    movzx rax, byte [rax]
    mov [rbp - 104], rax
    mov rax, [rbp - 80]
    push rax
    mov rax, [rbp - 104]
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    test rax, rax
    jz ir_if_next_166
    mov rax, 0
    mov [rbp - 120], rax
    mov rax, [rbp - 120]
    test rax, rax
    jz ir_errdefer_ok_171
    jmp ir_errdefer_end_172
ir_errdefer_ok_171:
ir_errdefer_end_172:
    mov rax, 0
    jmp Lstreq_exit
    jmp ir_if_end_165
ir_if_next_166:
ir_if_end_165:
    ; Load variable: i
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 128], rax
    mov rax, [rbp - 128]
    ; Store to variable: i
    mov qword [rbp - 24], rax  ; To stack [rbp - 24]
    jmp ir_while_161
ir_while_end_162:
    ; Load variable: b
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    test rax, rax
    jz ir_trap_null_175
    jmp ir_nonnull_176
ir_trap_null_175:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct17]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Void return - no value to handle
ir_nonnull_176:
    ; Load variable: i
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 136], rax
    ; Load variable: b
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, [rbp - 136]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 144], rax
    mov rax, [rbp - 144]
    movzx rax, byte [rax]
    mov [rbp - 152], rax
    mov rax, [rbp - 152]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 160], rax
    mov rax, [rbp - 160]
    test rax, rax
    jz ir_if_next_174
    mov rax, 0
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    test rax, rax
    jz ir_errdefer_ok_177
    jmp ir_errdefer_end_178
ir_errdefer_ok_177:
ir_errdefer_end_178:
    mov rax, 0
    jmp Lstreq_exit
    jmp ir_if_end_173
ir_if_next_174:
ir_if_end_173:
    mov rax, 1
    mov [rbp - 176], rax
    mov rax, [rbp - 176]
    test rax, rax
    jz ir_errdefer_ok_179
    jmp ir_errdefer_end_180
ir_errdefer_ok_179:
ir_errdefer_end_180:
    mov rax, 1
    jmp Lstreq_exit
Lstreq_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global strncmp

strncmp:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 960    ; Allocate 960 bytes on stack (aligned)
    ; Registering 4 function parameters
    mov [rbp - 8], rcx  ; Home param 'buf'
    ; Parameter 'buf' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'offset'
    ; Parameter 'offset' arrived in register rdx
    mov [rbp - 24], r8  ; Home param 'needle'
    ; Parameter 'needle' arrived in register r8
    mov [rbp - 32], r9  ; Home param 'buf_len'
    ; Parameter 'buf_len' arrived in register r9
ir_entry_181:
    ; Load variable: offset
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_if_next_183
    mov rax, 1
    neg rax
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    test rax, rax
    jz ir_errdefer_ok_184
    jmp ir_errdefer_end_185
ir_errdefer_ok_184:
ir_errdefer_end_185:
    mov rax, [rbp - 56]
    jmp Lstrncmp_exit
    jmp ir_if_end_182
ir_if_next_183:
ir_if_end_182:
    ; Load variable: buf_len
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    test rax, rax
    jz ir_if_next_187
    mov rax, 1
    neg rax
    mov [rbp - 80], rax
    mov rax, [rbp - 80]
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    test rax, rax
    jz ir_errdefer_ok_188
    jmp ir_errdefer_end_189
ir_errdefer_ok_188:
ir_errdefer_end_189:
    mov rax, [rbp - 80]
    jmp Lstrncmp_exit
    jmp ir_if_end_186
ir_if_next_187:
ir_if_end_186:
    ; Load variable: offset
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    ; Load variable: buf_len
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    mov r10, rax
    pop rax
    cmp rax, r10
    setg al
    movzx rax, al
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    test rax, rax
    jz ir_if_next_191
    mov rax, 1
    neg rax
    mov [rbp - 104], rax
    mov rax, [rbp - 104]
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    test rax, rax
    jz ir_errdefer_ok_192
    jmp ir_errdefer_end_193
ir_errdefer_ok_192:
ir_errdefer_end_193:
    mov rax, [rbp - 104]
    jmp Lstrncmp_exit
    jmp ir_if_end_190
ir_if_next_191:
ir_if_end_190:
    mov rax, 0
    ; Store to variable: i
    mov dword [rbp - 36], eax  ; To stack [rbp - 36]
ir_while_194:
    ; Load variable: needle
    mov rax, qword [rbp - 24]  ; String param ptr
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 120], rax
    mov rax, [rbp - 120]
    mov rax, qword [rax]
    mov [rbp - 128], rax
    ; Load variable: i
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    push rax
    mov rax, [rbp - 128]
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 136], rax
    mov rax, [rbp - 136]
    test rax, rax
    jz ir_while_end_195
    ; Load variable: offset
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    ; Load variable: i
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 144], rax
    mov rax, [rbp - 144]
    push rax
    ; Load variable: buf_len
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 152], rax
    mov rax, [rbp - 152]
    test rax, rax
    jz ir_if_next_197
    mov rax, 1
    neg rax
    mov [rbp - 160], rax
    mov rax, [rbp - 160]
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    test rax, rax
    jz ir_errdefer_ok_198
    jmp ir_errdefer_end_199
ir_errdefer_ok_198:
ir_errdefer_end_199:
    mov rax, [rbp - 160]
    jmp Lstrncmp_exit
    jmp ir_if_end_196
ir_if_next_197:
ir_if_end_196:
    ; Load variable: offset
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    ; Load variable: i
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 176], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_202
    jmp ir_nonnull_203
ir_trap_null_202:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct19]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Void return - no value to handle
ir_nonnull_203:
    mov rax, [rbp - 176]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 184], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 184]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 192], rax
    mov rax, [rbp - 192]
    movzx rax, byte [rax]
    mov [rbp - 200], rax
    ; Load variable: needle
    mov rax, qword [rbp - 24]  ; String param ptr
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 208], rax
    mov rax, [rbp - 208]
    mov rax, qword [rax]
    mov [rbp - 216], rax
    mov rax, [rbp - 216]
    test rax, rax
    jz ir_trap_null_204
    jmp ir_nonnull_205
ir_trap_null_204:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct21]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Void return - no value to handle
ir_nonnull_205:
    ; Load variable: i
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 224], rax
    mov rax, [rbp - 216]
    push rax
    mov rax, [rbp - 224]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 232], rax
    mov rax, [rbp - 232]
    movzx rax, byte [rax]
    mov [rbp - 240], rax
    mov rax, [rbp - 200]
    push rax
    mov rax, [rbp - 240]
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 248], rax
    mov rax, [rbp - 248]
    test rax, rax
    jz ir_if_next_201
    ; Load variable: offset
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    ; Load variable: i
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 256], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_206
    jmp ir_nonnull_207
ir_trap_null_206:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct23]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Void return - no value to handle
ir_nonnull_207:
    mov rax, [rbp - 256]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 264], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 264]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 272], rax
    mov rax, [rbp - 272]
    movzx rax, byte [rax]
    mov [rbp - 280], rax
    ; Load variable: needle
    mov rax, qword [rbp - 24]  ; String param ptr
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 288], rax
    mov rax, [rbp - 288]
    mov rax, qword [rax]
    mov [rbp - 296], rax
    mov rax, [rbp - 296]
    test rax, rax
    jz ir_trap_null_208
    jmp ir_nonnull_209
ir_trap_null_208:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct25]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Void return - no value to handle
ir_nonnull_209:
    ; Load variable: i
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 304], rax
    mov rax, [rbp - 296]
    push rax
    mov rax, [rbp - 304]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 312], rax
    mov rax, [rbp - 312]
    movzx rax, byte [rax]
    mov [rbp - 320], rax
    mov rax, [rbp - 280]
    push rax
    mov rax, [rbp - 320]
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 328], rax
    mov rax, [rbp - 328]
    mov [rbp - 336], rax
    mov rax, [rbp - 336]
    test rax, rax
    jz ir_errdefer_ok_210
    jmp ir_errdefer_end_211
ir_errdefer_ok_210:
ir_errdefer_end_211:
    mov rax, [rbp - 328]
    jmp Lstrncmp_exit
    jmp ir_if_end_200
ir_if_next_201:
ir_if_end_200:
    ; Load variable: i
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 344], rax
    mov rax, [rbp - 344]
    ; Store to variable: i
    mov dword [rbp - 36], eax  ; To stack [rbp - 36]
    jmp ir_while_194
ir_while_end_195:
    mov rax, 0
    mov [rbp - 352], rax
    mov rax, [rbp - 352]
    test rax, rax
    jz ir_errdefer_ok_212
    jmp ir_errdefer_end_213
ir_errdefer_ok_212:
ir_errdefer_end_213:
    mov rax, 0
    jmp Lstrncmp_exit
Lstrncmp_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller
    extern rand
    extern srand

global find_matching_close

find_matching_close:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 464    ; Allocate 464 bytes on stack (aligned)
    ; Registering 3 function parameters
    mov [rbp - 8], rcx  ; Home param 'program'
    ; Parameter 'program' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'pc'
    ; Parameter 'pc' arrived in register rdx
    mov [rbp - 24], r8  ; Home param 'len'
    ; Parameter 'len' arrived in register r8
ir_entry_214:
    mov rax, 1
    ; Store to variable: depth
    mov dword [rbp - 28], eax  ; To stack [rbp - 28]
    ; Load variable: pc
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    ; Store to variable: i
    mov dword [rbp - 32], eax  ; To stack [rbp - 32]
ir_while_215:
    ; Load variable: i
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    ; Load variable: len
    movsxd rax, dword [rbp - 24]  ; From stack [rbp - 24]
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_while_end_216
    ; Load variable: program
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_219
    jmp ir_nonnull_220
ir_trap_null_219:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct27]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Void return - no value to handle
ir_nonnull_220:
    ; Load variable: i
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 56], rax
    ; Load variable: program
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 56]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    movzx rax, byte [rax]
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    push rax
    mov rax, 91
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 80], rax
    mov rax, [rbp - 80]
    test rax, rax
    jz ir_if_next_218
    ; Load variable: depth
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    ; Store to variable: depth
    mov dword [rbp - 28], eax  ; To stack [rbp - 28]
    jmp ir_if_end_217
ir_if_next_218:
ir_if_end_217:
    ; Load variable: program
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_223
    jmp ir_nonnull_224
ir_trap_null_223:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct29]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Void return - no value to handle
ir_nonnull_224:
    ; Load variable: i
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 96], rax
    ; Load variable: program
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 96]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 104], rax
    mov rax, [rbp - 104]
    movzx rax, byte [rax]
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    push rax
    mov rax, 93
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 120], rax
    mov rax, [rbp - 120]
    test rax, rax
    jz ir_if_next_222
    ; Load variable: depth
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 128], rax
    mov rax, [rbp - 128]
    ; Store to variable: depth
    mov dword [rbp - 28], eax  ; To stack [rbp - 28]
    ; Load variable: depth
    movsxd rax, dword [rbp - 28]  ; From stack [rbp - 28]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 136], rax
    mov rax, [rbp - 136]
    test rax, rax
    jz ir_if_next_226
    ; Load variable: i
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    mov [rbp - 144], rax
    mov rax, [rbp - 144]
    test rax, rax
    jz ir_errdefer_ok_227
    jmp ir_errdefer_end_228
ir_errdefer_ok_227:
ir_errdefer_end_228:
    ; Load variable: i
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    jmp Lfind_matching_close_exit
    jmp ir_if_end_225
ir_if_next_226:
ir_if_end_225:
    jmp ir_if_end_221
ir_if_next_222:
ir_if_end_221:
    ; Load variable: i
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 152], rax
    mov rax, [rbp - 152]
    ; Store to variable: i
    mov dword [rbp - 32], eax  ; To stack [rbp - 32]
    jmp ir_while_215
ir_while_end_216:
    mov rax, 1
    neg rax
    mov [rbp - 160], rax
    mov rax, [rbp - 160]
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    test rax, rax
    jz ir_errdefer_ok_229
    jmp ir_errdefer_end_230
ir_errdefer_ok_229:
ir_errdefer_end_230:
    mov rax, [rbp - 160]
    jmp Lfind_matching_close_exit
Lfind_matching_close_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global find_matching_open

find_matching_open:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 448    ; Allocate 448 bytes on stack (aligned)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 'program'
    ; Parameter 'program' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'pc'
    ; Parameter 'pc' arrived in register rdx
ir_entry_231:
    mov rax, 1
    ; Store to variable: depth
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
    ; Load variable: pc
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    ; Store to variable: i
    mov dword [rbp - 24], eax  ; To stack [rbp - 24]
ir_while_232:
    ; Load variable: i
    movsxd rax, dword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_while_end_233
    ; Load variable: program
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_236
    jmp ir_nonnull_237
ir_trap_null_236:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct31]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Void return - no value to handle
ir_nonnull_237:
    ; Load variable: i
    movsxd rax, dword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 48], rax
    ; Load variable: program
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 48]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    movzx rax, byte [rax]
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    push rax
    mov rax, 93
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    test rax, rax
    jz ir_if_next_235
    ; Load variable: depth
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 80], rax
    mov rax, [rbp - 80]
    ; Store to variable: depth
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
    jmp ir_if_end_234
ir_if_next_235:
ir_if_end_234:
    ; Load variable: program
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_240
    jmp ir_nonnull_241
ir_trap_null_240:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct33]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Void return - no value to handle
ir_nonnull_241:
    ; Load variable: i
    movsxd rax, dword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 88], rax
    ; Load variable: program
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 88]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    movzx rax, byte [rax]
    mov [rbp - 104], rax
    mov rax, [rbp - 104]
    push rax
    mov rax, 91
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    test rax, rax
    jz ir_if_next_239
    ; Load variable: depth
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 120], rax
    mov rax, [rbp - 120]
    ; Store to variable: depth
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
    ; Load variable: depth
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 128], rax
    mov rax, [rbp - 128]
    test rax, rax
    jz ir_if_next_243
    ; Load variable: i
    movsxd rax, dword [rbp - 24]  ; From stack [rbp - 24]
    mov [rbp - 136], rax
    mov rax, [rbp - 136]
    test rax, rax
    jz ir_errdefer_ok_244
    jmp ir_errdefer_end_245
ir_errdefer_ok_244:
ir_errdefer_end_245:
    ; Load variable: i
    movsxd rax, dword [rbp - 24]  ; From stack [rbp - 24]
    jmp Lfind_matching_open_exit
    jmp ir_if_end_242
ir_if_next_243:
ir_if_end_242:
    jmp ir_if_end_238
ir_if_next_239:
ir_if_end_238:
    ; Load variable: i
    movsxd rax, dword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 144], rax
    mov rax, [rbp - 144]
    ; Store to variable: i
    mov dword [rbp - 24], eax  ; To stack [rbp - 24]
    jmp ir_while_232
ir_while_end_233:
    mov rax, 1
    neg rax
    mov [rbp - 152], rax
    mov rax, [rbp - 152]
    mov [rbp - 160], rax
    mov rax, [rbp - 160]
    test rax, rax
    jz ir_errdefer_ok_246
    jmp ir_errdefer_end_247
ir_errdefer_ok_246:
ir_errdefer_end_247:
    mov rax, [rbp - 152]
    jmp Lfind_matching_open_exit
Lfind_matching_open_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global bf_run

bf_run:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 1856    ; Allocate 1856 bytes on stack (aligned)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 'program'
    ; Parameter 'program' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'len'
    ; Parameter 'len' arrived in register rdx
ir_entry_248:
    mov rax, 0
    ; Store to variable: pc
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
    mov rax, 0
    ; Store to variable: j
    mov dword [rbp - 24], eax  ; To stack [rbp - 24]
ir_while_249:
    ; Load variable: j
    movsxd rax, dword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 30000
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_while_end_250
    ; Load variable: j
    movsxd rax, dword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 30000
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    test rax, rax
    jz ir_trap_bounds_251
    jmp ir_in_bounds_252
ir_trap_bounds_251:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct35]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Void return - no value to handle
ir_in_bounds_252:
    ; Load variable: j
    movsxd rax, dword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 64], rax
    ; Load variable: tape
    lea rax, [rel tape]  ; Array base address
    push rax
    mov rax, [rbp - 64]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    push rax
    mov rax, 0
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: j
    movsxd rax, dword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    ; Store to variable: j
    mov dword [rbp - 24], eax  ; To stack [rbp - 24]
    jmp ir_while_249
ir_while_end_250:
    mov rax, 0
    ; Store to variable: tape_ptr
    mov dword [rel tape_ptr], eax  ; To global memory
ir_while_253:
    ; Load variable: pc
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    ; Load variable: len
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    test rax, rax
    jz ir_while_end_254
    ; Load variable: program
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_255
    jmp ir_nonnull_256
ir_trap_null_255:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct37]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Void return - no value to handle
ir_nonnull_256:
    ; Load variable: pc
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 104], rax
    ; Load variable: program
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 104]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    movzx rax, byte [rax]
    mov [rbp - 120], rax
    mov rax, [rbp - 120]
    ; Store to variable: cmd
    mov byte [rbp - 25], al  ; To stack [rbp - 25]
    ; Load variable: cmd
    movzx rax, byte [rbp - 25]  ; From stack [rbp - 25]
    push rax
    mov rax, 62
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 128], rax
    mov rax, [rbp - 128]
    test rax, rax
    jz ir_if_next_258
    ; Load variable: tape_ptr
    movsxd rax, dword [rel tape_ptr]  ; From global memory
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 136], rax
    mov rax, [rbp - 136]
    ; Store to variable: tape_ptr
    mov dword [rel tape_ptr], eax  ; To global memory
    ; Load variable: tape_ptr
    movsxd rax, dword [rel tape_ptr]  ; From global memory
    push rax
    mov rax, 30000
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 144], rax
    mov rax, [rbp - 144]
    test rax, rax
    jz ir_if_next_260
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (34 bytes)
    lea rax, [rel Lstr_struct39]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 152], rax
    mov rax, 1
    mov [rbp - 160], rax
    mov rax, [rbp - 160]
    test rax, rax
    jz ir_errdefer_ok_261
    jmp ir_errdefer_end_262
ir_errdefer_ok_261:
ir_errdefer_end_262:
    mov rax, 1
    jmp Lbf_run_exit
    jmp ir_if_end_259
ir_if_next_260:
ir_if_end_259:
    jmp ir_if_end_257
ir_if_next_258:
ir_if_end_257:
    ; Load variable: cmd
    movzx rax, byte [rbp - 25]  ; From stack [rbp - 25]
    push rax
    mov rax, 60
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    test rax, rax
    jz ir_if_next_264
    ; Load variable: tape_ptr
    movsxd rax, dword [rel tape_ptr]  ; From global memory
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 176], rax
    mov rax, [rbp - 176]
    ; Store to variable: tape_ptr
    mov dword [rel tape_ptr], eax  ; To global memory
    ; Load variable: tape_ptr
    movsxd rax, dword [rel tape_ptr]  ; From global memory
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 184], rax
    mov rax, [rbp - 184]
    test rax, rax
    jz ir_if_next_266
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (34 bytes)
    lea rax, [rel Lstr_struct41]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 192], rax
    mov rax, 1
    mov [rbp - 200], rax
    mov rax, [rbp - 200]
    test rax, rax
    jz ir_errdefer_ok_267
    jmp ir_errdefer_end_268
ir_errdefer_ok_267:
ir_errdefer_end_268:
    mov rax, 1
    jmp Lbf_run_exit
    jmp ir_if_end_265
ir_if_next_266:
ir_if_end_265:
    jmp ir_if_end_263
ir_if_next_264:
ir_if_end_263:
    ; Load variable: cmd
    movzx rax, byte [rbp - 25]  ; From stack [rbp - 25]
    push rax
    mov rax, 43
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 208], rax
    mov rax, [rbp - 208]
    test rax, rax
    jz ir_if_next_270
    ; Load variable: tape_ptr
    movsxd rax, dword [rel tape_ptr]  ; From global memory
    push rax
    mov rax, 30000
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 216], rax
    mov rax, [rbp - 216]
    test rax, rax
    jz ir_trap_bounds_271
    jmp ir_in_bounds_272
ir_trap_bounds_271:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct43]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Void return - no value to handle
ir_in_bounds_272:
    ; Load variable: tape_ptr
    movsxd rax, dword [rel tape_ptr]  ; From global memory
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 224], rax
    ; Load variable: tape
    lea rax, [rel tape]  ; Array base address
    push rax
    mov rax, [rbp - 224]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 232], rax
    mov rax, [rbp - 232]
    movzx rax, byte [rax]
    mov [rbp - 240], rax
    mov rax, [rbp - 240]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 248], rax
    ; Load variable: tape_ptr
    movsxd rax, dword [rel tape_ptr]  ; From global memory
    push rax
    mov rax, 30000
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 256], rax
    mov rax, [rbp - 256]
    test rax, rax
    jz ir_trap_bounds_273
    jmp ir_in_bounds_274
ir_trap_bounds_273:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct45]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Void return - no value to handle
ir_in_bounds_274:
    ; Load variable: tape_ptr
    movsxd rax, dword [rel tape_ptr]  ; From global memory
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 264], rax
    ; Load variable: tape
    lea rax, [rel tape]  ; Array base address
    push rax
    mov rax, [rbp - 264]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 272], rax
    mov rax, [rbp - 272]
    push rax
    mov rax, [rbp - 248]
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    jmp ir_if_end_269
ir_if_next_270:
ir_if_end_269:
    ; Load variable: cmd
    movzx rax, byte [rbp - 25]  ; From stack [rbp - 25]
    push rax
    mov rax, 45
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 288], rax
    mov rax, [rbp - 288]
    test rax, rax
    jz ir_if_next_276
    ; Load variable: tape_ptr
    movsxd rax, dword [rel tape_ptr]  ; From global memory
    push rax
    mov rax, 30000
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 296], rax
    mov rax, [rbp - 296]
    test rax, rax
    jz ir_trap_bounds_277
    jmp ir_in_bounds_278
ir_trap_bounds_277:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct47]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Void return - no value to handle
ir_in_bounds_278:
    ; Load variable: tape_ptr
    movsxd rax, dword [rel tape_ptr]  ; From global memory
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 304], rax
    ; Load variable: tape
    lea rax, [rel tape]  ; Array base address
    push rax
    mov rax, [rbp - 304]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 312], rax
    mov rax, [rbp - 312]
    movzx rax, byte [rax]
    mov [rbp - 320], rax
    mov rax, [rbp - 320]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 328], rax
    ; Load variable: tape_ptr
    movsxd rax, dword [rel tape_ptr]  ; From global memory
    push rax
    mov rax, 30000
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 336], rax
    mov rax, [rbp - 336]
    test rax, rax
    jz ir_trap_bounds_279
    jmp ir_in_bounds_280
ir_trap_bounds_279:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct49]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Void return - no value to handle
ir_in_bounds_280:
    ; Load variable: tape_ptr
    movsxd rax, dword [rel tape_ptr]  ; From global memory
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 344], rax
    ; Load variable: tape
    lea rax, [rel tape]  ; Array base address
    push rax
    mov rax, [rbp - 344]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 352], rax
    mov rax, [rbp - 352]
    push rax
    mov rax, [rbp - 328]
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    jmp ir_if_end_275
ir_if_next_276:
ir_if_end_275:
    ; Load variable: cmd
    movzx rax, byte [rbp - 25]  ; From stack [rbp - 25]
    push rax
    mov rax, 46
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 368], rax
    mov rax, [rbp - 368]
    test rax, rax
    jz ir_if_next_282
    ; Load variable: tape_ptr
    movsxd rax, dword [rel tape_ptr]  ; From global memory
    push rax
    mov rax, 30000
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 376], rax
    mov rax, [rbp - 376]
    test rax, rax
    jz ir_trap_bounds_283
    jmp ir_in_bounds_284
ir_trap_bounds_283:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct51]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Void return - no value to handle
ir_in_bounds_284:
    ; Load variable: tape_ptr
    movsxd rax, dword [rel tape_ptr]  ; From global memory
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 384], rax
    ; Load variable: tape
    lea rax, [rel tape]  ; Array base address
    push rax
    mov rax, [rbp - 384]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 392], rax
    mov rax, [rbp - 392]
    movzx rax, byte [rax]
    mov [rbp - 400], rax
    ; IR call: putchar (1 args)
    sub rsp, 32
    mov rax, [rbp - 400]
    mov rcx, rax
    call putchar
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 408], rax
    jmp ir_if_end_281
ir_if_next_282:
ir_if_end_281:
    ; Load variable: cmd
    movzx rax, byte [rbp - 25]  ; From stack [rbp - 25]
    push rax
    mov rax, 44
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 416], rax
    mov rax, [rbp - 416]
    test rax, rax
    jz ir_if_next_286
    ; IR call: getchar (0 args)
    sub rsp, 32
    call getchar
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 424], rax
    ; Load variable: tape_ptr
    movsxd rax, dword [rel tape_ptr]  ; From global memory
    push rax
    mov rax, 30000
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 432], rax
    mov rax, [rbp - 432]
    test rax, rax
    jz ir_trap_bounds_287
    jmp ir_in_bounds_288
ir_trap_bounds_287:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct53]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Void return - no value to handle
ir_in_bounds_288:
    ; Load variable: tape_ptr
    movsxd rax, dword [rel tape_ptr]  ; From global memory
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 440], rax
    ; Load variable: tape
    lea rax, [rel tape]  ; Array base address
    push rax
    mov rax, [rbp - 440]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 448], rax
    mov rax, [rbp - 448]
    push rax
    mov rax, [rbp - 424]
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    jmp ir_if_end_285
ir_if_next_286:
ir_if_end_285:
    ; Load variable: cmd
    movzx rax, byte [rbp - 25]  ; From stack [rbp - 25]
    push rax
    mov rax, 91
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 464], rax
    mov rax, [rbp - 464]
    test rax, rax
    jz ir_if_next_290
    ; Load variable: tape_ptr
    movsxd rax, dword [rel tape_ptr]  ; From global memory
    push rax
    mov rax, 30000
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 472], rax
    mov rax, [rbp - 472]
    test rax, rax
    jz ir_trap_bounds_293
    jmp ir_in_bounds_294
ir_trap_bounds_293:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct55]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Void return - no value to handle
ir_in_bounds_294:
    ; Load variable: tape_ptr
    movsxd rax, dword [rel tape_ptr]  ; From global memory
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 480], rax
    ; Load variable: tape
    lea rax, [rel tape]  ; Array base address
    push rax
    mov rax, [rbp - 480]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 488], rax
    mov rax, [rbp - 488]
    movzx rax, byte [rax]
    mov [rbp - 496], rax
    mov rax, [rbp - 496]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 504], rax
    mov rax, [rbp - 504]
    test rax, rax
    jz ir_if_next_292
    ; IR call: find_matching_close (3 args)
    sub rsp, 32
    ; Load variable: program
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    ; Load variable: pc
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    mov rdx, rax
    ; Load variable: len
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    mov r8, rax
    call find_matching_close
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 512], rax
    mov rax, [rbp - 512]
    ; Store to variable: close
    mov dword [rbp - 32], eax  ; To stack [rbp - 32]
    mov rax, 1
    neg rax
    mov [rbp - 520], rax
    ; Load variable: close
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, [rbp - 520]
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 528], rax
    mov rax, [rbp - 528]
    test rax, rax
    jz ir_if_next_296
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (19 bytes)
    lea rax, [rel Lstr_struct57]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 536], rax
    mov rax, 1
    mov [rbp - 544], rax
    mov rax, [rbp - 544]
    test rax, rax
    jz ir_errdefer_ok_297
    jmp ir_errdefer_end_298
ir_errdefer_ok_297:
ir_errdefer_end_298:
    mov rax, 1
    jmp Lbf_run_exit
    jmp ir_if_end_295
ir_if_next_296:
ir_if_end_295:
    ; Load variable: close
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    ; Store to variable: pc
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
    jmp ir_if_end_291
ir_if_next_292:
ir_if_end_291:
    jmp ir_if_end_289
ir_if_next_290:
ir_if_end_289:
    ; Load variable: cmd
    movzx rax, byte [rbp - 25]  ; From stack [rbp - 25]
    push rax
    mov rax, 93
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 552], rax
    mov rax, [rbp - 552]
    test rax, rax
    jz ir_if_next_300
    ; Load variable: tape_ptr
    movsxd rax, dword [rel tape_ptr]  ; From global memory
    push rax
    mov rax, 30000
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 560], rax
    mov rax, [rbp - 560]
    test rax, rax
    jz ir_trap_bounds_303
    jmp ir_in_bounds_304
ir_trap_bounds_303:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (38 bytes)
    lea rax, [rel Lstr_struct59]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Void return - no value to handle
ir_in_bounds_304:
    ; Load variable: tape_ptr
    movsxd rax, dword [rel tape_ptr]  ; From global memory
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 568], rax
    ; Load variable: tape
    lea rax, [rel tape]  ; Array base address
    push rax
    mov rax, [rbp - 568]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 576], rax
    mov rax, [rbp - 576]
    movzx rax, byte [rax]
    mov [rbp - 584], rax
    mov rax, [rbp - 584]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 592], rax
    mov rax, [rbp - 592]
    test rax, rax
    jz ir_if_next_302
    ; IR call: find_matching_open (2 args)
    sub rsp, 32
    ; Load variable: program
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    ; Load variable: pc
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    mov rdx, rax
    call find_matching_open
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 600], rax
    mov rax, [rbp - 600]
    ; Store to variable: open
    mov dword [rbp - 36], eax  ; To stack [rbp - 36]
    mov rax, 1
    neg rax
    mov [rbp - 608], rax
    ; Load variable: open
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    push rax
    mov rax, [rbp - 608]
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 616], rax
    mov rax, [rbp - 616]
    test rax, rax
    jz ir_if_next_306
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (19 bytes)
    lea rax, [rel Lstr_struct61]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 624], rax
    mov rax, 1
    mov [rbp - 632], rax
    mov rax, [rbp - 632]
    test rax, rax
    jz ir_errdefer_ok_307
    jmp ir_errdefer_end_308
ir_errdefer_ok_307:
ir_errdefer_end_308:
    mov rax, 1
    jmp Lbf_run_exit
    jmp ir_if_end_305
ir_if_next_306:
ir_if_end_305:
    ; Load variable: open
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    ; Store to variable: pc
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
    jmp ir_if_end_301
ir_if_next_302:
ir_if_end_301:
    jmp ir_if_end_299
ir_if_next_300:
ir_if_end_299:
    ; Load variable: pc
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 640], rax
    mov rax, [rbp - 640]
    ; Store to variable: pc
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
    jmp ir_while_253
ir_while_end_254:
    mov rax, 0
    mov [rbp - 648], rax
    mov rax, [rbp - 648]
    test rax, rax
    jz ir_errdefer_ok_309
    jmp ir_errdefer_end_310
ir_errdefer_ok_309:
ir_errdefer_end_310:
    mov rax, 0
    jmp Lbf_run_exit
Lbf_run_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global main

main:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 192    ; Allocate 192 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_311:
    ; String literal (106 bytes)
    lea rax, [rel Lstr_struct63]  ; Load string struct address
    ; Store to variable: hello
    mov rcx, [rax]       ; string chars
    mov [rbp - 16], rcx
    mov rcx, [rax + 8]   ; string length
    mov [rbp - 8], rcx
    ; Load variable: hello
    lea rax, [rbp - 16]  ; Address of local string
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    mov rax, qword [rax]
    mov [rbp - 40], rax
    ; Load variable: hello
    lea rax, [rbp - 16]  ; Address of local string
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    mov rax, qword [rax]
    mov [rbp - 56], rax
    ; IR call: bf_run (2 args)
    sub rsp, 32
    mov rax, [rbp - 40]
    mov rcx, rax
    mov rax, [rbp - 56]
    mov rdx, rax
    call bf_run
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    ; Store to variable: result
    mov dword [rbp - 20], eax  ; To stack [rbp - 20]
    ; Load variable: result
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    test rax, rax
    jz ir_errdefer_ok_312
    jmp ir_errdefer_end_313
ir_errdefer_ok_312:
ir_errdefer_end_313:
    ; Load variable: result
    movsxd rax, dword [rbp - 20]  ; From stack [rbp - 20]
    jmp Lmain_exit
Lmain_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

; Default program entry point
global mainCRTStartup
mainCRTStartup:
    sub rsp, 40      ; Shadow space + alignment
    ; Initialize garbage collector runtime
    lea rcx, [rsp + 40]
    extern gc_init
    call gc_init
    extern gc_register_root
    lea rcx, [rel tape]
    call gc_register_root
    ; Call user main function
    call main
    mov [rsp + 32], rax ; Preserve main return code
    extern gc_shutdown
    call gc_shutdown
    mov rcx, [rsp + 32] ; Use main return as exit code
    extern ExitProcess
    call ExitProcess

; Data section for global variables
section .data
; Global variable: tape (uint8[30000], 30000 bytes)
section .bss
tape:
    resb 30000
section .data

; Global variable: tape_ptr (int32, 4 bytes)
tape_ptr:
    dd 0

Lstr_chars0:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct1:
    dq Lstr_chars0
    dq 37

Lstr_chars2:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct3:
    dq Lstr_chars2
    dq 37

Lstr_chars4:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct5:
    dq Lstr_chars4
    dq 38

Lstr_chars6:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct7:
    dq Lstr_chars6
    dq 38

Lstr_chars8:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct9:
    dq Lstr_chars8
    dq 37

Lstr_chars10:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct11:
    dq Lstr_chars10
    dq 37

Lstr_chars12:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct13:
    dq Lstr_chars12
    dq 37

Lstr_chars14:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct15:
    dq Lstr_chars14
    dq 37

Lstr_chars16:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct17:
    dq Lstr_chars16
    dq 37

Lstr_chars18:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct19:
    dq Lstr_chars18
    dq 37

Lstr_chars20:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct21:
    dq Lstr_chars20
    dq 37

Lstr_chars22:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct23:
    dq Lstr_chars22
    dq 37

Lstr_chars24:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct25:
    dq Lstr_chars24
    dq 37

Lstr_chars26:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct27:
    dq Lstr_chars26
    dq 37

Lstr_chars28:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct29:
    dq Lstr_chars28
    dq 37

Lstr_chars30:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct31:
    dq Lstr_chars30
    dq 37

Lstr_chars32:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct33:
    dq Lstr_chars32
    dq 37

Lstr_chars34:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct35:
    dq Lstr_chars34
    dq 38

Lstr_chars36:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct37:
    dq Lstr_chars36
    dq 37

Lstr_chars38:
    db "Error: tape pointer out of bounds", 10, 0
    align 8
Lstr_struct39:
    dq Lstr_chars38
    dq 34

Lstr_chars40:
    db "Error: tape pointer out of bounds", 10, 0
    align 8
Lstr_struct41:
    dq Lstr_chars40
    dq 34

Lstr_chars42:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct43:
    dq Lstr_chars42
    dq 38

Lstr_chars44:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct45:
    dq Lstr_chars44
    dq 38

Lstr_chars46:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct47:
    dq Lstr_chars46
    dq 38

Lstr_chars48:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct49:
    dq Lstr_chars48
    dq 38

Lstr_chars50:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct51:
    dq Lstr_chars50
    dq 38

Lstr_chars52:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct53:
    dq Lstr_chars52
    dq 38

Lstr_chars54:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct55:
    dq Lstr_chars54
    dq 38

Lstr_chars56:
    db "Error: unmatched [", 10, 0
    align 8
Lstr_struct57:
    dq Lstr_chars56
    dq 19

Lstr_chars58:
    db "Fatal error: Array index out of bounds", 0
    align 8
Lstr_struct59:
    dq Lstr_chars58
    dq 38

Lstr_chars60:
    db "Error: unmatched ]", 10, 0
    align 8
Lstr_struct61:
    dq Lstr_chars60
    dq 19

Lstr_chars62:
    db "++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]>>.>---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++.", 0
    align 8
Lstr_struct63:
    dq Lstr_chars62
    dq 106

