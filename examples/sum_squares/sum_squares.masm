// MethASM Sum-of-Squares benchmark
//
// Computes 1² + 2² + ... + n² for n=100000.
// Formula: n(n+1)(2n+1)/6. Benchmarks 50 full passes.
//
// Build: build.bat
// Run: sum_squares.exe

import "std/io";

extern function GetTickCount64() -> uint64 = "GetTickCount64";

// Returns 1² + 2² + ... + n² (iterative, no formula)
function sum_squares(n: int64) -> int64 {
  var sum: int64 = 0;
  var i: int64 = 1;
  while (i <= n) {
    sum = sum + i * i;
    i = i + 1;
  }
  return sum;
}

function main() -> int32 {
  var header: string = "Sum of squares: 1²+2²+...+100000²";
  println(cstr(header));

  var result: int64 = sum_squares(100000);
  var result_str: string = "Sum = ";
  print(cstr(result_str));
  println_int(result);

  // Benchmark: 500 full passes (enough for GetTickCount64 ~15ms resolution)
  var passes: int32 = 500;
  var bench_header: string = "Benchmark: 500 passes (sum_squares 100000 each)";
  println(cstr(bench_header));

  var t0: uint64 = GetTickCount64();
  var p: int32 = 0;
  var bench_sum: int64 = 0;
  while (p < passes) {
    bench_sum = bench_sum + sum_squares(100000);
    p = p + 1;
  }
  var t1: uint64 = GetTickCount64();
  var elapsed_ms: uint64 = t1 - t0;

  var sum_str: string = "Bench sum = ";
  print(cstr(sum_str));
  println_int(bench_sum);

  var time_str: string = "Time: ";
  print(cstr(time_str));
  print_int(elapsed_ms);
  println(cstr(" ms"));

  var per_pass: uint64 = elapsed_ms * 1000 / passes;
  var us_str: string = "Per pass: ~";
  print(cstr(us_str));
  print_int(per_pass);
  println(cstr(" us"));

  return 0;
}
