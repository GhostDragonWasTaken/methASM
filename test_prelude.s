; Generated by MethASM
; x86-64 Assembly Output

section .text
; Code section

; First pass: processing 21 declarations
; Declaration 0 type: 3 (AST_INLINE_ASM = 16)
; Declaration 1 type: 3 (AST_INLINE_ASM = 16)
; Declaration 2 type: 3 (AST_INLINE_ASM = 16)
; Declaration 3 type: 3 (AST_INLINE_ASM = 16)
; Declaration 4 type: 3 (AST_INLINE_ASM = 16)
; Declaration 5 type: 3 (AST_INLINE_ASM = 16)
; Declaration 6 type: 3 (AST_INLINE_ASM = 16)
; Declaration 7 type: 3 (AST_INLINE_ASM = 16)
; Declaration 8 type: 3 (AST_INLINE_ASM = 16)
; Declaration 9 type: 3 (AST_INLINE_ASM = 16)
; Declaration 10 type: 3 (AST_INLINE_ASM = 16)
; Declaration 11 type: 3 (AST_INLINE_ASM = 16)
; Declaration 12 type: 3 (AST_INLINE_ASM = 16)
; Declaration 13 type: 3 (AST_INLINE_ASM = 16)
; Declaration 14 type: 3 (AST_INLINE_ASM = 16)
; Declaration 15 type: 3 (AST_INLINE_ASM = 16)
; Declaration 16 type: 3 (AST_INLINE_ASM = 16)
; Declaration 17 type: 3 (AST_INLINE_ASM = 16)
; Declaration 18 type: 3 (AST_INLINE_ASM = 16)
; Declaration 19 type: 3 (AST_INLINE_ASM = 16)
; Declaration 20 type: 3 (AST_INLINE_ASM = 16)

section .text
    extern puts
    extern putchar

global cstr

cstr:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 80    ; Allocate 80 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 's'
    ; Parameter 's' arrived in register rcx
ir_entry_0:
    lea rax, [rbp - 8]
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    mov rax, qword [rax]
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    jmp Lcstr_exit
Lcstr_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global print

print:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 240    ; Allocate 240 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'msg'
    ; Parameter 'msg' arrived in register rcx
ir_entry_1:
    mov rax, 0
    ; Store to variable: i
    mov qword [rbp - 16], rax  ; To stack [rbp - 16]
ir_while_2:
    ; Load variable: i
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 24], rax
    ; Load variable: msg
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 24]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    movzx rax, byte [rax]
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_while_end_3
    ; Load variable: i
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 56], rax
    ; Load variable: msg
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 56]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    movzx rax, byte [rax]
    mov [rbp - 72], rax
    ; IR call: putchar (1 args)
    sub rsp, 32
    mov rax, [rbp - 72]
    mov rcx, rax
    call putchar
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 80], rax
    ; Load variable: i
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    ; Store to variable: i
    mov qword [rbp - 16], rax  ; To stack [rbp - 16]
    jmp ir_while_2
ir_while_end_3:
Lprint_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global println

println:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 32    ; Allocate 32 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'msg'
    ; Parameter 'msg' arrived in register rcx
ir_entry_4:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; Load variable: msg
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call puts
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 16], rax
Lprintln_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller
    extern abs

global min

min:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 48    ; Allocate 48 bytes on stack (aligned)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 'a'
    ; Parameter 'a' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'b'
    ; Parameter 'b' arrived in register rdx
ir_entry_5:
    ; Load variable: a
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    ; Load variable: b
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_else_6
    ; Load variable: a
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    jmp Lmin_exit
    jmp ir_if_end_7
ir_if_else_6:
ir_if_end_7:
    ; Load variable: b
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    jmp Lmin_exit
Lmin_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global max

max:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 48    ; Allocate 48 bytes on stack (aligned)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 'a'
    ; Parameter 'a' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'b'
    ; Parameter 'b' arrived in register rdx
ir_entry_8:
    ; Load variable: a
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    ; Load variable: b
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov r10, rax
    pop rax
    cmp rax, r10
    setg al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_else_9
    ; Load variable: a
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    jmp Lmax_exit
    jmp ir_if_end_10
ir_if_else_9:
ir_if_end_10:
    ; Load variable: b
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    jmp Lmax_exit
Lmax_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global clamp

clamp:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 80    ; Allocate 80 bytes on stack (aligned)
    ; Registering 3 function parameters
    mov [rbp - 8], rcx  ; Home param 'value'
    ; Parameter 'value' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'lo'
    ; Parameter 'lo' arrived in register rdx
    mov [rbp - 24], r8  ; Home param 'hi'
    ; Parameter 'hi' arrived in register r8
ir_entry_11:
    ; Load variable: value
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    ; Load variable: lo
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_if_else_12
    ; Load variable: lo
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    jmp Lclamp_exit
    jmp ir_if_end_13
ir_if_else_12:
ir_if_end_13:
    ; Load variable: value
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    ; Load variable: hi
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov r10, rax
    pop rax
    cmp rax, r10
    setg al
    movzx rax, al
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_if_else_14
    ; Load variable: hi
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    jmp Lclamp_exit
    jmp ir_if_end_15
ir_if_else_14:
ir_if_end_15:
    ; Load variable: value
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    jmp Lclamp_exit
Lclamp_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller
    extern atoi

global digit_to_char

digit_to_char:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 32    ; Allocate 32 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'd'
    ; Parameter 'd' arrived in register rcx
ir_entry_16:
    ; Load variable: d
    mov eax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 48
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    jmp Ldigit_to_char_exit
Ldigit_to_char_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global char_to_digit

char_to_digit:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 32    ; Allocate 32 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_17:
    ; Load variable: c
    mov eax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 48
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    jmp Lchar_to_digit_exit
Lchar_to_digit_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global is_digit

is_digit:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 64    ; Allocate 64 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_18:
    ; Load variable: c
    mov eax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 48
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_if_else_19
    ; Load variable: c
    mov eax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 57
    mov r10, rax
    pop rax
    cmp rax, r10
    setle al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_else_21
    mov rax, 1
    jmp Lis_digit_exit
    jmp ir_if_end_22
ir_if_else_21:
ir_if_end_22:
    jmp ir_if_end_20
ir_if_else_19:
ir_if_end_20:
    mov rax, 0
    jmp Lis_digit_exit
Lis_digit_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global is_upper

is_upper:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 64    ; Allocate 64 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_23:
    ; Load variable: c
    mov eax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 65
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_if_else_24
    ; Load variable: c
    mov eax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 90
    mov r10, rax
    pop rax
    cmp rax, r10
    setle al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_else_26
    mov rax, 1
    jmp Lis_upper_exit
    jmp ir_if_end_27
ir_if_else_26:
ir_if_end_27:
    jmp ir_if_end_25
ir_if_else_24:
ir_if_end_25:
    mov rax, 0
    jmp Lis_upper_exit
Lis_upper_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global is_lower

is_lower:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 64    ; Allocate 64 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_28:
    ; Load variable: c
    mov eax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 97
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_if_else_29
    ; Load variable: c
    mov eax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 122
    mov r10, rax
    pop rax
    cmp rax, r10
    setle al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_else_31
    mov rax, 1
    jmp Lis_lower_exit
    jmp ir_if_end_32
ir_if_else_31:
ir_if_end_32:
    jmp ir_if_end_30
ir_if_else_29:
ir_if_end_30:
    mov rax, 0
    jmp Lis_lower_exit
Lis_lower_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global to_lower

to_lower:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 80    ; Allocate 80 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_33:
    ; IR call: is_upper (1 args)
    sub rsp, 32
    ; Load variable: c
    mov eax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call is_upper
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_else_34
    ; Load variable: c
    mov eax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 32
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    jmp Lto_lower_exit
    jmp ir_if_end_35
ir_if_else_34:
ir_if_end_35:
    ; Load variable: c
    mov eax, dword [rbp - 8]  ; From stack [rbp - 8]
    jmp Lto_lower_exit
Lto_lower_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global to_upper

to_upper:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 80    ; Allocate 80 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_36:
    ; IR call: is_lower (1 args)
    sub rsp, 32
    ; Load variable: c
    mov eax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call is_lower
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_else_37
    ; Load variable: c
    mov eax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 32
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    jmp Lto_upper_exit
    jmp ir_if_end_38
ir_if_else_37:
ir_if_end_38:
    ; Load variable: c
    mov eax, dword [rbp - 8]  ; From stack [rbp - 8]
    jmp Lto_upper_exit
Lto_upper_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller
    extern exit
    extern rand
    extern srand

global main

main:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 304    ; Allocate 304 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_39:
    ; String literal (23 bytes)
    lea rax, [rel Lstr_struct1]  ; Load string struct address
    ; Store to variable: greeting
    mov qword [rbp - 16], rax  ; To stack [rbp - 16]
    ; IR call: cstr (1 args)
    sub rsp, 32
    ; Load variable: greeting
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov rcx, rax
    call cstr
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    mov [rbp - 56], rax
    ; IR call: println (1 args)
    sub rsp, 32
    mov rax, [rbp - 56]
    mov rcx, rax
    call println
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Void return - no value to handle
    mov [rbp - 64], rax
    ; IR call: min (2 args)
    sub rsp, 32
    mov rax, 10
    mov rcx, rax
    mov rax, 20
    mov rdx, rax
    call min
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    ; Store to variable: a
    mov qword [rbp - 24], rax  ; To stack [rbp - 24]
    ; IR call: max (2 args)
    sub rsp, 32
    mov rax, 10
    mov rcx, rax
    mov rax, 20
    mov rdx, rax
    call max
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    mov [rbp - 80], rax
    mov rax, [rbp - 80]
    ; Store to variable: b
    mov qword [rbp - 32], rax  ; To stack [rbp - 32]
    ; IR call: clamp (3 args)
    sub rsp, 32
    mov rax, 50
    mov rcx, rax
    mov rax, 0
    mov rdx, rax
    mov rax, 100
    mov r8, rax
    call clamp
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    ; Store to variable: c
    mov qword [rbp - 40], rax  ; To stack [rbp - 40]
    ; IR call: is_digit (1 args)
    sub rsp, 32
    mov rax, 57
    mov rcx, rax
    call is_digit
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    ; Store to variable: d
    mov dword [rbp - 44], eax  ; To stack [rbp - 44]
    ; IR call: to_lower (1 args)
    sub rsp, 32
    mov rax, 65
    mov rcx, rax
    call to_lower
    mov rcx, rax
    add rsp, 32
    mov rax, rcx
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 104], rax
    mov rax, [rbp - 104]
    ; Store to variable: e
    mov dword [rbp - 48], eax  ; To stack [rbp - 48]
    mov rax, 0
    jmp Lmain_exit
Lmain_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

; Default program entry point
global mainCRTStartup
mainCRTStartup:
    sub rsp, 40      ; Shadow space + alignment
    ; Initialize garbage collector runtime
    lea rcx, [rsp + 40]
    extern gc_init
    call gc_init
    ; Call user main function
    call main
    mov [rsp + 32], rax ; Preserve main return code
    extern gc_shutdown
    call gc_shutdown
    mov rcx, [rsp + 32] ; Use main return as exit code
    extern ExitProcess
    call ExitProcess
