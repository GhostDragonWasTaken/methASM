; Generated by MethASM
; x86-64 Assembly Output

section .text
; Code section

; First pass: processing 29 declarations
; Declaration 0 type: 4 (AST_INLINE_ASM = 21)
; Declaration 1 type: 4 (AST_INLINE_ASM = 21)
; Declaration 2 type: 4 (AST_INLINE_ASM = 21)
; Declaration 3 type: 4 (AST_INLINE_ASM = 21)
; Declaration 4 type: 4 (AST_INLINE_ASM = 21)
; Declaration 5 type: 4 (AST_INLINE_ASM = 21)
; Declaration 6 type: 4 (AST_INLINE_ASM = 21)
; Declaration 7 type: 4 (AST_INLINE_ASM = 21)
; Declaration 8 type: 4 (AST_INLINE_ASM = 21)
; Declaration 9 type: 4 (AST_INLINE_ASM = 21)
; Declaration 10 type: 4 (AST_INLINE_ASM = 21)
; Declaration 11 type: 4 (AST_INLINE_ASM = 21)
; Declaration 12 type: 4 (AST_INLINE_ASM = 21)
; Declaration 13 type: 4 (AST_INLINE_ASM = 21)
; Declaration 14 type: 4 (AST_INLINE_ASM = 21)
; Declaration 15 type: 4 (AST_INLINE_ASM = 21)
; Declaration 16 type: 4 (AST_INLINE_ASM = 21)
; Declaration 17 type: 4 (AST_INLINE_ASM = 21)
; Declaration 18 type: 4 (AST_INLINE_ASM = 21)
; Declaration 19 type: 4 (AST_INLINE_ASM = 21)
; Declaration 20 type: 4 (AST_INLINE_ASM = 21)
; Declaration 21 type: 4 (AST_INLINE_ASM = 21)
; Declaration 22 type: 4 (AST_INLINE_ASM = 21)
; Declaration 23 type: 4 (AST_INLINE_ASM = 21)
; Declaration 24 type: 4 (AST_INLINE_ASM = 21)
; Declaration 25 type: 4 (AST_INLINE_ASM = 21)
; Declaration 26 type: 3 (AST_INLINE_ASM = 21)
; Declaration 27 type: 3 (AST_INLINE_ASM = 21)
; Declaration 28 type: 4 (AST_INLINE_ASM = 21)

section .text
    extern system
    extern atoi
    extern atol

global digit_to_char

digit_to_char:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 64    ; Allocate 64 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'd'
    ; Parameter 'd' arrived in register rcx
ir_entry_0:
    ; Load variable: d
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 48
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_errdefer_ok_1
    jmp ir_errdefer_end_2
ir_errdefer_ok_1:
ir_errdefer_end_2:
    mov rax, [rbp - 16]
    jmp Ldigit_to_char_exit
Ldigit_to_char_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global char_to_digit

char_to_digit:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 64    ; Allocate 64 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_3:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 48
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_errdefer_ok_4
    jmp ir_errdefer_end_5
ir_errdefer_ok_4:
ir_errdefer_end_5:
    mov rax, [rbp - 16]
    jmp Lchar_to_digit_exit
Lchar_to_digit_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global is_digit

is_digit:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 112    ; Allocate 112 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_6:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 48
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_if_next_8
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 57
    mov r10, rax
    pop rax
    cmp rax, r10
    setle al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_next_10
    mov rax, 1
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_11
    jmp ir_errdefer_end_12
ir_errdefer_ok_11:
ir_errdefer_end_12:
    mov rax, 1
    jmp Lis_digit_exit
    jmp ir_if_end_9
ir_if_next_10:
ir_if_end_9:
    jmp ir_if_end_7
ir_if_next_8:
ir_if_end_7:
    mov rax, 0
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_errdefer_ok_13
    jmp ir_errdefer_end_14
ir_errdefer_ok_13:
ir_errdefer_end_14:
    mov rax, 0
    jmp Lis_digit_exit
Lis_digit_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global is_upper

is_upper:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 112    ; Allocate 112 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_15:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 65
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_if_next_17
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 90
    mov r10, rax
    pop rax
    cmp rax, r10
    setle al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_next_19
    mov rax, 1
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_20
    jmp ir_errdefer_end_21
ir_errdefer_ok_20:
ir_errdefer_end_21:
    mov rax, 1
    jmp Lis_upper_exit
    jmp ir_if_end_18
ir_if_next_19:
ir_if_end_18:
    jmp ir_if_end_16
ir_if_next_17:
ir_if_end_16:
    mov rax, 0
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_errdefer_ok_22
    jmp ir_errdefer_end_23
ir_errdefer_ok_22:
ir_errdefer_end_23:
    mov rax, 0
    jmp Lis_upper_exit
Lis_upper_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global is_lower

is_lower:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 112    ; Allocate 112 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_24:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 97
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_if_next_26
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 122
    mov r10, rax
    pop rax
    cmp rax, r10
    setle al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_next_28
    mov rax, 1
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_29
    jmp ir_errdefer_end_30
ir_errdefer_ok_29:
ir_errdefer_end_30:
    mov rax, 1
    jmp Lis_lower_exit
    jmp ir_if_end_27
ir_if_next_28:
ir_if_end_27:
    jmp ir_if_end_25
ir_if_next_26:
ir_if_end_25:
    mov rax, 0
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_errdefer_ok_31
    jmp ir_errdefer_end_32
ir_errdefer_ok_31:
ir_errdefer_end_32:
    mov rax, 0
    jmp Lis_lower_exit
Lis_lower_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global is_alpha

is_alpha:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 176    ; Allocate 176 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_33:
    ; IR call: is_upper (1 args)
    sub rsp, 32
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call is_upper
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_next_35
    mov rax, 1
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_36
    jmp ir_errdefer_end_37
ir_errdefer_ok_36:
ir_errdefer_end_37:
    mov rax, 1
    jmp Lis_alpha_exit
    jmp ir_if_end_34
ir_if_next_35:
ir_if_end_34:
    ; IR call: is_lower (1 args)
    sub rsp, 32
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call is_lower
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_if_next_39
    mov rax, 1
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    test rax, rax
    jz ir_errdefer_ok_40
    jmp ir_errdefer_end_41
ir_errdefer_ok_40:
ir_errdefer_end_41:
    mov rax, 1
    jmp Lis_alpha_exit
    jmp ir_if_end_38
ir_if_next_39:
ir_if_end_38:
    mov rax, 0
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    test rax, rax
    jz ir_errdefer_ok_42
    jmp ir_errdefer_end_43
ir_errdefer_ok_42:
ir_errdefer_end_43:
    mov rax, 0
    jmp Lis_alpha_exit
Lis_alpha_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global is_alnum

is_alnum:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 176    ; Allocate 176 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_44:
    ; IR call: is_alpha (1 args)
    sub rsp, 32
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call is_alpha
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_next_46
    mov rax, 1
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_errdefer_ok_47
    jmp ir_errdefer_end_48
ir_errdefer_ok_47:
ir_errdefer_end_48:
    mov rax, 1
    jmp Lis_alnum_exit
    jmp ir_if_end_45
ir_if_next_46:
ir_if_end_45:
    ; IR call: is_digit (1 args)
    sub rsp, 32
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call is_digit
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_if_next_50
    mov rax, 1
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    test rax, rax
    jz ir_errdefer_ok_51
    jmp ir_errdefer_end_52
ir_errdefer_ok_51:
ir_errdefer_end_52:
    mov rax, 1
    jmp Lis_alnum_exit
    jmp ir_if_end_49
ir_if_next_50:
ir_if_end_49:
    mov rax, 0
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    test rax, rax
    jz ir_errdefer_ok_53
    jmp ir_errdefer_end_54
ir_errdefer_ok_53:
ir_errdefer_end_54:
    mov rax, 0
    jmp Lis_alnum_exit
Lis_alnum_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global is_space

is_space:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 320    ; Allocate 320 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_55:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 32
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_if_next_57
    mov rax, 1
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_errdefer_ok_58
    jmp ir_errdefer_end_59
ir_errdefer_ok_58:
ir_errdefer_end_59:
    mov rax, 1
    jmp Lis_space_exit
    jmp ir_if_end_56
ir_if_next_57:
ir_if_end_56:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 9
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    test rax, rax
    jz ir_if_next_61
    mov rax, 1
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_errdefer_ok_62
    jmp ir_errdefer_end_63
ir_errdefer_ok_62:
ir_errdefer_end_63:
    mov rax, 1
    jmp Lis_space_exit
    jmp ir_if_end_60
ir_if_next_61:
ir_if_end_60:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 10
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_if_next_65
    mov rax, 1
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    test rax, rax
    jz ir_errdefer_ok_66
    jmp ir_errdefer_end_67
ir_errdefer_ok_66:
ir_errdefer_end_67:
    mov rax, 1
    jmp Lis_space_exit
    jmp ir_if_end_64
ir_if_next_65:
ir_if_end_64:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 13
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    test rax, rax
    jz ir_if_next_69
    mov rax, 1
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    test rax, rax
    jz ir_errdefer_ok_70
    jmp ir_errdefer_end_71
ir_errdefer_ok_70:
ir_errdefer_end_71:
    mov rax, 1
    jmp Lis_space_exit
    jmp ir_if_end_68
ir_if_next_69:
ir_if_end_68:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 12
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 80], rax
    mov rax, [rbp - 80]
    test rax, rax
    jz ir_if_next_73
    mov rax, 1
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    test rax, rax
    jz ir_errdefer_ok_74
    jmp ir_errdefer_end_75
ir_errdefer_ok_74:
ir_errdefer_end_75:
    mov rax, 1
    jmp Lis_space_exit
    jmp ir_if_end_72
ir_if_next_73:
ir_if_end_72:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 11
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    test rax, rax
    jz ir_if_next_77
    mov rax, 1
    mov [rbp - 104], rax
    mov rax, [rbp - 104]
    test rax, rax
    jz ir_errdefer_ok_78
    jmp ir_errdefer_end_79
ir_errdefer_ok_78:
ir_errdefer_end_79:
    mov rax, 1
    jmp Lis_space_exit
    jmp ir_if_end_76
ir_if_next_77:
ir_if_end_76:
    mov rax, 0
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    test rax, rax
    jz ir_errdefer_ok_80
    jmp ir_errdefer_end_81
ir_errdefer_ok_80:
ir_errdefer_end_81:
    mov rax, 0
    jmp Lis_space_exit
Lis_space_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global to_lower

to_lower:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 128    ; Allocate 128 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_82:
    ; IR call: is_upper (1 args)
    sub rsp, 32
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call is_upper
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_next_84
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 32
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_errdefer_ok_85
    jmp ir_errdefer_end_86
ir_errdefer_ok_85:
ir_errdefer_end_86:
    mov rax, [rbp - 32]
    jmp Lto_lower_exit
    jmp ir_if_end_83
ir_if_next_84:
ir_if_end_83:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_errdefer_ok_87
    jmp ir_errdefer_end_88
ir_errdefer_ok_87:
ir_errdefer_end_88:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    jmp Lto_lower_exit
Lto_lower_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global to_upper

to_upper:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 128    ; Allocate 128 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'c'
    ; Parameter 'c' arrived in register rcx
ir_entry_89:
    ; IR call: is_lower (1 args)
    sub rsp, 32
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call is_lower
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_if_next_91
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, 32
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_errdefer_ok_92
    jmp ir_errdefer_end_93
ir_errdefer_ok_92:
ir_errdefer_end_93:
    mov rax, [rbp - 32]
    jmp Lto_upper_exit
    jmp ir_if_end_90
ir_if_next_91:
ir_if_end_90:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_errdefer_ok_94
    jmp ir_errdefer_end_95
ir_errdefer_ok_94:
ir_errdefer_end_95:
    ; Load variable: c
    movsxd rax, dword [rbp - 8]  ; From stack [rbp - 8]
    jmp Lto_upper_exit
Lto_upper_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global strlen

strlen:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 176    ; Allocate 176 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 's'
    ; Parameter 's' arrived in register rcx
ir_entry_96:
    mov rax, 0
    ; Store to variable: i
    mov qword [rbp - 16], rax  ; To stack [rbp - 16]
ir_while_97:
    ; Load variable: s
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_99
    jmp ir_nonnull_100
ir_trap_null_99:
    extern puts
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct3]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Unknown return type - assuming integer
    extern exit
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_100:
    ; Load variable: i
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 24], rax
    ; Load variable: s
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 24]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    movzx rax, byte [rax]
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_while_end_98
    ; Load variable: i
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    ; Store to variable: i
    mov qword [rbp - 16], rax  ; To stack [rbp - 16]
    jmp ir_while_97
ir_while_end_98:
    ; Load variable: i
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    test rax, rax
    jz ir_errdefer_ok_101
    jmp ir_errdefer_end_102
ir_errdefer_ok_101:
ir_errdefer_end_102:
    ; Load variable: i
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    jmp Lstrlen_exit
Lstrlen_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global streq

streq:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 480    ; Allocate 480 bytes on stack (aligned)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 'a'
    ; Parameter 'a' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'b'
    ; Parameter 'b' arrived in register rdx
ir_entry_103:
    mov rax, 0
    ; Store to variable: i
    mov qword [rbp - 24], rax  ; To stack [rbp - 24]
ir_while_104:
    ; Load variable: a
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_106
    jmp ir_nonnull_107
ir_trap_null_106:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct5]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Unknown return type - assuming integer
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_107:
    ; Load variable: i
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 32], rax
    ; Load variable: a
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 32]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    movzx rax, byte [rax]
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    test rax, rax
    jz ir_while_end_105
    ; Load variable: a
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_110
    jmp ir_nonnull_111
ir_trap_null_110:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct7]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Unknown return type - assuming integer
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_111:
    ; Load variable: i
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 64], rax
    ; Load variable: a
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 64]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    movzx rax, byte [rax]
    mov [rbp - 80], rax
    ; Load variable: b
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    test rax, rax
    jz ir_trap_null_112
    jmp ir_nonnull_113
ir_trap_null_112:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct9]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Unknown return type - assuming integer
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_113:
    ; Load variable: i
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 88], rax
    ; Load variable: b
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, [rbp - 88]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    movzx rax, byte [rax]
    mov [rbp - 104], rax
    mov rax, [rbp - 80]
    push rax
    mov rax, [rbp - 104]
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    test rax, rax
    jz ir_if_next_109
    mov rax, 0
    mov [rbp - 120], rax
    mov rax, [rbp - 120]
    test rax, rax
    jz ir_errdefer_ok_114
    jmp ir_errdefer_end_115
ir_errdefer_ok_114:
ir_errdefer_end_115:
    mov rax, 0
    jmp Lstreq_exit
    jmp ir_if_end_108
ir_if_next_109:
ir_if_end_108:
    ; Load variable: i
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 128], rax
    mov rax, [rbp - 128]
    ; Store to variable: i
    mov qword [rbp - 24], rax  ; To stack [rbp - 24]
    jmp ir_while_104
ir_while_end_105:
    ; Load variable: b
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    test rax, rax
    jz ir_trap_null_118
    jmp ir_nonnull_119
ir_trap_null_118:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct11]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Unknown return type - assuming integer
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_119:
    ; Load variable: i
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 136], rax
    ; Load variable: b
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, [rbp - 136]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 144], rax
    mov rax, [rbp - 144]
    movzx rax, byte [rax]
    mov [rbp - 152], rax
    mov rax, [rbp - 152]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 160], rax
    mov rax, [rbp - 160]
    test rax, rax
    jz ir_if_next_117
    mov rax, 0
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    test rax, rax
    jz ir_errdefer_ok_120
    jmp ir_errdefer_end_121
ir_errdefer_ok_120:
ir_errdefer_end_121:
    mov rax, 0
    jmp Lstreq_exit
    jmp ir_if_end_116
ir_if_next_117:
ir_if_end_116:
    mov rax, 1
    mov [rbp - 176], rax
    mov rax, [rbp - 176]
    test rax, rax
    jz ir_errdefer_ok_122
    jmp ir_errdefer_end_123
ir_errdefer_ok_122:
ir_errdefer_end_123:
    mov rax, 1
    jmp Lstreq_exit
Lstreq_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global strncmp

strncmp:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 960    ; Allocate 960 bytes on stack (aligned)
    ; Registering 4 function parameters
    mov [rbp - 8], rcx  ; Home param 'buf'
    ; Parameter 'buf' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'offset'
    ; Parameter 'offset' arrived in register rdx
    mov [rbp - 24], r8  ; Home param 'needle'
    ; Parameter 'needle' arrived in register r8
    mov [rbp - 32], r9  ; Home param 'buf_len'
    ; Parameter 'buf_len' arrived in register r9
ir_entry_124:
    ; Load variable: offset
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_if_next_126
    mov rax, 1
    neg rax
    mov [rbp - 56], rax
    mov rax, [rbp - 56]
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    test rax, rax
    jz ir_errdefer_ok_127
    jmp ir_errdefer_end_128
ir_errdefer_ok_127:
ir_errdefer_end_128:
    mov rax, [rbp - 56]
    jmp Lstrncmp_exit
    jmp ir_if_end_125
ir_if_next_126:
ir_if_end_125:
    ; Load variable: buf_len
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 72], rax
    mov rax, [rbp - 72]
    test rax, rax
    jz ir_if_next_130
    mov rax, 1
    neg rax
    mov [rbp - 80], rax
    mov rax, [rbp - 80]
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    test rax, rax
    jz ir_errdefer_ok_131
    jmp ir_errdefer_end_132
ir_errdefer_ok_131:
ir_errdefer_end_132:
    mov rax, [rbp - 80]
    jmp Lstrncmp_exit
    jmp ir_if_end_129
ir_if_next_130:
ir_if_end_129:
    ; Load variable: offset
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    ; Load variable: buf_len
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    mov r10, rax
    pop rax
    cmp rax, r10
    setg al
    movzx rax, al
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    test rax, rax
    jz ir_if_next_134
    mov rax, 1
    neg rax
    mov [rbp - 104], rax
    mov rax, [rbp - 104]
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    test rax, rax
    jz ir_errdefer_ok_135
    jmp ir_errdefer_end_136
ir_errdefer_ok_135:
ir_errdefer_end_136:
    mov rax, [rbp - 104]
    jmp Lstrncmp_exit
    jmp ir_if_end_133
ir_if_next_134:
ir_if_end_133:
    mov rax, 0
    ; Store to variable: i
    mov dword [rbp - 36], eax  ; To stack [rbp - 36]
ir_while_137:
    ; Load variable: needle
    mov rax, qword [rbp - 24]  ; String param ptr
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 120], rax
    mov rax, [rbp - 120]
    mov rax, qword [rax]
    mov [rbp - 128], rax
    ; Load variable: i
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    push rax
    mov rax, [rbp - 128]
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 136], rax
    mov rax, [rbp - 136]
    test rax, rax
    jz ir_while_end_138
    ; Load variable: offset
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    ; Load variable: i
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 144], rax
    mov rax, [rbp - 144]
    push rax
    ; Load variable: buf_len
    movsxd rax, dword [rbp - 32]  ; From stack [rbp - 32]
    mov r10, rax
    pop rax
    cmp rax, r10
    setge al
    movzx rax, al
    mov [rbp - 152], rax
    mov rax, [rbp - 152]
    test rax, rax
    jz ir_if_next_140
    mov rax, 1
    neg rax
    mov [rbp - 160], rax
    mov rax, [rbp - 160]
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    test rax, rax
    jz ir_errdefer_ok_141
    jmp ir_errdefer_end_142
ir_errdefer_ok_141:
ir_errdefer_end_142:
    mov rax, [rbp - 160]
    jmp Lstrncmp_exit
    jmp ir_if_end_139
ir_if_next_140:
ir_if_end_139:
    ; Load variable: offset
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    ; Load variable: i
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 176], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_145
    jmp ir_nonnull_146
ir_trap_null_145:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct13]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Unknown return type - assuming integer
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_146:
    mov rax, [rbp - 176]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 184], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 184]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 192], rax
    mov rax, [rbp - 192]
    movzx rax, byte [rax]
    mov [rbp - 200], rax
    ; Load variable: needle
    mov rax, qword [rbp - 24]  ; String param ptr
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 208], rax
    mov rax, [rbp - 208]
    mov rax, qword [rax]
    mov [rbp - 216], rax
    mov rax, [rbp - 216]
    test rax, rax
    jz ir_trap_null_147
    jmp ir_nonnull_148
ir_trap_null_147:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct15]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Unknown return type - assuming integer
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_148:
    ; Load variable: i
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 224], rax
    mov rax, [rbp - 216]
    push rax
    mov rax, [rbp - 224]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 232], rax
    mov rax, [rbp - 232]
    movzx rax, byte [rax]
    mov [rbp - 240], rax
    mov rax, [rbp - 200]
    push rax
    mov rax, [rbp - 240]
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 248], rax
    mov rax, [rbp - 248]
    test rax, rax
    jz ir_if_next_144
    ; Load variable: offset
    movsxd rax, dword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    ; Load variable: i
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 256], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_149
    jmp ir_nonnull_150
ir_trap_null_149:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct17]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Unknown return type - assuming integer
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_150:
    mov rax, [rbp - 256]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 264], rax
    ; Load variable: buf
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 264]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 272], rax
    mov rax, [rbp - 272]
    movzx rax, byte [rax]
    mov [rbp - 280], rax
    ; Load variable: needle
    mov rax, qword [rbp - 24]  ; String param ptr
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 288], rax
    mov rax, [rbp - 288]
    mov rax, qword [rax]
    mov [rbp - 296], rax
    mov rax, [rbp - 296]
    test rax, rax
    jz ir_trap_null_151
    jmp ir_nonnull_152
ir_trap_null_151:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct19]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Unknown return type - assuming integer
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_152:
    ; Load variable: i
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 304], rax
    mov rax, [rbp - 296]
    push rax
    mov rax, [rbp - 304]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 312], rax
    mov rax, [rbp - 312]
    movzx rax, byte [rax]
    mov [rbp - 320], rax
    mov rax, [rbp - 280]
    push rax
    mov rax, [rbp - 320]
    mov r10, rax
    pop rax
    sub rax, r10
    mov [rbp - 328], rax
    mov rax, [rbp - 328]
    mov [rbp - 336], rax
    mov rax, [rbp - 336]
    test rax, rax
    jz ir_errdefer_ok_153
    jmp ir_errdefer_end_154
ir_errdefer_ok_153:
ir_errdefer_end_154:
    mov rax, [rbp - 328]
    jmp Lstrncmp_exit
    jmp ir_if_end_143
ir_if_next_144:
ir_if_end_143:
    ; Load variable: i
    movsxd rax, dword [rbp - 36]  ; From stack [rbp - 36]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 344], rax
    mov rax, [rbp - 344]
    ; Store to variable: i
    mov dword [rbp - 36], eax  ; To stack [rbp - 36]
    jmp ir_while_137
ir_while_end_138:
    mov rax, 0
    mov [rbp - 352], rax
    mov rax, [rbp - 352]
    test rax, rax
    jz ir_errdefer_ok_155
    jmp ir_errdefer_end_156
ir_errdefer_ok_155:
ir_errdefer_end_156:
    mov rax, 0
    jmp Lstrncmp_exit
Lstrncmp_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller
    extern malloc
    extern calloc
    extern realloc
    extern free
    extern memset
    extern memcpy
    extern memmove
    extern memcmp

global alloc_zeroed

alloc_zeroed:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 64    ; Allocate 64 bytes on stack (aligned)
    ; Registering 1 function parameters
    mov [rbp - 8], rcx  ; Home param 'n'
    ; Parameter 'n' arrived in register rcx
ir_entry_157:
    ; IR call: calloc (2 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    ; Load variable: n
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rdx, rax
    call calloc
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    mov [rbp - 24], rax
    mov rax, [rbp - 24]
    test rax, rax
    jz ir_errdefer_ok_158
    jmp ir_errdefer_end_159
ir_errdefer_ok_158:
ir_errdefer_end_159:
    mov rax, [rbp - 16]
    jmp Lalloc_zeroed_exit
Lalloc_zeroed_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global buf_dup

buf_dup:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 160    ; Allocate 160 bytes on stack (aligned)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 'src'
    ; Parameter 'src' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'len'
    ; Parameter 'len' arrived in register rdx
ir_entry_160:
    ; IR call: malloc (1 args)
    sub rsp, 32
    ; Load variable: len
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov rcx, rax
    call malloc
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 32], rax
    mov rax, [rbp - 32]
    ; Store to variable: dst
    mov qword [rbp - 24], rax  ; To stack [rbp - 24]
    ; Load variable: dst
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 40], rax
    mov rax, [rbp - 40]
    test rax, rax
    jz ir_if_next_162
    mov rax, 0
    mov [rbp - 48], rax
    mov rax, [rbp - 48]
    test rax, rax
    jz ir_errdefer_ok_163
    jmp ir_errdefer_end_164
ir_errdefer_ok_163:
ir_errdefer_end_164:
    mov rax, 0
    jmp Lbuf_dup_exit
    jmp ir_if_end_161
ir_if_next_162:
ir_if_end_161:
    ; IR call: memcpy (3 args)
    sub rsp, 32
    ; Load variable: dst
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov rcx, rax
    ; Load variable: src
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rdx, rax
    ; Load variable: len
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov r8, rax
    call memcpy
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 56], rax
    ; Load variable: dst
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov [rbp - 64], rax
    mov rax, [rbp - 64]
    test rax, rax
    jz ir_errdefer_ok_165
    jmp ir_errdefer_end_166
ir_errdefer_ok_165:
ir_errdefer_end_166:
    ; Load variable: dst
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    jmp Lbuf_dup_exit
Lbuf_dup_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global http_fetch_to_file

http_fetch_to_file:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 1808    ; Allocate 1808 bytes on stack (aligned)
    ; Registering 2 function parameters
    mov [rbp - 8], rcx  ; Home param 'url'
    ; Parameter 'url' arrived in register rcx
    mov [rbp - 16], rdx  ; Home param 'output_path'
    ; Parameter 'output_path' arrived in register rdx
ir_entry_167:
    ; IR call: strlen (1 args)
    sub rsp, 32
    ; Load variable: url
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    mov rcx, rax
    call strlen
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 80], rax
    mov rax, [rbp - 80]
    ; Store to variable: url_len
    mov qword [rbp - 24], rax  ; To stack [rbp - 24]
    ; IR call: strlen (1 args)
    sub rsp, 32
    ; Load variable: output_path
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    mov rcx, rax
    call strlen
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    ; Store to variable: path_len
    mov qword [rbp - 32], rax  ; To stack [rbp - 32]
    mov rax, 8
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    push rax
    ; Load variable: url_len
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 104], rax
    mov rax, [rbp - 104]
    push rax
    mov rax, 4
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 120], rax
    mov rax, [rbp - 120]
    push rax
    ; Load variable: path_len
    mov rax, qword [rbp - 32]  ; From stack [rbp - 32]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 128], rax
    mov rax, [rbp - 128]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 136], rax
    mov rax, [rbp - 136]
    ; Store to variable: total
    mov qword [rbp - 40], rax  ; To stack [rbp - 40]
    ; Load variable: total
    mov rax, qword [rbp - 40]  ; From stack [rbp - 40]
    push rax
    mov rax, 4096
    mov r10, rax
    pop rax
    cmp rax, r10
    setg al
    movzx rax, al
    mov [rbp - 144], rax
    mov rax, [rbp - 144]
    test rax, rax
    jz ir_if_next_169
    mov rax, 1
    neg rax
    mov [rbp - 152], rax
    mov rax, [rbp - 152]
    mov [rbp - 160], rax
    mov rax, [rbp - 160]
    test rax, rax
    jz ir_errdefer_ok_170
    jmp ir_errdefer_end_171
ir_errdefer_ok_170:
ir_errdefer_end_171:
    mov rax, [rbp - 152]
    jmp Lhttp_fetch_to_file_exit
    jmp ir_if_end_168
ir_if_next_169:
ir_if_end_168:
    ; IR call: malloc (1 args)
    sub rsp, 32
    ; Load variable: total
    mov rax, qword [rbp - 40]  ; From stack [rbp - 40]
    mov rcx, rax
    call malloc
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    ; Store to variable: buf
    mov qword [rbp - 48], rax  ; To stack [rbp - 48]
    ; Load variable: buf
    mov rax, qword [rbp - 48]  ; From stack [rbp - 48]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    sete al
    movzx rax, al
    mov [rbp - 176], rax
    mov rax, [rbp - 176]
    test rax, rax
    jz ir_if_next_173
    mov rax, 1
    neg rax
    mov [rbp - 184], rax
    mov rax, [rbp - 184]
    mov [rbp - 192], rax
    mov rax, [rbp - 192]
    test rax, rax
    jz ir_errdefer_ok_174
    jmp ir_errdefer_end_175
ir_errdefer_ok_174:
ir_errdefer_end_175:
    mov rax, [rbp - 184]
    jmp Lhttp_fetch_to_file_exit
    jmp ir_if_end_172
ir_if_next_173:
ir_if_end_172:
    mov rax, 0
    ; Store to variable: pos
    mov qword [rbp - 56], rax  ; To stack [rbp - 56]
    mov rax, 0
    ; Store to variable: i
    mov qword [rbp - 64], rax  ; To stack [rbp - 64]
ir_while_176:
    ; Load variable: CURL_CMD_PREFIX
    lea rax, [rel CURL_CMD_PREFIX]  ; Address of global string
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 200], rax
    mov rax, [rbp - 200]
    mov rax, qword [rax]
    mov [rbp - 208], rax
    ; Load variable: i
    mov rax, qword [rbp - 64]  ; From stack [rbp - 64]
    push rax
    mov rax, [rbp - 208]
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 216], rax
    mov rax, [rbp - 216]
    test rax, rax
    jz ir_while_end_177
    ; Load variable: CURL_CMD_PREFIX
    lea rax, [rel CURL_CMD_PREFIX]  ; Address of global string
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 224], rax
    mov rax, [rbp - 224]
    mov rax, qword [rax]
    mov [rbp - 232], rax
    mov rax, [rbp - 232]
    test rax, rax
    jz ir_trap_null_178
    jmp ir_nonnull_179
ir_trap_null_178:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct21]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Unknown return type - assuming integer
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_179:
    ; Load variable: i
    mov rax, qword [rbp - 64]  ; From stack [rbp - 64]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 240], rax
    mov rax, [rbp - 232]
    push rax
    mov rax, [rbp - 240]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 248], rax
    mov rax, [rbp - 248]
    movzx rax, byte [rax]
    mov [rbp - 256], rax
    ; Load variable: buf
    mov rax, qword [rbp - 48]  ; From stack [rbp - 48]
    test rax, rax
    jz ir_trap_null_180
    jmp ir_nonnull_181
ir_trap_null_180:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct23]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Unknown return type - assuming integer
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_181:
    ; Load variable: pos
    mov rax, qword [rbp - 56]  ; From stack [rbp - 56]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 264], rax
    ; Load variable: buf
    mov rax, qword [rbp - 48]  ; From stack [rbp - 48]
    push rax
    mov rax, [rbp - 264]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 272], rax
    mov rax, [rbp - 272]
    push rax
    mov rax, [rbp - 256]
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: pos
    mov rax, qword [rbp - 56]  ; From stack [rbp - 56]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 288], rax
    mov rax, [rbp - 288]
    ; Store to variable: pos
    mov qword [rbp - 56], rax  ; To stack [rbp - 56]
    ; Load variable: i
    mov rax, qword [rbp - 64]  ; From stack [rbp - 64]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 296], rax
    mov rax, [rbp - 296]
    ; Store to variable: i
    mov qword [rbp - 64], rax  ; To stack [rbp - 64]
    jmp ir_while_176
ir_while_end_177:
    mov rax, 0
    ; Store to variable: i
    mov qword [rbp - 64], rax  ; To stack [rbp - 64]
ir_while_182:
    ; Load variable: url
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_184
    jmp ir_nonnull_185
ir_trap_null_184:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct25]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Unknown return type - assuming integer
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_185:
    ; Load variable: i
    mov rax, qword [rbp - 64]  ; From stack [rbp - 64]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 304], rax
    ; Load variable: url
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 304]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 312], rax
    mov rax, [rbp - 312]
    movzx rax, byte [rax]
    mov [rbp - 320], rax
    mov rax, [rbp - 320]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 328], rax
    mov rax, [rbp - 328]
    test rax, rax
    jz ir_while_end_183
    ; Load variable: url
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    test rax, rax
    jz ir_trap_null_186
    jmp ir_nonnull_187
ir_trap_null_186:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct27]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Unknown return type - assuming integer
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_187:
    ; Load variable: i
    mov rax, qword [rbp - 64]  ; From stack [rbp - 64]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 336], rax
    ; Load variable: url
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    push rax
    mov rax, [rbp - 336]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 344], rax
    mov rax, [rbp - 344]
    movzx rax, byte [rax]
    mov [rbp - 352], rax
    ; Load variable: buf
    mov rax, qword [rbp - 48]  ; From stack [rbp - 48]
    test rax, rax
    jz ir_trap_null_188
    jmp ir_nonnull_189
ir_trap_null_188:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct29]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Unknown return type - assuming integer
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_189:
    ; Load variable: pos
    mov rax, qword [rbp - 56]  ; From stack [rbp - 56]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 360], rax
    ; Load variable: buf
    mov rax, qword [rbp - 48]  ; From stack [rbp - 48]
    push rax
    mov rax, [rbp - 360]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 368], rax
    mov rax, [rbp - 368]
    push rax
    mov rax, [rbp - 352]
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: pos
    mov rax, qword [rbp - 56]  ; From stack [rbp - 56]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 384], rax
    mov rax, [rbp - 384]
    ; Store to variable: pos
    mov qword [rbp - 56], rax  ; To stack [rbp - 56]
    ; Load variable: i
    mov rax, qword [rbp - 64]  ; From stack [rbp - 64]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 392], rax
    mov rax, [rbp - 392]
    ; Store to variable: i
    mov qword [rbp - 64], rax  ; To stack [rbp - 64]
    jmp ir_while_182
ir_while_end_183:
    mov rax, 0
    ; Store to variable: i
    mov qword [rbp - 64], rax  ; To stack [rbp - 64]
ir_while_190:
    ; Load variable: CURL_CMD_MID
    lea rax, [rel CURL_CMD_MID]  ; Address of global string
    push rax
    mov rax, 8
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 400], rax
    mov rax, [rbp - 400]
    mov rax, qword [rax]
    mov [rbp - 408], rax
    ; Load variable: i
    mov rax, qword [rbp - 64]  ; From stack [rbp - 64]
    push rax
    mov rax, [rbp - 408]
    mov r10, rax
    pop rax
    cmp rax, r10
    setl al
    movzx rax, al
    mov [rbp - 416], rax
    mov rax, [rbp - 416]
    test rax, rax
    jz ir_while_end_191
    ; Load variable: CURL_CMD_MID
    lea rax, [rel CURL_CMD_MID]  ; Address of global string
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 424], rax
    mov rax, [rbp - 424]
    mov rax, qword [rax]
    mov [rbp - 432], rax
    mov rax, [rbp - 432]
    test rax, rax
    jz ir_trap_null_192
    jmp ir_nonnull_193
ir_trap_null_192:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct31]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Unknown return type - assuming integer
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_193:
    ; Load variable: i
    mov rax, qword [rbp - 64]  ; From stack [rbp - 64]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 440], rax
    mov rax, [rbp - 432]
    push rax
    mov rax, [rbp - 440]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 448], rax
    mov rax, [rbp - 448]
    movzx rax, byte [rax]
    mov [rbp - 456], rax
    ; Load variable: buf
    mov rax, qword [rbp - 48]  ; From stack [rbp - 48]
    test rax, rax
    jz ir_trap_null_194
    jmp ir_nonnull_195
ir_trap_null_194:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct33]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Unknown return type - assuming integer
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_195:
    ; Load variable: pos
    mov rax, qword [rbp - 56]  ; From stack [rbp - 56]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 464], rax
    ; Load variable: buf
    mov rax, qword [rbp - 48]  ; From stack [rbp - 48]
    push rax
    mov rax, [rbp - 464]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 472], rax
    mov rax, [rbp - 472]
    push rax
    mov rax, [rbp - 456]
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: pos
    mov rax, qword [rbp - 56]  ; From stack [rbp - 56]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 488], rax
    mov rax, [rbp - 488]
    ; Store to variable: pos
    mov qword [rbp - 56], rax  ; To stack [rbp - 56]
    ; Load variable: i
    mov rax, qword [rbp - 64]  ; From stack [rbp - 64]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 496], rax
    mov rax, [rbp - 496]
    ; Store to variable: i
    mov qword [rbp - 64], rax  ; To stack [rbp - 64]
    jmp ir_while_190
ir_while_end_191:
    mov rax, 0
    ; Store to variable: i
    mov qword [rbp - 64], rax  ; To stack [rbp - 64]
ir_while_196:
    ; Load variable: output_path
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    test rax, rax
    jz ir_trap_null_198
    jmp ir_nonnull_199
ir_trap_null_198:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct35]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Unknown return type - assuming integer
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_199:
    ; Load variable: i
    mov rax, qword [rbp - 64]  ; From stack [rbp - 64]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 504], rax
    ; Load variable: output_path
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, [rbp - 504]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 512], rax
    mov rax, [rbp - 512]
    movzx rax, byte [rax]
    mov [rbp - 520], rax
    mov rax, [rbp - 520]
    push rax
    mov rax, 0
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 528], rax
    mov rax, [rbp - 528]
    test rax, rax
    jz ir_while_end_197
    ; Load variable: output_path
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    test rax, rax
    jz ir_trap_null_200
    jmp ir_nonnull_201
ir_trap_null_200:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct37]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Unknown return type - assuming integer
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_201:
    ; Load variable: i
    mov rax, qword [rbp - 64]  ; From stack [rbp - 64]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 536], rax
    ; Load variable: output_path
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, [rbp - 536]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 544], rax
    mov rax, [rbp - 544]
    movzx rax, byte [rax]
    mov [rbp - 552], rax
    ; Load variable: buf
    mov rax, qword [rbp - 48]  ; From stack [rbp - 48]
    test rax, rax
    jz ir_trap_null_202
    jmp ir_nonnull_203
ir_trap_null_202:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct39]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Unknown return type - assuming integer
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_203:
    ; Load variable: pos
    mov rax, qword [rbp - 56]  ; From stack [rbp - 56]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 560], rax
    ; Load variable: buf
    mov rax, qword [rbp - 48]  ; From stack [rbp - 48]
    push rax
    mov rax, [rbp - 560]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 568], rax
    mov rax, [rbp - 568]
    push rax
    mov rax, [rbp - 552]
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; Load variable: pos
    mov rax, qword [rbp - 56]  ; From stack [rbp - 56]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 584], rax
    mov rax, [rbp - 584]
    ; Store to variable: pos
    mov qword [rbp - 56], rax  ; To stack [rbp - 56]
    ; Load variable: i
    mov rax, qword [rbp - 64]  ; From stack [rbp - 64]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 592], rax
    mov rax, [rbp - 592]
    ; Store to variable: i
    mov qword [rbp - 64], rax  ; To stack [rbp - 64]
    jmp ir_while_196
ir_while_end_197:
    ; Load variable: buf
    mov rax, qword [rbp - 48]  ; From stack [rbp - 48]
    test rax, rax
    jz ir_trap_null_204
    jmp ir_nonnull_205
ir_trap_null_204:
    ; IR call: puts (1 args)
    sub rsp, 32
    ; String literal (37 bytes)
    lea rax, [rel Lstr_struct41]  ; Load string struct address
    mov rcx, rax
    call puts
    add rsp, 32
    ; Unknown return type - assuming integer
    ; IR call: exit (1 args)
    sub rsp, 32
    mov rax, 1
    mov rcx, rax
    call exit
    add rsp, 32
    ; Unknown return type - assuming integer
ir_nonnull_205:
    ; Load variable: pos
    mov rax, qword [rbp - 56]  ; From stack [rbp - 56]
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    imul rax, r10
    mov [rbp - 600], rax
    ; Load variable: buf
    mov rax, qword [rbp - 48]  ; From stack [rbp - 48]
    push rax
    mov rax, [rbp - 600]
    mov r10, rax
    pop rax
    add rax, r10
    mov [rbp - 608], rax
    mov rax, [rbp - 608]
    push rax
    mov rax, 0
    mov rcx, rax
    pop rax
    mov byte [rax], cl
    ; IR call: system (1 args)
    sub rsp, 32
    ; Load variable: buf
    mov rax, qword [rbp - 48]  ; From stack [rbp - 48]
    mov rcx, rax
    call system
    add rsp, 32
    ; Integer/pointer return value in rax
    ; 32-bit return value already in eax
    mov [rbp - 624], rax
    mov rax, [rbp - 624]
    ; Store to variable: result
    mov dword [rbp - 68], eax  ; To stack [rbp - 68]
    ; IR call: free (1 args)
    sub rsp, 32
    ; Load variable: buf
    mov rax, qword [rbp - 48]  ; From stack [rbp - 48]
    mov rcx, rax
    call free
    add rsp, 32
    ; Void return - no value to handle
    mov [rbp - 632], rax
    ; Load variable: result
    movsxd rax, dword [rbp - 68]  ; From stack [rbp - 68]
    mov [rbp - 640], rax
    mov rax, [rbp - 640]
    test rax, rax
    jz ir_errdefer_ok_206
    jmp ir_errdefer_end_207
ir_errdefer_ok_206:
ir_errdefer_end_207:
    ; Load variable: result
    movsxd rax, dword [rbp - 68]  ; From stack [rbp - 68]
    jmp Lhttp_fetch_to_file_exit
Lhttp_fetch_to_file_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

; Default program entry point
global mainCRTStartup
mainCRTStartup:
    sub rsp, 40      ; Shadow space + alignment
    ; Initialize garbage collector runtime
    lea rcx, [rsp + 40]
    extern gc_init
    call gc_init
    extern gc_register_root
    lea rcx, [rel CURL_CMD_PREFIX]
    call gc_register_root
    lea rcx, [rel CURL_CMD_MID]
    call gc_register_root
    extern gc_shutdown
    call gc_shutdown
    mov rcx, 0       ; Default exit status
    extern ExitProcess
    call ExitProcess

; Data section for global variables
section .data
; Global variable: CURL_CMD_PREFIX (string, 16 bytes)
CURL_CMD_PREFIX:
    dq Lstr0  ; Pointer to string data
    dq 9  ; String length
Lstr0:
    db "curl -sL ", 0

; Global variable: CURL_CMD_MID (string, 16 bytes)
CURL_CMD_MID:
    dq Lstr1  ; Pointer to string data
    dq 4  ; String length
Lstr1:
    db " -o ", 0

Lstr_chars2:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct3:
    dq Lstr_chars2
    dq 37

Lstr_chars4:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct5:
    dq Lstr_chars4
    dq 37

Lstr_chars6:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct7:
    dq Lstr_chars6
    dq 37

Lstr_chars8:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct9:
    dq Lstr_chars8
    dq 37

Lstr_chars10:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct11:
    dq Lstr_chars10
    dq 37

Lstr_chars12:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct13:
    dq Lstr_chars12
    dq 37

Lstr_chars14:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct15:
    dq Lstr_chars14
    dq 37

Lstr_chars16:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct17:
    dq Lstr_chars16
    dq 37

Lstr_chars18:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct19:
    dq Lstr_chars18
    dq 37

Lstr_chars20:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct21:
    dq Lstr_chars20
    dq 37

Lstr_chars22:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct23:
    dq Lstr_chars22
    dq 37

Lstr_chars24:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct25:
    dq Lstr_chars24
    dq 37

Lstr_chars26:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct27:
    dq Lstr_chars26
    dq 37

Lstr_chars28:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct29:
    dq Lstr_chars28
    dq 37

Lstr_chars30:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct31:
    dq Lstr_chars30
    dq 37

Lstr_chars32:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct33:
    dq Lstr_chars32
    dq 37

Lstr_chars34:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct35:
    dq Lstr_chars34
    dq 37

Lstr_chars36:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct37:
    dq Lstr_chars36
    dq 37

Lstr_chars38:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct39:
    dq Lstr_chars38
    dq 37

Lstr_chars40:
    db "Fatal error: Null pointer dereference", 0
    align 8
Lstr_struct41:
    dq Lstr_chars40
    dq 37

