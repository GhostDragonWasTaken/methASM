; Generated by MethASM
; x86-64 Assembly Output

section .text
; Code section

; First pass: processing 3 declarations
; Declaration 0 type: 4 (AST_INLINE_ASM = 21)
; Declaration 1 type: 4 (AST_INLINE_ASM = 21)
; Declaration 2 type: 4 (AST_INLINE_ASM = 21)

section .text
    extern puts

global cast_helper

cast_helper:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 48    ; Allocate 48 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_0:
    mov rax, 0
    mov [rbp - 8], rax
    mov rax, [rbp - 8]
    mov [rbp - 16], rax
    mov rax, [rbp - 16]
    test rax, rax
    jz ir_errdefer_ok_1
    jmp ir_errdefer_end_2
ir_errdefer_ok_1:
ir_errdefer_end_2:
    mov rax, [rbp - 8]
    jmp Lcast_helper_exit
Lcast_helper_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

global main

main:
    push rbp        ; Save old base pointer
    mov rbp, rsp  ; Set new base pointer
    sub rsp, 512    ; Allocate 512 bytes on stack (aligned)
    ; Registering 0 function parameters
ir_entry_3:
    mov rax, 0x40091eb851eb851f
    ; Store to variable: f
    mov qword [rbp - 8], rax  ; To stack [rbp - 8]
    ; Load variable: f
    mov rax, qword [rbp - 8]  ; From stack [rbp - 8]
    movq xmm0, rax
    cvttsd2si rax, xmm0
    mov [rbp - 80], rax
    mov rax, [rbp - 80]
    ; Store to variable: i
    mov qword [rbp - 16], rax  ; To stack [rbp - 16]
    ; Load variable: i
    mov rax, qword [rbp - 16]  ; From stack [rbp - 16]
    push rax
    mov rax, 3
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 88], rax
    mov rax, [rbp - 88]
    test rax, rax
    jz ir_if_next_5
    mov rax, 1
    mov [rbp - 96], rax
    mov rax, [rbp - 96]
    test rax, rax
    jz ir_errdefer_ok_6
    jmp ir_errdefer_end_7
ir_errdefer_ok_6:
ir_errdefer_end_7:
    mov rax, 1
    jmp Lmain_exit
    jmp ir_if_end_4
ir_if_next_5:
ir_if_end_4:
    mov rax, 5
    ; Store to variable: i2
    mov qword [rbp - 24], rax  ; To stack [rbp - 24]
    ; Load variable: i2
    mov rax, qword [rbp - 24]  ; From stack [rbp - 24]
    cvtsi2sd xmm0, rax
    movq rax, xmm0
    mov [rbp - 104], rax
    mov rax, [rbp - 104]
    ; Store to variable: f2
    mov qword [rbp - 32], rax  ; To stack [rbp - 32]
    ; Load variable: f2
    mov rax, qword [rbp - 32]  ; From stack [rbp - 32]
    push rax
    mov rax, 0x4014000000000000
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 112], rax
    mov rax, [rbp - 112]
    test rax, rax
    jz ir_if_next_9
    mov rax, 2
    mov [rbp - 120], rax
    mov rax, [rbp - 120]
    test rax, rax
    jz ir_errdefer_ok_10
    jmp ir_errdefer_end_11
ir_errdefer_ok_10:
ir_errdefer_end_11:
    mov rax, 2
    jmp Lmain_exit
    jmp ir_if_end_8
ir_if_next_9:
ir_if_end_8:
    mov rax, 0
    mov [rbp - 128], rax
    mov rax, [rbp - 128]
    ; Store to variable: p
    mov qword [rbp - 40], rax  ; To stack [rbp - 40]
    mov rax, 257
    ; Store to variable: large
    mov qword [rbp - 48], rax  ; To stack [rbp - 48]
    ; Load variable: large
    mov rax, qword [rbp - 48]  ; From stack [rbp - 48]
    movsx rax, al
    mov [rbp - 136], rax
    mov rax, [rbp - 136]
    ; Store to variable: small
    mov byte [rbp - 49], al  ; To stack [rbp - 49]
    ; Load variable: small
    movsx rax, byte [rbp - 49]  ; From stack [rbp - 49] (signed)
    push rax
    mov rax, 1
    mov r10, rax
    pop rax
    cmp rax, r10
    setne al
    movzx rax, al
    mov [rbp - 144], rax
    mov rax, [rbp - 144]
    test rax, rax
    jz ir_if_next_13
    mov rax, 3
    mov [rbp - 152], rax
    mov rax, [rbp - 152]
    test rax, rax
    jz ir_errdefer_ok_14
    jmp ir_errdefer_end_15
ir_errdefer_ok_14:
ir_errdefer_end_15:
    mov rax, 3
    jmp Lmain_exit
    jmp ir_if_end_12
ir_if_next_13:
ir_if_end_12:
    ; IR call: cast_helper (0 args)
    sub rsp, 32
    call cast_helper
    add rsp, 32
    ; Integer/pointer return value in rax
    mov [rbp - 160], rax
    mov rax, [rbp - 160]
    ; Store to variable: p1
    mov qword [rbp - 64], rax  ; To stack [rbp - 64]
    ; Load variable: p1
    mov rax, qword [rbp - 64]  ; From stack [rbp - 64]
    mov [rbp - 168], rax
    mov rax, [rbp - 168]
    ; Store to variable: p2
    mov qword [rbp - 72], rax  ; To stack [rbp - 72]
    mov rax, 0
    mov [rbp - 176], rax
    mov rax, [rbp - 176]
    test rax, rax
    jz ir_errdefer_ok_16
    jmp ir_errdefer_end_17
ir_errdefer_ok_16:
ir_errdefer_end_17:
    mov rax, 0
    jmp Lmain_exit
Lmain_exit:
    ; Function epilogue
    mov rsp, rbp  ; Restore stack pointer
    pop rbp         ; Restore old base pointer
    ret               ; Return to caller

; Default program entry point
global mainCRTStartup
mainCRTStartup:
    sub rsp, 40      ; Shadow space + alignment
    ; Initialize garbage collector runtime
    lea rcx, [rsp + 40]
    extern gc_init
    call gc_init
    ; Call user main function
    call main
    mov [rsp + 32], rax ; Preserve main return code
    extern gc_shutdown
    call gc_shutdown
    mov rcx, [rsp + 32] ; Use main return as exit code
    extern ExitProcess
    call ExitProcess
