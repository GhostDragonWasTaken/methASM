#include "code_generator.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

CodeGenerator* code_generator_create(SymbolTable* symbol_table, RegisterAllocator* allocator) {
    CodeGenerator* generator = malloc(sizeof(CodeGenerator));
    if (!generator) return NULL;
    
    generator->symbol_table = symbol_table;
    generator->register_allocator = allocator;
    generator->output_file = NULL;
    generator->output_buffer = malloc(4096);
    generator->buffer_size = 0;
    generator->buffer_capacity = 4096;
    generator->current_label_id = 0;
    generator->current_stack_offset = 0;
    generator->function_stack_size = 0;
    generator->current_function_name = NULL;
    generator->global_variables_buffer = malloc(2048);
    generator->global_variables_size = 0;
    generator->global_variables_capacity = 2048;
    
    if (!generator->output_buffer || !generator->global_variables_buffer) {
        free(generator->output_buffer);
        free(generator->global_variables_buffer);
        free(generator);
        return NULL;
    }
    
    generator->output_buffer[0] = '\0';
    generator->global_variables_buffer[0] = '\0';
    
    return generator;
}

void code_generator_destroy(CodeGenerator* generator) {
    if (generator) {
        free(generator->output_buffer);
        free(generator->current_function_name);
        free(generator->global_variables_buffer);
        free(generator);
    }
}

int code_generator_generate_program(CodeGenerator* generator, ASTNode* program) {
    if (!generator || !program) {
        return 0;
    }
    
    if (program->type != AST_PROGRAM) {
        return 0;
    }
    
    // Generate assembly header
    code_generator_emit(generator, "# Generated by MethASM\n");
    code_generator_emit(generator, "# x86-64 Assembly Output\n\n");
    
    // Generate data section for global variables
    code_generator_emit_data_section(generator);
    
    // Generate text section
    code_generator_emit_text_section(generator);
    
    // First pass: collect global variables and handle top-level inline assembly
    Program* program_data = (Program*)program->data;
    if (program_data) {
        code_generator_emit(generator, "# First pass: processing %zu declarations\n", program_data->declaration_count);
        for (size_t i = 0; i < program_data->declaration_count; i++) {
            ASTNode* declaration = program_data->declarations[i];
            code_generator_emit(generator, "# Declaration %zu type: %d (AST_INLINE_ASM = %d)\n", i, declaration->type, AST_INLINE_ASM);
            
            if (declaration->type == AST_VAR_DECLARATION) {
                code_generator_generate_global_variable(generator, declaration);
            } else if (declaration->type == AST_INLINE_ASM) {
                // Top-level inline assembly - emit directly without register preservation
                InlineAsm* asm_data = (InlineAsm*)declaration->data;
                if (asm_data && asm_data->assembly_code) {
                    code_generator_emit(generator, "# Top-level inline assembly found\n");
                    code_generator_emit(generator, "# Assembly: %s\n", asm_data->assembly_code);
                    code_generator_emit_inline_asm_block(generator, asm_data->assembly_code);
                    code_generator_emit(generator, "\n");
                } else {
                    code_generator_emit(generator, "# Inline assembly node but no data\n");
                }
            }
        }
    } else {
        code_generator_emit(generator, "# No program data found\n");
    }
    
    // Emit the collected global variables in data section
    if (generator->global_variables_size > 0) {
        code_generator_emit(generator, "%s", generator->global_variables_buffer);
    }
    
    // Second pass: process functions and other declarations
    if (program_data) {
        for (size_t i = 0; i < program_data->declaration_count; i++) {
            ASTNode* declaration = program_data->declarations[i];
            
            switch (declaration->type) {
                case AST_FUNCTION_DECLARATION:
                    code_generator_generate_function(generator, declaration);
                    break;
                case AST_VAR_DECLARATION:
                    // Already handled in first pass
                    break;
                case AST_STRUCT_DECLARATION:
                    // Generate struct type layout information
                    code_generator_generate_struct_declaration(generator, declaration);
                    break;
                case AST_INLINE_ASM:
                    // Already handled in first pass
                    break;
                default:
                    // Other declarations
                    break;
            }
        }
    }
    
    // Generate main entry point if no main function was found
    code_generator_emit(generator, "\n# Default program entry point\n");
    code_generator_emit(generator, ".global _start\n");
    code_generator_emit(generator, "_start:\n");
    code_generator_emit(generator, "    # Exit gracefully\n");
    code_generator_emit(generator, "    mov $60, %%rax    # sys_exit\n");
    code_generator_emit(generator, "    mov $0, %%rdi     # exit status\n");
    code_generator_emit(generator, "    syscall\n");
    
    return 1;
}

void code_generator_generate_function(CodeGenerator* generator, ASTNode* function) {
    if (!generator || !function || function->type != AST_FUNCTION_DECLARATION) {
        return;
    }
    
    FunctionDeclaration* func_data = (FunctionDeclaration*)function->data;
    if (!func_data || !func_data->name) {
        return;
    }
    
    // Make function globally accessible
    code_generator_emit_global_symbol(generator, func_data->name);
    
    // Calculate stack space needed (simplified - in practice would analyze local variables)
    int stack_size = func_data->parameter_count * 8; // Rough estimate
    
    // Generate function prologue
    code_generator_function_prologue(generator, func_data->name, stack_size);
    
    // Generate function body
    if (func_data->body) {
        // Generate statements in function body
        if (func_data->body->type == AST_PROGRAM) {
            // Handle compound statement (block)
            Program* block = (Program*)func_data->body->data;
            if (block) {
                for (size_t i = 0; i < block->declaration_count; i++) {
                    code_generator_generate_statement(generator, block->declarations[i]);
                }
            }
        } else {
            // Single statement
            code_generator_generate_statement(generator, func_data->body);
        }
    }
    
    // Generate function epilogue
    code_generator_function_epilogue(generator);
}

void code_generator_generate_statement(CodeGenerator* generator, ASTNode* statement) {
    if (!generator || !statement) {
        return;
    }
    
    switch (statement->type) {
        case AST_VAR_DECLARATION:
            {
                // Local variable declaration inside function
                code_generator_generate_local_variable(generator, statement);
            }
            break;
            
        case AST_ASSIGNMENT:
            {
                // Assignment statement
                code_generator_generate_assignment_statement(generator, statement);
            }
            break;
            
        case AST_FUNCTION_CALL:
            {
                // Function call as statement (not expression)
                code_generator_generate_function_call(generator, statement);
            }
            break;
            
        case AST_RETURN_STATEMENT:
            {
                ReturnStatement* return_data = (ReturnStatement*)statement->data;
                code_generator_emit(generator, "    # Return statement\n");
                
                if (return_data && return_data->value) {
                    // Generate the return value expression
                    code_generator_generate_expression(generator, return_data->value);
                    // Result is already in RAX (the return register for integers)
                    code_generator_emit(generator, "    # Return value in %%rax\n");
                } else {
                    // Void return - no value to return
                    code_generator_emit(generator, "    # Void return\n");
                }
                
                // Jump to function epilogue (or inline it)
                code_generator_function_epilogue(generator);
            }
            break;
            
        case AST_INLINE_ASM:
            {
                // Inline assembly within function
                code_generator_generate_inline_assembly(generator, statement);
            }
            break;
            
        default:
            code_generator_emit(generator, "    # Unhandled statement type: %d\n", statement->type);
            break;
    }
}

void code_generator_generate_expression(CodeGenerator* generator, ASTNode* expression) {
    if (!generator || !expression) {
        return;
    }
    
    switch (expression->type) {
        case AST_NUMBER_LITERAL:
            {
                NumberLiteral* num_data = (NumberLiteral*)expression->data;
                if (num_data) {
                    if (num_data->is_float) {
                        code_generator_emit(generator, "    # Float literal: %f\n", num_data->float_value);
                        // TODO: Load float value into appropriate register
                    } else {
                        code_generator_emit(generator, "    # Integer literal: %lld\n", num_data->int_value);
                        code_generator_emit(generator, "    mov $%lld, %%rax\n", num_data->int_value);
                    }
                }
            }
            break;
            
        case AST_STRING_LITERAL:
            {
                StringLiteral* str_data = (StringLiteral*)expression->data;
                if (str_data && str_data->value) {
                    code_generator_load_string_literal(generator, str_data->value);
                }
            }
            break;
            
        case AST_IDENTIFIER:
            {
                Identifier* id_data = (Identifier*)expression->data;
                if (id_data && id_data->name) {
                    code_generator_load_variable(generator, id_data->name);
                }
            }
            break;
            
        case AST_BINARY_EXPRESSION:
            {
                BinaryExpression* bin_data = (BinaryExpression*)expression->data;
                if (bin_data && bin_data->left && bin_data->right && bin_data->operator) {
                    code_generator_generate_binary_operation(generator, bin_data->left, 
                                                           bin_data->operator, bin_data->right);
                }
            }
            break;
            
        case AST_UNARY_EXPRESSION:
            {
                UnaryExpression* unary_data = (UnaryExpression*)expression->data;
                if (unary_data && unary_data->operand && unary_data->operator) {
                    code_generator_generate_unary_operation(generator, unary_data->operator, 
                                                           unary_data->operand);
                }
            }
            break;
            
        case AST_FUNCTION_CALL:
            {
                // Function call as expression (returns value)
                code_generator_generate_function_call(generator, expression);
            }
            break;
            
        case AST_MEMBER_ACCESS:
            {
                // Member access (struct.field)
                code_generator_generate_member_access(generator, expression);
            }
            break;
            
        default:
            code_generator_emit(generator, "    # Unhandled expression type: %d\n", expression->type);
            break;
    }
}

void code_generator_emit(CodeGenerator* generator, const char* format, ...) {
    va_list args;
    va_start(args, format);
    
    // Calculate required size
    va_list args_copy;
    va_copy(args_copy, args);
    int required_size = vsnprintf(NULL, 0, format, args_copy);
    va_end(args_copy);
    
    // Ensure buffer has enough space
    if (generator->buffer_size + required_size + 1 > generator->buffer_capacity) {
        size_t new_capacity = generator->buffer_capacity * 2;
        while (new_capacity < generator->buffer_size + required_size + 1) {
            new_capacity *= 2;
        }
        
        char* new_buffer = realloc(generator->output_buffer, new_capacity);
        if (!new_buffer) {
            va_end(args);
            return;
        }
        
        generator->output_buffer = new_buffer;
        generator->buffer_capacity = new_capacity;
    }
    
    // Append to buffer
    int written = vsnprintf(generator->output_buffer + generator->buffer_size, 
                           generator->buffer_capacity - generator->buffer_size, 
                           format, args);
    
    if (written > 0) {
        generator->buffer_size += written;
    }
    
    va_end(args);
}

char* code_generator_get_output(CodeGenerator* generator) {
    return generator->output_buffer;
}

// Stack frame management functions
void code_generator_function_prologue(CodeGenerator* generator, const char* function_name, int stack_size) {
    // Save current function name and reset stack tracking
    free(generator->current_function_name);
    generator->current_function_name = strdup(function_name);
    generator->function_stack_size = stack_size;
    generator->current_stack_offset = 0; // Reset for new function
    
    // Generate function label
    code_generator_emit(generator, "\n%s:\n", function_name);
    
    // Standard x86-64 function prologue
    code_generator_emit(generator, "    push %%rbp        # Save old base pointer\n");
    code_generator_emit(generator, "    mov %%rsp, %%rbp  # Set new base pointer\n");
    
    // Allocate stack space if needed (will be expanded as local variables are encountered)
    if (stack_size > 0) {
        code_generator_emit(generator, "    sub $%d, %%rsp    # Allocate %d bytes on stack\n", 
                           stack_size, stack_size);
    }
}

void code_generator_function_epilogue(CodeGenerator* generator) {
    // Standard x86-64 function epilogue
    code_generator_emit(generator, "    mov %%rbp, %%rsp  # Restore stack pointer\n");
    code_generator_emit(generator, "    pop %%rbp         # Restore old base pointer\n");
    code_generator_emit(generator, "    ret               # Return to caller\n");
}

char* code_generator_generate_label(CodeGenerator* generator, const char* prefix) {
    char* label = malloc(64);
    if (label) {
        snprintf(label, 64, ".L%s%d", prefix, generator->current_label_id++);
    }
    return label;
}

// Assembly helper functions
void code_generator_emit_data_section(CodeGenerator* generator) {
    code_generator_emit(generator, ".section .data\n");
    code_generator_emit(generator, "# Global variables will be placed here\n\n");
}

void code_generator_emit_text_section(CodeGenerator* generator) {
    code_generator_emit(generator, ".section .text\n");
    code_generator_emit(generator, "# Code section\n\n");
}

void code_generator_emit_global_symbol(CodeGenerator* generator, const char* symbol) {
    code_generator_emit(generator, ".global %s\n", symbol);
}

void code_generator_emit_instruction(CodeGenerator* generator, const char* mnemonic, const char* operands) {
    if (operands && strlen(operands) > 0) {
        code_generator_emit(generator, "    %s %s\n", mnemonic, operands);
    } else {
        code_generator_emit(generator, "    %s\n", mnemonic);
    }
}

// Helper function to emit to global variables buffer
static void emit_to_global_buffer(CodeGenerator* generator, const char* format, ...) {
    va_list args;
    va_start(args, format);
    
    // Calculate required size
    va_list args_copy;
    va_copy(args_copy, args);
    int required_size = vsnprintf(NULL, 0, format, args_copy);
    va_end(args_copy);
    
    // Ensure buffer has enough space
    if (generator->global_variables_size + required_size + 1 > generator->global_variables_capacity) {
        size_t new_capacity = generator->global_variables_capacity * 2;
        while (new_capacity < generator->global_variables_size + required_size + 1) {
            new_capacity *= 2;
        }
        
        char* new_buffer = realloc(generator->global_variables_buffer, new_capacity);
        if (!new_buffer) {
            va_end(args);
            return;
        }
        
        generator->global_variables_buffer = new_buffer;
        generator->global_variables_capacity = new_capacity;
    }
    
    // Append to buffer
    int written = vsnprintf(generator->global_variables_buffer + generator->global_variables_size, 
                           generator->global_variables_capacity - generator->global_variables_size, 
                           format, args);
    
    if (written > 0) {
        generator->global_variables_size += written;
    }
    
    va_end(args);
}

// Variable declaration implementation functions
void code_generator_generate_global_variable(CodeGenerator* generator, ASTNode* var_declaration) {
    if (!generator || !var_declaration || var_declaration->type != AST_VAR_DECLARATION) {
        return;
    }
    
    VarDeclaration* var_data = (VarDeclaration*)var_declaration->data;
    if (!var_data || !var_data->name) {
        return;
    }
    
    // Calculate variable size
    int var_size = code_generator_calculate_variable_size(generator, var_data->type_name);
    if (var_size <= 0) {
        var_size = 8; // Default to 8 bytes for unknown types
    }
    
    emit_to_global_buffer(generator, "# Global variable: %s (%s, %d bytes)\n", 
                         var_data->name, var_data->type_name ? var_data->type_name : "unknown", var_size);
    
    if (var_data->initializer) {
        // Initialized data goes in .data section
        emit_to_global_buffer(generator, "%s:\n", var_data->name);
        
        // Generate initialization based on type and initializer
        if (var_data->initializer->type == AST_NUMBER_LITERAL) {
            NumberLiteral* num = (NumberLiteral*)var_data->initializer->data;
            if (num) {
                if (num->is_float) {
                    emit_to_global_buffer(generator, "    .quad 0x%016llx  # float64: %f\n", 
                                         *(long long*)&num->float_value, num->float_value);
                } else {
                    if (var_size == 1) {
                        emit_to_global_buffer(generator, "    .byte %lld\n", num->int_value);
                    } else if (var_size == 2) {
                        emit_to_global_buffer(generator, "    .word %lld\n", num->int_value);
                    } else if (var_size == 4) {
                        emit_to_global_buffer(generator, "    .long %lld\n", num->int_value);
                    } else {
                        emit_to_global_buffer(generator, "    .quad %lld\n", num->int_value);
                    }
                }
            }
        } else if (var_data->initializer->type == AST_STRING_LITERAL) {
            StringLiteral* str = (StringLiteral*)var_data->initializer->data;
            if (str && str->value) {
                emit_to_global_buffer(generator, "    .asciz \"%s\"\n", str->value);
            }
        } else {
            // For complex initializers, reserve space and initialize at runtime
            emit_to_global_buffer(generator, "    .space %d\n", var_size);
        }
    } else {
        // Uninitialized data goes in .bss section
        emit_to_global_buffer(generator, ".bss\n");
        emit_to_global_buffer(generator, "%s:\n", var_data->name);
        emit_to_global_buffer(generator, "    .space %d\n", var_size);
        emit_to_global_buffer(generator, ".section .data\n");
    }
    
    emit_to_global_buffer(generator, "\n");
}

void code_generator_generate_local_variable(CodeGenerator* generator, ASTNode* var_declaration) {
    if (!generator || !var_declaration || var_declaration->type != AST_VAR_DECLARATION) {
        return;
    }
    
    VarDeclaration* var_data = (VarDeclaration*)var_declaration->data;
    if (!var_data || !var_data->name) {
        return;
    }
    
    // Calculate variable size and allocate stack space
    int var_size = code_generator_calculate_variable_size(generator, var_data->type_name);
    if (var_size <= 0) {
        var_size = 8; // Default to 8 bytes for unknown types
    }
    
    int alignment = (var_size > 4) ? 8 : var_size; // Align to size, max 8
    int offset = code_generator_allocate_stack_space(generator, var_size, alignment);
    
    code_generator_emit(generator, "    # Local variable: %s (%s, %d bytes) at offset -%d\n", 
                       var_data->name, var_data->type_name ? var_data->type_name : "unknown", 
                       var_size, offset);
    
    // Update symbol table with memory offset if symbol exists
    Symbol* symbol = symbol_table_lookup(generator->symbol_table, var_data->name);
    if (symbol && symbol->kind == SYMBOL_VARIABLE) {
        symbol->data.variable.memory_offset = -offset; // Negative offset from rbp
        symbol->data.variable.is_in_register = 0;
    }
    
    // Generate initialization code if initializer exists
    if (var_data->initializer) {
        code_generator_generate_variable_initialization(generator, symbol, var_data->initializer);
    }
}

void code_generator_generate_variable_initialization(CodeGenerator* generator, Symbol* symbol, ASTNode* initializer) {
    if (!generator || !symbol || !initializer) {
        return;
    }
    
    code_generator_emit(generator, "    # Initialize variable %s\n", symbol->name);
    
    // Generate the initializer expression
    code_generator_generate_expression(generator, initializer);
    
    // Store the result (in rax) to the variable's memory location
    if (symbol->data.variable.is_in_register) {
        // TODO: Handle register allocation
        code_generator_emit(generator, "    # TODO: Store to register\n");
    } else {
        // Store to stack location
        int offset = symbol->data.variable.memory_offset;
        if (symbol->type && symbol->type->size <= 4) {
            code_generator_emit(generator, "    mov %%eax, %d(%%rbp)\n", offset);
        } else {
            code_generator_emit(generator, "    mov %%rax, %d(%%rbp)\n", offset);
        }
    }
}

int code_generator_calculate_variable_size(CodeGenerator* generator, const char* type_name) {
    (void)generator; // Suppress unused parameter warning
    
    if (!type_name) {
        return 8; // Default size
    }
    
    // Basic type size mapping
    if (strcmp(type_name, "int8") == 0 || strcmp(type_name, "uint8") == 0) {
        return 1;
    } else if (strcmp(type_name, "int16") == 0 || strcmp(type_name, "uint16") == 0) {
        return 2;
    } else if (strcmp(type_name, "int32") == 0 || strcmp(type_name, "uint32") == 0 || 
               strcmp(type_name, "float32") == 0) {
        return 4;
    } else if (strcmp(type_name, "int64") == 0 || strcmp(type_name, "uint64") == 0 || 
               strcmp(type_name, "float64") == 0 || strcmp(type_name, "string") == 0) {
        return 8;
    }
    
    // For unknown types, assume pointer size
    return 8;
}

int code_generator_allocate_stack_space(CodeGenerator* generator, int size, int alignment) {
    if (!generator) {
        return 0;
    }
    
    // Align current offset
    int aligned_offset = generator->current_stack_offset;
    if (alignment > 1) {
        aligned_offset = (aligned_offset + alignment - 1) & ~(alignment - 1);
    }
    
    // Allocate space
    aligned_offset += size;
    generator->current_stack_offset = aligned_offset;
    
    return aligned_offset;
}

// Function call implementation functions
void code_generator_generate_function_call(CodeGenerator* generator, ASTNode* call_expression) {
    if (!generator || !call_expression || call_expression->type != AST_FUNCTION_CALL) {
        return;
    }
    
    CallExpression* call_data = (CallExpression*)call_expression->data;
    if (!call_data || !call_data->function_name) {
        return;
    }
    
    code_generator_emit(generator, "    # Function call: %s\n", call_data->function_name);
    
    // Get calling convention spec from register allocator
    CallingConventionSpec* conv_spec = generator->register_allocator->calling_convention;
    if (!conv_spec) {
        code_generator_emit(generator, "    # Error: No calling convention set\n");
        return;
    }
    
    // 1. Align stack for function call (x86-64 requires 16-byte alignment)
    code_generator_align_stack_for_call(generator, call_data->argument_count);
    
    // 2. Save caller-saved registers that are NOT used for parameters
    // TODO: Only save registers that are actually in use and not parameter registers
    code_generator_save_caller_saved_registers(generator);
    
    // 3. Pass parameters
    code_generator_generate_parameter_passing(generator, call_data->arguments, call_data->argument_count);
    
    // 4. Generate the call instruction
    code_generator_emit(generator, "    call %s\n", call_data->function_name);
    
    // 5. Clean up stack if needed (for parameters passed on stack)
    int stack_params = 0;
    if (call_data->argument_count > conv_spec->int_param_count) {
        stack_params = call_data->argument_count - conv_spec->int_param_count;
        if (stack_params > 0) {
            code_generator_emit(generator, "    add $%d, %%rsp    # Clean up stack parameters\n", 
                               stack_params * 8);
        }
    }
    
    // 6. Restore caller-saved registers
    code_generator_restore_caller_saved_registers(generator);
    
    // 7. Return value is now in RAX (or XMM0 for floats)
    code_generator_emit(generator, "    # Return value in %%rax\n");
}

void code_generator_generate_parameter_passing(CodeGenerator* generator, ASTNode** arguments, size_t argument_count) {
    if (!generator || !arguments || argument_count == 0) {
        return;
    }
    
    CallingConventionSpec* conv_spec = generator->register_allocator->calling_convention;
    if (!conv_spec) {
        return;
    }
    
    code_generator_emit(generator, "    # Passing %zu parameters\n", argument_count);
    
    // Pass parameters according to calling convention
    for (size_t i = 0; i < argument_count; i++) {
        if (arguments[i]) {
            // For now, assume all parameters are integers (TODO: add type checking)
            Type* param_type = NULL; // TODO: Get actual parameter type from symbol table
            code_generator_generate_parameter(generator, arguments[i], (int)i, param_type);
        }
    }
}

void code_generator_generate_parameter(CodeGenerator* generator, ASTNode* argument, int param_index, Type* param_type) {
    if (!generator || !argument) {
        return;
    }
    
    CallingConventionSpec* conv_spec = generator->register_allocator->calling_convention;
    if (!conv_spec) {
        return;
    }
    
    // Generate the argument expression (result will be in RAX)
    code_generator_generate_expression(generator, argument);
    
    // Determine if this parameter goes in a register or on the stack
    if (param_index < (int)conv_spec->int_param_count) {
        // Parameter goes in register
        x86Register param_reg = conv_spec->int_param_registers[param_index];
        const char* reg_name = code_generator_get_register_name(param_reg);
        
        if (reg_name) {
            code_generator_emit(generator, "    mov %%rax, %%%s    # Parameter %d in register\n", 
                               reg_name, param_index + 1);
        }
    } else {
        // Parameter goes on stack
        code_generator_emit(generator, "    push %%rax          # Parameter %d on stack\n", 
                           param_index + 1);
    }
}

void code_generator_save_caller_saved_registers(CodeGenerator* generator) {
    if (!generator) {
        return;
    }
    
    CallingConventionSpec* conv_spec = generator->register_allocator->calling_convention;
    if (!conv_spec) {
        return;
    }
    
    code_generator_emit(generator, "    # Save caller-saved registers (non-parameter)\n");
    
    // Save only caller-saved registers that are NOT used for parameter passing
    // In a full implementation, this would only save registers that are actually in use
    
    // RAX is always caller-saved and not used for parameters (it's the return register)
    code_generator_emit(generator, "    push %%rax\n");
    
    // R10, R11 are caller-saved and not used for parameters in either calling convention
    code_generator_emit(generator, "    push %%r10\n");
    code_generator_emit(generator, "    push %%r11\n");
}

void code_generator_restore_caller_saved_registers(CodeGenerator* generator) {
    if (!generator) {
        return;
    }
    
    code_generator_emit(generator, "    # Restore caller-saved registers (non-parameter)\n");
    
    // Restore in reverse order
    code_generator_emit(generator, "    pop %%r11\n");
    code_generator_emit(generator, "    pop %%r10\n");
    code_generator_emit(generator, "    pop %%rax\n");
}

void code_generator_align_stack_for_call(CodeGenerator* generator, int param_count) {
    if (!generator) {
        return;
    }
    
    // x86-64 ABI requires 16-byte stack alignment before function calls
    // RSP must be 16-byte aligned when call instruction is executed
    
    CallingConventionSpec* conv_spec = generator->register_allocator->calling_convention;
    if (!conv_spec) {
        return;
    }
    
    // Calculate how many parameters will be pushed on stack
    int stack_params = param_count - (int)conv_spec->int_param_count;
    if (stack_params < 0) {
        stack_params = 0;
    }
    
    // Account for caller-saved registers we're pushing (3 registers: rax, r10, r11)
    int total_pushes = 3 + stack_params;
    
    // If total pushes results in misaligned stack, add padding
    if ((total_pushes % 2) != 0) {
        code_generator_emit(generator, "    sub $8, %%rsp       # Align stack to 16 bytes\n");
    }
}

const char* code_generator_get_register_name(x86Register reg) {
    switch (reg) {
        case REG_RAX: return "rax";
        case REG_RBX: return "rbx";
        case REG_RCX: return "rcx";
        case REG_RDX: return "rdx";
        case REG_RSI: return "rsi";
        case REG_RDI: return "rdi";
        case REG_RSP: return "rsp";
        case REG_RBP: return "rbp";
        case REG_R8:  return "r8";
        case REG_R9:  return "r9";
        case REG_R10: return "r10";
        case REG_R11: return "r11";
        case REG_R12: return "r12";
        case REG_R13: return "r13";
        case REG_R14: return "r14";
        case REG_R15: return "r15";
        case REG_XMM0: return "xmm0";
        case REG_XMM1: return "xmm1";
        case REG_XMM2: return "xmm2";
        case REG_XMM3: return "xmm3";
        case REG_XMM4: return "xmm4";
        case REG_XMM5: return "xmm5";
        case REG_XMM6: return "xmm6";
        case REG_XMM7: return "xmm7";
        case REG_XMM8: return "xmm8";
        case REG_XMM9: return "xmm9";
        case REG_XMM10: return "xmm10";
        case REG_XMM11: return "xmm11";
        case REG_XMM12: return "xmm12";
        case REG_XMM13: return "xmm13";
        case REG_XMM14: return "xmm14";
        case REG_XMM15: return "xmm15";
        default: return NULL;
    }
}

// Expression and assignment implementation functions
void code_generator_generate_binary_operation(CodeGenerator* generator, ASTNode* left, const char* op, ASTNode* right) {
    if (!generator || !left || !op || !right) {
        return;
    }
    
    code_generator_emit(generator, "    # Binary operation: %s\n", op);
    
    // Generate left operand (result in RAX)
    code_generator_generate_expression(generator, left);
    
    // Save left operand result
    code_generator_emit(generator, "    push %%rax           # Save left operand\n");
    
    // Generate right operand (result in RAX)
    code_generator_generate_expression(generator, right);
    
    // Move right operand to RBX for operation
    code_generator_emit(generator, "    mov %%rax, %%rbx     # Move right operand to RBX\n");
    
    // Restore left operand to RAX
    code_generator_emit(generator, "    pop %%rax            # Restore left operand\n");
    
    // Generate the operation
    const char* instruction = code_generator_get_arithmetic_instruction(op, 0); // Assume integers for now
    if (instruction) {
        if (strcmp(op, "/") == 0) {
            // Division requires special handling
            code_generator_emit(generator, "    cqo                  # Sign-extend RAX to RDX:RAX\n");
            code_generator_emit(generator, "    idiv %%rbx           # Divide RDX:RAX by RBX\n");
        } else if (strcmp(op, "%") == 0) {
            // Modulo requires division then use remainder in RDX
            code_generator_emit(generator, "    cqo                  # Sign-extend RAX to RDX:RAX\n");
            code_generator_emit(generator, "    idiv %%rbx           # Divide RDX:RAX by RBX\n");
            code_generator_emit(generator, "    mov %%rdx, %%rax     # Move remainder to RAX\n");
        } else {
            code_generator_emit(generator, "    %s %%rbx, %%rax      # %s operation\n", instruction, op);
        }
    } else {
        // Handle comparison and logical operators
        if (strcmp(op, "==") == 0) {
            code_generator_emit(generator, "    cmp %%rbx, %%rax     # Compare\n");
            code_generator_emit(generator, "    sete %%al            # Set AL if equal\n");
            code_generator_emit(generator, "    movzx %%al, %%rax    # Zero-extend AL to RAX\n");
        } else if (strcmp(op, "!=") == 0) {
            code_generator_emit(generator, "    cmp %%rbx, %%rax     # Compare\n");
            code_generator_emit(generator, "    setne %%al           # Set AL if not equal\n");
            code_generator_emit(generator, "    movzx %%al, %%rax    # Zero-extend AL to RAX\n");
        } else if (strcmp(op, "<") == 0) {
            code_generator_emit(generator, "    cmp %%rbx, %%rax     # Compare\n");
            code_generator_emit(generator, "    setl %%al            # Set AL if less\n");
            code_generator_emit(generator, "    movzx %%al, %%rax    # Zero-extend AL to RAX\n");
        } else if (strcmp(op, "<=") == 0) {
            code_generator_emit(generator, "    cmp %%rbx, %%rax     # Compare\n");
            code_generator_emit(generator, "    setle %%al           # Set AL if less or equal\n");
            code_generator_emit(generator, "    movzx %%al, %%rax    # Zero-extend AL to RAX\n");
        } else if (strcmp(op, ">") == 0) {
            code_generator_emit(generator, "    cmp %%rbx, %%rax     # Compare\n");
            code_generator_emit(generator, "    setg %%al            # Set AL if greater\n");
            code_generator_emit(generator, "    movzx %%al, %%rax    # Zero-extend AL to RAX\n");
        } else if (strcmp(op, ">=") == 0) {
            code_generator_emit(generator, "    cmp %%rbx, %%rax     # Compare\n");
            code_generator_emit(generator, "    setge %%al           # Set AL if greater or equal\n");
            code_generator_emit(generator, "    movzx %%al, %%rax    # Zero-extend AL to RAX\n");
        } else if (strcmp(op, "&&") == 0) {
            code_generator_emit(generator, "    and %%rbx, %%rax     # Logical AND\n");
        } else if (strcmp(op, "||") == 0) {
            code_generator_emit(generator, "    or %%rbx, %%rax      # Logical OR\n");
        } else {
            code_generator_emit(generator, "    # Unknown operator: %s\n", op);
        }
    }
}

void code_generator_generate_unary_operation(CodeGenerator* generator, const char* op, ASTNode* operand) {
    if (!generator || !op || !operand) {
        return;
    }
    
    code_generator_emit(generator, "    # Unary operation: %s\n", op);
    
    // Generate operand (result in RAX)
    code_generator_generate_expression(generator, operand);
    
    // Apply unary operation
    if (strcmp(op, "-") == 0) {
        code_generator_emit(generator, "    neg %%rax            # Negate\n");
    } else if (strcmp(op, "!") == 0) {
        code_generator_emit(generator, "    test %%rax, %%rax    # Test for zero\n");
        code_generator_emit(generator, "    setz %%al            # Set AL if zero\n");
        code_generator_emit(generator, "    movzx %%al, %%rax    # Zero-extend AL to RAX\n");
    } else if (strcmp(op, "~") == 0) {
        code_generator_emit(generator, "    not %%rax            # Bitwise NOT\n");
    } else if (strcmp(op, "+") == 0) {
        // Unary plus - no operation needed
        code_generator_emit(generator, "    # Unary plus (no-op)\n");
    } else {
        code_generator_emit(generator, "    # Unknown unary operator: %s\n", op);
    }
}

void code_generator_generate_assignment_statement(CodeGenerator* generator, ASTNode* assignment) {
    if (!generator || !assignment || assignment->type != AST_ASSIGNMENT) {
        return;
    }
    
    Assignment* assign_data = (Assignment*)assignment->data;
    if (!assign_data || !assign_data->variable_name || !assign_data->value) {
        return;
    }
    
    code_generator_emit(generator, "    # Assignment to %s\n", assign_data->variable_name);
    
    // Generate the value expression (result in RAX)
    code_generator_generate_expression(generator, assign_data->value);
    
    // Store the result to the variable
    code_generator_store_variable(generator, assign_data->variable_name, "rax");
}

void code_generator_load_variable(CodeGenerator* generator, const char* variable_name) {
    if (!generator || !variable_name) {
        return;
    }
    
    code_generator_emit(generator, "    # Load variable: %s\n", variable_name);
    
    // Look up variable in symbol table
    Symbol* symbol = symbol_table_lookup(generator->symbol_table, variable_name);
    if (symbol && symbol->kind == SYMBOL_VARIABLE) {
        if (symbol->data.variable.is_in_register) {
            // Variable is in register
            x86Register reg = (x86Register)symbol->data.variable.register_id;
            const char* reg_name = code_generator_get_register_name(reg);
            if (reg_name) {
                code_generator_emit(generator, "    mov %%%s, %%rax      # From register\n", reg_name);
            } else {
                code_generator_emit(generator, "    # Error: Invalid register for %s\n", variable_name);
            }
        } else {
            // Variable is in memory (stack or global)
            int offset = symbol->data.variable.memory_offset;
            if (symbol->scope && symbol->scope->type == SCOPE_GLOBAL) {
                // Global variable
                code_generator_emit(generator, "    mov %s(%%rip), %%rax  # From global memory\n", variable_name);
            } else {
                // Local variable (stack)
                code_generator_emit(generator, "    mov %d(%%rbp), %%rax  # From stack\n", offset);
            }
        }
    } else {
        // Variable not found - might be undefined or we need better symbol table integration
        code_generator_emit(generator, "    # Warning: Variable %s not found in symbol table\n", variable_name);
        code_generator_emit(generator, "    mov $0, %%rax        # Default to 0\n");
    }
}

void code_generator_store_variable(CodeGenerator* generator, const char* variable_name, const char* source_reg) {
    if (!generator || !variable_name || !source_reg) {
        return;
    }
    
    code_generator_emit(generator, "    # Store to variable: %s\n", variable_name);
    
    // Look up variable in symbol table
    Symbol* symbol = symbol_table_lookup(generator->symbol_table, variable_name);
    if (symbol && symbol->kind == SYMBOL_VARIABLE) {
        if (symbol->data.variable.is_in_register) {
            // Variable is in register
            x86Register reg = (x86Register)symbol->data.variable.register_id;
            const char* reg_name = code_generator_get_register_name(reg);
            if (reg_name) {
                code_generator_emit(generator, "    mov %%%s, %%%s       # To register\n", source_reg, reg_name);
            } else {
                code_generator_emit(generator, "    # Error: Invalid register for %s\n", variable_name);
            }
        } else {
            // Variable is in memory (stack or global)
            int offset = symbol->data.variable.memory_offset;
            if (symbol->scope && symbol->scope->type == SCOPE_GLOBAL) {
                // Global variable
                code_generator_emit(generator, "    mov %%%s, %s(%%rip)  # To global memory\n", source_reg, variable_name);
            } else {
                // Local variable (stack)
                // Use appropriate register size based on variable type
                if (symbol->type && symbol->type->size <= 4) {
                    code_generator_emit(generator, "    mov %%eax, %d(%%rbp)  # To stack (32-bit)\n", offset);
                } else {
                    code_generator_emit(generator, "    mov %%%s, %d(%%rbp)  # To stack (64-bit)\n", source_reg, offset);
                }
            }
        }
    } else {
        // Variable not found
        code_generator_emit(generator, "    # Error: Cannot store to undefined variable %s\n", variable_name);
    }
}

void code_generator_load_string_literal(CodeGenerator* generator, const char* string_value) {
    if (!generator || !string_value) {
        return;
    }
    
    code_generator_emit(generator, "    # String literal: \"%s\"\n", string_value);
    
    // Generate a unique label for this string
    char* label = code_generator_generate_label(generator, "str");
    if (label) {
        // Add string to data section (this would ideally be collected and emitted later)
        // For now, generate immediate reference
        code_generator_emit(generator, "    lea %s(%%rip), %%rax  # Load string address\n", label);
        
        // TODO: Properly collect string literals for data section emission
        code_generator_emit(generator, "    # TODO: Add %s: .asciz \"%s\" to data section\n", label, string_value);
        
        free(label);
    }
}

int code_generator_get_operator_precedence(const char* op) {
    if (!op) return 0;
    
    // Higher numbers = higher precedence
    if (strcmp(op, "*") == 0 || strcmp(op, "/") == 0 || strcmp(op, "%") == 0) {
        return 6;
    } else if (strcmp(op, "+") == 0 || strcmp(op, "-") == 0) {
        return 5;
    } else if (strcmp(op, "<") == 0 || strcmp(op, "<=") == 0 || 
               strcmp(op, ">") == 0 || strcmp(op, ">=") == 0) {
        return 4;
    } else if (strcmp(op, "==") == 0 || strcmp(op, "!=") == 0) {
        return 3;
    } else if (strcmp(op, "&&") == 0) {
        return 2;
    } else if (strcmp(op, "||") == 0) {
        return 1;
    }
    return 0;
}

const char* code_generator_get_arithmetic_instruction(const char* op, int is_float) {
    if (!op) return NULL;
    
    if (is_float) {
        // Floating point instructions (for future implementation)
        if (strcmp(op, "+") == 0) return "addss";
        if (strcmp(op, "-") == 0) return "subss";
        if (strcmp(op, "*") == 0) return "mulss";
        if (strcmp(op, "/") == 0) return "divss";
        return NULL;
    } else {
        // Integer instructions
        if (strcmp(op, "+") == 0) return "add";
        if (strcmp(op, "-") == 0) return "sub";
        if (strcmp(op, "*") == 0) return "imul";
        // Division and modulo are handled specially
        if (strcmp(op, "&") == 0) return "and";  // Bitwise AND
        if (strcmp(op, "|") == 0) return "or";   // Bitwise OR
        if (strcmp(op, "^") == 0) return "xor";  // Bitwise XOR
        return NULL;
    }
}

// Struct and method implementation functions
void code_generator_generate_struct_declaration(CodeGenerator* generator, ASTNode* struct_declaration) {
    if (!generator || !struct_declaration || struct_declaration->type != AST_STRUCT_DECLARATION) {
        return;
    }
    
    StructDeclaration* struct_data = (StructDeclaration*)struct_declaration->data;
    if (!struct_data || !struct_data->name) {
        return;
    }
    
    code_generator_emit(generator, "    # Struct declaration: %s\n", struct_data->name);
    
    // Look up struct type in symbol table
    Symbol* struct_symbol = symbol_table_lookup(generator->symbol_table, struct_data->name);
    if (struct_symbol && struct_symbol->kind == SYMBOL_STRUCT && struct_symbol->type) {
        Type* struct_type = struct_symbol->type;
        
        // Calculate and set struct layout
        code_generator_calculate_struct_layout(generator, struct_type);
        
        code_generator_emit(generator, "    # Struct %s: size=%zu, alignment=%zu\n", 
                           struct_data->name, struct_type->size, struct_type->alignment);
        
        // Generate method implementations if any
        if (struct_data->methods && struct_data->method_count > 0) {
            for (size_t i = 0; i < struct_data->method_count; i++) {
                if (struct_data->methods[i] && struct_data->methods[i]->type == AST_FUNCTION_DECLARATION) {
                    // Generate method with implicit "this" parameter
                    code_generator_emit(generator, "    # Method of struct %s\n", struct_data->name);
                    code_generator_generate_function(generator, struct_data->methods[i]);
                }
            }
        }
    } else {
        code_generator_emit(generator, "    # Warning: Struct type %s not found in symbol table\n", struct_data->name);
    }
}

void code_generator_generate_method_call(CodeGenerator* generator, ASTNode* method_call, ASTNode* object) {
    if (!generator || !method_call || !object) {
        return;
    }
    
    // Method calls are handled as special function calls with implicit "this"
    CallExpression* call_data = (CallExpression*)method_call->data;
    if (!call_data) {
        return;
    }
    
    code_generator_emit(generator, "    # Method call: %s\n", call_data->function_name);
    
    // Generate the object expression to get "this" pointer
    code_generator_emit(generator, "    # Generate 'this' pointer\n");
    code_generator_generate_expression(generator, object);
    
    // Save "this" pointer as first parameter
    code_generator_emit(generator, "    push %%rax           # Save 'this' pointer\n");
    
    // Get calling convention for parameter passing
    CallingConventionSpec* conv_spec = generator->register_allocator->calling_convention;
    if (conv_spec && conv_spec->int_param_count > 0) {
        // Move "this" to first parameter register
        const char* first_param_reg = code_generator_get_register_name(conv_spec->int_param_registers[0]);
        if (first_param_reg) {
            code_generator_emit(generator, "    pop %%%s             # 'this' in first parameter register\n", first_param_reg);
        }
    }
    
    // Generate other parameters starting from second parameter position
    if (call_data->arguments && call_data->argument_count > 0) {
        for (size_t i = 0; i < call_data->argument_count; i++) {
            if (call_data->arguments[i]) {
                // Generate argument (starts at parameter index 1 since 0 is "this")
                code_generator_generate_parameter(generator, call_data->arguments[i], (int)i + 1, NULL);
            }
        }
    }
    
    // Generate the actual method call
    code_generator_emit(generator, "    call %s\n", call_data->function_name);
    code_generator_emit(generator, "    # Return value in %%rax\n");
}

void code_generator_generate_member_access(CodeGenerator* generator, ASTNode* member_access) {
    if (!generator || !member_access || member_access->type != AST_MEMBER_ACCESS) {
        return;
    }
    
    MemberAccess* access_data = (MemberAccess*)member_access->data;
    if (!access_data || !access_data->object || !access_data->member) {
        return;
    }
    
    code_generator_emit(generator, "    # Member access: .%s\n", access_data->member);
    
    // Generate the object expression to get base address
    code_generator_generate_expression(generator, access_data->object);
    
    // Try to determine object type for proper field offset calculation
    // This requires enhanced type information from semantic analysis
    Type* object_type = NULL;
    
    // If the object is an identifier, look up its type
    if (access_data->object->type == AST_IDENTIFIER) {
        Identifier* id_data = (Identifier*)access_data->object->data;
        if (id_data && id_data->name) {
            Symbol* object_symbol = symbol_table_lookup(generator->symbol_table, id_data->name);
            if (object_symbol && object_symbol->type) {
                object_type = object_symbol->type;
            }
        }
    }
    
    int field_offset = -1;
    
    // If we have type information, calculate proper field offset
    if (object_type && object_type->kind == TYPE_STRUCT) {
        field_offset = code_generator_get_field_offset(generator, object_type, access_data->member);
    }
    
    // If we couldn't determine the offset, use default values for testing
    if (field_offset < 0) {
        code_generator_emit(generator, "    # Warning: Could not determine field offset for %s\n", access_data->member);
        // Use simple default offsets for common field names
        if (strcmp(access_data->member, "x") == 0 || strcmp(access_data->member, "field1") == 0) {
            field_offset = 0;
        } else if (strcmp(access_data->member, "y") == 0 || strcmp(access_data->member, "field2") == 0) {
            field_offset = 8;
        } else if (strcmp(access_data->member, "z") == 0 || strcmp(access_data->member, "field3") == 0) {
            field_offset = 16;
        } else {
            field_offset = 0; // Default to offset 0
        }
    }
    
    code_generator_emit(generator, "    # Field offset for %s: %d\n", access_data->member, field_offset);
    
    if (field_offset > 0) {
        code_generator_emit(generator, "    add $%d, %%rax       # Add field offset\n", field_offset);
    }
    
    // Load the field value (assumes the field is a pointer-sized value)
    code_generator_emit(generator, "    mov (%%rax), %%rax    # Load field value\n");
}

void code_generator_calculate_struct_layout(CodeGenerator* generator, Type* struct_type) {
    if (!generator || !struct_type || struct_type->kind != TYPE_STRUCT) {
        return;
    }
    
    if (!struct_type->field_names || !struct_type->field_types || struct_type->field_count == 0) {
        struct_type->size = 0;
        struct_type->alignment = 1;
        return;
    }
    
    // Allocate field offsets array if not already allocated
    if (!struct_type->field_offsets) {
        struct_type->field_offsets = malloc(struct_type->field_count * sizeof(size_t));
        if (!struct_type->field_offsets) {
            return;
        }
    }
    
    size_t current_offset = 0;
    size_t max_alignment = 1;
    
    // Calculate field offsets with proper alignment
    for (size_t i = 0; i < struct_type->field_count; i++) {
        Type* field_type = struct_type->field_types[i];
        if (!field_type) {
            continue;
        }
        
        size_t field_size = field_type->size;
        size_t field_alignment = field_type->alignment;
        
        if (field_alignment == 0) {
            field_alignment = code_generator_calculate_struct_alignment(field_size);
        }
        
        // Update maximum alignment
        if (field_alignment > max_alignment) {
            max_alignment = field_alignment;
        }
        
        // Align current offset to field alignment
        if (field_alignment > 1) {
            current_offset = (current_offset + field_alignment - 1) & ~(field_alignment - 1);
        }
        
        // Set field offset
        struct_type->field_offsets[i] = current_offset;
        
        // Advance offset by field size
        current_offset += field_size;
    }
    
    // Align total struct size to maximum field alignment
    if (max_alignment > 1) {
        current_offset = (current_offset + max_alignment - 1) & ~(max_alignment - 1);
    }
    
    struct_type->size = current_offset;
    struct_type->alignment = max_alignment;
}

int code_generator_get_field_offset(CodeGenerator* generator, Type* struct_type, const char* field_name) {
    if (!generator || !struct_type || !field_name || struct_type->kind != TYPE_STRUCT) {
        return -1;
    }
    
    if (!struct_type->field_names || !struct_type->field_offsets || struct_type->field_count == 0) {
        return -1;
    }
    
    // Search for field by name
    for (size_t i = 0; i < struct_type->field_count; i++) {
        if (struct_type->field_names[i] && strcmp(struct_type->field_names[i], field_name) == 0) {
            return (int)struct_type->field_offsets[i];
        }
    }
    
    return -1; // Field not found
}

int code_generator_calculate_struct_alignment(int field_size) {
    // Standard alignment rules for x86-64
    // Fields align to their natural size, but with maximum alignment of 8
    if (field_size >= 8) {
        return 8;
    } else if (field_size > 4) {
        return 8;  // Fields larger than 4 bytes align to 8
    } else if (field_size > 2) {
        return 4;  // Fields larger than 2 bytes align to 4
    } else if (field_size > 1) {
        return 2;  // Fields larger than 1 byte align to 2
    } else {
        return 1;
    }
}

// Inline assembly implementation functions
void code_generator_generate_inline_assembly(CodeGenerator* generator, ASTNode* inline_asm) {
    if (!generator || !inline_asm || inline_asm->type != AST_INLINE_ASM) {
        return;
    }
    
    InlineAsm* asm_data = (InlineAsm*)inline_asm->data;
    if (!asm_data || !asm_data->assembly_code) {
        return;
    }
    
    code_generator_emit(generator, "    # Begin inline assembly block\n");
    
    // Preserve registers that might be clobbered by inline assembly
    code_generator_preserve_registers_for_inline_asm(generator);
    
    // Emit the inline assembly code exactly as provided
    code_generator_emit_inline_asm_block(generator, asm_data->assembly_code);
    
    // Restore preserved registers
    code_generator_restore_registers_after_inline_asm(generator);
    
    code_generator_emit(generator, "    # End inline assembly block\n");
}

void code_generator_preserve_registers_for_inline_asm(CodeGenerator* generator) {
    if (!generator) {
        return;
    }
    
    code_generator_emit(generator, "    # Preserve registers for inline assembly\n");
    
    // Preserve caller-saved registers that might be used by surrounding code
    // This is a conservative approach - in a full implementation, we'd analyze
    // the inline assembly to determine which registers it actually uses
    code_generator_emit(generator, "    push %%rax           # Preserve RAX\n");
    code_generator_emit(generator, "    push %%rcx           # Preserve RCX\n");
    code_generator_emit(generator, "    push %%rdx           # Preserve RDX\n");
    code_generator_emit(generator, "    push %%r8            # Preserve R8\n");
    code_generator_emit(generator, "    push %%r9            # Preserve R9\n");
    code_generator_emit(generator, "    push %%r10           # Preserve R10\n");
    code_generator_emit(generator, "    push %%r11           # Preserve R11\n");
}

void code_generator_restore_registers_after_inline_asm(CodeGenerator* generator) {
    if (!generator) {
        return;
    }
    
    code_generator_emit(generator, "    # Restore registers after inline assembly\n");
    
    // Restore in reverse order
    code_generator_emit(generator, "    pop %%r11            # Restore R11\n");
    code_generator_emit(generator, "    pop %%r10            # Restore R10\n");
    code_generator_emit(generator, "    pop %%r9             # Restore R9\n");
    code_generator_emit(generator, "    pop %%r8             # Restore R8\n");
    code_generator_emit(generator, "    pop %%rdx            # Restore RDX\n");
    code_generator_emit(generator, "    pop %%rcx            # Restore RCX\n");
    code_generator_emit(generator, "    pop %%rax            # Restore RAX\n");
}

void code_generator_emit_inline_asm_block(CodeGenerator* generator, const char* assembly_code) {
    if (!generator || !assembly_code) {
        return;
    }
    
    // Check if the assembly code needs proper indentation
    const char* line_start = assembly_code;
    const char* line_end;
    
    while (*line_start) {
        // Find the end of the current line
        line_end = line_start;
        while (*line_end && *line_end != '\n' && *line_end != '\r') {
            line_end++;
        }
        
        // Calculate line length
        size_t line_length = line_end - line_start;
        
        if (line_length > 0) {
            // Check if line starts with whitespace (already indented)
            if (*line_start == ' ' || *line_start == '\t') {
                // Line is already indented, emit as-is
                code_generator_emit(generator, "%.*s\n", (int)line_length, line_start);
            } else {
                // Line needs indentation for consistency
                code_generator_emit(generator, "    %.*s\n", (int)line_length, line_start);
            }
        } else {
            // Empty line
            code_generator_emit(generator, "\n");
        }
        
        // Move to next line
        line_start = line_end;
        while (*line_start == '\n' || *line_start == '\r') {
            line_start++;
        }
    }
}