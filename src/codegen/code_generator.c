#include "code_generator.h"
#include "../semantic/symbol_table.h"
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

static void emit_to_global_buffer(CodeGenerator *generator, const char *format,
                                  ...);
static void code_generator_set_error(CodeGenerator *generator,
                                     const char *format, ...);

CodeGenerator *code_generator_create(SymbolTable *symbol_table,
                                     TypeChecker *type_checker,
                                     RegisterAllocator *allocator) {
  CodeGenerator *generator = malloc(sizeof(CodeGenerator));
  if (!generator)
    return NULL;

  generator->symbol_table = symbol_table;
  generator->type_checker = type_checker;
  generator->register_allocator = allocator;
  generator->debug_info = NULL;
  generator->output_file = NULL;
  generator->output_buffer = malloc(4096);
  generator->buffer_size = 0;
  generator->buffer_capacity = 4096;
  generator->current_label_id = 0;
  generator->current_stack_offset = 0;
  generator->function_stack_size = 0;
  generator->current_function_name = NULL;
  generator->global_variables_buffer = malloc(2048);
  generator->global_variables_size = 0;
  generator->global_variables_capacity = 2048;
  generator->current_assembly_line = 1;
  generator->generate_debug_info = 0;
  generator->has_error = 0;
  generator->error_message = NULL;

  if (!generator->output_buffer || !generator->global_variables_buffer) {
    free(generator->output_buffer);
    free(generator->global_variables_buffer);
    free(generator);
    return NULL;
  }

  generator->output_buffer[0] = '\0';
  generator->global_variables_buffer[0] = '\0';

  return generator;
}

CodeGenerator *code_generator_create_with_debug(SymbolTable *symbol_table,
                                                TypeChecker *type_checker,
                                                RegisterAllocator *allocator,
                                                DebugInfo *debug_info) {
  CodeGenerator *generator =
      code_generator_create(symbol_table, type_checker, allocator);
  if (!generator)
    return NULL;

  generator->debug_info = debug_info;
  generator->generate_debug_info = 1;

  return generator;
}

void code_generator_destroy(CodeGenerator *generator) {
  if (generator) {
    free(generator->output_buffer);
    free(generator->current_function_name);
    free(generator->global_variables_buffer);
    free(generator->error_message);
    free(generator);
  }
}

static void code_generator_set_error(CodeGenerator *generator,
                                     const char *format, ...) {
  if (!generator || !format) {
    return;
  }

  if (generator->has_error) {
    return;
  }

  generator->has_error = 1;
  free(generator->error_message);
  generator->error_message = NULL;

  va_list args;
  va_start(args, format);

  va_list args_copy;
  va_copy(args_copy, args);
  int size = vsnprintf(NULL, 0, format, args_copy);
  va_end(args_copy);

  if (size > 0) {
    generator->error_message = malloc((size_t)size + 1);
    if (generator->error_message) {
      vsnprintf(generator->error_message, (size_t)size + 1, format, args);
    }
  }

  va_end(args);
}

int code_generator_generate_program(CodeGenerator *generator,
                                    ASTNode *program) {
  if (!generator || !program) {
    return 0;
  }

  if (program->type != AST_PROGRAM) {
    code_generator_set_error(generator, "Expected AST_PROGRAM root node");
    return 0;
  }

  // Generate assembly header
  code_generator_emit(generator, "; Generated by MethASM\n");
  code_generator_emit(generator, "; x86-64 Assembly Output\n\n");

  // Generate text section first
  code_generator_emit_text_section(generator);

  // First pass: collect global variables and handle top-level inline assembly
  Program *program_data = (Program *)program->data;
  if (program_data) {
    code_generator_emit(generator,
                        "; First pass: processing %zu declarations\n",
                        program_data->declaration_count);
    for (size_t i = 0; i < program_data->declaration_count; i++) {
      ASTNode *declaration = program_data->declarations[i];
      code_generator_emit(generator,
                          "; Declaration %zu type: %d (AST_INLINE_ASM = %d)\n",
                          i, declaration->type, AST_INLINE_ASM);

      if (declaration->type == AST_VAR_DECLARATION) {
        code_generator_generate_global_variable(generator, declaration);
      } else if (declaration->type == AST_INLINE_ASM) {
        // Top-level inline assembly - emit directly without register
        // preservation
        InlineAsm *asm_data = (InlineAsm *)declaration->data;
        if (asm_data && asm_data->assembly_code) {
          code_generator_emit(generator, "; Top-level inline assembly found\n");
          code_generator_emit(generator, "; Assembly: %s\n",
                              asm_data->assembly_code);
          code_generator_emit(generator, "%s\n", asm_data->assembly_code);
          code_generator_emit(generator, "\n");
        } else {
          code_generator_emit(generator,
                              "; Inline assembly node but no data\n");
        }
      }

      if (generator->has_error) {
        return 0;
      }
    }
  } else {
    code_generator_emit(generator, "; No program data found\n");
  }

  // Emit the collected global variables in data section
  if (generator->global_variables_size > 0) {
    code_generator_emit(generator, "\n; Data section for global variables\n");
    code_generator_emit(generator, "section .data\n");
    code_generator_emit(generator, "%s", generator->global_variables_buffer);
  }

  // Second pass: process functions and other declarations
  if (program_data) {
    for (size_t i = 0; i < program_data->declaration_count; i++) {
      ASTNode *declaration = program_data->declarations[i];

      switch (declaration->type) {
      case AST_FUNCTION_DECLARATION:
        code_generator_generate_function(generator, declaration);
        break;
      case AST_VAR_DECLARATION:
        // Already handled in first pass
        break;
      case AST_STRUCT_DECLARATION:
        // Generate struct type layout information
        code_generator_generate_struct_declaration(generator, declaration);
        break;
      case AST_INLINE_ASM:
        // Already handled in first pass
        break;
      default:
        // Other declarations
        break;
      }

      if (generator->has_error) {
        return 0;
      }
    }
  }

  int has_main = 0;
  if (program_data) {
    for (size_t i = 0; i < program_data->declaration_count; i++) {
      ASTNode *declaration = program_data->declarations[i];
      if (!declaration || declaration->type != AST_FUNCTION_DECLARATION) {
        continue;
      }

      FunctionDeclaration *func_data = (FunctionDeclaration *)declaration->data;
      if (func_data && func_data->name && strcmp(func_data->name, "main") == 0) {
        has_main = 1;
        break;
      }
    }
  }

  // Generate process entry point.
  code_generator_emit(generator, "\n; Default program entry point\n");
  code_generator_emit(generator, "global _start\n");
  code_generator_emit(generator, "_start:\n");
  code_generator_emit(generator, "    ; Initialize garbage collector runtime\n");
  code_generator_emit(generator, "    mov rdi, rsp\n");
  code_generator_emit(generator, "    extern gc_init\n");
  code_generator_emit(generator, "    call gc_init\n");

  // Register global root slots for pointer-like globals.
  if (program_data) {
    int emitted_gc_root_extern = 0;
    for (size_t i = 0; i < program_data->declaration_count; i++) {
      ASTNode *declaration = program_data->declarations[i];
      if (!declaration || declaration->type != AST_VAR_DECLARATION) {
        continue;
      }

      VarDeclaration *var_data = (VarDeclaration *)declaration->data;
      if (!var_data || !var_data->name) {
        continue;
      }

      int should_register = 0;
      Symbol *symbol = symbol_table_lookup(generator->symbol_table, var_data->name);
      if (symbol && symbol->type) {
        switch (symbol->type->kind) {
        case TYPE_POINTER:
        case TYPE_ARRAY:
        case TYPE_STRING:
        case TYPE_STRUCT:
          should_register = 1;
          break;
        default:
          should_register = 0;
          break;
        }
      } else {
        code_generator_set_error(
            generator,
            "Global variable '%s' is missing type information during "
            "root-registration",
            var_data->name);
        return 0;
      }

      if (!should_register) {
        continue;
      }

      if (!emitted_gc_root_extern) {
        code_generator_emit(generator, "    extern gc_register_root\n");
        emitted_gc_root_extern = 1;
      }

      code_generator_emit(generator, "    lea rdi, [%s + rip]\n", var_data->name);
      code_generator_emit(generator, "    call gc_register_root\n");
    }
  }

  if (has_main) {
    code_generator_emit(generator, "    ; Call user main function\n");
    code_generator_emit(generator, "    call main\n");
    code_generator_emit(generator, "    push rax         ; Preserve main return code\n");
    code_generator_emit(generator, "    extern gc_shutdown\n");
    code_generator_emit(generator, "    call gc_shutdown\n");
    code_generator_emit(generator, "    pop rdi          ; Use main return as exit code\n");
  } else {
    code_generator_emit(generator, "    extern gc_shutdown\n");
    code_generator_emit(generator, "    call gc_shutdown\n");
    code_generator_emit(generator, "    mov rdi, 0       ; Default exit status\n");
  }
  code_generator_emit(generator, "    mov rax, 60    ; sys_exit\n");
  code_generator_emit(generator, "    syscall\n");

  return generator->has_error ? 0 : 1;
}

// Forward declaration
void code_generator_generate_statement(CodeGenerator *generator,
                                       ASTNode *statement);

void code_generator_register_function_parameters(
    CodeGenerator *generator, FunctionDeclaration *func_data) {
  if (!generator || !func_data) {
    return;
  }

  code_generator_emit(generator, "    ; Registering %zu function parameters\n",
                      func_data->parameter_count);

  CallingConventionSpec *conv_spec =
      generator->register_allocator->calling_convention;
  size_t int_param_reg_index = 0;
  size_t float_param_reg_index = 0;
  int stack_offset = 16; // Start after return address and saved RBP

  for (size_t i = 0; i < func_data->parameter_count; i++) {
    const char *param_name = func_data->parameter_names[i];
    const char *type_name = func_data->parameter_types[i];

    // Create a temporary variable declaration AST node for the parameter
    ASTNode *param_var_decl = ast_create_var_declaration(
        param_name, type_name, NULL, (SourceLocation){0, 0});
    if (!param_var_decl)
      continue;

    Symbol *param_symbol =
        symbol_table_lookup(generator->symbol_table, param_name);
    if (!param_symbol) {
      // This should have been created during semantic analysis, but as a
      // fallback:
      param_symbol = symbol_create(param_name, SYMBOL_VARIABLE, NULL);
      symbol_table_insert(generator->symbol_table, param_symbol);
    }

    // Determine if parameter is in register or on stack
    int is_in_register = 0;
    int register_id = -1;
    int memory_offset = 0;

    Type *param_type = param_symbol->type; // Assume type is set in symbol
    int is_float = code_generator_is_floating_point_type(param_type);

    if (is_float && float_param_reg_index < conv_spec->float_param_count) {
      is_in_register = 1;
      register_id = conv_spec->float_param_registers[float_param_reg_index++];
    } else if (!is_float && int_param_reg_index < conv_spec->int_param_count) {
      is_in_register = 1;
      register_id = conv_spec->int_param_registers[int_param_reg_index++];
    } else {
      // Parameter is on the stack
      memory_offset = stack_offset;
      stack_offset += 8; // Assuming 8-byte parameters
    }

    param_symbol->data.variable.is_in_register = is_in_register;
    if (is_in_register) {
      param_symbol->data.variable.register_id = register_id;
      code_generator_emit(generator, "    ; Parameter '%s' in register %s\n",
                          param_name,
                          code_generator_get_register_name(register_id));
    } else {
      param_symbol->data.variable.memory_offset = memory_offset;
      code_generator_emit(generator,
                          "    ; Parameter '%s' on stack at [rbp + %d]\n",
                          param_name, memory_offset);
    }

    ast_destroy_node(param_var_decl);
  }
}

void code_generator_generate_function(CodeGenerator *generator,
                                      ASTNode *function) {
  if (!generator || !function || function->type != AST_FUNCTION_DECLARATION) {
    return;
  }

  FunctionDeclaration *func_data = (FunctionDeclaration *)function->data;
  if (!func_data || !func_data->name) {
    return;
  }

  // Enter a new scope for the function
  symbol_table_enter_scope(generator->symbol_table, SCOPE_FUNCTION);

  // Add debug symbol for function
  if (generator->generate_debug_info) {
    code_generator_add_debug_symbol(
        generator, func_data->name, DEBUG_SYMBOL_FUNCTION,
        func_data->return_type, function->location.line,
        function->location.column);

    // Add line mapping for function start
    code_generator_add_line_mapping(generator, function->location.line,
                                    function->location.column,
                                    generator->debug_info->source_filename);
  }

  code_generator_emit(generator, "\nglobal %s\n", func_data->name);

  // Pre-pass to register all local variables and calculate stack size
  int stack_size = 0;
  if (func_data->body) {
    Program *body_prog = (Program *)func_data->body->data;
    if (body_prog) {
      for (size_t i = 0; i < body_prog->declaration_count; i++) {
        ASTNode *stmt = body_prog->declarations[i];
        if (stmt && stmt->type == AST_VAR_DECLARATION) {
          VarDeclaration *var_decl = (VarDeclaration *)stmt->data;
          if (var_decl) {
            Type *var_type = NULL;
            if (var_decl->type_name) {
              var_type = type_checker_get_type_by_name(generator->type_checker,
                                                       var_decl->type_name);
            } else if (var_decl->initializer) {
              var_type = type_checker_infer_type(generator->type_checker,
                                                 var_decl->initializer);
            }
            if (!var_type) {
              var_type =
                  type_checker_get_type_by_name(generator->type_checker, "int64");
            }

            int var_size = 0;
            if (var_type && var_type->size > 0) {
              var_size = (int)var_type->size;
            } else {
              var_size = code_generator_calculate_variable_size(
                  generator, var_decl->type_name);
            }
            if (var_size <= 0) {
              var_size = 8;
            }
            stack_size += var_size;

            // Register symbol without generating code yet.
            Symbol *existing = symbol_table_lookup_current_scope(
                generator->symbol_table, var_decl->name);
            if (!existing) {
              Symbol *var_symbol =
                  symbol_create(var_decl->name, SYMBOL_VARIABLE, var_type);
              if (var_symbol &&
                  !symbol_table_declare(generator->symbol_table, var_symbol)) {
                symbol_destroy(var_symbol);
              }
            }
          }
        }
      }
    }
  }

  // Generate function prologue
  code_generator_function_prologue(generator, func_data->name, stack_size);

  // Register parameters in symbol table
  code_generator_register_function_parameters(generator, func_data);

  // Generate function body
  if (func_data->body) {
    code_generator_generate_statement(generator, func_data->body);
  }

  // Add a label for the function exit
  code_generator_emit(generator, "L%s_exit:\n", func_data->name);

  // Generate function epilogue
  code_generator_function_epilogue(generator);

  // Exit the function's scope
  symbol_table_exit_scope(generator->symbol_table);
}

void code_generator_generate_statement(CodeGenerator *generator,
                                       ASTNode *statement) {
  if (!generator || !statement || generator->has_error) {
    return;
  }

  // Add line mapping for statement if debug info is enabled
  if (generator->generate_debug_info && statement->location.line > 0) {
    code_generator_add_line_mapping(generator, statement->location.line,
                                    statement->location.column,
                                    generator->debug_info->source_filename);
    code_generator_emit_debug_label(generator, statement->location.line);
  }

  switch (statement->type) {
  case AST_PROGRAM: // This is a block
  {
    Program *block = (Program *)statement->data;
    if (block) {
      for (size_t i = 0; i < block->declaration_count; i++) {
        code_generator_generate_statement(generator, block->declarations[i]);
      }
    }
  } break;
  case AST_VAR_DECLARATION: {
    // Local variable declaration inside function
    code_generator_generate_local_variable(generator, statement);
  } break;

  case AST_ASSIGNMENT: {
    // Assignment statement
    code_generator_generate_assignment_statement(generator, statement);
  } break;

  case AST_FUNCTION_CALL: {
    // Function call as statement (not expression)
    code_generator_generate_function_call(generator, statement);
  } break;

  case AST_RETURN_STATEMENT: {
    ReturnStatement *return_data = (ReturnStatement *)statement->data;
    code_generator_emit(generator, "    ; Return statement\n");

    if (return_data && return_data->value) {
      // Generate the return value expression
      code_generator_generate_expression(generator, return_data->value);
      // Result is already in RAX (the return register for integers)
      code_generator_emit(generator, "    ; Return value in %rax\n");
    } else {
      // Void return - no value to return
      code_generator_emit(generator, "    ; Void return\n");
    }

    // Jump to function epilogue (or inline it)
    code_generator_emit(generator, "    jmp L%s_exit\n",
                        generator->current_function_name);
  } break;

  case AST_INLINE_ASM: {
    // Inline assembly within function
    code_generator_generate_inline_assembly(generator, statement);
  } break;

  case AST_BINARY_EXPRESSION: {
    // Binary expression as a statement (value is discarded)
    code_generator_generate_expression(generator, statement);
  } break;

  case AST_IF_STATEMENT: {
    IfStatement *if_data = (IfStatement *)statement->data;
    if (if_data && if_data->condition && if_data->then_branch) {
      char *else_label = code_generator_generate_label(generator, "if_else");
      char *end_label = code_generator_generate_label(generator, "if_end");
      if (!else_label || !end_label)
        break;

      code_generator_generate_expression(generator, if_data->condition);
      code_generator_emit(generator,
                          "    test rax, rax      ; Test condition\n");
      code_generator_emit(generator, "    jz %s              ; Jump if false\n",
                          else_label);

      code_generator_generate_statement(generator, if_data->then_branch);
      code_generator_emit(generator, "    jmp %s              ; Skip else\n",
                          end_label);

      code_generator_emit(generator, "%s:\n", else_label);
      if (if_data->else_branch) {
        code_generator_generate_statement(generator, if_data->else_branch);
      }

      code_generator_emit(generator, "%s:\n", end_label);
      free(else_label);
      free(end_label);
    } else {
      code_generator_set_error(generator, "Malformed if statement");
    }
  } break;

  case AST_WHILE_STATEMENT: {
    WhileStatement *while_data = (WhileStatement *)statement->data;
    if (while_data && while_data->condition && while_data->body) {
      char *loop_start = code_generator_generate_label(generator, "while");
      char *loop_end = code_generator_generate_label(generator, "while_end");
      if (!loop_start || !loop_end)
        break;

      code_generator_emit(generator, "%s:\n", loop_start);
      code_generator_generate_expression(generator, while_data->condition);
      code_generator_emit(generator,
                          "    test rax, rax      ; Test condition\n");
      code_generator_emit(
          generator, "    jz %s              ; Exit loop if false\n", loop_end);

      code_generator_generate_statement(generator, while_data->body);
      code_generator_emit(generator, "    jmp %s              ; Loop back\n",
                          loop_start);

      code_generator_emit(generator, "%s:\n", loop_end);
      free(loop_start);
      free(loop_end);
    } else {
      code_generator_set_error(generator, "Malformed while statement");
    }
  } break;

  default:
    code_generator_set_error(generator, "Unhandled statement type: %d",
                             statement->type);
    break;
  }
}

void code_generator_generate_expression(CodeGenerator *generator,
                                        ASTNode *expression) {
  if (!generator || !expression || generator->has_error) {
    return;
  }

  switch (expression->type) {
  case AST_NUMBER_LITERAL: {
    NumberLiteral *num_data = (NumberLiteral *)expression->data;
    if (num_data) {
      if (num_data->is_float) {
        code_generator_emit(generator, "    ; Float literal: %f\n",
                            num_data->float_value);
        // Load float value into XMM0 register
        char *float_label = code_generator_generate_label(generator, "float");
        if (float_label) {
          code_generator_emit(
              generator,
              "    movsd xmm0, [%s + rip]  ; Load float from memory\n",
              float_label);

          // Add the float literal to the global data section
          emit_to_global_buffer(generator, "%s:\n", float_label);
          emit_to_global_buffer(generator, "    dq 0x%016llx  ; float64: %f\n",
                                *(long long *)&num_data->float_value,
                                num_data->float_value);

          free(float_label);
        }
      } else {
        code_generator_emit(generator, "    ; Integer literal: %lld\n",
                            num_data->int_value);
        code_generator_emit(generator, "    mov rax, %lld\n",
                            num_data->int_value);
      }
    } else {
      code_generator_set_error(generator, "Malformed number literal");
    }
  } break;

  case AST_STRING_LITERAL: {
    StringLiteral *str_data = (StringLiteral *)expression->data;
    if (str_data && str_data->value) {
      code_generator_load_string_literal(generator, str_data->value);
    } else {
      code_generator_set_error(generator, "Malformed string literal");
    }
  } break;

  case AST_IDENTIFIER: {
    Identifier *id_data = (Identifier *)expression->data;
    if (id_data && id_data->name) {
      code_generator_load_variable(generator, id_data->name);
    } else {
      code_generator_set_error(generator, "Malformed identifier expression");
    }
  } break;

  case AST_BINARY_EXPRESSION: {
    BinaryExpression *bin_data = (BinaryExpression *)expression->data;
    if (bin_data && bin_data->left && bin_data->right && bin_data->operator) {
      code_generator_generate_binary_operation(
          generator, bin_data->left, bin_data->operator, bin_data->right);
    } else {
      code_generator_set_error(generator, "Malformed binary expression");
    }
  } break;

  case AST_UNARY_EXPRESSION: {
    UnaryExpression *unary_data = (UnaryExpression *)expression->data;
    if (unary_data && unary_data->operand && unary_data->operator) {
      code_generator_generate_unary_operation(generator, unary_data->operator,
                                              unary_data->operand);
    } else {
      code_generator_set_error(generator, "Malformed unary expression");
    }
  } break;

  case AST_FUNCTION_CALL: {
    // Function call as expression (returns value)
    code_generator_generate_function_call(generator, expression);
  } break;

  case AST_MEMBER_ACCESS: {
    // Member access (struct.field)
    code_generator_generate_member_access(generator, expression);
  } break;

  case AST_NEW_EXPRESSION: {
    NewExpression *new_expr = (NewExpression *)expression->data;
    if (new_expr && new_expr->type_name) {
      code_generator_emit(generator, "    ; Heap allocation: new %s\n",
                          new_expr->type_name);

      // Determine the size of the type being allocated
      int alloc_size = code_generator_calculate_variable_size(
          generator, new_expr->type_name);
      if (alloc_size <= 0) {
        // Fallback size if lookup fails
        alloc_size = 8;
      }

      // Call gc_alloc(alloc_size)
      code_generator_emit(generator, "    mov rdi, %d      ; size in bytes\n",
                          alloc_size);
      code_generator_emit(generator, "    extern gc_alloc\n");
      code_generator_emit(generator, "    call gc_alloc\n");
      // The allocated memory pointer is returned in RAX,
      // ready for variable assignments or immediate struct usage.
    } else {
      code_generator_set_error(generator, "Malformed new-expression");
    }
  } break;

  default:
    code_generator_set_error(generator, "Unhandled expression type: %d",
                             expression->type);
    break;
  }
}

void code_generator_emit(CodeGenerator *generator, const char *format, ...) {
  if (!generator || !format || generator->has_error) {
    return;
  }

  va_list args;
  va_start(args, format);

  // Calculate required size
  va_list args_copy;
  va_copy(args_copy, args);
  int required_size = vsnprintf(NULL, 0, format, args_copy);
  va_end(args_copy);

  // Ensure buffer has enough space
  if (generator->buffer_size + required_size + 1 > generator->buffer_capacity) {
    size_t new_capacity = generator->buffer_capacity * 2;
    while (new_capacity < generator->buffer_size + required_size + 1) {
      new_capacity *= 2;
    }

    char *new_buffer = realloc(generator->output_buffer, new_capacity);
    if (!new_buffer) {
      code_generator_set_error(generator,
                               "Out of memory while expanding output buffer");
      va_end(args);
      return;
    }

    generator->output_buffer = new_buffer;
    generator->buffer_capacity = new_capacity;
  }

  // Append to buffer
  int written = vsnprintf(generator->output_buffer + generator->buffer_size,
                          generator->buffer_capacity - generator->buffer_size,
                          format, args);

  if (written > 0) {
    generator->buffer_size += written;

    // Count newlines to track assembly line numbers for debug info
    if (generator->generate_debug_info) {
      const char *text =
          generator->output_buffer + generator->buffer_size - written;
      for (int i = 0; i < written; i++) {
        if (text[i] == '\n') {
          generator->current_assembly_line++;
        }
      }
    }
  }

  va_end(args);
}

char *code_generator_get_output(CodeGenerator *generator) {
  return generator->output_buffer;
}

// Stack frame management functions
void code_generator_function_prologue(CodeGenerator *generator,
                                      const char *function_name,
                                      int stack_size) {
  // Save current function name and reset stack tracking
  free(generator->current_function_name);
  if (function_name) {
    size_t len = strlen(function_name) + 1;
    generator->current_function_name = malloc(len);
    if (generator->current_function_name) {
      memcpy(generator->current_function_name, function_name, len);
    }
  } else {
    generator->current_function_name = NULL;
  }
  generator->function_stack_size = stack_size;
  generator->current_stack_offset = 0; // Reset for new function

  // Generate function label
  code_generator_emit(generator, "\n%s:\n", function_name);

  // Standard x86-64 function prologue
  code_generator_emit(generator,
                      "    push rbp        ; Save old base pointer\n");
  code_generator_emit(generator, "    mov rbp, rsp  ; Set new base pointer\n");

  // Get calling convention for callee-saved register handling
  CallingConventionSpec *conv_spec =
      generator->register_allocator->calling_convention;

  // Save callee-saved registers that will be used by this function
  // This is a simplified approach - in practice, we'd only save registers we
  // actually use
  if (conv_spec && conv_spec->callee_saved_registers) {
    code_generator_emit(generator, "    ; Save callee-saved registers\n");
    for (size_t i = 0; i < conv_spec->callee_saved_count; i++) {
      x86Register reg = conv_spec->callee_saved_registers[i];
      const char *reg_name = code_generator_get_register_name(reg);
      if (reg_name && reg != REG_RBP && reg != REG_RSP) {
        // Only save if we might use this register (simplified check)
        if (reg == REG_RBX || reg == REG_R12 || reg == REG_R13 ||
            reg == REG_R14 || reg == REG_R15) {
          code_generator_emit(
              generator, "    push %s         ; Save callee-saved register\n",
              reg_name);
          generator->function_stack_size += 8; // Track additional stack usage
        }
      }
    }
  }

  // Allocate stack space for local variables
  // Ensure 16-byte alignment for the stack frame
  int aligned_stack_size = stack_size;
  if (aligned_stack_size > 0) {
    // Round up to nearest 16-byte boundary
    aligned_stack_size = (aligned_stack_size + 15) & ~15;
    code_generator_emit(
        generator,
        "    sub $%d, %rsp    ; Allocate %d bytes on stack (aligned)\n",
        aligned_stack_size, aligned_stack_size);
    generator->function_stack_size = aligned_stack_size;
  }

  // Initialize local variables to zero if needed
  if (aligned_stack_size > 0) {
    code_generator_emit(generator,
                        "    ; Zero-initialize local variable space\n");
    code_generator_emit(generator,
                        "    mov %rsp, %rdi  ; Destination for memset\n");
    code_generator_emit(generator,
                        "    mov $0, %rax     ; Value to set (zero)\n");
    code_generator_emit(generator, "    mov $%d, %rcx    ; Number of bytes\n",
                        aligned_stack_size);
    code_generator_emit(generator,
                        "    rep stosb         ; Zero-fill the stack space\n");
  }
}

void code_generator_function_epilogue(CodeGenerator *generator) {
  if (!generator) {
    return;
  }

  code_generator_emit(generator, "    ; Function epilogue\n");

  // Get calling convention for callee-saved register handling
  CallingConventionSpec *conv_spec =
      generator->register_allocator->calling_convention;

  // Restore stack pointer to base pointer (cleans up local variables)
  code_generator_emit(generator, "    mov rsp, rbp  ; Restore stack pointer\n");

  // Restore callee-saved registers in reverse order
  if (conv_spec && conv_spec->callee_saved_registers) {
    code_generator_emit(generator, "    ; Restore callee-saved registers\n");
    // Restore in reverse order of saving
    for (int i = (int)conv_spec->callee_saved_count - 1; i >= 0; i--) {
      x86Register reg = conv_spec->callee_saved_registers[i];
      const char *reg_name = code_generator_get_register_name(reg);
      if (reg_name && reg != REG_RBP && reg != REG_RSP) {
        // Only restore if we saved this register
        if (reg == REG_RBX || reg == REG_R12 || reg == REG_R13 ||
            reg == REG_R14 || reg == REG_R15) {
          code_generator_emit(
              generator,
              "    pop %s          ; Restore callee-saved register\n",
              reg_name);
        }
      }
    }
  }

  // Restore old base pointer
  code_generator_emit(generator,
                      "    pop rbp         ; Restore old base pointer\n");

  // Return to caller
  code_generator_emit(generator, "    ret               ; Return to caller\n");
}

char *code_generator_generate_label(CodeGenerator *generator,
                                    const char *prefix) {
  char *label = malloc(64);
  if (label) {
    snprintf(label, 64, "L%s%d", prefix, generator->current_label_id++);
  }
  return label;
}

// Assembly helper functions
void code_generator_emit_data_section(CodeGenerator *generator) {
  code_generator_emit(generator, "section .data\n");
  code_generator_emit(generator, "; Global variables will be placed here\n\n");
}

void code_generator_emit_text_section(CodeGenerator *generator) {
  code_generator_emit(generator, "section .text\n");
  code_generator_emit(generator, "; Code section\n\n");
}

void code_generator_emit_global_symbol(CodeGenerator *generator,
                                       const char *symbol) {
  code_generator_emit(generator, "global %s\n", symbol);
}

void code_generator_emit_instruction(CodeGenerator *generator,
                                     const char *mnemonic,
                                     const char *operands) {
  if (operands && strlen(operands) > 0) {
    code_generator_emit(generator, "    %s %s\n", mnemonic, operands);
  } else {
    code_generator_emit(generator, "    %s\n", mnemonic);
  }
}

// Helper function to emit to global variables buffer
static void emit_to_global_buffer(CodeGenerator *generator, const char *format,
                                  ...) {
  if (!generator || !format || generator->has_error) {
    return;
  }

  va_list args;
  va_start(args, format);

  // Calculate required size
  va_list args_copy;
  va_copy(args_copy, args);
  int required_size = vsnprintf(NULL, 0, format, args_copy);
  va_end(args_copy);

  // Ensure buffer has enough space
  if (generator->global_variables_size + required_size + 1 >
      generator->global_variables_capacity) {
    size_t new_capacity = generator->global_variables_capacity * 2;
    while (new_capacity <
           generator->global_variables_size + required_size + 1) {
      new_capacity *= 2;
    }

    char *new_buffer =
        realloc(generator->global_variables_buffer, new_capacity);
    if (!new_buffer) {
      code_generator_set_error(
          generator, "Out of memory while expanding global buffer");
      va_end(args);
      return;
    }

    generator->global_variables_buffer = new_buffer;
    generator->global_variables_capacity = new_capacity;
  }

  // Append to buffer
  int written = vsnprintf(
      generator->global_variables_buffer + generator->global_variables_size,
      generator->global_variables_capacity - generator->global_variables_size,
      format, args);

  if (written > 0) {
    generator->global_variables_size += written;
  }

  va_end(args);
}

// Variable declaration implementation functions
void code_generator_generate_global_variable(CodeGenerator *generator,
                                             ASTNode *var_declaration) {
  if (!generator || !var_declaration ||
      var_declaration->type != AST_VAR_DECLARATION) {
    return;
  }

  VarDeclaration *var_data = (VarDeclaration *)var_declaration->data;
  if (!var_data || !var_data->name) {
    return;
  }

  // Add debug symbol for global variable
  if (generator->generate_debug_info) {
    code_generator_add_debug_symbol(
        generator, var_data->name, DEBUG_SYMBOL_VARIABLE, var_data->type_name,
        var_declaration->location.line, var_declaration->location.column);
  }

  // Calculate variable size
  int var_size =
      code_generator_calculate_variable_size(generator, var_data->type_name);
  if (var_size <= 0) {
    var_size = 8; // Default to 8 bytes for unknown types
  }

  emit_to_global_buffer(
      generator, "; Global variable: %s (%s, %d bytes)\n", var_data->name,
      var_data->type_name ? var_data->type_name : "unknown", var_size);

  if (var_data->initializer) {
    // Initialized data goes in .data section
    emit_to_global_buffer(generator, "%s:\n", var_data->name);

    // Generate initialization based on type and initializer
    if (var_data->initializer->type == AST_NUMBER_LITERAL) {
      NumberLiteral *num = (NumberLiteral *)var_data->initializer->data;
      if (num) {
        if (num->is_float) {
          // Handle different float types based on variable type
          if (var_data->type_name &&
              strcmp(var_data->type_name, "float32") == 0) {
            float float32_val = (float)num->float_value;
            emit_to_global_buffer(generator, "    dd 0x%08x  ; float32: %f\n",
                                  *(int *)&float32_val, float32_val);
          } else {
            // Default to float64
            emit_to_global_buffer(
                generator, "    dq 0x%016llx  ; float64: %f\n",
                *(long long *)&num->float_value, num->float_value);
          }
        } else {
          // Handle different integer sizes with proper bounds checking
          long long value = num->int_value;
          if (var_size == 1) {
            if (value < -128 || value > 255) {
              emit_to_global_buffer(
                  generator,
                  "    ; Warning: Value %lld truncated to fit in %d bytes\n",
                  value, var_size);
            }
            emit_to_global_buffer(generator, "    db %lld\n", value & 0xFF);
          } else if (var_size == 2) {
            if (value < -32768 || value > 65535) {
              emit_to_global_buffer(
                  generator,
                  "    ; Warning: Value %lld truncated to fit in %d bytes\n",
                  value, var_size);
            }
            emit_to_global_buffer(generator, "    dw %lld\n", value & 0xFFFF);
          } else if (var_size == 4) {
            if (value < -2147483648LL || value > 4294967295LL) {
              emit_to_global_buffer(
                  generator,
                  "    ; Warning: Value %lld truncated to fit in %d bytes\n",
                  value, var_size);
            }
            emit_to_global_buffer(generator, "    dd %lld\n",
                                  value & 0xFFFFFFFF);
          } else {
            emit_to_global_buffer(generator, "    dq %lld\n", value);
          }
        }
      }
    } else if (var_data->initializer->type == AST_STRING_LITERAL) {
      StringLiteral *str = (StringLiteral *)var_data->initializer->data;
      if (str && str->value) {
        // For string variables, store pointer to string data
        if (var_data->type_name && strcmp(var_data->type_name, "string") == 0) {
          char *str_label = code_generator_generate_label(generator, "str");
          if (str_label) {
            emit_to_global_buffer(
                generator, "    dq %s  ; Pointer to string data\n", str_label);
            emit_to_global_buffer(generator, "%s:\n", str_label);
            emit_to_global_buffer(generator, "    db \"%s\", 0\n", str->value);
            free(str_label);
          }
        } else {
          // Direct string storage
          emit_to_global_buffer(generator, "    db \"%s\", 0\n", str->value);
        }
      }
    } else if (var_data->initializer->type == AST_IDENTIFIER) {
      // Initialize with another variable's value (copy initialization)
      emit_to_global_buffer(
          generator, "    resb %d  ; Initialize from variable at runtime\n",
          var_size);
      emit_to_global_buffer(
          generator,
          "    ; Runtime initialization needed for variable reference\n");
    } else {
      // For complex initializers (expressions, function calls, etc.), reserve
      // space and initialize at runtime
      emit_to_global_buffer(
          generator,
          "    resb %d  ; Complex initializer - runtime initialization\n",
          var_size);
    }
  } else {
    // Uninitialized data goes in .bss section
    emit_to_global_buffer(generator, "section .bss\n");
    emit_to_global_buffer(generator, "%s:\n", var_data->name);
    emit_to_global_buffer(generator, "    resb %d\n", var_size);
    emit_to_global_buffer(generator, "section .data\n");
  }

  emit_to_global_buffer(generator, "\n");
}

void code_generator_generate_local_variable(CodeGenerator *generator,
                                            ASTNode *var_declaration) {
  if (!generator || !var_declaration ||
      var_declaration->type != AST_VAR_DECLARATION) {
    return;
  }

  VarDeclaration *var_data = (VarDeclaration *)var_declaration->data;
  if (!var_data || !var_data->name) {
    return;
  }

  Symbol *symbol = symbol_table_lookup(generator->symbol_table, var_data->name);
  if (!symbol) {
    Type *var_type = NULL;
    if (var_data->type_name) {
      var_type = type_checker_get_type_by_name(generator->type_checker,
                                               var_data->type_name);
    } else if (var_data->initializer) {
      var_type = type_checker_infer_type(generator->type_checker,
                                         var_data->initializer);
    }
    if (!var_type) {
      var_type = type_checker_get_type_by_name(generator->type_checker, "int64");
    }

    Symbol *new_symbol = symbol_create(var_data->name, SYMBOL_VARIABLE, var_type);
    if (new_symbol && symbol_table_declare(generator->symbol_table, new_symbol)) {
      symbol = new_symbol;
    } else {
      symbol_destroy(new_symbol);
      symbol = symbol_table_lookup(generator->symbol_table, var_data->name);
    }
  }

  const char *resolved_type_name = var_data->type_name;
  if ((!resolved_type_name || resolved_type_name[0] == '\0') && symbol &&
      symbol->type && symbol->type->name) {
    resolved_type_name = symbol->type->name;
  }
  if (!resolved_type_name) {
    resolved_type_name = "unknown";
  }

  // Add debug symbol for local variable
  if (generator->generate_debug_info) {
    code_generator_add_debug_symbol(
        generator, var_data->name, DEBUG_SYMBOL_VARIABLE, resolved_type_name,
        var_declaration->location.line, var_declaration->location.column);
  }

  // Calculate variable size and allocate stack space
  int var_size = 0;
  if (symbol && symbol->type && symbol->type->size > 0) {
    var_size = (int)symbol->type->size;
  } else {
    var_size =
        code_generator_calculate_variable_size(generator, resolved_type_name);
  }
  if (var_size <= 0) {
    var_size = 8; // Default to 8 bytes for unknown types
  }

  int alignment = (var_size > 4) ? 8 : var_size; // Align to size, max 8
  int offset =
      code_generator_allocate_stack_space(generator, var_size, alignment);

  code_generator_emit(
      generator, "    ; Local variable: %s (%s, %d bytes) at offset -%d\n",
      var_data->name, resolved_type_name, var_size, offset);

  // Update symbol table with memory offset if symbol exists
  if (symbol && symbol->kind == SYMBOL_VARIABLE) {
    symbol->data.variable.memory_offset = offset; // Positive offset for [rbp - offset]
    symbol->data.variable.is_in_register = 0;

    // Update debug symbol with stack offset
    if (generator->generate_debug_info) {
      debug_info_set_symbol_stack_offset(generator->debug_info, var_data->name,
                                         -offset);
    }
  }

  // Generate initialization code
  if (var_data->initializer) {
    code_generator_generate_variable_initialization(generator, symbol,
                                                    var_data->initializer);
  } else {
    // Zero-initialize the variable if no explicit initializer
    code_generator_generate_variable_zero_initialization(generator, symbol);
  }
}

void code_generator_generate_variable_initialization(CodeGenerator *generator,
                                                     Symbol *symbol,
                                                     ASTNode *initializer) {
  if (!generator || !symbol || !initializer) {
    return;
  }

  code_generator_emit(generator, "    ; Initialize variable %s\n",
                      symbol->name);

  // Generate the initializer expression
  code_generator_generate_expression(generator, initializer);

  // Store the result (in rax) to the variable's memory location
  if (symbol->data.variable.is_in_register) {
    // Handle register allocation - store to assigned register
    x86Register reg = (x86Register)symbol->data.variable.register_id;
    const char *reg_name = code_generator_get_register_name(reg);
    if (reg_name) {
      // Check if it's a floating-point register
      if (reg >= REG_XMM0 && reg <= REG_XMM15) {
        code_generator_emit(generator,
                            "    movsd xmm0, %s    ; Store float to register\n",
                            reg_name);
      } else {
        code_generator_emit(
            generator, "    mov %s, rax      ; Store to register\n", reg_name);
      }
    } else {
      code_generator_emit(generator, "    ; Error: Invalid register for %s\n",
                          symbol->name);
    }
  } else {
    // Store to stack location
    int offset = symbol->data.variable.memory_offset;

    // Handle different types and sizes properly
    if (symbol->type) {
      if (symbol->type->kind >= TYPE_FLOAT32 &&
          symbol->type->kind <= TYPE_FLOAT64) {
        // Floating-point types - use XMM registers
        if (symbol->type->size == 4) {
          code_generator_emit(generator,
                              "    movss %xmm0, %d(%rbp)  ; Store float32\n",
                              offset);
        } else {
          code_generator_emit(generator,
                              "    movsd %xmm0, %d(%rbp)  ; Store float64\n",
                              offset);
        }
      } else if (symbol->type->kind == TYPE_STRING) {
        // String type - store pointer
        code_generator_emit(
            generator, "    mov %rax, %d(%rbp)     ; Store string pointer\n",
            offset);
      } else {
        // Integer types - use appropriate register size
        if (symbol->type->size == 1) {
          code_generator_emit(
              generator, "    mov %al, %d(%rbp)      ; Store int8\n", offset);
        } else if (symbol->type->size == 2) {
          code_generator_emit(
              generator, "    mov %ax, %d(%rbp)      ; Store int16\n", offset);
        } else if (symbol->type->size == 4) {
          code_generator_emit(
              generator, "    mov %eax, %d(%rbp)     ; Store int32\n", offset);
        } else {
          code_generator_emit(
              generator, "    mov %rax, %d(%rbp)     ; Store int64\n", offset);
        }
      }
    } else {
      // Fallback for unknown types
      code_generator_emit(generator,
                          "    mov %rax, %d(%rbp)     ; Store (unknown type)\n",
                          offset);
    }
  }
}

void code_generator_generate_variable_zero_initialization(
    CodeGenerator *generator, Symbol *symbol) {
  if (!generator || !symbol) {
    return;
  }

  code_generator_emit(generator, "    ; Zero-initialize variable %s\n",
                      symbol->name);

  if (symbol->data.variable.is_in_register) {
    // Zero-initialize register
    x86Register reg = (x86Register)symbol->data.variable.register_id;
    const char *reg_name = code_generator_get_register_name(reg);
    if (reg_name) {
      if (reg >= REG_XMM0 && reg <= REG_XMM15) {
        code_generator_emit(generator,
                            "    xorps %s, %s      ; Zero float register\n",
                            reg_name, reg_name);
      } else {
        code_generator_emit(generator,
                            "    xor %s, %s        ; Zero integer register\n",
                            reg_name, reg_name);
      }
    }
  } else {
    // Zero-initialize memory location
    int offset = symbol->data.variable.memory_offset;

    if (symbol->type) {
      if (symbol->type->kind >= TYPE_FLOAT32 &&
          symbol->type->kind <= TYPE_FLOAT64) {
        // Zero floating-point variable
        if (symbol->type->size == 4) {
          code_generator_emit(generator,
                              "    movl $0, %d(%rbp)       ; Zero float32\n",
                              offset);
        } else {
          code_generator_emit(generator,
                              "    movq $0, %d(%rbp)       ; Zero float64\n",
                              offset);
        }
      } else {
        // Zero integer or pointer variable
        if (symbol->type->size == 1) {
          code_generator_emit(
              generator, "    movb $0, %d(%rbp)       ; Zero int8\n", offset);
        } else if (symbol->type->size == 2) {
          code_generator_emit(
              generator, "    movw $0, %d(%rbp)       ; Zero int16\n", offset);
        } else if (symbol->type->size == 4) {
          code_generator_emit(
              generator, "    movl $0, %d(%rbp)       ; Zero int32\n", offset);
        } else {
          code_generator_emit(
              generator, "    movq $0, %d(%rbp)       ; Zero int64/pointer\n",
              offset);
        }
      }
    } else {
      // Default zero initialization
      code_generator_emit(generator,
                          "    movq $0, %d(%rbp)       ; Zero (unknown type)\n",
                          offset);
    }
  }
}

int code_generator_calculate_variable_size(CodeGenerator *generator,
                                           const char *type_name) {
  (void)generator; // Suppress unused parameter warning

  if (!type_name) {
    return 8; // Default size for unknown types
  }

  // Basic type size mapping - comprehensive coverage
  if (strcmp(type_name, "int8") == 0 || strcmp(type_name, "uint8") == 0) {
    return 1;
  } else if (strcmp(type_name, "int16") == 0 ||
             strcmp(type_name, "uint16") == 0) {
    return 2;
  } else if (strcmp(type_name, "int32") == 0 ||
             strcmp(type_name, "uint32") == 0) {
    return 4;
  } else if (strcmp(type_name, "int64") == 0 ||
             strcmp(type_name, "uint64") == 0) {
    return 8;
  } else if (strcmp(type_name, "float32") == 0) {
    return 4;
  } else if (strcmp(type_name, "float64") == 0) {
    return 8;
  } else if (strcmp(type_name, "string") == 0) {
    return 8; // String is a pointer to char array
  } else if (strcmp(type_name, "void") == 0) {
    return 0; // Void type has no size
  } else if (strstr(type_name, "*") != NULL) {
    return 8; // All pointers are 8 bytes on x86-64
  } else if (strstr(type_name, "[") != NULL) {
    // Array type - would need more complex parsing
    // For now, assume it's a pointer to the array
    return 8;
  }

  // Check if it's a struct type by looking it up in symbol table
  if (generator && generator->symbol_table) {
    Symbol *type_symbol =
        symbol_table_lookup(generator->symbol_table, type_name);
    if (type_symbol && type_symbol->kind == SYMBOL_STRUCT &&
        type_symbol->type) {
      return (int)type_symbol->type->size;
    }
  }

  // For unknown types, assume pointer size (8 bytes on x86-64)
  return 8;
}

int code_generator_allocate_stack_space(CodeGenerator *generator, int size,
                                        int alignment) {
  if (!generator) {
    return 0;
  }

  // Ensure minimum alignment of 1
  if (alignment < 1) {
    alignment = 1;
  }

  // Align current offset to the required alignment
  int aligned_offset = generator->current_stack_offset;
  if (alignment > 1) {
    aligned_offset = (aligned_offset + alignment - 1) & ~(alignment - 1);
  }

  // Allocate space for the variable
  aligned_offset += size;

  // Update the current stack offset
  generator->current_stack_offset = aligned_offset;

  // Ensure stack remains 16-byte aligned for function calls
  // This is important for x86-64 ABI compliance
  int total_stack_used = aligned_offset;
  if ((total_stack_used % 16) != 0) {
    int padding = 16 - (total_stack_used % 16);
    generator->current_stack_offset += padding;
    code_generator_emit(generator,
                        "    ; Added %d bytes padding for 16-byte alignment\n",
                        padding);
  }

  return aligned_offset;
}

// Function call implementation functions
void code_generator_generate_function_call(CodeGenerator *generator,
                                           ASTNode *call_expression) {
  if (!generator || !call_expression ||
      call_expression->type != AST_FUNCTION_CALL) {
    code_generator_set_error(generator, "Invalid function call AST node");
    return;
  }

  CallExpression *call_data = (CallExpression *)call_expression->data;
  if (!call_data || !call_data->function_name) {
    code_generator_set_error(generator, "Malformed function call expression");
    return;
  }

  // Check if this is a method call (has an object)
  if (call_data->object) {
    // Method call with name mangling
    // Try to determine the struct type for proper name mangling
    char mangled_name[256];
    const char *struct_name = NULL;

    if (call_data->object->type == AST_IDENTIFIER) {
      Identifier *id_data = (Identifier *)call_data->object->data;
      if (id_data && id_data->name) {
        Symbol *obj_symbol =
            symbol_table_lookup(generator->symbol_table, id_data->name);
        if (obj_symbol && obj_symbol->type && obj_symbol->type->name) {
          struct_name = obj_symbol->type->name;
        }
      }
    }

    if (struct_name) {
      snprintf(mangled_name, sizeof(mangled_name), "%s_%s", struct_name,
               call_data->function_name);
    } else {
      snprintf(mangled_name, sizeof(mangled_name), "%s",
               call_data->function_name);
    }

    code_generator_emit(generator, "    ; Method call: %s (mangled: %s)\n",
                        call_data->function_name, mangled_name);

    // Generate the method call using the existing helper
    code_generator_generate_method_call(generator, call_expression,
                                        call_data->object);

    // Patch the emitted call target to use the mangled name
    // (The method_call function already emitted the call, so we handle name
    // mangling there)
    return;
  }

  code_generator_emit(generator, "    ; Function call: %s\n",
                      call_data->function_name);

  // Get calling convention spec from register allocator
  CallingConventionSpec *conv_spec =
      generator->register_allocator->calling_convention;
  if (!conv_spec) {
    code_generator_set_error(generator, "No calling convention configured");
    return;
  }

  // Look up function symbol to get return type
  Symbol *func_symbol =
      symbol_table_lookup(generator->symbol_table, call_data->function_name);
  Type *return_type = NULL;
  if (func_symbol && func_symbol->kind == SYMBOL_FUNCTION &&
      func_symbol->type) {
    return_type = func_symbol->type;
  }

  // 1. Align stack for function call (x86-64 requires 16-byte alignment)
  code_generator_align_stack_for_call(generator, call_data->argument_count);

  // 2. Save caller-saved registers that are NOT used for parameters
  // Only save registers that are actually in use and not parameter registers
  code_generator_save_caller_saved_registers_selective(generator);

  // 3. Pass parameters according to calling convention
  code_generator_generate_parameter_passing(generator, call_data->arguments,
                                            call_data->argument_count);

  // 4. Generate the call instruction
  code_generator_emit(generator, "    call %s\n", call_data->function_name);

  // 5. Clean up stack if needed (for parameters passed on stack)
  code_generator_cleanup_stack_after_call(generator, call_data->arguments,
                                          call_data->argument_count);

  // 6. Handle return value based on type
  code_generator_handle_return_value(generator, return_type);

  // 7. Restore caller-saved registers
  code_generator_restore_caller_saved_registers_selective(generator);

  // 8. Return value is now properly positioned
  if (return_type && code_generator_is_floating_point_type(return_type)) {
    code_generator_emit(generator, "    ; Return value in %xmm0 (float)\n");
  } else if (return_type && return_type->name &&
             strcmp(return_type->name, "void") != 0) {
    code_generator_emit(generator,
                        "    ; Return value in %rax (integer/pointer)\n");
  } else {
    code_generator_emit(generator, "    ; Void function - no return value\n");
  }
}

void code_generator_generate_parameter_passing(CodeGenerator *generator,
                                               ASTNode **arguments,
                                               size_t argument_count) {
  if (!generator || !arguments || argument_count == 0) {
    return;
  }

  CallingConventionSpec *conv_spec =
      generator->register_allocator->calling_convention;
  if (!conv_spec) {
    return;
  }

  code_generator_emit(generator, "    ; Passing %zu parameters\n",
                      argument_count);

  // Track register usage for parameter passing
  int int_reg_index = 0;
  int float_reg_index = 0;
  int stack_param_count = 0;

  // Pass parameters in reverse order for stack parameters (right-to-left)
  // But register parameters are passed in forward order

  // First pass: count stack parameters and prepare
  for (size_t i = 0; i < argument_count; i++) {
    if (arguments[i]) {
      // Determine parameter type (simplified type inference)
      Type *param_type =
          code_generator_infer_expression_type(generator, arguments[i]);
      int is_float = code_generator_is_floating_point_type(param_type);

      if (is_float) {
        if (float_reg_index >= (int)conv_spec->float_param_count) {
          stack_param_count++;
        }
        float_reg_index++;
      } else {
        if (int_reg_index >= (int)conv_spec->int_param_count) {
          stack_param_count++;
        }
        int_reg_index++;
      }
    }
  }

  // Reset counters for actual parameter passing
  int_reg_index = 0;
  float_reg_index = 0;

  // Second pass: generate parameters in correct order
  // Stack parameters need to be pushed in reverse order (right-to-left)
  if (stack_param_count > 0) {
    // Process stack parameters in reverse order
    for (int i = (int)argument_count - 1; i >= 0; i--) {
      if (arguments[i]) {
        Type *param_type =
            code_generator_infer_expression_type(generator, arguments[i]);
        int is_float = code_generator_is_floating_point_type(param_type);

        // Check if this parameter goes on stack
        int goes_on_stack = 0;
        if (is_float && float_reg_index >= (int)conv_spec->float_param_count) {
          goes_on_stack = 1;
        } else if (!is_float &&
                   int_reg_index >= (int)conv_spec->int_param_count) {
          goes_on_stack = 1;
        }

        if (goes_on_stack) {
          code_generator_generate_parameter(generator, arguments[i], i,
                                            param_type);
        }

        // Update counters (counting backwards)
        if (is_float) {
          float_reg_index++;
        } else {
          int_reg_index++;
        }
      }
    }
  }

  // Reset counters for register parameters
  int_reg_index = 0;
  float_reg_index = 0;

  // Third pass: generate register parameters in forward order
  for (size_t i = 0; i < argument_count; i++) {
    if (arguments[i]) {
      Type *param_type =
          code_generator_infer_expression_type(generator, arguments[i]);
      int is_float = code_generator_is_floating_point_type(param_type);

      // Check if this parameter goes in register
      int goes_in_register = 0;
      if (is_float && float_reg_index < (int)conv_spec->float_param_count) {
        goes_in_register = 1;
      } else if (!is_float && int_reg_index < (int)conv_spec->int_param_count) {
        goes_in_register = 1;
      }

      if (goes_in_register) {
        code_generator_generate_parameter(generator, arguments[i], (int)i,
                                          param_type);
      }

      // Update counters
      if (is_float) {
        float_reg_index++;
      } else {
        int_reg_index++;
      }
    }
  }
}

void code_generator_generate_parameter(CodeGenerator *generator,
                                       ASTNode *argument, int param_index,
                                       Type *param_type) {
  if (!generator || !argument) {
    return;
  }

  CallingConventionSpec *conv_spec =
      generator->register_allocator->calling_convention;
  if (!conv_spec) {
    return;
  }

  // Generate the argument expression
  code_generator_generate_expression(generator, argument);

  // Determine parameter type if not provided
  if (!param_type) {
    param_type = code_generator_infer_expression_type(generator, argument);
  }

  int is_float = code_generator_is_floating_point_type(param_type);

  // Track register indices separately for int and float parameters
  static int int_reg_index = 0;
  static int float_reg_index = 0;

  // Reset counters at start of function call (this is a simplification)
  if (param_index == 0) {
    int_reg_index = 0;
    float_reg_index = 0;
  }

  if (is_float) {
    // Floating-point parameter
    if (float_reg_index < (int)conv_spec->float_param_count) {
      // Parameter goes in floating-point register
      x86Register param_reg = conv_spec->float_param_registers[float_reg_index];
      const char *reg_name = code_generator_get_register_name(param_reg);

      if (reg_name) {
        code_generator_emit(
            generator,
            "    movsd xmm0, %s    ; Float parameter %d in register\n",
            reg_name, param_index + 1);
      }
      float_reg_index++;
    } else {
      // Parameter goes on stack
      code_generator_emit(
          generator,
          "    sub $8, %rsp        ; Allocate stack space for float\n");
      code_generator_emit(
          generator, "    movsd %xmm0, (%rsp) ; Float parameter %d on stack\n",
          param_index + 1);
    }
  } else {
    // Integer/pointer parameter
    if (int_reg_index < (int)conv_spec->int_param_count) {
      // Parameter goes in integer register
      x86Register param_reg = conv_spec->int_param_registers[int_reg_index];
      const char *reg_name = code_generator_get_register_name(param_reg);

      if (reg_name) {
        // Handle different parameter sizes
        const char *src_reg = "rax";
        const char *dst_reg = reg_name;

        if (param_type && param_type->size == 4) {
          // 32-bit parameter - use 32-bit register names
          src_reg = "eax";
          if (strcmp(reg_name, "rdi") == 0)
            dst_reg = "edi";
          else if (strcmp(reg_name, "rsi") == 0)
            dst_reg = "esi";
          else if (strcmp(reg_name, "rdx") == 0)
            dst_reg = "edx";
          else if (strcmp(reg_name, "rcx") == 0)
            dst_reg = "ecx";
          else if (strcmp(reg_name, "r8") == 0)
            dst_reg = "r8d";
          else if (strcmp(reg_name, "r9") == 0)
            dst_reg = "r9d";
        }

        code_generator_emit(
            generator, "    mov %s, %s    ; Integer parameter %d in register\n",
            dst_reg, src_reg, param_index + 1);
      }
      int_reg_index++;
    } else {
      // Parameter goes on stack
      if (param_type && param_type->size <= 4) {
        // 32-bit or smaller - push as 64-bit for alignment
        code_generator_emit(
            generator,
            "    push %rax          ; Integer parameter %d on stack\n",
            param_index + 1);
      } else {
        // 64-bit parameter
        code_generator_emit(
            generator,
            "    push %rax          ; Integer parameter %d on stack\n",
            param_index + 1);
      }
    }
  }
}

void code_generator_save_caller_saved_registers(CodeGenerator *generator) {
  if (!generator) {
    return;
  }

  CallingConventionSpec *conv_spec =
      generator->register_allocator->calling_convention;
  if (!conv_spec) {
    return;
  }

  code_generator_emit(generator,
                      "    ; Save caller-saved registers (non-parameter)\n");

  // Save only caller-saved registers that are NOT used for parameter passing
  // In a full implementation, this would only save registers that are actually
  // in use

  // RAX is always caller-saved and not used for parameters (it's the return
  // register)
  code_generator_emit(generator, "    push %rax\n");

  // R10, R11 are caller-saved and not used for parameters in either calling
  // convention
  code_generator_emit(generator, "    push %r10\n");
  code_generator_emit(generator, "    push %r11\n");
}

void code_generator_restore_caller_saved_registers(CodeGenerator *generator) {
  if (!generator) {
    return;
  }

  code_generator_emit(generator,
                      "    ; Restore caller-saved registers (non-parameter)\n");

  // Restore in reverse order
  code_generator_emit(generator, "    pop %r11\n");
  code_generator_emit(generator, "    pop %r10\n");
  code_generator_emit(generator, "    pop %rax\n");
}

// Selective register saving - only save registers that are actually in use
void code_generator_save_caller_saved_registers_selective(
    CodeGenerator *generator) {
  if (!generator) {
    return;
  }

  CallingConventionSpec *conv_spec =
      generator->register_allocator->calling_convention;
  if (!conv_spec) {
    return;
  }

  code_generator_emit(generator,
                      "    ; Save caller-saved registers (selective)\n");

  // Save caller-saved registers that are not used for parameter passing
  // and are currently in use by the register allocator

  // Always save RAX as it might contain a value and is not used for parameters
  code_generator_emit(generator, "    push %rax\n");

  // Save R10, R11 which are caller-saved but not parameter registers
  code_generator_emit(generator, "    push %r10\n");
  code_generator_emit(generator, "    push %r11\n");

  // For floating-point calls, save XMM registers that are caller-saved
  // but not used for parameters (XMM8-XMM15 on System V, XMM4-XMM15 on Windows)
  int float_param_regs = (int)conv_spec->float_param_count;
  for (int i = float_param_regs; i < 8; i++) {
    if (i >= 4 || conv_spec->convention == CALLING_CONV_SYSV) {
      code_generator_emit(generator, "    sub $16, %rsp\n");
      code_generator_emit(generator,
                          "    movdqu %xmm%d, (%rsp)  ; Save XMM%d\n", i, i);
    }
  }
}

void code_generator_restore_caller_saved_registers_selective(
    CodeGenerator *generator) {
  if (!generator) {
    return;
  }

  CallingConventionSpec *conv_spec =
      generator->register_allocator->calling_convention;
  if (!conv_spec) {
    return;
  }

  code_generator_emit(generator,
                      "    ; Restore caller-saved registers (selective)\n");

  // Restore XMM registers in reverse order
  int float_param_regs = (int)conv_spec->float_param_count;
  for (int i = 7; i >= float_param_regs; i--) {
    if (i >= 4 || conv_spec->convention == CALLING_CONV_SYSV) {
      code_generator_emit(generator,
                          "    movdqu (%rsp), %xmm%d  ; Restore XMM%d\n", i, i);
      code_generator_emit(generator, "    add $16, %rsp\n");
    }
  }

  // Restore general-purpose registers in reverse order
  code_generator_emit(generator, "    pop %r11\n");
  code_generator_emit(generator, "    pop %r10\n");
  code_generator_emit(generator, "    pop %rax\n");
}

// Clean up stack after function call
void code_generator_cleanup_stack_after_call(CodeGenerator *generator,
                                             ASTNode **arguments,
                                             size_t argument_count) {
  if (!generator) {
    return;
  }

  CallingConventionSpec *conv_spec =
      generator->register_allocator->calling_convention;
  if (!conv_spec) {
    return;
  }

  // Calculate how many parameters were pushed on stack
  int stack_bytes = 0;
  int int_reg_used = 0;
  int float_reg_used = 0;

  for (size_t i = 0; i < argument_count; i++) {
    if (arguments[i]) {
      Type *param_type =
          code_generator_infer_expression_type(generator, arguments[i]);
      int is_float = code_generator_is_floating_point_type(param_type);

      if (is_float) {
        if (float_reg_used >= (int)conv_spec->float_param_count) {
          stack_bytes += 8; // Each stack parameter is 8 bytes
        }
        float_reg_used++;
      } else {
        if (int_reg_used >= (int)conv_spec->int_param_count) {
          stack_bytes += 8; // Each stack parameter is 8 bytes
        }
        int_reg_used++;
      }
    }
  }

  // Clean up stack parameters
  if (stack_bytes > 0) {
    code_generator_emit(
        generator,
        "    add $%d, %rsp    ; Clean up %d bytes of stack parameters\n",
        stack_bytes, stack_bytes);
  }

  // Clean up shadow space for Microsoft x64
  if (conv_spec->convention == CALLING_CONV_MS_X64 &&
      conv_spec->shadow_space_size > 0) {
    code_generator_emit(generator,
                        "    add $%d, %rsp      ; Clean up shadow space\n",
                        conv_spec->shadow_space_size);
  }

  // Clean up alignment padding if it was added
  // This is a simplified approach - in practice, we'd track the exact padding
  code_generator_emit(generator, "    ; Stack cleanup complete\n");
}

// Handle return value based on type
void code_generator_handle_return_value(CodeGenerator *generator,
                                        Type *return_type) {
  if (!generator) {
    return;
  }

  if (!return_type || !return_type->name) {
    code_generator_emit(generator,
                        "    ; Unknown return type - assuming integer\n");
    return;
  }

  if (strcmp(return_type->name, "void") == 0) {
    code_generator_emit(generator, "    ; Void return - no value to handle\n");
    return;
  }

  if (code_generator_is_floating_point_type(return_type)) {
    code_generator_emit(generator, "    ; Float return value in xmm0\n");
    // If we need to store it somewhere else, we can move it
    // For now, leave it in XMM0 as that's where expressions expect it
  } else {
    code_generator_emit(generator,
                        "    ; Integer/pointer return value in rax\n");
    // Handle different integer sizes if needed
    if (return_type->size == 1) {
      code_generator_emit(
          generator, "    movzx eax, al    ; Zero-extend 8-bit return value\n");
    } else if (return_type->size == 2) {
      code_generator_emit(
          generator,
          "    movzx eax, ax    ; Zero-extend 16-bit return value\n");
    } else if (return_type->size == 4) {
      code_generator_emit(generator,
                          "    ; 32-bit return value already in eax\n");
    }
    // 64-bit values are already in full RAX
  }
}
void code_generator_align_stack_for_call(CodeGenerator *generator,
                                         int param_count) {
  if (!generator) {
    return;
  }

  // x86-64 ABI requires 16-byte stack alignment before function calls
  // RSP must be 16-byte aligned when call instruction is executed

  CallingConventionSpec *conv_spec =
      generator->register_allocator->calling_convention;
  if (!conv_spec) {
    return;
  }

  // Calculate how many parameters will be pushed on stack
  int stack_params = 0;
  if (param_count > (int)conv_spec->int_param_count) {
    stack_params = param_count - (int)conv_spec->int_param_count;
  }

  // Account for caller-saved registers we're pushing (3 registers: rax, r10,
  // r11)
  int total_pushes = 3 + stack_params;

  // Add shadow space for Microsoft x64 calling convention
  if (conv_spec->convention == CALLING_CONV_MS_X64 &&
      conv_spec->shadow_space_size > 0) {
    code_generator_emit(generator,
                        "    sub rsp, %d      ; Allocate shadow space\n",
                        conv_spec->shadow_space_size);
  }

  // If total pushes results in misaligned stack, add padding
  if ((total_pushes % 2) != 0) {
    code_generator_emit(generator,
                        "    sub rsp, 8       ; Align stack to 16 bytes\n");
  }
}

// Helper function to infer expression type (simplified implementation)
Type *code_generator_infer_expression_type(CodeGenerator *generator,
                                           ASTNode *expression) {
  if (!generator || !expression) {
    return NULL;
  }

  // Create a basic type structure for return
  static Type int_type = {
      .kind = TYPE_INT32, .name = "int32", .size = 4, .alignment = 4};
  static Type float_type = {
      .kind = TYPE_FLOAT64, .name = "float64", .size = 8, .alignment = 8};
  static Type string_type = {.kind = TYPE_STRING,
                             .name = "string",
                             .size = 8,
                             .alignment = 8}; // pointer size

  switch (expression->type) {
  case AST_NUMBER_LITERAL: {
    NumberLiteral *num = (NumberLiteral *)expression->data;
    if (num && num->is_float) {
      return &float_type;
    } else {
      return &int_type;
    }
  }
  case AST_STRING_LITERAL:
    return &string_type;

  case AST_IDENTIFIER: {
    // Look up variable type in symbol table
    Identifier *id = (Identifier *)expression->data;
    if (id && id->name) {
      Symbol *symbol = symbol_table_lookup(generator->symbol_table, id->name);
      if (symbol && symbol->type) {
        return symbol->type;
      }
    }
    return &int_type; // Default fallback
  }

  case AST_FUNCTION_CALL: {
    // Look up function return type
    CallExpression *call = (CallExpression *)expression->data;
    if (call && call->function_name) {
      Symbol *func_symbol =
          symbol_table_lookup(generator->symbol_table, call->function_name);
      if (func_symbol && func_symbol->kind == SYMBOL_FUNCTION &&
          func_symbol->type) {
        return func_symbol->type;
      }
    }
    return &int_type; // Default fallback
  }

  case AST_BINARY_EXPRESSION: {
    // For binary expressions, use the type of the left operand (simplified)
    BinaryExpression *bin = (BinaryExpression *)expression->data;
    if (bin && bin->left) {
      return code_generator_infer_expression_type(generator, bin->left);
    }
    return &int_type;
  }

  default:
    return &int_type; // Default fallback
  }
}

// Helper function to check if a type is floating-point
int code_generator_is_floating_point_type(Type *type) {
  if (!type || !type->name) {
    return 0;
  }

  return (strcmp(type->name, "float32") == 0 ||
          strcmp(type->name, "float64") == 0 ||
          strcmp(type->name, "double") == 0 ||
          strcmp(type->name, "float") == 0);
}

const char *code_generator_get_register_name(x86Register reg) {
  switch (reg) {
  case REG_RAX:
    return "rax";
  case REG_RBX:
    return "rbx";
  case REG_RCX:
    return "rcx";
  case REG_RDX:
    return "rdx";
  case REG_RSI:
    return "rsi";
  case REG_RDI:
    return "rdi";
  case REG_RSP:
    return "rsp";
  case REG_RBP:
    return "rbp";
  case REG_R8:
    return "r8";
  case REG_R9:
    return "r9";
  case REG_R10:
    return "r10";
  case REG_R11:
    return "r11";
  case REG_R12:
    return "r12";
  case REG_R13:
    return "r13";
  case REG_R14:
    return "r14";
  case REG_R15:
    return "r15";
  case REG_XMM0:
    return "xmm0";
  case REG_XMM1:
    return "xmm1";
  case REG_XMM2:
    return "xmm2";
  case REG_XMM3:
    return "xmm3";
  case REG_XMM4:
    return "xmm4";
  case REG_XMM5:
    return "xmm5";
  case REG_XMM6:
    return "xmm6";
  case REG_XMM7:
    return "xmm7";
  case REG_XMM8:
    return "xmm8";
  case REG_XMM9:
    return "xmm9";
  case REG_XMM10:
    return "xmm10";
  case REG_XMM11:
    return "xmm11";
  case REG_XMM12:
    return "xmm12";
  case REG_XMM13:
    return "xmm13";
  case REG_XMM14:
    return "xmm14";
  case REG_XMM15:
    return "xmm15";
  default:
    return NULL;
  }
}

// Expression and assignment implementation functions
void code_generator_generate_binary_operation(CodeGenerator *generator,
                                              ASTNode *left, const char *op,
                                              ASTNode *right) {
  if (!generator || !left || !op || !right) {
    code_generator_set_error(generator, "Malformed binary operation");
    return;
  }

  code_generator_emit(generator, "    ; Binary operation: %s\n", op);

  Type *left_type = code_generator_infer_expression_type(generator, left);
  Type *right_type = code_generator_infer_expression_type(generator, right);
  int is_float = code_generator_is_floating_point_type(left_type) ||
                 code_generator_is_floating_point_type(right_type);

  if (is_float) {
    // Generate and push left operand (float)
    code_generator_generate_expression(generator, left); // result in xmm0
    code_generator_emit(
        generator, "    sub rsp, 8          ; Make space for float on stack\n");
    code_generator_emit(generator,
                        "    movsd [rsp], xmm0  ; Save left operand (float)\n");

    // Generate right operand (float)
    code_generator_generate_expression(generator, right); // result in xmm0

    // Pop left operand into xmm1
    code_generator_emit(
        generator, "    movsd xmm1, [rsp]  ; Restore left operand (float)\n");
    code_generator_emit(generator,
                        "    add rsp, 8          ; Clean up stack\n");

    const char *instruction = code_generator_get_arithmetic_instruction(op, 1);
    if (instruction) {
      code_generator_emit(generator, "    %s xmm1, xmm0      ; %s operation\n",
                          instruction, op);
      code_generator_emit(generator,
                          "    movsd xmm0, xmm1   ; Move result to xmm0\n");
    } else {
      // Handle float comparisons
      if (strcmp(op, "==") == 0 || strcmp(op, "!=") == 0 ||
          strcmp(op, "<") == 0 || strcmp(op, "<=") == 0 ||
          strcmp(op, ">") == 0 || strcmp(op, ">=") == 0) {
        code_generator_emit(generator,
                            "    ucomisd xmm1, xmm0 ; Compare floats\n");
        const char *set_instruction = "nop";
        if (strcmp(op, "==") == 0)
          set_instruction = "sete";
        else if (strcmp(op, "!=") == 0)
          set_instruction = "setne";
        else if (strcmp(op, "<") == 0)
          set_instruction = "setb";
        else if (strcmp(op, "<=") == 0)
          set_instruction = "setbe";
        else if (strcmp(op, ">") == 0)
          set_instruction = "seta";
        else if (strcmp(op, ">=") == 0)
          set_instruction = "setae";

        code_generator_emit(generator,
                            "    %s al             ; Set AL on condition\n",
                            set_instruction);
        code_generator_emit(generator,
                            "    movzx rax, al     ; Zero-extend AL to RAX\n");
      } else {
        code_generator_set_error(generator,
                                 "Unsupported floating-point operator '%s'",
                                 op);
      }
    }
  } else {
    // Integer operations
    code_generator_generate_expression(generator, left);
    code_generator_emit(generator,
                        "    push rax           ; Save left operand\n");

    code_generator_generate_expression(generator, right);
    code_generator_emit(generator,
                        "    mov rbx, rax     ; Move right operand to RBX\n");

    code_generator_emit(generator,
                        "    pop rax            ; Restore left operand\n");

    const char *instruction = code_generator_get_arithmetic_instruction(op, 0);
    if (instruction) {
      if (strcmp(op, "/") == 0) {
        code_generator_emit(
            generator,
            "    cqo                  ; Sign-extend RAX to RDX:RAX\n");
        code_generator_emit(generator,
                            "    idiv rbx           ; Divide RDX:RAX by RBX\n");
      } else if (strcmp(op, "%") == 0) {
        code_generator_emit(
            generator,
            "    cqo                  ; Sign-extend RAX to RDX:RAX\n");
        code_generator_emit(generator,
                            "    idiv rbx           ; Divide RDX:RAX by RBX\n");
        code_generator_emit(generator,
                            "    mov rax, rdx     ; Move remainder to RAX\n");
      } else {
        code_generator_emit(generator, "    %s rax, rbx      ; %s operation\n",
                            instruction, op);
      }
    } else {
      // Handle comparison and logical operators
      code_generator_emit(generator, "    cmp rax, rbx     ; Compare\n");
      const char *set_instruction = "nop";
      if (strcmp(op, "==") == 0)
        set_instruction = "sete";
      else if (strcmp(op, "!=") == 0)
        set_instruction = "setne";
      else if (strcmp(op, "<") == 0)
        set_instruction = "setl";
      else if (strcmp(op, "<=") == 0)
        set_instruction = "setle";
      else if (strcmp(op, ">") == 0)
        set_instruction = "setg";
      else if (strcmp(op, ">=") == 0)
        set_instruction = "setge";

      if (strcmp(set_instruction, "nop") != 0) {
        code_generator_emit(generator,
                            "    %s al            ; Set AL on condition\n",
                            set_instruction);
        code_generator_emit(generator,
                            "    movzx rax, al    ; Zero-extend AL to RAX\n");
      } else if (strcmp(op, "&&") == 0) {
        code_generator_emit(generator, "    and rax, rbx     ; Logical AND\n");
        code_generator_emit(
            generator,
            "    setne al           ; Set AL if result is not zero\n");
        code_generator_emit(generator,
                            "    movzx rax, al    ; Zero-extend AL to RAX\n");
      } else if (strcmp(op, "||") == 0) {
        code_generator_emit(generator, "    or rax, rbx      ; Logical OR\n");
        code_generator_emit(
            generator,
            "    setne al           ; Set AL if result is not zero\n");
        code_generator_emit(generator,
                            "    movzx rax, al    ; Zero-extend AL to RAX\n");
      } else {
        code_generator_set_error(generator, "Unknown binary operator '%s'", op);
      }
    }
  }
}
void code_generator_generate_unary_operation(CodeGenerator *generator,
                                             const char *op, ASTNode *operand) {
  if (!generator || !op || !operand) {
    code_generator_set_error(generator, "Malformed unary operation");
    return;
  }

  code_generator_emit(generator, "    ; Unary operation: %s\n", op);

  // Generate operand (result in RAX)
  code_generator_generate_expression(generator, operand);

  // Apply unary operation
  if (strcmp(op, "-") == 0) {
    code_generator_emit(generator, "    neg rax            ; Negate\n");
  } else if (strcmp(op, "!") == 0) {
    code_generator_emit(generator, "    test rax, rax    ; Test for zero\n");
    code_generator_emit(generator, "    setz al            ; Set AL if zero\n");
    code_generator_emit(generator,
                        "    movzx rax, al    ; Zero-extend AL to RAX\n");
  } else if (strcmp(op, "~") == 0) {
    code_generator_emit(generator, "    not rax            ; Bitwise NOT\n");
  } else if (strcmp(op, "+") == 0) {
    // Unary plus - no operation needed
    code_generator_emit(generator, "    ; Unary plus (no-op)\n");
  } else {
    code_generator_set_error(generator, "Unknown unary operator '%s'", op);
  }
}
void code_generator_generate_assignment_statement(CodeGenerator *generator,
                                                  ASTNode *assignment) {
  if (!generator || !assignment || assignment->type != AST_ASSIGNMENT) {
    return;
  }

  Assignment *assign_data = (Assignment *)assignment->data;
  if (!assign_data || !assign_data->value) {
    return;
  }

  if (assign_data->target && assign_data->target->type == AST_MEMBER_ACCESS) {
    // Struct field assignment: obj.field = expr
    MemberAccess *access = (MemberAccess *)assign_data->target->data;
    if (!access || !access->object || !access->member)
      return;

    code_generator_emit(generator, "    ; Field assignment: .%s = ...\n",
                        access->member);

    // Generate the value expression (result in RAX)
    code_generator_generate_expression(generator, assign_data->value);
    code_generator_emit(generator, "    push rax           ; Save value\n");

    // Generate the object base address
    code_generator_generate_expression(generator, access->object);
    // RAX now has the base address of the struct

    // Calculate field offset
    int field_offset = -1;
    Type *object_type = NULL;

    if (access->object->type == AST_IDENTIFIER) {
      Identifier *id_data = (Identifier *)access->object->data;
      if (id_data && id_data->name) {
        Symbol *object_symbol =
            symbol_table_lookup(generator->symbol_table, id_data->name);
        if (object_symbol && object_symbol->type &&
            object_symbol->type->kind == TYPE_STRUCT) {
          object_type = object_symbol->type;
          field_offset = code_generator_get_field_offset(generator, object_type,
                                                         access->member);
        }
      }
    }

    if (field_offset < 0) {
      code_generator_set_error(
          generator, "Cannot determine field offset for '%s' in assignment",
          access->member);
      return;
    }

    if (field_offset > 0) {
      code_generator_emit(generator,
                          "    add rax, %d       ; Add field offset\n",
                          field_offset);
    }

    code_generator_emit(generator, "    pop rcx            ; Restore value\n");
    code_generator_emit(generator,
                        "    mov [rax], rcx     ; Store value to field\n");
  } else if (assign_data->variable_name) {
    // Simple variable assignment: name = expr
    code_generator_emit(generator, "    ; Assignment to %s\n",
                        assign_data->variable_name);

    // Generate the value expression (result in RAX)
    code_generator_generate_expression(generator, assign_data->value);

    // Store the result to the variable
    code_generator_store_variable(generator, assign_data->variable_name, "rax");
  } else {
    code_generator_set_error(generator, "Invalid assignment target");
  }
}

void code_generator_load_variable(CodeGenerator *generator,
                                  const char *variable_name) {
  if (!generator || !variable_name) {
    return;
  }

  code_generator_emit(generator, "    ; Load variable: %s\n", variable_name);

  Symbol *symbol = symbol_table_lookup(generator->symbol_table, variable_name);
  if (symbol && symbol->kind == SYMBOL_VARIABLE) {
    if (symbol->data.variable.is_in_register) {
      x86Register reg = (x86Register)symbol->data.variable.register_id;
      const char *reg_name = code_generator_get_register_name(reg);
      if (reg_name) {
        code_generator_emit(generator, "    mov rax, %s      ; From register\n",
                            reg_name);
      }
    } else {
      if (symbol->scope && symbol->scope->type == SCOPE_GLOBAL) {
        code_generator_emit(generator,
                            "    mov rax, [%s + rip]  ; From global memory\n",
                            variable_name);
      } else {
        // Local variable or parameter on stack
        int offset = symbol->data.variable.memory_offset;
        code_generator_emit(
            generator, "    mov rax, [rbp - %d]  ; From stack [rbp - %d]\n",
            offset, offset);
      }
    }
  } else {
    code_generator_set_error(generator,
                             "Undefined variable '%s' during code generation",
                             variable_name);
  }
}

void code_generator_store_variable(CodeGenerator *generator,
                                   const char *variable_name,
                                   const char *source_reg) {
  if (!generator || !variable_name || !source_reg) {
    return;
  }

  code_generator_emit(generator, "    ; Store to variable: %s\n",
                      variable_name);

  Symbol *symbol = symbol_table_lookup(generator->symbol_table, variable_name);
  if (symbol && symbol->kind == SYMBOL_VARIABLE) {
    if (symbol->data.variable.is_in_register) {
      x86Register reg = (x86Register)symbol->data.variable.register_id;
      const char *reg_name = code_generator_get_register_name(reg);
      if (reg_name) {
        code_generator_emit(generator, "    mov %s, %s       ; To register\n",
                            reg_name, source_reg);
      }
    } else {
      if (symbol->scope && symbol->scope->type == SCOPE_GLOBAL) {
        code_generator_emit(generator,
                            "    mov [%s + rip], %s  ; To global memory\n",
                            variable_name, source_reg);
      } else {
        // Local variable or parameter on stack
        int offset = symbol->data.variable.memory_offset;
        code_generator_emit(generator,
                            "    mov [rbp - %d], %s  ; To stack [rbp - %d]\n",
                            offset, source_reg, offset);
      }
    }
  } else {
    code_generator_set_error(generator,
                             "Cannot store to undefined variable '%s'",
                             variable_name);
  }
}
void code_generator_load_string_literal(CodeGenerator *generator,
                                        const char *string_value) {
  if (!generator || !string_value) {
    return;
  }

  code_generator_emit(generator, "    ; String literal: \"%s\"\n",
                      string_value);

  // Generate a unique label for this string
  char *label = code_generator_generate_label(generator, "str");
  if (label) {
    // Load string address into RAX
    code_generator_emit(
        generator, "    lea rax, [%s + rip]  ; Load string address\n", label);

    // Add string to global variables buffer for data section
    emit_to_global_buffer(generator, "%s:\n", label);
    emit_to_global_buffer(generator, "    db \"%s\", 0\n", string_value);
    emit_to_global_buffer(generator, "\n");

    free(label);
  }
}

int code_generator_get_operator_precedence(const char *op) {
  if (!op)
    return 0;

  // Higher numbers = higher precedence
  if (strcmp(op, "*") == 0 || strcmp(op, "/") == 0 || strcmp(op, "%") == 0) {
    return 6;
  } else if (strcmp(op, "+") == 0 || strcmp(op, "-") == 0) {
    return 5;
  } else if (strcmp(op, "<") == 0 || strcmp(op, "<=") == 0 ||
             strcmp(op, ">") == 0 || strcmp(op, ">=") == 0) {
    return 4;
  } else if (strcmp(op, "==") == 0 || strcmp(op, "!=") == 0) {
    return 3;
  } else if (strcmp(op, "&&") == 0) {
    return 2;
  } else if (strcmp(op, "||") == 0) {
    return 1;
  }
  return 0;
}

const char *code_generator_get_arithmetic_instruction(const char *op,
                                                      int is_float) {
  if (!op)
    return NULL;

  if (is_float) {
    // Floating point instructions (for future implementation)
    if (strcmp(op, "+") == 0)
      return "addsd";
    if (strcmp(op, "-") == 0)
      return "subsd";
    if (strcmp(op, "*") == 0)
      return "mulsd";
    if (strcmp(op, "/") == 0)
      return "divsd";
    return NULL;
  } else {
    // Integer instructions
    if (strcmp(op, "+") == 0)
      return "add";
    if (strcmp(op, "-") == 0)
      return "sub";
    if (strcmp(op, "*") == 0)
      return "imul";
    // Division and modulo are handled specially
    if (strcmp(op, "&") == 0)
      return "and"; // Bitwise AND
    if (strcmp(op, "|") == 0)
      return "or"; // Bitwise OR
    if (strcmp(op, "^") == 0)
      return "xor"; // Bitwise XOR
    return NULL;
  }
}

// Struct and method implementation functions
void code_generator_generate_struct_declaration(CodeGenerator *generator,
                                                ASTNode *struct_declaration) {
  if (!generator || !struct_declaration ||
      struct_declaration->type != AST_STRUCT_DECLARATION) {
    return;
  }

  StructDeclaration *struct_data =
      (StructDeclaration *)struct_declaration->data;
  if (!struct_data || !struct_data->name) {
    return;
  }

  code_generator_emit(generator, "    ; Struct declaration: %s\n",
                      struct_data->name);

  // Look up struct type in symbol table
  Symbol *struct_symbol =
      symbol_table_lookup(generator->symbol_table, struct_data->name);
  if (struct_symbol && struct_symbol->kind == SYMBOL_STRUCT &&
      struct_symbol->type) {
    Type *struct_type = struct_symbol->type;

    // Calculate and set struct layout
    code_generator_calculate_struct_layout(generator, struct_type);

    code_generator_emit(generator, "    ; Struct %s: size=%zu, alignment=%zu\n",
                        struct_data->name, struct_type->size,
                        struct_type->alignment);

    // Generate method implementations if any
    if (struct_data->methods && struct_data->method_count > 0) {
      for (size_t i = 0; i < struct_data->method_count; i++) {
        if (struct_data->methods[i] &&
            struct_data->methods[i]->type == AST_FUNCTION_DECLARATION) {
          // Mangle the method name: StructName_methodname
          FunctionDeclaration *method_data =
              (FunctionDeclaration *)struct_data->methods[i]->data;
          if (method_data && method_data->name) {
            char *original_name = method_data->name;
            char mangled[256];
            snprintf(mangled, sizeof(mangled), "%s_%s", struct_data->name,
                     original_name);
            method_data->name = strdup(mangled);
            free(original_name);

            code_generator_emit(generator, "    ; Method %s of struct %s\n",
                                mangled, struct_data->name);
            code_generator_generate_function(generator,
                                             struct_data->methods[i]);
          }
        }
      }
    }
  } else {
    code_generator_set_error(
        generator, "Struct type '%s' not found during code generation",
        struct_data->name ? struct_data->name : "<unknown>");
  }
}

void code_generator_generate_method_call(CodeGenerator *generator,
                                         ASTNode *method_call,
                                         ASTNode *object) {
  if (!generator || !method_call || !object) {
    code_generator_set_error(generator, "Invalid method call AST node");
    return;
  }

  // Method calls are handled as special function calls with implicit "this"
  CallExpression *call_data = (CallExpression *)method_call->data;
  if (!call_data) {
    code_generator_set_error(generator, "Malformed method call expression");
    return;
  }

  code_generator_emit(generator, "    ; Method call: %s\n",
                      call_data->function_name);

  // Generate the object expression to get "this" pointer
  code_generator_emit(generator, "    ; Generate 'this' pointer\n");
  code_generator_generate_expression(generator, object);

  // Save "this" pointer as first parameter
  code_generator_emit(generator,
                      "    push %rax           ; Save 'this' pointer\n");

  // Get calling convention for parameter passing
  CallingConventionSpec *conv_spec =
      generator->register_allocator->calling_convention;
  if (conv_spec && conv_spec->int_param_count > 0) {
    // Move "this" to first parameter register
    const char *first_param_reg =
        code_generator_get_register_name(conv_spec->int_param_registers[0]);
    if (first_param_reg) {
      code_generator_emit(
          generator,
          "    pop %s             ; 'this' in first parameter register\n",
          first_param_reg);
    }
  }

  // Generate other parameters starting from second parameter position
  if (call_data->arguments && call_data->argument_count > 0) {
    for (size_t i = 0; i < call_data->argument_count; i++) {
      if (call_data->arguments[i]) {
        // Generate argument (starts at parameter index 1 since 0 is "this")
        code_generator_generate_parameter(generator, call_data->arguments[i],
                                          (int)i + 1, NULL);
      }
    }
  }

  // Determine the mangled method name (StructName_methodname)
  char mangled_name[256];
  const char *struct_name = NULL;

  if (object->type == AST_IDENTIFIER) {
    Identifier *id_data = (Identifier *)object->data;
    if (id_data && id_data->name) {
      Symbol *obj_symbol =
          symbol_table_lookup(generator->symbol_table, id_data->name);
      if (obj_symbol && obj_symbol->type && obj_symbol->type->name) {
        struct_name = obj_symbol->type->name;
      }
    }
  }

  if (struct_name) {
    snprintf(mangled_name, sizeof(mangled_name), "%s_%s", struct_name,
             call_data->function_name);
  } else {
    snprintf(mangled_name, sizeof(mangled_name), "%s",
             call_data->function_name);
  }

  // Generate the actual method call with mangled name
  code_generator_emit(generator, "    call %s\n", mangled_name);
  code_generator_emit(generator, "    ; Return value in %rax\n");
}

void code_generator_generate_member_access(CodeGenerator *generator,
                                           ASTNode *member_access) {
  if (!generator || !member_access ||
      member_access->type != AST_MEMBER_ACCESS) {
    code_generator_set_error(generator, "Invalid member access AST node");
    return;
  }

  MemberAccess *access_data = (MemberAccess *)member_access->data;
  if (!access_data || !access_data->object || !access_data->member) {
    code_generator_set_error(generator, "Malformed member access expression");
    return;
  }

  code_generator_emit(generator, "    ; Member access: .%s\n",
                      access_data->member);

  // Generate the object expression to get base address
  code_generator_generate_expression(generator, access_data->object);

  // Try to determine object type for proper field offset calculation
  // This requires enhanced type information from semantic analysis
  Type *object_type = NULL;

  // If the object is an identifier, look up its type
  if (access_data->object->type == AST_IDENTIFIER) {
    Identifier *id_data = (Identifier *)access_data->object->data;
    if (id_data && id_data->name) {
      Symbol *object_symbol =
          symbol_table_lookup(generator->symbol_table, id_data->name);
      if (object_symbol && object_symbol->type) {
        object_type = object_symbol->type;
      }
    }
  }

  int field_offset = -1;

  // If we have type information, calculate proper field offset
  if (object_type && object_type->kind == TYPE_STRUCT) {
    field_offset = code_generator_get_field_offset(generator, object_type,
                                                   access_data->member);
  }

  // If we couldn't determine the offset, use default values for testing
  if (field_offset < 0) {
    code_generator_set_error(generator,
                             "Cannot determine field offset for '%s'",
                             access_data->member);
    return;
  }

  code_generator_emit(generator, "    ; Field offset for %s: %d\n",
                      access_data->member, field_offset);

  if (field_offset > 0) {
    code_generator_emit(generator, "    add rax, %d       ; Add field offset\n",
                        field_offset);
  }

  // Load the field value (assumes the field is a pointer-sized value)
  code_generator_emit(generator, "    mov rax, [rax]    ; Load field value\n");
}

void code_generator_calculate_struct_layout(CodeGenerator *generator,
                                            Type *struct_type) {
  if (!generator || !struct_type || struct_type->kind != TYPE_STRUCT) {
    return;
  }

  if (!struct_type->field_names || !struct_type->field_types ||
      struct_type->field_count == 0) {
    struct_type->size = 0;
    struct_type->alignment = 1;
    return;
  }

  // Allocate field offsets array if not already allocated
  if (!struct_type->field_offsets) {
    struct_type->field_offsets =
        malloc(struct_type->field_count * sizeof(size_t));
    if (!struct_type->field_offsets) {
      return;
    }
  }

  size_t current_offset = 0;
  size_t max_alignment = 1;

  // Calculate field offsets with proper alignment
  for (size_t i = 0; i < struct_type->field_count; i++) {
    Type *field_type = struct_type->field_types[i];
    if (!field_type) {
      continue;
    }

    size_t field_size = field_type->size;
    size_t field_alignment = field_type->alignment;

    if (field_alignment == 0) {
      field_alignment = code_generator_calculate_struct_alignment(field_size);
    }

    // Update maximum alignment
    if (field_alignment > max_alignment) {
      max_alignment = field_alignment;
    }

    // Align current offset to field alignment
    if (field_alignment > 1) {
      current_offset =
          (current_offset + field_alignment - 1) & ~(field_alignment - 1);
    }

    // Set field offset
    struct_type->field_offsets[i] = current_offset;

    // Advance offset by field size
    current_offset += field_size;
  }

  // Align total struct size to maximum field alignment
  if (max_alignment > 1) {
    current_offset =
        (current_offset + max_alignment - 1) & ~(max_alignment - 1);
  }

  struct_type->size = current_offset;
  struct_type->alignment = max_alignment;
}

int code_generator_get_field_offset(CodeGenerator *generator, Type *struct_type,
                                    const char *field_name) {
  if (!generator || !struct_type || !field_name ||
      struct_type->kind != TYPE_STRUCT) {
    return -1;
  }

  if (!struct_type->field_names || !struct_type->field_offsets ||
      struct_type->field_count == 0) {
    return -1;
  }

  // Search for field by name
  for (size_t i = 0; i < struct_type->field_count; i++) {
    if (struct_type->field_names[i] &&
        strcmp(struct_type->field_names[i], field_name) == 0) {
      return (int)struct_type->field_offsets[i];
    }
  }

  return -1; // Field not found
}

int code_generator_calculate_struct_alignment(int field_size) {
  // Standard alignment rules for x86-64
  // Fields align to their natural size, but with maximum alignment of 8
  if (field_size >= 8) {
    return 8;
  } else if (field_size > 4) {
    return 8; // Fields larger than 4 bytes align to 8
  } else if (field_size > 2) {
    return 4; // Fields larger than 2 bytes align to 4
  } else if (field_size > 1) {
    return 2; // Fields larger than 1 byte align to 2
  } else {
    return 1;
  }
}

// Inline assembly implementation functions
void code_generator_generate_inline_assembly(CodeGenerator *generator,
                                             ASTNode *inline_asm) {
  if (!generator || !inline_asm || inline_asm->type != AST_INLINE_ASM) {
    return;
  }

  InlineAsm *asm_data = (InlineAsm *)inline_asm->data;
  if (!asm_data || !asm_data->assembly_code) {
    return;
  }

  code_generator_emit(generator, "    ; Begin inline assembly block\n");

  // Preserve registers that might be clobbered by inline assembly
  code_generator_preserve_registers_for_inline_asm(generator);

  // Emit the inline assembly code directly
  code_generator_emit(generator, "%s\n", asm_data->assembly_code);

  // Restore preserved registers
  code_generator_restore_registers_after_inline_asm(generator);

  code_generator_emit(generator, "    ; End inline assembly block\n");
}

void code_generator_preserve_registers_for_inline_asm(
    CodeGenerator *generator) {
  if (!generator) {
    return;
  }

  code_generator_emit(generator,
                      "    ; Preserve registers for inline assembly\n");

  // Preserve caller-saved registers that might be used by surrounding code
  // This is a conservative approach - in a full implementation, we'd analyze
  // the inline assembly to determine which registers it actually uses
  code_generator_emit(generator, "    push rax           ; Preserve RAX\n");
  code_generator_emit(generator, "    push rcx           ; Preserve RCX\n");
  code_generator_emit(generator, "    push rdx           ; Preserve RDX\n");
  code_generator_emit(generator, "    push r8            ; Preserve R8\n");
  code_generator_emit(generator, "    push r9            ; Preserve R9\n");
  code_generator_emit(generator, "    push r10           ; Preserve R10\n");
  code_generator_emit(generator, "    push r11           ; Preserve R11\n");
}

void code_generator_restore_registers_after_inline_asm(
    CodeGenerator *generator) {
  if (!generator) {
    return;
  }

  code_generator_emit(generator,
                      "    ; Restore registers after inline assembly\n");

  // Restore in reverse order
  code_generator_emit(generator, "    pop r11            ; Restore R11\n");
  code_generator_emit(generator, "    pop r10            ; Restore R10\n");
  code_generator_emit(generator, "    pop r9             ; Restore R9\n");
  code_generator_emit(generator, "    pop r8             ; Restore R8\n");
  code_generator_emit(generator, "    pop rdx            ; Restore RDX\n");
  code_generator_emit(generator, "    pop rcx            ; Restore RCX\n");
  code_generator_emit(generator, "    pop rax            ; Restore RAX\n");
}

// Debug info integration functions
void code_generator_add_debug_symbol(CodeGenerator *generator, const char *name,
                                     DebugSymbolType type,
                                     const char *type_name, size_t line,
                                     size_t column) {
  if (!generator || !generator->debug_info || !name) {
    return;
  }

  debug_info_add_symbol(generator->debug_info, name, type, type_name, line,
                        column);
}

void code_generator_add_line_mapping(CodeGenerator *generator,
                                     size_t source_line, size_t source_column,
                                     const char *filename) {
  if (!generator || !generator->debug_info) {
    return;
  }

  debug_info_add_line_mapping(generator->debug_info, source_line, source_column,
                              generator->current_assembly_line, filename);
}

void code_generator_emit_debug_label(CodeGenerator *generator,
                                     size_t source_line) {
  if (!generator || !generator->generate_debug_info) {
    return;
  }

  code_generator_emit(generator, "L%zu:\n", source_line);
  generator->current_assembly_line++;
}
